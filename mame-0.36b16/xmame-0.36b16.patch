diff -Naur ../mmmmm/m36b16/build.sh mame-0.36b16/build.sh
--- ../mmmmm/m36b16/build.sh	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/build.sh	2023-07-07 16:17:10.800122954 -0400
@@ -0,0 +1,4 @@
+#!/bin/bash
+#cat patch.txt | patch -p1 --dry-ru
+#make -f makefile.unix DISPLAY_METHOD=x11
+make -f makefile.unix SHELL='sh -x'  MY_CPU=amd64  SOUND_ALSA=1 
diff -Naur ../mmmmm/m36b16/makefile.obj-xmame mame-0.36b16/makefile.obj-xmame
--- ../mmmmm/m36b16/makefile.obj-xmame	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/makefile.obj-xmame	2023-07-07 14:40:23.198821444 -0400
@@ -0,0 +1,102 @@
+# uncomment the following lines to include a CPU core
+CPUS+=Z80@
+
+# uncomment the following lines to include a sound core
+SOUNDS+=CUSTOM@
+SOUNDS+=SAMPLES@
+SOUNDS+=DAC@
+SOUNDS+=AY8910@
+SOUNDS+=YM2203@
+# enable only one of the following two
+#SOUNDS+=YM2151@
+# SOUNDS+=SN76477@
+SOUNDS+=SN76496@
+SOUNDS+=NAMCO@
+
+# List of CPU core (and, for a debug build, disassembler) object files
+CPUDEFS =
+CPUOBJS =
+DBGOBJS =
+ASMDEFS =
+
+CPU=$(strip $(findstring Z80@,$(CPUS)))
+ifneq ($(CPU),)
+CPUDEFS += -DHAS_Z80=1
+CPUOBJS += $(OBJ)/cpu/z80/z80.o
+DBGOBJS += $(OBJ)/cpu/z80/z80dasm.o
+endif
+
+
+
+
+SOUND=$(strip $(findstring CUSTOM@,$(SOUNDS)))
+ifneq ($(SOUND),)
+SOUNDDEFS += -DHAS_CUSTOM=1
+endif
+
+SOUND=$(strip $(findstring SAMPLES@,$(SOUNDS)))
+ifneq ($(SOUND),)
+SOUNDDEFS += -DHAS_SAMPLES=1
+SOUNDOBJS += $(OBJ)/sound/samples.o
+endif
+
+SOUND=$(strip $(findstring DAC@,$(SOUNDS)))
+ifneq ($(SOUND),)
+SOUNDDEFS += -DHAS_DAC=1
+SOUNDOBJS += $(OBJ)/sound/dac.o
+endif
+
+SOUND=$(strip $(findstring AY8910@,$(SOUNDS)))
+ifneq ($(SOUND),)
+SOUNDDEFS += -DHAS_AY8910=1
+SOUNDOBJS += $(OBJ)/sound/ay8910.o
+endif
+
+
+SOUND=$(strip $(findstring SN76477@,$(SOUNDS)))
+ifneq ($(SOUND),)
+SOUNDDEFS += -DHAS_SN76477=1
+SOUNDOBJS += $(OBJ)/sound/sn76477.o
+endif
+
+SOUND=$(strip $(findstring SN76496@,$(SOUNDS)))
+ifneq ($(SOUND),)
+SOUNDDEFS += -DHAS_SN76496=1
+SOUNDOBJS += $(OBJ)/sound/sn76496.o
+endif
+
+
+SOUND=$(strip $(findstring NAMCO@,$(SOUNDS)))
+ifneq ($(SOUND),)
+SOUNDDEFS += -DHAS_NAMCO=1
+SOUNDOBJS += $(OBJ)/sound/namco.o
+endif
+
+
+
+OBJCORE = \
+	$(OBJ)/version.o $(OBJ)/driver.o $(OBJ)/mame.o \
+	$(OBJ)/drawgfx.o $(OBJ)/common.o $(OBJ)/usrintrf.o \
+	$(OBJ)/cpuintrf.o $(OBJ)/memory.o $(OBJ)/timer.o $(OBJ)/palette.o \
+	$(OBJ)/input.o $(OBJ)/inptport.o $(OBJ)/cheat.o $(OBJ)/unzip.o \
+	$(OBJ)/audit.o $(OBJ)/info.o $(OBJ)/png.o $(OBJ)/artwork.o \
+	$(OBJ)/tilemap.o $(OBJ)/sprite.o $(OBJ)/gfxobj.o \
+	$(sort $(CPUOBJS)) \
+	$(OBJ)/sndintrf.o \
+	$(OBJ)/sound/streams.o $(OBJ)/sound/mixer.o \
+	$(sort $(SOUNDOBJS)) \
+	$(OBJ)/sound/votrax.o \
+	$(OBJ)/machine/z80fmly.o \
+	$(OBJ)/vidhrdw/generic.o \
+	$(OBJ)/mamedbg.o $(OBJ)/window.o \
+	$(OBJ)/profiler.o \
+	$(sort $(DBGOBJS)) \
+	$(OBJ)/pacman.a \
+
+$(OBJ)/pacman.a: \
+	$(OBJ)/machine/pacman.o $(OBJ)/drivers/pacman.o \
+	$(OBJ)/machine/pacplus.o \
+	$(OBJ)/machine/theglob.o \
+	$(OBJ)/machine/jrpacman.o $(OBJ)/drivers/jrpacman.o $(OBJ)/vidhrdw/jrpacman.o \
+	$(OBJ)/vidhrdw/pengo.o $(OBJ)/drivers/pengo.o \
+
diff -Naur ../mmmmm/m36b16/makefile.unix mame-0.36b16/makefile.unix
--- ../mmmmm/m36b16/makefile.unix	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/makefile.unix	2023-07-07 14:17:27.743875209 -0400
@@ -0,0 +1,582 @@
+##############################################################################
+#
+# makefile for xmame/xmess
+#
+# original by Juan Antonio Martinez
+# current version by Hans de Goede
+# http://x.mame.net
+# mailto:hans@highrise.nl
+#
+##############################################################################
+
+VERSION = 0.36.1
+DATE    = 24 March 2000
+
+#########################################################################
+#									#
+# READ COMMENTS AND MODIFY CONFIGURABLE OPTIONS WITH CARE...		#
+#									#
+# Members of Mame and X-Mame project assumes no responsability  	#
+# implicit or explicit about illegal or incorrect use of this   	#
+# sofware and about possible hard/soft damage derived of it   	  	#
+#									#
+# THIS SOFTWARE IS DISTRIBUTED "AS IS" . USE AT YOUR OWN RISK		#
+#									#
+# Mame and X-Mame are Copyright of Nicola Salmoria and Mirko buffoni	#
+# and distributed under terms simular to the GNU General Public License #
+# see doc/readme.unix for more details                                  #
+#									#
+# Arcade ROM images are copyright of their authors. DISTRIBUTING MAME   #
+# OR X-MAME INCLUDING ROM IMAGES IN THE SAME PACKAGE IS ILLEGAL AND	#
+# CONSTITUTES A VIOLATION OF TERMS OF COPYRIGHT				#
+#									#
+#########################################################################
+
+##############################################################################
+# xmame or xmess ?
+##############################################################################
+
+#set name to "xmame" (without the ") to compile xmame and to "xmess" to
+#compile xmess.
+NAME = xmame
+
+
+##############################################################################
+# *** development environment options 
+##############################################################################
+
+# GNU MAKE is MANDATORY !!!
+
+# *** Choose your compiler
+# Use gcc if available
+CC	= gcc
+# otherwise try the default cc
+# CC    = cc
+# Use of `c89' is recommend for ultrix as it generates faster code (which
+# means less frames to be skipped and better graphics) but `gcc' works just
+# as well. However, stay away from the `cc' ultrix compiler if possible.
+# CC	= c89
+# for ansi compliance testing, only for developers !!
+
+# *** Choose your compiler flags.
+# Note1:
+# xmame compilation breaks when using egcs-1.1.x or gcc-2.95, use
+# -fno-strict-aliasing to fix it. gcc-2.95.1 does work with -fstrict-aliasing,
+# and gives a nice speed increase.
+#
+# Note2:
+# linux-powerpc needs -fsigned-char
+#
+# Note3:
+# next/macosx needs -traditional-cpp
+#
+### for normal optimalisation, full warnings
+CFLAGS    = -O -Wall
+### this should work with all compilers 
+# CFLAGS    =
+### to get full optimization under gcc/x Intel based OS's..
+# CFLAGS    = -O3 -m486 -Wall -Wno-unused -funroll-loops \
+#  -fstrength-reduce -fomit-frame-pointer -ffast-math -malign-functions=2 \
+#  -malign-jumps=2 -malign-loops=2
+### for Linux/PowerPC use following opts
+# CFLAGS    = -O3 -Wall  -Wno-unused -funroll-loops\
+#  -fstrength-reduce -fomit-frame-pointer -ffast-math -fsigned-char
+### for OpenStep/MacOS X use following opts
+# CFLAGS    = -O4 -Wall -Wno-unused -finline-functions -ffast-math \
+#  -fstrength-reduce -traditional-cpp
+### for IRIX with all optimization
+# CFLAGS    = -O2 -OPT:Olimit=3077
+### used by me, for full ansi testing and debugging (with gcc).
+# CFLAGS    = -ggdb -ansi -pedantic -D_XOPEN_SOURCE -D_BSD_SOURCE -Wall \
+#  -Wno-long-long -Wno-trigraphs -Wno-unused -Dasm=__asm__ -O3 -m486 \
+#  -fstrength-reduce -ffast-math -malign-functions=2 -malign-jumps=2 \
+#  -malign-loops=2
+
+# *** Does your compiler supports inline funcs?. use appropiate item:
+# do not use IL = inline : wont work due to Z80 and 6809 stuffs
+# if strict ansi used set IL to "static"
+# This can very noticably increase xmame's performance, so enabling this is
+# encouraged, it works fine with gcc and probably with most other compilers.
+# IL	= '-DINLINE=static inline'
+IL     = -DINLINE=static
+
+# *** Choose your linker & linker flags ( some OS's needs native linker
+# instead GNU one )
+# normal
+LD	= $(CC) -s
+# to profile with gcc and gprof
+# LD	= $(CC) -pg
+# no profiling (less strace output), but with debug info
+# LD	= $(CC)
+# for debugging only, only works with gnu-binutils !!
+# LD	= $(CC) -Wl,-warn-common
+
+# *** Does your platform have ranlib (leave this untouched unless you are
+# using irix or Unixware 7
+RANLIB = ranlib
+# RANLIB = true
+
+# *** How to install executable? ( some OS's doesn't support install command )
+INSTALL = cp
+
+# *** Extra include and or library paths, sometimes needed for zlib,
+# with suse linux -L/usr/X11R6/lib is needed for example,
+# and with unixware7 -lsocket is needed
+# LIBS     = -L/usr/X11R6/lib -L/usr/local/lib
+# INCLUDES = -I/usr/X11R6/include -I/usr/local/include
+
+# *** If your system doesn't have zlib, or your systems zlib is giving you
+# troubles, you can use the one distributed with xmame.
+# Uncomment the following lines to use xmame's own version of zlib
+# ZLIB          = contrib/cutzlib-1.1.3/libz.a
+# ZLIB_LIBS     = -Lcontrib/cutzlib-1.1.3
+# ZLIB_INCLUDES = -Icontrib/cutzlib-1.1.3 -I../../contrib/cutzlib-1.1.3
+
+# *** Does your system support gettimeofday() function? If so, we encourage
+# you to enable this feature . Else .... comment it :-(
+TD	= -DHAVE_GETTIMEOFDAY
+
+
+##############################################################################
+# *** Configuration files and directories
+##############################################################################
+
+# *** Select destination directory for your compiled program , manual page
+# and binary distribution ( if you want to... )
+# ( only needed to install, not to compile... )
+DESTDIR = /usr/games
+MANDIR  = /usr/local/man/man6
+DISTDIR = /home/ftp/pub/emulators/$(NAME)
+
+# *** xmameroot, this is the default rompath, place where the highscores are
+# stored, global rc location etc. Since most of these are configurable through
+# the rc-file anyway, there are no longer seperate defines for each.
+XMAMEROOT = /usr/games/lib/$(NAME)
+
+
+##############################################################################
+# *** Special features
+##############################################################################
+
+# *** Uncomment this if you want network-play! see doc/multiplayer-readme.txt
+# It doesn't work correctly under all circumstances yet, it can't hurt
+# to enable it though, it won't matter for normal games. But don't expect
+# network play to work perfect. I'll work on that though, I should have taken
+# the time to test this earlier ;)
+#
+# The dos boys are working on some kind of net support in the core,
+# so this is currently broken ;|
+# MAMENET = -DMAME_NET
+
+# *** Uncommenty the next lines to build xmame with build in debugger, only
+# supported for x11 and svgalib. Only enable this if you need it, if you 
+# want to develop drivers that is, since it slows down xmame concederably.
+# DEBUG     = -DMAME_DEBUG
+# DEBUGLIBS = -lcurses
+
+# *** Uncomment the next lines to use x86-asm cpu cores. This is only
+# supported for some 386 machines with nasm-0.96 or higher available in your
+# path! the asm 68k core could cause problem with certain games, please test
+# with the c-core before reporting any problems.
+# uncomment next line to use Assembler 68k engine
+# X86_ASM_68K = 1
+#
+# And choose elf / or aout
+# ELF settings: no leading underscores + elf object format Tested with
+# linux/i386. Also for e.g. Solaris/x86
+ASM_STRIP = contrib/porting/strip_
+NASM_FMT  = -f elf
+# aout settings: with leading underscores + aout object format. Tested with
+# netBSD i386. Also for older linux installs, freebsd and others.
+# ASM_STRIP = true  # no strip command
+# NASM_FMT  = -f aoutb
+
+# *** Comment this line to get verbose make output, for debugging build
+# problems
+QUIET = 1
+
+
+##############################################################################
+# *** Input Devices
+##############################################################################
+
+# *** Select one or more joystick types which you want to use, which one is
+# actually used can be selected runtime with the -joytype switch.
+
+# *** for using X Input Extensions based joystick
+# This is known to not work right now ;|
+# ( Recommended if available. Of course: doesn't work in SVGALib arch ...)
+# You should also declare a default name for input device.
+# and choose polling method ( event processing or device polling )
+# use provided program "xlistdev" to now available ones
+# and dont forget to include library in linker definition !!
+# JSX11	 = -DX11_JOYSTICK
+# JSNAME = \"Joystick\"
+# JSPOLL  = -DUSE_X11_JOYEVENTS
+# JSLIB   = -lXi
+
+# *** On iX86 based OS's, if supported, you can use standard joystick driver
+# JSI386 = -DI386_JOYSTICK
+
+# *** Linux FM-TOWNS game PAD joystick emulation support
+# Thanks to Osamu Kurati for provided patch
+# JSPAD	 = -DLIN_FM_TOWNS
+
+
+##############################################################################
+# *** Sound Devices
+##############################################################################
+
+# select one or more sound drivers you want to exclude, besided the native
+# sound driver for your system
+
+# uncomment the following 2 lines for esound support
+# ESOUND_CFLAGS = -DSYSDEP_DSP_ESOUND `esd-config --cflags`
+# ESOUND_LIBS = `esd-config --libs`
+
+
+##############################################################################
+# *** Select your display method, choose only one
+# note: x11 is the only one supported on all platforms
+##############################################################################
+
+### X11
+DISPLAY_METHOD = x11
+### svgalib, only supported under linux
+# DISPLAY_METHOD = svgalib
+### ggi, only tested under linux
+# DISPLAY_METHOD = ggi
+### OpenGL under X11
+# DISPLAY_METHOD = xgl
+### glide under X11
+# DISPLAY_METHOD = xfx
+### glide in console mode
+# DISPLAY_METHOD = svgafx
+### OpenStep bitmaps
+# DISPLAY_METHOD = openstep
+### SDL library
+# DISPLAY_METHOD = SDL
+
+
+##############################################################################
+# *** X windows options, only needed for X as display method
+##############################################################################
+
+# *** If you don't have the MIT-Shared Memory X Extensions, comment the
+# following: ( Test if available by mean of xdpyinfo command )
+MSHM	= -DUSE_MITSHM
+
+# *** If you are running xfree86 and wnat to use DGA, uncomment the following:
+# DGA     = -DUSE_DGA
+# DGALIBS = -lXxf86dga -lXxf86vm
+
+# *** If you have the XIL library (Solaris 2.5.1 and higher), uncomment
+# the following lines:
+# XILFLAGS = -DUSE_XIL
+# XILLIBS  = -lxil -lpthread
+
+# *** Choice the location of your X headers & libs
+# standard location for X11 
+# X11INC		= -I/usr/include/X11
+# X11LIB		= -L/usr/lib/X11
+# standard location for XFree86
+X11INC		= -I/usr/X11R6/include
+X11LIB		= -L/usr/X11R6/lib
+# for Sun systems
+# X11INC		= -I/usr/openwin/include
+# X11LIB		= -L/usr/openwin/lib
+# for non-standard locations
+# X11INC		= -I/usr/local/include/X11
+# X11LIB		= -L/usr/local/lib
+
+
+##############################################################################
+# *** OpenGL info -- configure if you are using the xgl display option
+##############################################################################
+# *** what are the names of your OpenGL libs?
+GLLIBS= -lGL -lGLU
+
+# *** Uncomment next line if you're using NVIDIA's hw accelerated GLX drivers
+# NVIDIA= -DNVIDIA
+
+##############################################################################
+# *** architecture, Choose your CPU (!!only one!!) 
+##############################################################################
+
+### i386 + gnu-asm
+ MY_CPU = i386
+### i386 no asm
+# MY_CPU = i386_noasm
+### alpha
+# MY_CPU = alpha
+### m68k
+# MY_CPU = m68k
+### generic risc (powerpc, sparc, hppa, ibm)
+# MY_CPU = risc
+### generic risc, lsb-first (RISC (ultrix machines))
+# MY_CPU = risc_lsb
+### mips (generic risc + SGI compiler bug workarounds)
+# MY_CPU = mips
+
+##############################################################################
+# *** architecture, Choose your OS (!!only one!!) 
+##############################################################################
+
+### Linux 
+ARCH  = linux
+### FreeBSD
+# ARCH  = freebsd
+### NetBSD
+# ARCH  = netbsd
+### Solaris / SunOS
+# ARCH  = solaris
+### OpenStep
+# ARCH  = next
+### Mac OS X
+# ARCH  = macosx
+### IRIX ( with sound requires the dmedia package ) (*)
+# ARCH  = irix
+### IRIX ( with sound using the new al package) (*)
+# ARCH  = irix_al
+### aix ( with sound, you'll need the UMS and SOM lpp's installed ( under AIX4 ))
+# ARCH  = aix
+### generic unix, no sound
+# ARCH  = generic
+
+# *) For IRIX 6.5 or higher add -DHAVE_SNPRINTF to CFLAGS.irix(_al) in
+# src/unix/Makefile
+
+##############################################################################
+# All done, type make -f makefile.unix and enjoy xmame/xmess ;)
+# No configurable options below this line....
+##############################################################################
+
+
+##############################################################################
+# **** CPU dependent cflags.
+##############################################################################
+#note : -D__CPU_$(MY_CPU) is added automaticly later on.
+CFLAGS.i386       = -DLSB_FIRST -DX86_ASM
+CFLAGS.i386_noasm = -DLSB_FIRST -Di386
+CFLAGS.alpha      = -DLSB_FIRST -DALIGN_INTS -DALIGN_SHORTS -D__LP64__
+CFLAGS.amd64      = -DLSB_FIRST -DALIGN_INTS -DALIGN_SHORTS -D__LP64__
+CFLAGS.m68k       = 
+CFLAGS.risc       = -DALIGN_INTS -DALIGN_SHORTS 
+CFLAGS.risc_lsb   = -DALIGN_INTS -DALIGN_SHORTS -DLSB_FIRST
+CFLAGS.mips       = -DALIGN_INTS -DALIGN_SHORTS -DSGI_FIX_MWA_NOP
+
+##############################################################################
+# **** Architecture dependent libs.
+##############################################################################
+LIBS.solaris       = -lnsl -lsocket
+LIBS.irix          = -laudio
+LIBS.irix_al       = -laudio
+LIBS.aix           = -lUMSobj
+
+##############################################################################
+# **** Display dependent libs.
+##############################################################################
+# svga and ggi also use $(X11LIB) since that's where zlib often is
+LIBS.x11        = $(X11LIB) $(XILLIBS) $(DGALIBS) $(JSLIB) -lX11 -lXext 
+LIBS.svgalib    = $(X11LIB) -lvga -lvgagl
+LIBS.ggi        = $(X11LIB) -lggi
+LIBS.xgl        = $(X11LIB) -lX11 -lXext $(GLLIBS) -ljpeg
+LIBS.xfx        = $(X11LIB) -lX11 -lXext -lglide2x
+LIBS.svgafx     = $(X11LIB) -lvga -lvgagl -lglide2x
+LIBS.openstep	= -framework AppKit -framework SoundKit
+LIBS.SDL	= -ldl -lSDL -lpthread -D_REENTRANT
+
+##############################################################################
+# **** Display dependent cflags.
+##############################################################################
+CFLAGS.x11      = $(X11INC) $(DGA) $(MSHM) $(XILFLAGS) $(JSX11) \
+ $(JSPOLL) "-DX11_JOYNAME='$(JSNAME)'"
+CFLAGS.xgl      = $(X11INC) $(MSHM) $(JSX11) $(JSPOLL) \
+ "-DX11_JOYNAME='$(JSNAME)'" $(NVIDIA)
+CFLAGS.xfx      = $(X11INC) $(MSHM) $(JSX11) $(JSPOLL) \
+ "-DX11_JOYNAME='$(JSNAME)'" -I/usr/include/glide
+CFLAGS.svgafx   = -I/usr/include/glide
+CFLAGS.SDL      = -D_REENTRANT
+
+##############################################################################
+# **** Display dependent install.
+##############################################################################
+INST.x11        = doinstall
+INST.ggi        = doinstall
+INST.svgalib    = doinstallsuid
+INST.xgl        = doinstallsuid copycab
+INST.xfx        = doinstallsuid
+INST.svgafx     = doinstallsuid
+INST.SDL	= doinstallsuid
+
+##############################################################################
+# Quiet the compiler output if requested
+##############################################################################
+ifdef QUIET
+CC_COMMENT = 
+CC_COMPILE = @
+AR_OPTS = rc
+else
+CC_COMMENT = \#
+CC_COMPILE = 
+AR_OPTS = rcv
+endif
+
+##############################################################################
+# these are the object subdirectories that need to be created.
+##############################################################################
+OBJ     = obj-$(NAME)
+
+OBJDIRS = $(OBJ) \
+	$(OBJ)/drivers $(OBJ)/machine $(OBJ)/vidhrdw $(OBJ)/sndhrdw \
+	$(OBJ)/cpu $(OBJ)/sound $(OBJ)/cpu/i8039 $(OBJ)/cpu/i8085 \
+	$(OBJ)/cpu/i86 $(OBJ)/cpu/m6502 $(OBJ)/cpu/m68000 $(OBJ)/cpu/m6805 \
+	$(OBJ)/cpu/m6800 $(OBJ)/cpu/m6809 $(OBJ)/cpu/s2650 $(OBJ)/cpu/t11 \
+	$(OBJ)/cpu/z80 $(OBJ)/cpu/tms34010 $(OBJ)/cpu/tms9900 \
+	$(OBJ)/cpu/z8000 $(OBJ)/cpu/tms32010 $(OBJ)/cpu/h6280 \
+	$(OBJ)/cpu/ccpu $(OBJ)/cpu/pdp1 $(OBJ)/cpu/konami $(OBJ)/cpu/nec \
+	$(OBJ)/cpu/gensync $(OBJ)/cpu/adsp2100 $(OBJ)/cpu/z80gb \
+	$(OBJ)/mess $(OBJ)/mess/systems $(OBJ)/mess/machine \
+	$(OBJ)/mess/vidhrdw $(OBJ)/mess/sndhrdw
+
+##############################################################################
+# Begin of the real makefile.
+##############################################################################
+all: $(OBJDIRS) osdepend $(NAME).$(DISPLAY_METHOD)
+
+include makefile.$(OBJ)
+
+ifeq ($(NAME),xmess)
+   MESS=-DMESS -DNEOFREE
+endif
+
+# Perhaps one day original mame/mess sources will use POSIX strcasecmp and
+# M_PI instead MS-DOS counterparts... ( a long and sad history ...)
+MY_CFLAGS = $(CFLAGS) $(IL) $(TD) $(CFLAGS.$(MY_CPU)) \
+	-D__ARCH_$(ARCH) -D__CPU_$(MY_CPU) \
+	-D$(DISPLAY_METHOD) -Dstricmp=strcasecmp -DPI=M_PI -DUNIX \
+        -DSIGNED_SAMPLES $(MESS) $(MAMENET) $(DEBUG) \
+	$(SOUNDDEFS) $(CPUDEFS) $(ASMDEFS) \
+	$(INCLUDES) $(ZLIB_INCLUDES) -Isrc -Isrc/unix -I$(OBJ)/cpu/m68000 \
+	-Isrc/cpu/m68000
+
+# CONFIG are the cflags used to build the unix tree, this is were most defines
+# go
+CONFIG = $(MY_CFLAGS) $(CFLAGS.$(DISPLAY_METHOD)) $(JSI386) $(JSPAD) \
+	 -DXMAMEROOT='\"$(XMAMEROOT)\"' -DVERSION='\"$(VERSION)\"' \
+	 -DNAME='\"$(NAME)\"' -DDISPLAY_METHOD='\"$(DISPLAY_METHOD)\"' \
+	 $(ESOUND_CFLAGS)
+
+OBJS   = $(OBJCORE) $(OBJ)/unix.$(DISPLAY_METHOD)/osdepend.a \
+ $(OBJ)/unix.$(DISPLAY_METHOD)/vector.o
+
+MY_LIBS = $(LIBS) $(LIBS.$(ARCH)) $(LIBS.$(DISPLAY_METHOD)) $(ZLIB_LIBS) \
+ $(DEBUGLIBS) $(ESOUND_LIBS) -lz -lm
+
+$(NAME).$(DISPLAY_METHOD): $(ZLIB) $(OBJS)
+	$(CC_COMMENT) @echo 'Linking $@ ...'
+	$(CC_COMPILE) $(LD) -o $@ $(OBJS) $(MY_LIBS)
+
+$(OBJDIRS):
+	-mkdir $@
+
+xlistdev: contrib/tools/xlistdev.c
+	$(CC_COMMENT) @echo 'Compiling $< ...'
+	$(CC_COMPILE) $(CC) $(X11INC) contrib/tools/xlistdev.c -o xlistdev $(JSLIB) $(LIBS.$(ARCH)) $(LIBS.$(DISPLAY_METHOD)) -lm
+
+osdepend:
+	$(CC_COMMENT) @echo 'Compiling in the unix directory...'
+	$(CC_COMPILE) \
+	 ( \
+	 cd src/unix; \
+	  $(MAKE) CC="$(CC)" RANLIB="$(RANLIB)" ARCH="$(ARCH)" \
+	  DISPLAY_METHOD="$(DISPLAY_METHOD)" CFLAGS="$(CONFIG)" \
+	  CC_COMMENT="$(CC_COMMENT)" CC_COMPILE="$(CC_COMPILE)" \
+	  AR_OPTS="$(AR_OPTS)" OBJ="$(OBJ)" \
+	 )
+
+contrib/cutzlib-1.1.3/libz.a:
+	( \
+	cd contrib/cutzlib-1.1.3; \
+	./configure; \
+	$(MAKE) libz.a \
+	)
+
+$(OBJ)/%.o: src/%.c
+	$(CC_COMMENT) @echo 'Compiling $< ...'
+	$(CC_COMPILE) $(CC) $(MY_CFLAGS) -o $@ -c $<
+
+$(OBJ)/%.a:
+	$(CC_COMMENT) @echo 'Archiving $@ ...'
+	$(CC_COMPILE) ar $(AR_OPTS) $@ $^
+	$(CC_COMPILE) $(RANLIB) $@
+
+# special cases for the 68000 core
+#
+# The objs created from generated c-files
+M68000_GENERATED_OBJS = \
+ $(OBJ)/cpu/m68000/m68kops.o $(OBJ)/cpu/m68000/m68kopac.o \
+ $(OBJ)/cpu/m68000/m68kopdm.o $(OBJ)/cpu/m68000/m68kopnz.o
+
+# this generates the C source files for the 68000 emulator
+$(OBJ)/cpu/m68000/m68kmake $(OBJ)/cpu/m68000/m68kops.h: src/cpu/m68000/m68kmake.c src/cpu/m68000/m68k_in.c
+	$(CC_COMMENT) @echo 'Compiling src/cpu/m68000/m68kmake.c ...'
+	$(CC_COMPILE) $(CC) $(MY_CFLAGS) -o $(OBJ)/cpu/m68000/m68kmake src/cpu/m68000/m68kmake.c
+	$(CC_COMMENT) @echo 'Compiling src/cpu/m68000/m68k_in.c ...'
+	$(CC_COMPILE) $(OBJ)/cpu/m68000/m68kmake $(OBJ)/cpu/m68000 src/cpu/m68000/m68k_in.c
+
+# to compile generated C-files
+$(M68000_GENERATED_OBJS): $(OBJ)/cpu/m68000/m68kmake
+	$(CC_COMMENT) @echo 'Compiling $*.c ...'
+	$(CC_COMPILE) $(CC) $(MY_CFLAGS) -o $@ -c $*.c
+
+# src/cpu/m68000/m68kcpu.c needs a generated .h file
+$(OBJ)/cpu/m68000/m68kcpu.o: $(OBJ)/cpu/m68000/m68kops.h
+
+# The m68000 asm core
+$(OBJ)/cpu/m68000/68kem.o: src/cpu/m68000/make68k.c
+	$(CC_COMMENT) @echo 'Compiling $< ...'
+	$(CC_COMPILE) $(CC) $(MY_CFLAGS) -o $(OBJ)/cpu/m68000/make68k src/cpu/m68000/make68k.c
+	$(CC_COMPILE) $(OBJ)/cpu/m68000/make68k $(OBJ)/cpu/m68000/68kem.asm $(OBJ)/cpu/m68000/comptab.asm
+	$(CC_COMMENT) @echo 'Assembling $(OBJ)/cpu/m68000/68kem.asm ...'
+	$(CC_COMPILE) $(ASM_STRIP) $(OBJ)/cpu/m68000/68kem.asm
+	$(CC_COMPILE) nasm $(NASM_FMT) -o $(OBJ)/cpu/m68000/68kem.o $(OBJ)/cpu/m68000/68kem.asm
+
+
+#some tricks, since vector.o these days is display-method dependent:
+$(OBJ)/unix.$(DISPLAY_METHOD)/vector.o: src/vidhrdw/vector.c
+	$(CC_COMMENT) @echo 'Compiling $< ...'
+	$(CC_COMPILE) $(CC) $(MY_CFLAGS) -o $@ -c $<
+
+#make sure this isn't accidently in makefile.$(OBJ):
+$(OBJ)/vidhrdw/vector.o: bla
+
+install: $(INST.$(DISPLAY_METHOD)) install-man
+	@echo $(NAME) $(VERSION) for $(ARCH) installation completed
+
+install-man:
+	@echo installing manual pages under $(MANDIR) ...
+	-mkdir $(MANDIR)
+	$(INSTALL) doc/xmame.man $(MANDIR)/xmame.6
+
+doinstall:
+	@echo installing binaries under $(DESTDIR)...
+	$(INSTALL) $(NAME).$(DISPLAY_METHOD) $(DESTDIR)
+
+doinstallsuid:
+	@echo installing binaries under $(DESTDIR)...
+	$(INSTALL) $(NAME).$(DISPLAY_METHOD) $(DESTDIR)
+	chmod 4755 $(DESTDIR)/$(NAME).$(DISPLAY_METHOD)
+
+copycab:
+	@echo installing cabinet files under $(XMAMEROOT)...
+	$(INSTALL) -R cab $(XMAMEROOT)
+
+clean: 
+	rm -fr $(OBJ) $(NAME).* xlistdev contrib/cutzlib-1.1.3/libz.a contrib/cutzlib-1.1.3/*.o
+
+bindist: 
+	tar zcvf $(DISTDIR)/$(NAME).$(ARCH)-$(DISPLAY_METHOD)_bin.tgz $(NAME).$(DISPLAY_METHOD) doc
+
+srcdist: clean
+	( cd ..; tar zcvf $(DISTDIR)/$(NAME)-$(VERSION)_src.tgz $(NAME)-$(VERSION) )
diff -Naur ../mmmmm/m36b16/src/cheat.c mame-0.36b16/src/cheat.c
--- ../mmmmm/m36b16/src/cheat.c	2000-01-08 12:04:44.000000000 -0500
+++ mame-0.36b16/src/cheat.c	2023-07-07 14:26:35.545137673 -0400
@@ -1909,6 +1909,7 @@
 		BankToScanTable[2] = 1;
 	}
 #endif
+#if 0 /* RB */
 #ifndef NEOFREE
 #ifndef TINY_COMPILE
 	if (Machine->gamedrv->clone_of == &driver_neogeo)
@@ -1919,7 +1920,7 @@
 	}
 #endif
 #endif
-
+#endif /* RB */
       /* No CPU so we scan RAM & BANKn */
       if ((CpuToScan == -1) && (fastsearch == 2))
       	for (i = 0; i < 9;i ++)
diff -Naur ../mmmmm/m36b16/src/driver.c mame-0.36b16/src/driver.c
--- ../mmmmm/m36b16/src/driver.c	2000-02-01 14:55:08.000000000 -0500
+++ mame-0.36b16/src/driver.c	2023-07-07 14:36:24.183016542 -0400
@@ -1,2749 +1,2755 @@
-/******************************************************************************
-
-  driver.c
-
-  The list of all available drivers. Drivers have to be included here to be
-  recognized by the executable.
-
-  To save some typing, we use a hack here. This file is recursively #included
-  twice, with different definitions of the DRIVER() macro. The first one
-  declares external references to the drivers; the second one builds an array
-  storing all the drivers.
-
-******************************************************************************/
-
-#include "driver.h"
-
-
-#ifndef DRIVER_RECURSIVE
-
-/* The "root" driver, defined so we can have &driver_##NAME in macros. */
-struct GameDriver driver_0 =
-{
-	__FILE__,
-	0,
-	"",
-	0,
-	0,
-	0,
-	0,
-	0,
-	0,
-	0,
-	NOT_A_DRIVER
-};
-
-#endif
-
-#ifdef TINY_COMPILE
-extern struct GameDriver TINY_NAME;
-
-const struct GameDriver *drivers[] =
-{
-	&TINY_NAME,
-	0	/* end of array */
-};
-
-#else
-
-#ifndef DRIVER_RECURSIVE
-
-#define DRIVER_RECURSIVE
-
-/* step 1: declare all external references */
-#define DRIVER(NAME) extern struct GameDriver driver_##NAME;
-#define TESTDRIVER(NAME) extern struct GameDriver driver_##NAME;
-#include "driver.c"
-
-/* step 2: define the drivers[] array */
-#undef DRIVER
-#undef TESTDRIVER
-#define DRIVER(NAME) &driver_##NAME,
-#define TESTDRIVER(NAME)
-const struct GameDriver *drivers[] =
-{
-#include "driver.c"
-	0	/* end of array */
-};
-
-#else	/* DRIVER_RECURSIVE */
-
-#ifndef NEOMAME
-
-	/* "Pacman hardware" games */
-	DRIVER( pacman )	/* (c) 1980 Namco */
-	DRIVER( pacmanjp )	/* (c) 1980 Namco */
-	DRIVER( pacmanm )	/* (c) 1980 Midway */
-	DRIVER( npacmod )	/* (c) 1981 Namco */
-	DRIVER( pacmod )	/* (c) 1981 Midway */
-	DRIVER( hangly )	/* hack */
-	DRIVER( hangly2 )	/* hack */
-	DRIVER( puckman )	/* hack */
-	DRIVER( pacheart )	/* hack */
-	DRIVER( piranha )	/* hack */
-	DRIVER( pacplus )
-	DRIVER( mspacman )	/* (c) 1981 Midway (but it's a bootleg) */	/* made by Gencomp */
-	DRIVER( mspacatk )	/* hack */
-	DRIVER( pacgal )	/* hack */
-	DRIVER( maketrax )	/* (c) 1981 Williams, high score table says KRL (fur Kural) */
-	DRIVER( crush )		/* (c) 1981 Kural Samno Electric Ltd */
-	DRIVER( crush2 )	/* (c) 1981 Kural Esco Electric Ltd - bootleg? */
-	DRIVER( crush3 )	/* Kural Electric Ltd - bootleg? */
-	DRIVER( mbrush )	/* 1981 bootleg */
-	DRIVER( paintrlr )	/* 1981 bootleg */
-	DRIVER( eyes )		/* (c) 1982 Digitrex Techstar + "Rockola presents" */
-	DRIVER( eyes2 )		/* (c) 1982 Techstar + "Rockola presents" */
-	DRIVER( mrtnt )		/* (c) 1983 Telko */
-	DRIVER( ponpoko )	/* (c) 1982 Sigma Ent. Inc. */
-	DRIVER( ponpokov )	/* (c) 1982 Sigma Ent. Inc. + Venture Line license */
-	DRIVER( lizwiz )	/* (c) 1985 Techstar + "Sunn presents" */
-	DRIVER( theglob )	/* (c) 1983 Epos Corporation */
-	DRIVER( beastf )	/* (c) 1984 Epos Corporation */
-	DRIVER( jumpshot )
-	DRIVER( vanvan )	/* (c) 1983 Karateco (bootleg?) */
-	DRIVER( vanvanb )	/* bootleg */
-	DRIVER( alibaba )	/* (c) 1982 Sega */
-	DRIVER( pengo )		/* 834-0386 (c) 1982 Sega */
-	DRIVER( pengo2 )	/* 834-0386 (c) 1982 Sega */
-	DRIVER( pengo2u )	/* 834-0386 (c) 1982 Sega */
-	DRIVER( penta )		/* bootleg */
-	DRIVER( jrpacman )	/* (c) 1983 Midway */
-
-	/* "Galaxian hardware" games */
-	DRIVER( galaxian )	/* (c) Namco */
-	DRIVER( galmidw )	/* (c) Midway */
-	DRIVER( superg )	/* hack */
-	DRIVER( galaxb )	/* bootleg */
-	DRIVER( galapx )	/* hack */
-	DRIVER( galap1 )	/* hack */
-	DRIVER( galap4 )	/* hack */
-	DRIVER( galturbo )	/* hack */
-	DRIVER( swarm )		/* hack */
-	DRIVER( pisces )	/* ? */
-	DRIVER( uniwars )	/* (c) Irem */
-	DRIVER( gteikoku )	/* (c) Irem */
-	DRIVER( spacbatt )	/* bootleg */
-	DRIVER( warofbug )	/* (c) 1981 Armenia */
-	DRIVER( redufo )	/* ? */
-	DRIVER( pacmanbl )	/* bootleg */
-	DRIVER( devilfsg )	/* (c) 1984 Vision / Artic (bootleg?) */
-	DRIVER( zigzag )	/* (c) 1982 LAX */
-	DRIVER( zigzag2 )	/* (c) 1982 LAX */
-	DRIVER( jumpbug )	/* (c) 1981 Rock-ola */
-	DRIVER( jumpbugb )	/* (c) 1981 Sega */
-	DRIVER( levers )	/* (c) 1983 Rock-ola */
-	DRIVER( azurian )	/* (c) 1982 Rait Electronics Ltd */
-	DRIVER( orbitron )	/* Signatron USA */
-	DRIVER( mooncrgx )	/* bootleg */
-	DRIVER( mooncrst )	/* (c) 1980 Nichibutsu */
-	DRIVER( mooncrsg )	/* (c) 1980 Gremlin */
-	DRIVER( smooncrs )	/* Gremlin */
-	DRIVER( mooncrsb )	/* bootleg */
-	DRIVER( mooncrs2 )	/* bootleg */
-	DRIVER( fantazia )	/* bootleg */
-	DRIVER( eagle )		/* (c) Centuri */
-	DRIVER( eagle2 )	/* (c) Centuri */
-	DRIVER( moonqsr )	/* (c) 1980 Nichibutsu */
-	DRIVER( checkman )	/* (c) 1982 Zilec-Zenitone */
-	DRIVER( checkmaj )	/* (c) 1982 Jaleco (Zenitone/Zilec in ROM CM4, and the programmer names) */
-	DRIVER( streakng )	/* [1980] Shoei */
-	DRIVER( blkhole )	/* TDS (Tokyo Denshi Sekkei) */
-	DRIVER( moonal2 )	/* Nichibutsu */
-	DRIVER( moonal2b )	/* Nichibutsu */
-	DRIVER( kingball )	/* (c) 1980 Namco */
-	DRIVER( kingbalj )	/* (c) 1980 Namco */
-
-	/* "Scramble hardware" (and variations) games */
-	DRIVER( scramble )	/* GX387 (c) 1981 Konami */
-	DRIVER( scrambls )	/* GX387 (c) 1981 Stern */
-	DRIVER( scramblb )	/* bootleg */
-	DRIVER( atlantis )	/* (c) 1981 Comsoft */
-	DRIVER( atlants2 )	/* (c) 1981 Comsoft */
-	DRIVER( theend )	/* (c) 1980 Konami */
-	DRIVER( theends )	/* (c) 1980 Stern */
-	DRIVER( ckongs )	/* bootleg */
-	DRIVER( froggers )	/* bootleg */
-	DRIVER( amidars )	/* (c) 1982 Konami */
-	DRIVER( triplep )	/* (c) 1982 KKI */
-	DRIVER( knockout )	/* (c) 1982 KKK */
-	DRIVER( mariner )	/* (c) 1981 Amenip */
-	DRIVER( mars )		/* (c) 1981 Artic */
-	DRIVER( devilfsh )	/* (c) 1982 Artic */
-	DRIVER( newsin7 )	/* (c) 1983 ATW USA, Inc. */
-	DRIVER( hotshock )	/* (c) 1982 E.G. Felaco */
-	DRIVER( hunchbks )	/* (c) 1983 Century */
-	DRIVER( scobra )	/* GX316 (c) 1981 Konami */
-	DRIVER( scobras )	/* GX316 (c) 1981 Stern */
-	DRIVER( scobrab )	/* GX316 (c) 1981 Karateco (bootleg?) */
-	DRIVER( stratgyx )	/* GX306 (c) 1981 Konami */
-	DRIVER( stratgys )	/* GX306 (c) 1981 Stern */
-	DRIVER( armorcar )	/* (c) 1981 Stern */
-	DRIVER( armorca2 )	/* (c) 1981 Stern */
-	DRIVER( moonwar2 )	/* (c) 1981 Stern */
-	DRIVER( monwar2a )	/* (c) 1981 Stern */
-	DRIVER( spdcoin )	/* (c) 1984 Stern */
-	DRIVER( darkplnt )	/* (c) 1982 Stern */
-	DRIVER( tazmania )	/* (c) 1982 Stern */
-	DRIVER( tazmani2 )	/* (c) 1982 Stern */
-	DRIVER( calipso )	/* (c) 1982 Tago */
-	DRIVER( anteater )	/* (c) 1982 Tago */
-	DRIVER( rescue )	/* (c) 1982 Stern */
-	DRIVER( minefld )	/* (c) 1983 Stern */
-	DRIVER( losttomb )	/* (c) 1982 Stern */
-	DRIVER( losttmbh )	/* (c) 1982 Stern */
-	DRIVER( superbon )	/* bootleg */
-	DRIVER( hustler )	/* GX343 (c) 1981 Konami */
-	DRIVER( billiard )	/* bootleg */
-	DRIVER( hustlerb )	/* bootleg */
-	DRIVER( frogger )	/* GX392 (c) 1981 Konami */
-	DRIVER( frogseg1 )	/* (c) 1981 Sega */
-	DRIVER( frogseg2 )	/* 834-0068 (c) 1981 Sega */
-	DRIVER( froggrmc )	/* 800-3110 (c) 1981 Sega */
-	DRIVER( amidar )	/* GX337 (c) 1981 Konami */
-	DRIVER( amidaru )	/* GX337 (c) 1982 Konami + Stern license */
-	DRIVER( amidaro )	/* GX337 (c) 1982 Konami + Olympia license */
-	DRIVER( amigo )		/* bootleg */
-	DRIVER( turtles )	/* (c) 1981 Stern */
-	DRIVER( turpin )	/* (c) 1981 Sega */
-	DRIVER( 600 )		/* GX353 (c) 1981 Konami */
-	DRIVER( flyboy )	/* (c) 1982 Kaneko */
-	DRIVER( flyboyb )	/* bootleg */
-	DRIVER( fastfred )	/* (c) 1982 Atari */
-	DRIVER( jumpcoas )	/* (c) 1983 Kaneko */
-
-	/* "Crazy Climber hardware" games */
-	DRIVER( cclimber )	/* (c) 1980 Nichibutsu */
-	DRIVER( cclimbrj )	/* (c) 1980 Nichibutsu */
-	DRIVER( ccboot )	/* bootleg */
-	DRIVER( ccboot2 )	/* bootleg */
-	DRIVER( ckong )		/* (c) 1981 Falcon */
-	DRIVER( ckonga )	/* (c) 1981 Falcon */
-	DRIVER( ckongjeu )	/* bootleg */
-	DRIVER( ckongo )	/* bootleg */
-	DRIVER( ckongalc )	/* bootleg */
-	DRIVER( monkeyd )	/* bootleg */
-	DRIVER( rpatrolb )	/* bootleg */
-	DRIVER( silvland )	/* Falcon */
-	DRIVER( yamato )	/* (c) 1983 Sega */
-	DRIVER( yamato2 )	/* (c) 1983 Sega */
-	DRIVER( swimmer )	/* (c) 1982 Tehkan */
-	DRIVER( swimmera )	/* (c) 1982 Tehkan */
-	DRIVER( guzzler )	/* (c) 1983 Tehkan */
-
-	/* Nichibutsu games */
-	DRIVER( friskyt )	/* (c) 1981 */
-	DRIVER( radrad )	/* (c) 1982 Nichibutsu USA */
-	DRIVER( seicross )	/* (c) 1984 + Alice */
-	DRIVER( sectrzon )	/* (c) 1984 + Alice */
-	DRIVER( wiping )	/* (c) 1982 */
-	DRIVER( rugrats )	/* (c) 1983 */
-	DRIVER( cop01 )		/* (c) 1985 */
-	DRIVER( cop01a )	/* (c) 1985 */
-	DRIVER( terracre )	/* (c) 1985 */
-	DRIVER( terracrb )	/* (c) 1985 */
-	DRIVER( terracra )	/* (c) 1985 */
-	DRIVER( galivan )	/* (c) 1985 */
-	DRIVER( galivan2 )	/* (c) 1985 */
-	DRIVER( dangar )	/* (c) 1986 */
-	DRIVER( dangar2 )	/* (c) 1986 */
-	DRIVER( dangarb )	/* bootleg */
-	DRIVER( ninjemak )	/* (c) 1986 (US?) */
-	DRIVER( youma )		/* (c) 1986 (Japan) */
-	DRIVER( terraf )	/* (c) 1987 */
-	DRIVER( terrafu )	/* (c) 1987 Nichibutsu USA */
-	DRIVER( kodure )	/* (c) 1987 (Japan) */
-	DRIVER( armedf )	/* (c) 1988 */
-	DRIVER( cclimbr2 )	/* (c) 1988 (Japan) */
-
-	/* "Phoenix hardware" (and variations) games */
-	DRIVER( phoenix )	/* (c) 1980 Amstar */
-	DRIVER( phoenixa )	/* (c) 1980 Amstar + Centuri license */
-	DRIVER( phoenixt )	/* (c) 1980 Taito */
-	DRIVER( phoenix3 )	/* bootleg */
-	DRIVER( phoenixc )	/* bootleg */
-	DRIVER( pleiads )	/* (c) 1981 Tehkan */
-	DRIVER( pleiadbl )	/* bootleg */
-	DRIVER( pleiadce )	/* (c) 1981 Centuri + Tehkan */
-	DRIVER( naughtyb )	/* (c) 1982 Jaleco */
-	DRIVER( naughtya )	/* bootleg */
-	DRIVER( naughtyc )	/* (c) 1982 Jaleco + Cinematronics */
-	DRIVER( popflame )	/* (c) 1982 Jaleco */
-	DRIVER( popflama )	/* (c) 1982 Jaleco */
-
-	/* Namco games (plus some intruders on similar hardware) */
-	DRIVER( geebee )	/* [1978] Namco */
-	DRIVER( geebeeg )	/* [1978] Gremlin */
-	DRIVER( bombbee )	/* [1979] Namco */
-	DRIVER( cutieq )	/* (c) 1979 Namco */
-	DRIVER( navalone )	/* (c) 1980 Namco */
-	DRIVER( kaitei )	/* [1980] K.K. Tokki */
-	DRIVER( kaitein )	/* [1980] Namco */
-	DRIVER( sos )		/* [1980] Namco */
-	DRIVER( tankbatt )	/* (c) 1980 Namco */
-	DRIVER( warpwarp )	/* (c) 1981 Namco */
-	DRIVER( warpwarr )	/* (c) 1981 Rock-ola - the high score table says "NAMCO" */
-	DRIVER( warpwar2 )	/* (c) 1981 Rock-ola - the high score table says "NAMCO" */
-	DRIVER( rallyx )	/* (c) 1980 Namco */
-	DRIVER( rallyxm )	/* (c) 1980 Midway */
-	DRIVER( nrallyx )	/* (c) 1981 Namco */
-	DRIVER( jungler )	/* GX327 (c) 1981 Konami */
-	DRIVER( junglers )	/* GX327 (c) 1981 Stern */
-	DRIVER( locomotn )	/* GX359 (c) 1982 Konami + Centuri license */
-	DRIVER( gutangtn )	/* GX359 (c) 1982 Konami + Sega license */
-	DRIVER( cottong )	/* bootleg */
-	DRIVER( commsega )	/* (c) 1983 Sega */
-	/* the following ones all have a custom I/O chip */
-	DRIVER( bosco )		/* (c) 1981 */
-	DRIVER( boscomd )	/* (c) 1981 Midway */
-	DRIVER( boscomdo )	/* (c) 1981 Midway */
-	DRIVER( galaga )	/* (c) 1981 */
-	DRIVER( galagamw )	/* (c) 1981 Midway */
-	DRIVER( galagads )	/* hack */
-	DRIVER( gallag )	/* bootleg */
-	DRIVER( galagab2 )	/* bootleg */
-	DRIVER( galaga84 )	/* hack */
-	DRIVER( nebulbee )	/* hack */
-	DRIVER( digdug )	/* (c) 1982 */
-	DRIVER( digdugb )	/* (c) 1982 */
-	DRIVER( digdugat )	/* (c) 1982 Atari */
-	DRIVER( dzigzag )	/* bootleg */
-	DRIVER( xevious )	/* (c) 1982 */
-	DRIVER( xeviousa )	/* (c) 1982 + Atari license */
-	DRIVER( xevios )	/* bootleg */
-	DRIVER( sxevious )	/* (c) 1984 */
-	DRIVER( superpac )	/* (c) 1982 */
-	DRIVER( superpcm )	/* (c) 1982 Midway */
-	DRIVER( pacnpal )	/* (c) 1983 */
-	DRIVER( pacnchmp )	/* (c) 1983 */
-	DRIVER( phozon )	/* (c) 1983 */
-	DRIVER( mappy )		/* (c) 1983 */
-	DRIVER( mappyjp )	/* (c) 1983 */
-	DRIVER( digdug2 )	/* (c) 1985 */
-	DRIVER( digdug2a )	/* (c) 1985 */
-	DRIVER( todruaga )	/* (c) 1984 */
-	DRIVER( todruagb )	/* (c) 1984 */
-	DRIVER( motos )		/* (c) 1985 */
-	DRIVER( grobda )	/* (c) 1984 */
-	DRIVER( grobda2 )	/* (c) 1984 */
-	DRIVER( grobda3 )	/* (c) 1984 */
-	DRIVER( gaplus )	/* (c) 1984 */
-	DRIVER( gaplusa )	/* (c) 1984 */
-	DRIVER( galaga3 )	/* (c) 1984 */
-	DRIVER( galaga3a )	/* (c) 1984 */
-	/* Z8000 games */
-	DRIVER( polepos )	/* (c) 1982  */
-	DRIVER( poleposa )	/* (c) 1982 + Atari license */
-	DRIVER( polepos1 )	/* (c) 1982 Atari */
-	DRIVER( topracer )	/* bootleg */
-	DRIVER( polepos2 )	/* (c) 1983 + Atari license */
-	DRIVER( poleps2a )	/* (c) 1983 + Atari license */
-	/* no custom I/O in the following, HD63701 (or compatible) microcontroller instead */
-	DRIVER( pacland )	/* (c) 1984 */
-	DRIVER( pacland2 )	/* (c) 1984 */
-	DRIVER( pacland3 )	/* (c) 1984 */
-	DRIVER( paclandm )	/* (c) 1984 Midway */
-	DRIVER( drgnbstr )	/* (c) 1984 */
-	DRIVER( skykid )	/* (c) 1985 */
-	DRIVER( baraduke )	/* (c) 1985 */
-	DRIVER( metrocrs )	/* (c) 1985 */
-
-	/* Namco System 86 games */
-	DRIVER( hopmappy )	/* (c) 1986 */
-	DRIVER( skykiddx )	/* (c) 1986 */
-	DRIVER( skykiddo )	/* (c) 1986 */
-	DRIVER( roishtar )	/* (c) 1986 */
-	DRIVER( genpeitd )	/* (c) 1986 */
-	DRIVER( rthunder )	/* (c) 1986 new version */
-	DRIVER( rthundro )	/* (c) 1986 old version */
-	DRIVER( wndrmomo )	/* (c) 1987 */
-
-	/* Namco System 1 games */
-	DRIVER( shadowld )	/* (c) 1987 */
-	DRIVER( youkaidk )	/* (c) 1987 (Japan) */
-	DRIVER( dspirit )	/* (c) 1987 new version */
-	DRIVER( dspirito )	/* (c) 1987 old version */
-	DRIVER( blazer )	/* (c) 1987 (Japan) */
-	/* 1987 Quester */
-	DRIVER( pacmania )	/* (c) 1987 */
-	DRIVER( pacmanij )	/* (c) 1987 (Japan) */
-	DRIVER( galaga88 )	/* (c) 1987 */
-	DRIVER( galag88b )	/* (c) 1987 */
-	DRIVER( galag88j )	/* (c) 1987 (Japan) */
-	/* 1988 World Stadium */
-TESTDRIVER( berabohm )	/* (c) 1988 */
-	/* 1988 Alice in Wonderland (English version of Marchen maze) */
-	DRIVER( mmaze )		/* (c) 1988 (Japan) */
-TESTDRIVER( bakutotu )	/* (c) 1988 */
-	DRIVER( wldcourt )	/* (c) 1988 (Japan) */
-	DRIVER( splatter )	/* (c) 1988 (Japan) */
-	/* 1988 Face Off */
-	DRIVER( rompers )	/* (c) 1989 (Japan) */
-	DRIVER( blastoff )	/* (c) 1989 (Japan) */
-	/* World Stadium '89 */
-	DRIVER( dangseed )	/* (c) 1989 (Japan) */
-	DRIVER( ws90 )		/* (c) 1990 (Japan) */
-	DRIVER( pistoldm )	/* (c) 1990 (Japan) */
-	DRIVER( soukobdx )	/* (c) 1990 (Japan) */
-	DRIVER( tankfrce )	/* (c) 1991 (US) */
-	DRIVER( tankfrcj )	/* (c) 1991 (Japan) */
-
-	/* Namco System 2 games */
-TESTDRIVER( finallap )	/* 87.12 Final Lap */
-TESTDRIVER( finalapd )	/* 87.12 Final Lap */
-TESTDRIVER( finalapc )	/* 87.12 Final Lap */
-TESTDRIVER( finlapjc )	/* 87.12 Final Lap */
-TESTDRIVER( finlapjb )	/* 87.12 Final Lap */
-	DRIVER( assault )	/* (c) 1988 */
-	DRIVER( assaultj )	/* (c) 1988 (Japan) */
-	DRIVER( assaultp )	/* (c) 1988 (Japan) */
-TESTDRIVER( metlhawk )	/* (c) 1988 */
-	DRIVER( mirninja )	/* (c) 1988 (Japan) */
-	DRIVER( ordyne )	/* (c) 1988 */
-	DRIVER( phelios )	/* (c) 1988 (Japan) */
-	DRIVER( burnforc )	/* (c) 1989 (Japan) */
-TESTDRIVER( dirtfoxj )	/* (c) 1989 (Japan) */
-	DRIVER( finehour )	/* (c) 1989 (Japan) */
-TESTDRIVER( fourtrax )	/* 89.11 */
-	DRIVER( marvland )	/* (c) 1989 (US) */
-	DRIVER( marvlanj )	/* (c) 1989 (Japan) */
-	DRIVER( valkyrie )	/* (c) 1989 (Japan) */
-	/* 90.5  [Kyuukai Douchuuki] (baseball game. uses character of Youkai Douchuuki) */
-	DRIVER( dsaber )	/* (c) 1990 */
-	DRIVER( dsaberj )	/* (c) 1990 (Japan) */
-	DRIVER( rthun2 )	/* (c) 1990 */
-	DRIVER( rthun2j )	/* (c) 1990 (Japan) */
-TESTDRIVER( finalap2 )	/* 90.8  Final Lap 2 */
-TESTDRIVER( finalp2j )	/* 90.8  Final Lap 2 (Japan) */
-	/* 91.3  Steel Gunner */
-	/* 91.7  Golly Ghost */
-	/* 91.9  Super World Stadium */
-TESTDRIVER( sgunner2 )	/* (c) 1991 (Japan) */
-	DRIVER( cosmogng )	/* (c) 1991 (US) */
-	DRIVER( cosmognj )	/* (c) 1991 (Japan) */
-TESTDRIVER( finalap3 )	/* 92.9  Final Lap 3 */
-TESTDRIVER( suzuka8h )
-	/* 92.8  Bubble Trouble */
-	DRIVER( sws92 )		/* (c) 1992 (Japan) */
-	/* 93.4  Lucky & Wild */
-	DRIVER( sws93 )		/* (c) 1993 (Japan) */
-	/* 93.6  Super World Stadium '93 */
-
-/*
->other remaining Namco games
->-----------------------------------------------------
->Libble Rabble board
->83.12 Libble Rabble (The first Japanese game that uses M68K)
->86.4  Toy Pop
->
->-----------------------------------------------------
->NA-1 system
->92.10 F/A
-
-*/
-
-	/* Universal games */
-	DRIVER( cosmicg )	/* (c) 1979 */
-	DRIVER( cosmica )	/* (c) [1979] */
-	DRIVER( panic )		/* (c) 1980 */
-	DRIVER( panica )	/* (c) 1980 */
-	DRIVER( panicger )	/* (c) 1980 */
-	DRIVER( magspot2 )	/* (c) [1980?] */
-	DRIVER( devzone )	/* (c) [1980?] */
-	DRIVER( nomnlnd )	/* (c) [1980?] */
-	DRIVER( nomnlndg )	/* (c) [1980?] + Gottlieb */
-	DRIVER( cheekyms )	/* (c) [1980?] */
-	DRIVER( ladybug )	/* (c) 1981 */
-	DRIVER( ladybugb )	/* bootleg */
-	DRIVER( snapjack )	/* (c) */
-	DRIVER( cavenger )	/* (c) 1981 */
-	DRIVER( mrdo )		/* (c) 1982 */
-	DRIVER( mrdot )		/* (c) 1982 + Taito license */
-	DRIVER( mrdofix )	/* (c) 1982 + Taito license */
-	DRIVER( mrlo )		/* bootleg */
-	DRIVER( mrdu )		/* bootleg */
-	DRIVER( mrdoy )		/* bootleg */
-	DRIVER( yankeedo )	/* bootleg */
-	DRIVER( docastle )	/* (c) 1983 */
-	DRIVER( docastl2 )	/* (c) 1983 */
-	DRIVER( douni )		/* (c) 1983 */
-	DRIVER( dorunrun )	/* (c) 1984 */
-	DRIVER( dorunru2 )	/* (c) 1984 */
-	DRIVER( dorunruc )	/* (c) 1984 */
-	DRIVER( spiero )	/* (c) 1987 */
-	DRIVER( dowild )	/* (c) 1984 */
-	DRIVER( jjack )		/* (c) 1984 */
-	DRIVER( kickridr )	/* (c) 1984 */
-
-	/* Nintendo games */
-	DRIVER( radarscp )	/* (c) 1980 Nintendo */
-	DRIVER( dkong )		/* (c) 1981 Nintendo of America */
-	DRIVER( dkongjp )	/* (c) 1981 Nintendo */
-	DRIVER( dkongjpo )	/* (c) 1981 Nintendo */
-	DRIVER( dkongjr )	/* (c) 1982 Nintendo of America */
-	DRIVER( dkngjrjp )	/* no copyright notice */
-	DRIVER( dkjrjp )	/* (c) 1982 Nintendo */
-	DRIVER( dkjrbl )	/* (c) 1982 Nintendo of America */
-	DRIVER( dkong3 )	/* (c) 1983 Nintendo of America */
-	DRIVER( dkong3j )	/* (c) 1983 Nintendo */
-	DRIVER( mario )		/* (c) 1983 Nintendo of America */
-	DRIVER( mariojp )	/* (c) 1983 Nintendo */
-	DRIVER( masao )		/* bootleg */
-	DRIVER( hunchbkd )	/* (c) 1983 Century */
-	DRIVER( herbiedk )	/* (c) 1984 CVS */
-TESTDRIVER( herocast )
-	DRIVER( popeye )
-	DRIVER( popeye2 )
-	DRIVER( popeyebl )	/* bootleg */
-	DRIVER( punchout )	/* (c) 1984 */
-	DRIVER( spnchout )	/* (c) 1984 */
-	DRIVER( armwrest )	/* (c) 1985 */
-
-	/* Midway 8080 b/w games */
-	DRIVER( seawolf )	/* 596 [1976] */
-	DRIVER( gunfight )	/* 597 [1975] */
-	/* 603 - Top Gun [1976] */
-	DRIVER( tornbase )	/* 605 [1976] */
-	DRIVER( 280zzzap )	/* 610 [1976] */
-	DRIVER( maze )		/* 611 [1976] */
-	DRIVER( boothill )	/* 612 [1977] */
-	DRIVER( checkmat )	/* 615 [1977] */
-	/* 618 - Road Runner [1977] */
-	/* 618 - Desert Gun [1977] */
-	DRIVER( dplay )		/* 619 [1977] */
-	DRIVER( lagunar )	/* 622 [1977] */
-	DRIVER( gmissile )	/* 623 [1977] */
-	DRIVER( m4 )		/* 626 [1977] */
-	DRIVER( clowns )	/* 630 [1978] */
-	/* 640 - Space Walk [1978] */
-	DRIVER( einnings )	/* 642 [1978] Midway */
-	/* 643 - Shuffleboard [1978] */
-	DRIVER( dogpatch )	/* 644 [1977] */
-	DRIVER( spcenctr )	/* 645 (c) 1980 Midway */
-	DRIVER( phantom2 )	/* 652 [1979] */
-	DRIVER( bowler )	/* 730 [1978] Midway */
-	DRIVER( invaders )	/* 739 [1979] */
-	DRIVER( blueshrk )	/* 742 [1978] */
-	DRIVER( invad2ct )	/* 851 (c) 1980 Midway */
-	DRIVER( invadpt2 )	/* 852 [1980] Taito */
-	DRIVER( invdpt2m )	/* 852 [1980] Midway */
-	/* 870 - Space Invaders Deluxe cocktail */
-	DRIVER( earthinv )
-	DRIVER( spaceatt )
-	DRIVER( sinvemag )
-	DRIVER( jspecter )
-	DRIVER( invrvnge )
-	DRIVER( invrvnga )
-	DRIVER( galxwars )
-	DRIVER( starw )
-	DRIVER( lrescue )	/* (c) 1979 Taito */
-	DRIVER( grescue )	/* bootleg? */
-	DRIVER( desterth )	/* bootleg */
-	DRIVER( cosmicmo )	/* Universal */
-	DRIVER( rollingc )	/* Nichibutsu */
-	DRIVER( bandido )	/* (c) Exidy */
-	DRIVER( ozmawars )	/* Shin Nihon Kikaku (SNK) */
-	DRIVER( solfight )	/* bootleg */
-	DRIVER( spaceph )	/* Zilec Games */
-	DRIVER( schaser )	/* Taito */
-	DRIVER( lupin3 )	/* (c) 1980 Taito */
-	DRIVER( helifire )	/* (c) Nintendo */
-	DRIVER( helifira )	/* (c) Nintendo */
-	DRIVER( spacefev )
-	DRIVER( sfeverbw )
-	DRIVER( astlaser )
-	DRIVER( intruder )
-	DRIVER( polaris )	/* (c) 1980 Taito */
-	DRIVER( polarisa )	/* (c) 1980 Taito */
-	DRIVER( ballbomb )	/* (c) 1980 Taito */
-	DRIVER( m79amb )
-	DRIVER( alieninv )
-	DRIVER( si_tv )
-	DRIVER( si_cv )
-	DRIVER( si_sv )
-	DRIVER( sisv2 )
-	DRIVER( spacewr3 )
-	DRIVER( logitec )
-	DRIVER( yosakdon )
-	DRIVER( spceking )
-	DRIVER( spcewars )
-	DRIVER( spcewarl )
-
-	/* "Midway" Z80 b/w games */
-	DRIVER( astinvad )	/* (c) 1980 Stern */
-	DRIVER( kamikaze )	/* Leijac Corporation */
-	DRIVER( spaceint )	/* [1980] Shoei */
-
-	/* Meadows S2650 games */
-	DRIVER( lazercmd )	/* [1976?] */
-	DRIVER( deadeye )	/* [1978?] */
-	DRIVER( gypsyjug )	/* [1978?] */
-	DRIVER( medlanes )	/* [1977?] */
-
-	/* Midway "Astrocade" games */
-	DRIVER( wow )		/* (c) 1980 */
-	DRIVER( robby )		/* (c) 1981 */
-	DRIVER( gorf )		/* (c) 1981 */
-	DRIVER( gorfpgm1 )	/* (c) 1981 */
-	DRIVER( seawolf2 )
-	DRIVER( spacezap )	/* (c) 1980 */
-	DRIVER( ebases )
-
-	/* Bally Midway MCR games */
-	/* MCR1 */
-	DRIVER( solarfox )	/* (c) 1981 */
-	DRIVER( kick )		/* (c) 1981 */
-	DRIVER( kicka )		/* bootleg? */
-	/* MCR2 */
-	DRIVER( shollow )	/* (c) 1981 */
-	DRIVER( shollow2 )	/* (c) 1981 */
-	DRIVER( tron )		/* (c) 1982 */
-	DRIVER( tron2 )		/* (c) 1982 */
-	DRIVER( kroozr )	/* (c) 1982 */
-	DRIVER( domino )	/* (c) 1982 */
-	DRIVER( wacko )		/* (c) 1982 */
-	DRIVER( twotiger )	/* (c) 1984 */
-	/* MCR2 + MCR3 sprites */
-	DRIVER( journey )	/* (c) 1983 */
-	/* MCR3 */
-	DRIVER( tapper )	/* (c) 1983 */
-	DRIVER( tappera )	/* (c) 1983 */
-	DRIVER( sutapper )	/* (c) 1983 */
-	DRIVER( rbtapper )	/* (c) 1984 */
-	DRIVER( timber )	/* (c) 1984 */
-	DRIVER( dotron )	/* (c) 1983 */
-	DRIVER( dotrone )	/* (c) 1983 */
-	DRIVER( destderb )	/* (c) 1984 */
-	DRIVER( destderm )	/* (c) 1984 */
-	DRIVER( sarge )		/* (c) 1985 */
-	DRIVER( rampage )	/* (c) 1986 */
-	DRIVER( rampage2 )	/* (c) 1986 */
-	DRIVER( powerdrv )	/* (c) 1986 */
-	DRIVER( maxrpm )	/* (c) 1986 */
-	DRIVER( spyhunt )	/* (c) 1983 */
-	DRIVER( turbotag )	/* (c) 1985 */
-	DRIVER( crater )	/* (c) 1984 */
-	/* MCR 68000 */
-	DRIVER( zwackery )	/* (c) 1984 */
-	DRIVER( xenophob )	/* (c) 1987 */
-	DRIVER( spyhunt2 )	/* (c) 1987 */
-	DRIVER( blasted )	/* (c) 1988 */
-	DRIVER( archrivl )	/* (c) 1989 */
-	DRIVER( archriv2 )	/* (c) 1989 */
-	DRIVER( trisport )	/* (c) 1989 */
-	DRIVER( pigskin )	/* (c) 1990 */
-/* other possible MCR games:
-Black Belt
-Shoot the Bull
-Special Force
-MotorDome
-Six Flags (?)
-*/
-
-	/* Bally / Sente games */
-	DRIVER( sentetst )
-	DRIVER( cshift )	/* (c) 1984 */
-	DRIVER( gghost )	/* (c) 1984 */
-	DRIVER( hattrick )	/* (c) 1984 */
-	DRIVER( otwalls )	/* (c) 1984 */
-	DRIVER( snakepit )	/* (c) 1984 */
-	DRIVER( snakjack )	/* (c) 1984 */
-	DRIVER( stocker )	/* (c) 1984 */
-	DRIVER( triviag1 )	/* (c) 1984 */
-	DRIVER( triviag2 )	/* (c) 1984 */
-	DRIVER( triviasp )	/* (c) 1984 */
-	DRIVER( triviayp )	/* (c) 1984 */
-	DRIVER( triviabb )	/* (c) 1984 */
-	DRIVER( gimeabrk )	/* (c) 1985 */
-	DRIVER( minigolf )	/* (c) 1985 */
-	DRIVER( minigol2 )	/* (c) 1985 */
-	DRIVER( toggle )	/* (c) 1985 */
-	DRIVER( nametune )	/* (c) 1986 */
-	DRIVER( nstocker )	/* (c) 1986 */
-	DRIVER( sfootbal )	/* (c) 1986 */
-	DRIVER( spiker )	/* (c) 1986 */
-	DRIVER( rescraid )	/* (c) 1987 */
-
-	/* Irem games */
-	/* trivia: IREM means "International Rental Electronics Machines" */
-	DRIVER( skychut )	/* (c) [1980] */
-	DRIVER( mpatrol )	/* (c) 1982 */
-	DRIVER( mpatrolw )	/* (c) 1982 + Williams license */
-	DRIVER( mranger )	/* bootleg */
-	DRIVER( troangel )	/* (c) 1983 */
-	DRIVER( yard )		/* (c) 1983 */
-	DRIVER( vsyard )	/* (c) 1983/1984 */
-	DRIVER( vsyard2 )	/* (c) 1983/1984 */
-	DRIVER( travrusa )	/* (c) 1983 */
-	DRIVER( motorace )	/* (c) 1983 Williams license */
-	/* M62 */
-	DRIVER( kungfum )	/* (c) 1984 */
-	DRIVER( kungfud )	/* (c) 1984 + Data East license */
-	DRIVER( spartanx )	/* (c) 1984 */
-	DRIVER( kungfub )	/* bootleg */
-	DRIVER( kungfub2 )	/* bootleg */
-	DRIVER( battroad )	/* (c) 1984 */
-	DRIVER( ldrun )		/* (c) 1984 licensed from Broderbund */
-	DRIVER( ldruna )	/* (c) 1984 licensed from Broderbund */
-	DRIVER( ldrun2 )	/* (c) 1984 licensed from Broderbund */
-	DRIVER( ldrun3 )	/* (c) 1985 licensed from Broderbund */
-	DRIVER( ldrun4 )	/* (c) 1986 licensed from Broderbund */
-	DRIVER( lotlot )	/* (c) 1985 licensed from Tokuma Shoten */
-	DRIVER( kidniki )	/* (c) 1986 + Data East USA license */
-	DRIVER( yanchamr )	/* (c) 1986 (Japan) */
-	DRIVER( spelunkr )	/* (c) 1985 licensed from Broderbund */
-	DRIVER( spelunk2 )	/* (c) 1986 licensed from Broderbund */
-
-	DRIVER( vigilant )	/* (c) 1988 (World) */
-	DRIVER( vigilntu )	/* (c) 1988 (US) */
-	DRIVER( vigilntj )	/* (c) 1988 (Japan) */
-	DRIVER( kikcubic )	/* (c) 1988 (Japan) */
-	/* M72 (and derivatives) */
-	DRIVER( rtype )		/* (c) 1987 (Japan) */
-	DRIVER( rtypeu )	/* (c) 1987 + Nintendo USA license (US) */
-	DRIVER( rtypeb )	/* bootleg */
-	DRIVER( bchopper )	/* (c) 1987 */
-	DRIVER( mrheli )	/* (c) 1987 (Japan) */
-	DRIVER( nspirit )	/* (c) 1988 */
-	DRIVER( nspiritj )	/* (c) 1988 (Japan) */
-	DRIVER( imgfight )	/* (c) 1988 (Japan) */
-	DRIVER( loht )		/* (c) 1989 */
-	DRIVER( xmultipl )	/* (c) 1989 (Japan) */
-	DRIVER( dbreed )	/* (c) 1989 */
-	DRIVER( rtype2 )	/* (c) 1989 */
-	DRIVER( rtype2j )	/* (c) 1989 (Japan) */
-	DRIVER( majtitle )	/* (c) 1990 (Japan) */
-	DRIVER( hharry )	/* (c) 1990 (World) */
-	DRIVER( hharryu )	/* (c) 1990 Irem America (US) */
-	DRIVER( dkgensan )	/* (c) 1990 (Japan) */
-TESTDRIVER( kengo )
-	DRIVER( gallop )	/* (c) 1991 (Japan) */
-TESTDRIVER( poundfor )
-	/* not M72, but same sound hardware */
-	DRIVER( sichuan2 )	/* (c) 1989 Tamtex */
-	DRIVER( sichuana )	/* (c) 1989 Tamtex */
-	DRIVER( shisen )	/* (c) 1989 Tamtex */
-	/* M92 */
-	DRIVER( bmaster )	/* (c) 1991 Irem */
-	DRIVER( gunforce )	/* (c) 1991 Irem (World) */
-	DRIVER( gunforcu )	/* (c) 1991 Irem America (US) */
-	DRIVER( hook )		/* (c) 1992 Irem (World) */
-	DRIVER( hooku )		/* (c) 1992 Irem America (US) */
-	DRIVER( mysticri )	/* (c) 1992 Irem (World) */
-	DRIVER( gunhohki )	/* (c) 1992 Irem (Japan) */
-	DRIVER( uccops )	/* (c) 1992 Irem (World) */
-	DRIVER( uccopsj )	/* (c) 1992 Irem (Japan) */
-	DRIVER( rtypeleo )	/* (c) 1992 Irem (Japan) */
-	DRIVER( majtitl2 )	/* (c) 1992 Irem (World) */
-	DRIVER( skingame )	/* (c) 1992 Irem America (US) */
-	DRIVER( skingam2 )	/* (c) 1992 Irem America (US) */
-	DRIVER( inthunt )	/* (c) 1993 Irem (World) */
-	DRIVER( kaiteids )	/* (c) 1993 Irem (Japan) */
-TESTDRIVER( nbbatman )	/* (c) 1993 Irem America (US) */
-TESTDRIVER( leaguemn )	/* (c) 1993 Irem (Japan) */
-	DRIVER( lethalth )	/* (c) 1991 Irem (World) */
-	DRIVER( thndblst )	/* (c) 1991 Irem (Japan) */
-	DRIVER( psoldier )	/* (c) 1993 Irem (Japan) */
-	/* M97 */
-TESTDRIVER( riskchal )
-TESTDRIVER( gussun )
-TESTDRIVER( shisen2 )
-TESTDRIVER( quizf1 )
-TESTDRIVER( atompunk )
-TESTDRIVER( bbmanw )
-	/* M107 */
-TESTDRIVER( firebarr )	/* (c) 1993 Irem (Japan) */
-	DRIVER( dsoccr94 )	/* (c) 1994 Irem (Data East Corporation license) */
-
-	/* Gottlieb/Mylstar games (Gottlieb became Mylstar in 1983) */
-	DRIVER( reactor )	/* GV-100 (c) 1982 Gottlieb */
-	DRIVER( mplanets )	/* GV-102 (c) 1983 Gottlieb */
-	DRIVER( qbert )		/* GV-103 (c) 1982 Gottlieb */
-	DRIVER( qbertjp )	/* GV-103 (c) 1982 Gottlieb + Konami license */
-	DRIVER( sqbert )	/* (c) 1983 Mylstar - never released */
-	DRIVER( krull )		/* GV-105 (c) 1983 Gottlieb */
-	DRIVER( mach3 )		/* GV-109 (c) 1983 Mylstar */
-	DRIVER( usvsthem )	/* GV-??? (c) 198? Mylstar */
-	DRIVER( 3stooges )	/* GV-113 (c) 1984 Mylstar */
-	DRIVER( qbertqub )	/* GV-119 (c) 1983 Mylstar */
-	DRIVER( curvebal )	/* GV-134 (c) 1984 Mylstar */
-
-	/* older Taito games */
-	DRIVER( crbaloon )	/* (c) 1980 Taito Corporation */
-	DRIVER( crbalon2 )	/* (c) 1980 Taito Corporation */
-
-	/* Taito "Qix hardware" games */
-	DRIVER( qix )		/* (c) 1981 Taito America Corporation */
-	DRIVER( qixa )		/* (c) 1981 Taito America Corporation */
-	DRIVER( qixb )		/* (c) 1981 Taito America Corporation */
-	DRIVER( qix2 )		/* (c) 1981 Taito America Corporation */
-	DRIVER( sdungeon )	/* (c) 1981 Taito America Corporation */
-	DRIVER( elecyoyo )	/* (c) 1982 Taito America Corporation */
-	DRIVER( elecyoy2 )	/* (c) 1982 Taito America Corporation */
-	DRIVER( kram )		/* (c) 1982 Taito America Corporation */
-	DRIVER( kram2 )		/* (c) 1982 Taito America Corporation */
-	DRIVER( zookeep )	/* (c) 1982 Taito America Corporation */
-	DRIVER( zookeep2 )	/* (c) 1982 Taito America Corporation */
-	DRIVER( zookeep3 )	/* (c) 1982 Taito America Corporation */
-
-	/* Taito SJ System games */
-	DRIVER( spaceskr )	/* (c) 1981 Taito Corporation */
-	DRIVER( junglek )	/* (c) 1982 Taito Corporation */
-	DRIVER( junglkj2 )	/* (c) 1982 Taito Corporation */
-	DRIVER( jungleh )	/* (c) 1982 Taito America Corporation */
-	DRIVER( alpine )	/* (c) 1982 Taito Corporation */
-	DRIVER( alpinea )	/* (c) 1982 Taito Corporation */
-	DRIVER( timetunl )	/* (c) 1982 Taito Corporation */
-	DRIVER( wwestern )	/* (c) 1982 Taito Corporation */
-	DRIVER( wwester1 )	/* (c) 1982 Taito Corporation */
-	DRIVER( frontlin )	/* (c) 1982 Taito Corporation */
-	DRIVER( elevator )	/* (c) 1983 Taito Corporation */
-	DRIVER( elevatob )	/* bootleg */
-	DRIVER( tinstar )	/* (c) 1983 Taito Corporation */
-	DRIVER( waterski )	/* (c) 1983 Taito Corporation */
-	DRIVER( bioatack )	/* (c) 1983 Taito Corporation + Fox Video Games license */
-	DRIVER( hwrace )	/* (c) 1983 Taito Corporation */
-	DRIVER( sfposeid )	/* 1984 */
-	DRIVER( kikstart )
-
-	/* other Taito games */
-	DRIVER( bking2 )	/* (c) 1983 Taito Corporation */
-	DRIVER( gsword )	/* (c) 1984 Taito Corporation */
-	DRIVER( lkage )		/* (c) 1984 Taito Corporation */
-	DRIVER( lkageb )	/* bootleg */
-	DRIVER( retofinv )	/* (c) 1985 Taito Corporation */
-	DRIVER( retofin1 )	/* bootleg */
-	DRIVER( retofin2 )	/* bootleg */
-	DRIVER( tsamurai )	/* (c) 1985 Taito */
-	DRIVER( tsamura2 )	/* (c) 1985 Taito */
-	DRIVER( nunchaku )	/* (c) 1985 Taito */
-	DRIVER( yamagchi )	/* (c) 1985 Taito */
-TESTDRIVER( flstory )	/* (c) 1985 Taito */
-	DRIVER( gladiatr )	/* (c) 1986 Taito America Corporation (US) */
-	DRIVER( ogonsiro )	/* (c) 1986 Taito Corporation (Japan) */
-	DRIVER( bublbobl )	/* (c) 1986 Taito Corporation */
-	DRIVER( bublbobr )	/* (c) 1986 Taito America Corporation */
-	DRIVER( boblbobl )	/* bootleg */
-	DRIVER( sboblbob )	/* bootleg */
-	DRIVER( tokio )		/* 1986 */
-	DRIVER( tokiob )	/* bootleg */
-	DRIVER( kicknrun )	/* (c) 1986 Taito Corporation */
-	DRIVER( mexico86 )	/* bootleg (Micro Research) */
-	DRIVER( kikikai )	/* (c) 1986 Taito Corporation */
-	DRIVER( rastan )	/* (c) 1987 Taito Corporation Japan (World) */
-	DRIVER( rastanu )	/* (c) 1987 Taito America Corporation (US) */
-	DRIVER( rastanu2 )	/* (c) 1987 Taito America Corporation (US) */
-	DRIVER( rastsaga )	/* (c) 1987 Taito Corporation (Japan)*/
-	DRIVER( rainbow )	/* (c) 1987 Taito Corporation */
-	DRIVER( rainbowe )	/* (c) 1988 Taito Corporation */
-	DRIVER( jumping )	/* bootleg */
-	DRIVER( arkanoid )	/* (c) 1986 Taito Corporation Japan (World) */
-	DRIVER( arknoidu )	/* (c) 1986 Taito America Corporation + Romstar license (US) */
-	DRIVER( arknoidj )	/* (c) 1986 Taito Corporation (Japan) */
-	DRIVER( arkbl2 )	/* bootleg */
-TESTDRIVER( arkbl3 )	/* bootleg */
-	DRIVER( arkatayt )	/* bootleg */
-TESTDRIVER( arkblock )	/* bootleg */
-	DRIVER( arkbloc2 )	/* bootleg */
-	DRIVER( arkangc )	/* bootleg */
-	DRIVER( superqix )	/* 1987 */
-	DRIVER( sqixbl )	/* bootleg? but (c) 1987 */
-	DRIVER( superman )	/* (c) 1988 Taito Corporation */
-TESTDRIVER( footchmp )	/* (c) 1990 Taito Corporation Japan (World) */
-	DRIVER( minivadr )	/* cabinet test board */
-
-	/* Taito "tnzs" hardware */
-	DRIVER( extrmatn )	/* (c) 1987 World Games */
-	DRIVER( arkanoi2 )	/* (c) 1987 Taito Corporation Japan (World) */
-	DRIVER( ark2us )	/* (c) 1987 Taito America Corporation + Romstar license (US) */
-	DRIVER( ark2jp )	/* (c) 1987 Taito Corporation (Japan) */
-	DRIVER( plumppop )	/* (c) 1987 Taito Corporation (Japan) */
-	DRIVER( drtoppel )	/* (c) 1987 Taito Corporation (Japan) */
-	DRIVER( chukatai )	/* (c) 1988 Taito Corporation (Japan) */
-	DRIVER( tnzs )		/* (c) 1988 Taito Corporation (Japan) (new logo) */
-	DRIVER( tnzsb )		/* bootleg but Taito Corporation Japan (World) (new logo) */
-	DRIVER( tnzs2 )		/* (c) 1988 Taito Corporation Japan (World) (old logo) */
-	DRIVER( insectx )	/* (c) 1989 Taito Corporation Japan (World) */
-	DRIVER( kageki )	/* (c) 1988 Taito America Corporation + Romstar license (US) */
-	DRIVER( kagekij )	/* (c) 1988 Taito Corporation (Japan) */
-
-	/* Taito L-System games */
-	DRIVER( fhawk )		/* (c) 1988 Taito Corporation (Japan) */
-	DRIVER( raimais )	/* (c) 1988 Taito Corporation (Japan) */
-	DRIVER( champwr )	/* (c) 1989 Taito Corporation Japan (World) */
-	DRIVER( champwrj )	/* (c) 1989 Taito Corporation (Japan) */
-	DRIVER( puzznic )	/* (c) 1989 Taito Corporation (Japan) */
-	DRIVER( plotting )	/* (c) 1989 Taito Corporation Japan (World) */
-	DRIVER( palamed )	/* (c) 1990 Taito Corporation (Japan) */
-	DRIVER( horshoes )	/* (c) 1990 Taito America Corporation (US) */
-	DRIVER( cachat )	/* (c) 1993 Taito Corporation (Japan) */
-
-	/* Taito F2 games */
-	DRIVER( ssi )		/* (c) 1990 Taito Corporation Japan (World) */
-	/* Majestic 12 (c) 1990 Taito America Corporation (US) */
-	DRIVER( majest12 )	/* (c) 1990 Taito Corporation (Japan) */
-TESTDRIVER( finalb )
-TESTDRIVER( megab )
-	DRIVER( liquidk )	/* (c) 1990 Taito Corporation Japan (World) */
-	DRIVER( liquidku )	/* (c) 1990 Taito America Corporation (US) */
-	DRIVER( mizubaku )	/* (c) 1990 Taito Corporation (Japan) */
-	DRIVER( growl )		/* (c) 1990 Taito Corporation Japan (World) */
-	DRIVER( growlu )	/* (c) 1990 Taito America Corporation (US) */
-	DRIVER( runark )	/* (c) 1990 Taito Corporation (Japan) */
-
-	/* Toaplan games */
-	DRIVER( tigerh )	/* GX-551 [not a Konami board!] */
-	DRIVER( tigerh2 )	/* GX-551 [not a Konami board!] */
-	DRIVER( tigerhb1 )	/* bootleg but (c) 1985 Taito Corporation */
-	DRIVER( tigerhb2 )	/* bootleg but (c) 1985 Taito Corporation */
-	DRIVER( slapfigh )	/* TP-??? */
-	DRIVER( slapbtjp )	/* bootleg but (c) 1986 Taito Corporation */
-	DRIVER( slapbtuk )	/* bootleg but (c) 1986 Taito Corporation */
-	DRIVER( alcon )		/* TP-??? */
-	DRIVER( getstar )	/* TP-??? bootleg but (c) 1986 Taito Corporation */
-
-	DRIVER( fshark )	/* TP-007 (c) 1987 Taito Corporation (World) */
-	DRIVER( skyshark )	/* TP-007 (c) 1987 Taito America Corporation + Romstar license (US) */
-	DRIVER( hishouza )	/* TP-007 (c) 1987 Taito Corporation (Japan) */
-	DRIVER( fsharkbt )	/* bootleg */
-	DRIVER( wardner )	/* TP-??? (c) 1987 Taito Corporation Japan (World) */
-	DRIVER( pyros )		/* TP-??? (c) 1987 Taito America Corporation (US) */
-	DRIVER( wardnerj )	/* TP-??? (c) 1987 Taito Corporation Japan (Japan) */
-	DRIVER( twincobr )	/* TP-011 (c) 1987 Taito Corporation (World) */
-	DRIVER( twincobu )	/* TP-011 (c) 1987 Taito America Corporation + Romstar license (US) */
-	DRIVER( ktiger )	/* TP-011 (c) 1987 Taito Corporation (Japan) */
-
-	DRIVER( rallybik )	/* TP-012 (c) 1988 Taito */
-	DRIVER( truxton )	/* TP-013B (c) 1988 Taito */
-	DRIVER( hellfire )	/* TP-??? (c) 1989 Toaplan + Taito license */
-	DRIVER( zerowing )	/* TP-015 (c) 1989 Toaplan */
-	DRIVER( demonwld )	/* TP-016 (c) 1989 Toaplan + Taito license */
-	DRIVER( outzone )	/* TP-018 (c) 1990 Toaplan */
-	DRIVER( outzonep )	/* bootleg */
-	DRIVER( vimana )	/* TP-019 (c) 1991 Toaplan (+ Tecmo license when set to Japan) */
-	DRIVER( vimana2 )	/* TP-019 (c) 1991 Toaplan (+ Tecmo license when set to Japan)  */
-	DRIVER( vimanan )	/* TP-019 (c) 1991 Toaplan (+ Nova Apparate GMBH & Co license) */
-	DRIVER( snowbros )	/* MIN16-02 (c) 1990 Toaplan + Romstar license */
-	DRIVER( snowbroa )	/* MIN16-02 (c) 1990 Toaplan + Romstar license */
-	DRIVER( snowbrob )	/* MIN16-02 (c) 1990 Toaplan + Romstar license */
-	DRIVER( snowbroj )	/* MIN16-02 (c) 1990 Toaplan */
-
-/*
-Toa Plan's board list
-(translated from http://www.aianet.ne.jp/~eisetu/rom/rom_toha.html)
-
-Title              ROMno.   Remark(1)   Remark(2)
---------------------------------------------------
-Tiger Heli           A47      GX-551
-Hishouzame           B02      TP-007
-Kyukyoku Tiger       B30      TP-011
-Dash Yarou           B45      TP-012
-Tatsujin             B65      TP-013B   M6100649A
-Zero Wing            O15      TP-015
-Horror Story         O16      TP-016
-Same!Same!Same!      O17      TP-017
-Out Zone                      TP-018
-Vimana                        TP-019
-Teki Paki            O20      TP-020
-Ghox               TP-21      TP-021
-Dogyuun                       TP-022
-Tatsujin Oh                   TP-024    *1
-Fixeight                      TP-026
-V-V                           TP-027
-
-*1 There is a doubt this game uses TP-024 board and TP-025 romsets.
-
-   86 Mahjong Sisters                                 Kit 2P 8W+2B     HC    Mahjong TP-
-   88 Dash                                            Kit 2P 8W+2B                   TP-
-   89 Fire Shark                                      Kit 2P 8W+2B     VC    Shooter TP-017
-   89 Twin Hawk                                       Kit 2P 8W+2B     VC    Shooter TP-
-   91 Whoopie                                         Kit 2P 8W+2B     HC    Action
-   92 Teki Paki                                       Kit 2P                         TP-020
-   92 Ghox                                            Kit 2P Paddle+1B VC    Action  TP-021
-10/92 Dogyuun                                         Kit 2P 8W+2B     VC    Shooter TP-022
-92/93 Knuckle Bash                 Atari Games        Kit 2P 8W+2B     HC    Action  TP-023
-10/92 Tatsujin II/Truxton II       Taito              Kit 2P 8W+2B     VC    Shooter TP-024
-10/92 Truxton II/Tatsujin II       Taito              Kit 2P 8W+2B     VC    Shooter TP-024
-      Pipi & Bipi                                                                    TP-025
-   92 Fix Eight                                       Kit 2P 8W+2B     VC    Action  TP-026
-12/92 V  -  V (5)/Grind Stormer                       Kit 2P 8W+2B     VC    Shooter TP-027
- 1/93 Grind Stormer/V - V (Five)                      Kit 2P 8W+2B     VC    Shooter TP-027
- 2/94 Batsugun                                        Kit 2P 8W+2B     VC            TP-
- 4/94 Snow Bros. 2                                    Kit 2P 8W+2B     HC    Action  TP-
-*/
-
-	/* Kyugo games */
-	/* Kyugo only made four games: Repulse, Flash Gal, SRD Mission and Air Wolf. */
-	/* Gyrodine was made by Crux. Crux was antecedent of Toa Plan, and spin-off from Orca. */
-	DRIVER( gyrodine )	/* (c) 1984 Taito Corporation */
-	DRIVER( sonofphx )	/* (c) 1985 Associated Overseas MFR */
-	DRIVER( repulse )	/* (c) 1985 Sega */
-	DRIVER( 99lstwar )	/* (c) 1985 Proma */
-	DRIVER( 99lstwra )	/* (c) 1985 Proma */
-	DRIVER( flashgal )	/* (c) 1985 Sega */
-	DRIVER( srdmissn )	/* (c) 1986 Taito Corporation */
-	DRIVER( airwolf )	/* (c) 1987 Kyugo */
-	DRIVER( skywolf )	/* bootleg */
-	DRIVER( skywolf2 )	/* bootleg */
-
-	/* Williams games */
-	DRIVER( defender )	/* (c) 1980 */
-	DRIVER( defendg )	/* (c) 1980 */
-TESTDRIVER( defndjeu )	/* bootleg */
-	DRIVER( defcmnd )	/* bootleg */
-TESTDRIVER( defcomnd )	/* bootleg */
-	DRIVER( defence )	/* bootleg */
-	DRIVER( mayday )
-	DRIVER( maydaya )
-	DRIVER( colony7 )	/* (c) 1981 Taito */
-	DRIVER( colony7a )	/* (c) 1981 Taito */
-	DRIVER( stargate )	/* (c) 1981 */
-	DRIVER( robotron )	/* (c) 1982 */
-	DRIVER( robotryo )	/* (c) 1982 */
-	DRIVER( joust )		/* (c) 1982 */
-	DRIVER( joustr )	/* (c) 1982 */
-	DRIVER( joustwr )	/* (c) 1982 */
-	DRIVER( bubbles )	/* (c) 1982 */
-	DRIVER( bubblesr )	/* (c) 1982 */
-	DRIVER( splat )		/* (c) 1982 */
-	DRIVER( sinistar )	/* (c) 1982 */
-	DRIVER( sinista1 )	/* (c) 1982 */
-	DRIVER( sinista2 )	/* (c) 1982 */
-	DRIVER( blaster )	/* (c) 1983 */
-	DRIVER( mysticm )	/* (c) 1983 */
-	DRIVER( tshoot )	/* (c) 1984 */
-	DRIVER( inferno )	/* (c) 1984 */
-	DRIVER( joust2 )	/* (c) 1986 */
-	DRIVER( lottofun )	/* (c) 1987 H.A.R. Management */
-
-	/* Capcom games */
-	/* The following is a COMPLETE list of the Capcom games up to 1997, as shown on */
-	/* their web site. The list is sorted by production date. */
-	DRIVER( vulgus )	/*  5/1984 (c) 1984 */
-	DRIVER( vulgus2 )	/*  5/1984 (c) 1984 */
-	DRIVER( vulgusj )	/*  5/1984 (c) 1984 */
-	DRIVER( sonson )	/*  7/1984 (c) 1984 */
-	DRIVER( higemaru )	/*  9/1984 (c) 1984 */
-	DRIVER( 1942 )		/* 12/1984 (c) 1984 */
-	DRIVER( 1942a )		/* 12/1984 (c) 1984 */
-	DRIVER( 1942b )		/* 12/1984 (c) 1984 */
-	DRIVER( exedexes )	/*  2/1985 (c) 1985 */
-	DRIVER( savgbees )	/*  2/1985 (c) 1985 + Memetron license */
-	DRIVER( commando )	/*  5/1985 (c) 1985 (World) */
-	DRIVER( commandu )	/*  5/1985 (c) 1985 + Data East license (US) */
-	DRIVER( commandj )	/*  5/1985 (c) 1985 (Japan) */
-	DRIVER( spaceinv )	/* bootleg */
-	DRIVER( gng )		/*  9/1985 (c) 1985 */
-	DRIVER( gnga )		/*  9/1985 (c) 1985 */
-	DRIVER( gngt )		/*  9/1985 (c) 1985 */
-	DRIVER( makaimur )	/*  9/1985 (c) 1985 */
-	DRIVER( makaimuc )	/*  9/1985 (c) 1985 */
-	DRIVER( makaimug )	/*  9/1985 (c) 1985 */
-	DRIVER( diamond )	/* (c) 1989 KH Video (NOT A CAPCOM GAME but runs on GnG hardware) */
-	DRIVER( gunsmoke )	/* 11/1985 (c) 1985 (World) */
-	DRIVER( gunsmrom )	/* 11/1985 (c) 1985 + Romstar (US) */
-	DRIVER( gunsmoka )	/* 11/1985 (c) 1985 (US) */
-	DRIVER( gunsmokj )	/* 11/1985 (c) 1985 (Japan) */
-	DRIVER( sectionz )	/* 12/1985 (c) 1985 */
-	DRIVER( sctionza )	/* 12/1985 (c) 1985 */
-	DRIVER( trojan )	/*  4/1986 (c) 1986 (US) */
-	DRIVER( trojanr )	/*  4/1986 (c) 1986 + Romstar */
-	DRIVER( trojanj )	/*  4/1986 (c) 1986 (Japan) */
-	DRIVER( srumbler )	/*  9/1986 (c) 1986 */
-	DRIVER( srumblr2 )	/*  9/1986 (c) 1986 */
-	DRIVER( rushcrsh )	/*  9/1986 (c) 1986 */
-	DRIVER( lwings )	/* 11/1986 (c) 1986 */
-	DRIVER( lwings2 )	/* 11/1986 (c) 1986 */
-	DRIVER( lwingsjp )	/* 11/1986 (c) 1986 */
-	DRIVER( sidearms )	/* 12/1986 (c) 1986 (World) */
-	DRIVER( sidearmr )	/* 12/1986 (c) 1986 + Romstar license (US) */
-	DRIVER( sidearjp )	/* 12/1986 (c) 1986 (Japan) */
-	DRIVER( turtship )	/* (c) 1988 Philco (NOT A CAPCOM GAME but runs on modified Sidearms hardware) */
-	DRIVER( dyger )		/* (c) 1989 Philco (NOT A CAPCOM GAME but runs on modified Sidearms hardware) */
-	DRIVER( avengers )	/*  2/1987 (c) 1987 (US) */
-	DRIVER( avenger2 )	/*  2/1987 (c) 1987 (US) */
-	DRIVER( bionicc )	/*  3/1987 (c) 1987 (US) */
-	DRIVER( bionicc2 )	/*  3/1987 (c) 1987 (US) */
-	DRIVER( topsecrt )	/*  3/1987 (c) 1987 (Japan) */
-	DRIVER( 1943 )		/*  6/1987 (c) 1987 (US) */
-	DRIVER( 1943j )		/*  6/1987 (c) 1987 (Japan) */
-	DRIVER( blktiger )	/*  8/1987 (c) 1987 (US) */
-	DRIVER( bktigerb )	/* bootleg */
-	DRIVER( blkdrgon )	/*  8/1987 (c) 1987 (Japan) */
-	DRIVER( blkdrgnb )	/* bootleg, hacked to say Black Tiger */
-	DRIVER( sf1 )		/*  8/1987 (c) 1987 (World) */
-	DRIVER( sf1us )		/*  8/1987 (c) 1987 (US) */
-	DRIVER( sf1jp )		/*  8/1987 (c) 1987 (Japan) */
-	DRIVER( tigeroad )	/* 11/1987 (c) 1987 + Romstar (US) */
-	DRIVER( toramich )	/* 11/1987 (c) 1987 (Japan) */
-	DRIVER( f1dream )	/*  4/1988 (c) 1988 + Romstar */
-	DRIVER( f1dreamb )	/* bootleg */
-	DRIVER( 1943kai )	/*  6/1988 (c) 1987 (Japan) */
-	DRIVER( lastduel )	/*  7/1988 (c) 1988 (US) */
-	DRIVER( lstduela )	/*  7/1988 (c) 1988 (US) */
-	DRIVER( lstduelb )	/* bootleg */
-	DRIVER( madgear )	/*  2/1989 (c) 1989 (US) */
-	DRIVER( madgearj )	/*  2/1989 (c) 1989 (Japan) */
-	DRIVER( ledstorm )	/*  2/1989 (c) 1989 (US) */
-	/*  3/1989 Dokaben (baseball) - see below among "Mitchell" games */
-	/*  8/1989 Dokaben 2 (baseball) - see below among "Mitchell" games */
-	/* 10/1989 Capcom Baseball - see below among "Mitchell" games */
-	/* 11/1989 Capcom World - see below among "Mitchell" games */
-	/*  3/1990 Adventure Quiz 2 Hatena no Dai-Bouken - see below among "Mitchell" games */
-	/*  1/1991 Quiz Tonosama no Yabou - see below among "Mitchell" games */
-	/*  4/1991 Ashita Tenki ni Naare (golf) - see below among "Mitchell" games */
-	/*  5/1991 Ataxx - see below among "Leland" games */
-	/*  6/1991 Quiz Sangokushi - see below among "Mitchell" games */
-	/* 10/1991 Block Block - see below among "Mitchell" games */
-	/*  6/1995 Street Fighter - the Movie - see below among "Incredible Technologies" games */
-	/* 11/1995 Battle Arena Toshinden 2 (PSX hardware) */
-	/*  7/1996 Star Gladiator (PSX hardware?) */
-TESTDRIVER( sfex )		/* 12/1996 Street Fighter EX (PSX hardware) */
-	/*  4/1997 Street Fighter EX Plus (PSX hardware) */
-	/*  Rival Schools (PSX hardware) */
-	/*  Rival Schools 2 (PSX hardware) */
-
-	/* Capcom CPS1 games */
-	DRIVER( forgottn )	/*  7/1988 (c) 1988 (US) */
-	DRIVER( lostwrld )	/*  7/1988 (c) 1988 (Japan) */
-	DRIVER( ghouls )	/* 12/1988 (c) 1988 */
-	DRIVER( ghoulsj )	/* 12/1988 (c) 1988 */
-	DRIVER( strider )	/*  3/1989 (c) 1989 */
-	DRIVER( striderj )	/*  3/1989 (c) 1989 */
-	DRIVER( stridrja )	/*  3/1989 (c) 1989 */
-	DRIVER( dwj )		/*  4/1989 (c) 1989 */
-	DRIVER( willow )	/*  6/1989 (c) 1989 (Japan) */
-	DRIVER( willowj )	/*  6/1989 (c) 1989 (Japan) */
-	DRIVER( unsquad )	/*  8/1989 (c) 1989 */
-	DRIVER( area88 )	/*  8/1989 (c) 1989 */
-	DRIVER( ffight )	/* 12/1989 (c) (World) */
-	DRIVER( ffightu )	/* 12/1989 (c) (US)    */
-	DRIVER( ffightj )	/* 12/1989 (c) (Japan) */
-	DRIVER( 1941 )		/*  2/1990 (c) 1990 (World) */
-	DRIVER( 1941j )		/*  2/1990 (c) 1990 (Japan) */
-	DRIVER( mercs )		/*  3/ 2/1990 (c) 1990 (World) */
-	DRIVER( mercsu )	/*  3/ 2/1990 (c) 1990 (US)    */
-	DRIVER( mercsj )	/*  3/ 2/1990 (c) 1990 (Japan) */
-	DRIVER( mtwins )	/*  6/19/1990 (c) 1990 (World) */
-	DRIVER( chikij )	/*  6/19/1990 (c) 1990 (Japan) */
-	DRIVER( msword )	/*  7/25/1990 (c) 1990 (World) */
-	DRIVER( mswordu )	/*  7/25/1990 (c) 1990 (US)    */
-	DRIVER( mswordj )	/*  6/23/1990 (c) 1990 (Japan) */
-	DRIVER( cawing )	/* 10/12/1990 (c) 1990 (World) */
-	DRIVER( cawingj )	/* 10/12/1990 (c) 1990 (Japan) */
-	DRIVER( nemo )		/* 11/30/1990 (c) 1990 (World) */
-	DRIVER( nemoj )		/* 11/20/1990 (c) 1990 (Japan) */
-	DRIVER( sf2 )		/*  2/14/1991 (c) 1991 (World) */
-	DRIVER( sf2a )		/*  2/ 6/1991 (c) 1991 (US)    */
-	DRIVER( sf2b )		/*  2/14/1991 (c) 1991 (US)    */
-	DRIVER( sf2e )		/*  2/28/1991 (c) 1991 (US)    */
-	DRIVER( sf2j )		/* 12/10/1991 (c) 1991 (Japan) */
-	DRIVER( sf2jb )		/*  2/14/1991 (c) 1991 (Japan) */
-	DRIVER( 3wonders )	/*  5/20/1991 (c) 1991 (US) */
-	DRIVER( wonder3 )	/*  5/20/1991 (c) 1991 (Japan) */
-	DRIVER( kod )		/*  7/11/1991 (c) 1991 (World) */
-	DRIVER( kodj )		/*  8/ 5/1991 (c) 1991 (Japan) */
-	DRIVER( kodb )		/* bootleg */
-	DRIVER( captcomm )	/* 10/14/1991 (c) 1991 (World) */
-	DRIVER( captcomu )	/*  9/28/1991 (c) 1991 (US)    */
-	DRIVER( captcomj )	/* 12/ 2/1991 (c) 1991 (Japan) */
-	DRIVER( knights )	/* 11/27/1991 (c) 1991 (World) */
-	DRIVER( knightsj )	/* 11/27/1991 (c) 1991 (Japan) */
-	DRIVER( sf2ce )		/*  3/13/1992 (c) 1992 (World) */
-	DRIVER( sf2cea )	/*  3/13/1992 (c) 1992 (US)    */
-	DRIVER( sf2ceb )	/*  5/13/1992 (c) 1992 (US)    */
-	DRIVER( sf2cej )	/*  5/13/1992 (c) 1992 (Japan) */
-	DRIVER( sf2rb )		/* hack */
-	DRIVER( sf2red )	/* hack */
-	DRIVER( sf2accp2 )	/* hack */
-	DRIVER( varth )		/*  6/12/1992 (c) 1992 (World) */
-	DRIVER( varthj )	/*  7/14/1992 (c) 1992 (Japan) */
-	DRIVER( cworld2j )	/*  6/11/1992 (QUIZ 5) (c) 1992 (Japan) */
-	DRIVER( wof )		/* 10/ 2/1992 (c) 1992 (World) (CPS1 + QSound) */
-	DRIVER( wofj )		/* 10/31/1992 (c) 1992 (Japan) (CPS1 + QSound) */
-	DRIVER( sf2t )		/* 12/ 9/1992 (c) 1992 (US)    */
-	DRIVER( sf2tj )		/* 12/ 9/1992 (c) 1992 (Japan) */
-	DRIVER( dino )		/*  2/ 1/1993 (c) 1993 (World) (CPS1 + QSound) */
-	DRIVER( dinoj )		/*  2/ 1/1993 (c) 1993 (Japan) (CPS1 + QSound) */
-	DRIVER( punisher )	/*  4/22/1993 (c) 1993 (World) (CPS1 + QSound) */
-	DRIVER( punishru )	/*  4/22/1993 (c) 1993 (US)    (CPS1 + QSound) */
-	DRIVER( punishrj )	/*  4/22/1993 (c) 1993 (Japan) (CPS1 + QSound) */
-	DRIVER( slammast )	/*  7/13/1993 (c) 1993 (World) (CPS1 + QSound) */
-	DRIVER( mbomberj )	/*  7/13/1993 (c) 1993 (Japan) (CPS1 + QSound) */
-	DRIVER( mbombrd )	/* 12/ 6/1993 (c) 1993 (World) (CPS1 + QSound) */
-	DRIVER( mbombrdj )	/* 12/ 6/1993 (c) 1993 (Japan) (CPS1 + QSound) */
-	DRIVER( pnickj )	/*  6/ 8/1994 (c) 1994 + Compile license (Japan) not listed on Capcom's site */
-	DRIVER( qad )		/*  7/ 1/1992 (c) 1992 (US)    */
-	DRIVER( qadj )		/*  9/21/1994 (c) 1994 (Japan) */
-	DRIVER( qtono2 )	/*  1/23/1995 (c) 1995 (Japan) */
-	DRIVER( pang3 )		/*  5/11/1995 (c) 1995 Mitchell (Japan) not listed on Capcom's site */
-	DRIVER( megaman )	/* 10/ 6/1995 (c) 1995 (Asia)  */
-	DRIVER( rockmanj )	/*  9/22/1995 (c) 1995 (Japan) */
-	DRIVER( sfzch )		/* 10/20/1995 (c) 1995 (Japan) (CPS Changer) */
-
-	/* Capcom CPS2 games */
-	/* list completed by CPS2Shock */
-	/* http://cps2shock.retrogames.com */
-TESTDRIVER( ssf2 )		/* Super Street Fighter 2: The New Challengers (USA 930911) */
-TESTDRIVER( ssf2a )		/* Super Street Fighter 2: The New Challengers (Asia 930911) */
-TESTDRIVER( ssf2j )		/* Super Street Fighter 2: The New Challengers (Japan 930910) */
-TESTDRIVER( ecofe )		/* Eco Fighters (Etc 931203) */
-TESTDRIVER( ddtod )		/* Dungeons & Dragons: Tower of Doom (USA 940113) */
-TESTDRIVER( ddtoda )	/* Dungeons & Dragons: Tower of Doom (Asia 940113) */
-TESTDRIVER( ddtodr1 )	/* Dungeons & Dragons: Tower of Doom (USA 940125) */
-TESTDRIVER( ssf2t )		/* Super Street Fighter 2 Turbo (USA 940223) */
-TESTDRIVER( ssf2xj )	/* Super Street Fighter 2 X: Grand Master Challenge (Japan 940223) */
-TESTDRIVER( avsp )		/* Aliens Vs. Predator (USA 940520) */
-TESTDRIVER( vampj )		/* Vampire: The Night Warriors (Japan 940705) */
-TESTDRIVER( vampa )		/* Vampire: The Night Warriors (Asia 940705) */
-TESTDRIVER( dstlk )		/* DarkStalkers: The Night Warriors (USA 940818) */
-TESTDRIVER( slam2e )	/* Saturday Night Slammasters II: Ring of Destruction (Euro 940902) */
-TESTDRIVER( armwara )	/* Armoured Warriors (Asia 940920) */
-TESTDRIVER( xmcotaj )	/* X-Men: Children of the Atom (Japan 941219) */
-TESTDRIVER( xmcota )	/* X-Men: Children of the Atom (USA 950105) */
-TESTDRIVER( vhuntj )	/* Vampire Hunter: Darkstalkers 2 (Japan 950302) */
-TESTDRIVER( nwarr )		/* Night Warriors: DarkStalkers Revenge (USA 950406) */
-TESTDRIVER( cybotsj )	/* Cyberbots: Full Metal Madness (Japan 950420) */
-TESTDRIVER( sfa )		/* Street Fighter Alpha: The Warriors Dream (USA 950627) */
-TESTDRIVER( sfar1 )		/* Street Fighter Alpha: The Warriors Dream (USA 950727) */
-TESTDRIVER( sfzj )		/* Street Fighter Zero (Japan 950627) */
-TESTDRIVER( sfzjr1 )	/* Street Fighter Zero (Japan 950727) */
-TESTDRIVER( msh )		/* Marvel Super Heroes (USA 951024) */
-TESTDRIVER( 19xx )		/* 19XX: The Battle Against Destiny (USA 951207) */
-TESTDRIVER( ddsom )		/* Dungeons & Dragons 2: Shadow over Mystara (USA 960209) */
-TESTDRIVER( sfz2j )		/* Street Fighter Zero 2 (Japan 960227) */
-TESTDRIVER( spf2xj )	/* Super Puzzle Fighter 2 X (Japan 960531) */
-TESTDRIVER( spf2t )		/* Super Puzzle Fighter 2 Turbo (USA 960620) */
-TESTDRIVER( rckman2j )	/* Rockman 2: The Power Fighters (Japan 960708) */
-TESTDRIVER( sfz2a )		/* Street Fighter Zero 2 Alpha (Japan 960805) */
-						/*  9/1996 Quiz Naneiro Dreams */
-TESTDRIVER( xmvsf )		/* X-Men Vs. Street Fighter (USA 961004) */
-TESTDRIVER( batcirj )	/* Battle Circuit (Japan 970319) */
-TESTDRIVER( batcira )	/* Battle Circuit (Asia 970319) */
-TESTDRIVER( vsav )		/* Vampire Savior: The Lord of Vampire (USA 970519) */
-TESTDRIVER( vsavj )		/* Vampire Savior: The Lord of Vampire (Japan 970519) */
-TESTDRIVER( mshvsf )	/* Marvel Super Heroes Vs. Street Fighter (USA 970625) */
-TESTDRIVER( vhunt2 )	/* Vampire Hunter 2: Darkstalkers Revenge (Japan 970828) */
-TESTDRIVER( sgemf )		/* Super Gem Fighter Mini Mix (USA 970904) */
-TESTDRIVER( pfghtj )	/* Pocket Fighter (Japan 970904) */
-TESTDRIVER( vsav2 )		/* Vampire Savior 2: The Lord of Vampire (Japan 970913) */
-TESTDRIVER( mvsc )		/* Marvel Super Heroes vs. Capcom: Clash of Super Heroes (USA 980123) */
-TESTDRIVER( sfa3 )		/* Street Fighter Alpha 3 (USA 980629) */
-						/* 1999 Giga Wing */
-						/* Gulum Pa! */
-
-	/* Capcom CPS3 games */
-	/* 10/1996 Warzard */
-	/*  2/1997 Street Fighter III - New Generation */
-	/* ???? Jojo's Bizarre Adventure */
-	/* ???? Street Fighter 3: Second Impact ~giant attack~ */
-	/* ???? Street Fighter 3: Third Strike ~fight to the finish~ */
-
-	/* Mitchell games */
-	DRIVER( mgakuen )	/* (c) 1988 Yuga */
-	DRIVER( mgakuen2 )	/* (c) 1989 Face */
-	DRIVER( pkladies )	/* (c) 1989 Mitchell */
-	DRIVER( dokaben )	/*  3/1989 (c) 1989 Capcom (Japan) */
-	/*  8/1989 Dokaben 2 (baseball) */
-	DRIVER( pang )		/* (c) 1989 Mitchell (World) */
-	DRIVER( pangb )		/* bootleg */
-	DRIVER( bbros )		/* (c) 1989 Capcom (US) not listed on Capcom's site */
-	DRIVER( pompingw )	/* (c) 1989 Mitchell (Japan) */
-	DRIVER( cbasebal )	/* 10/1989 (c) 1989 Capcom (Japan) (different hardware) */
-	DRIVER( cworld )	/* 11/1989 (QUIZ 1) (c) 1989 Capcom */
-	DRIVER( hatena )	/*  2/28/1990 (QUIZ 2) (c) 1990 Capcom (Japan) */
-	DRIVER( spang )		/*  9/14/1990 (c) 1990 Mitchell (World) */
-	DRIVER( sbbros )	/* 10/ 1/1990 (c) 1990 Mitchell + Capcom (US) not listed on Capcom's site */
-	DRIVER( marukin )	/* 10/17/1990 (c) 1990 Yuga (Japan) */
-	DRIVER( qtono1 )	/* 12/25/1990 (QUIZ 3) (c) 1991 Capcom (Japan) */
-	/*  4/1991 Ashita Tenki ni Naare (golf) */
-	DRIVER( qsangoku )	/*  6/ 7/1991 (QUIZ 4) (c) 1991 Capcom (Japan) */
-	DRIVER( block )		/*  9/10/1991 (c) 1991 Capcom (World) */
-	DRIVER( blockj )	/*  9/10/1991 (c) 1991 Capcom (Japan) */
-	DRIVER( blockbl )	/* bootleg */
-
-	/* Incredible Technologies games */
-	DRIVER( capbowl )	/* (c) 1988 Incredible Technologies */
-	DRIVER( capbowl2 )	/* (c) 1988 Incredible Technologies */
-	DRIVER( clbowl )	/* (c) 1989 Incredible Technologies */
-	DRIVER( bowlrama )	/* (c) 1991 P & P Marketing */
-/*
-The Incredible Technologies game list
-http://www.itsgames.com/it/CorporateProfile/corporateprofile_main.htm
-
-ShuffleShot - (Incredible Technologies, Inc.)
-Peter Jacobsen's Golden Tee '97 - (Incredible Technologies, Inc.)
-World Class Bowling - (Incredible Technologies, Inc.)
-Peter Jacobsen's Golden Tee 3D Golf - (Incredible Technologies, Inc.)
-Street Fighter - "The Movie" (Capcom)
-PAIRS - (Strata)
-BloodStorm - (Strata)
-Driver's Edge - (Strata)
-NFL Hard Yardage - (Strata)
-Time Killers - (Strata)
-Neck 'n' Neck - (Bundra Games)
-Ninja Clowns - (Strata)
-Rim Rockin' Basketball - (Strata)
-Arlington Horse Racing - (Strata)
-Dyno Bop - (Grand Products)
-Poker Dice - (Strata)
-Peggle - (Strata)
-Slick Shot - (Grand Products)
-Golden Tee Golf II - (Strata)
-Hot Shots Tennis - (Strata)
-Strata Bowling - (Strata)
-Golden Tee Golf I - (Strata)
-Capcom Bowling - (Strata)
-*/
-
-	/* Leland games */
-TESTDRIVER( mayhem )	/* (c) 1985 Cinematronics */
-TESTDRIVER( wseries )	/* (c) 1985 Cinematronics Inc. */
-TESTDRIVER( dangerz )	/* (c) 1986 Cinematronics USA Inc. */
-TESTDRIVER( basebal2 )	/* (c) 1987 Cinematronics Inc. */
-TESTDRIVER( dblplay )	/* (c) 1987 Tradewest / The Leland Corp. */
-TESTDRIVER( teamqb )	/* (c) 1988 Leland Corp. */
-TESTDRIVER( strkzone )	/* (c) 1988 The Leland Corporation */
-TESTDRIVER( offroad )	/* (c) 1989 Leland Corp. */
-TESTDRIVER( offroadt )
-TESTDRIVER( pigout )	/* (c) 1990 The Leland Corporation */
-TESTDRIVER( pigoutj )	/* (c) 1990 The Leland Corporation */
-TESTDRIVER( redlin2p )
-TESTDRIVER( viper )
-TESTDRIVER( aafb )
-TESTDRIVER( aafb2p )
-TESTDRIVER( aafbu )
-TESTDRIVER( alleymas )
-TESTDRIVER( cerberus )
-TESTDRIVER( ataxx )
-TESTDRIVER( ataxxa )
-TESTDRIVER( indyheat )
-TESTDRIVER( wsf )
-
-	/* Gremlin 8080 games */
-	/* the numbers listed are the range of ROM part numbers */
-	DRIVER( blockade )	/* 1-4 [1977 Gremlin] */
-	DRIVER( comotion )	/* 5-7 [1977 Gremlin] */
-	DRIVER( hustle )	/* 16-21 [1977 Gremlin] */
-	DRIVER( blasto )	/* [1978 Gremlin] */
-
-	/* Gremlin/Sega "VIC dual game board" games */
-	/* the numbers listed are the range of ROM part numbers */
-	DRIVER( depthch )	/* 50-55 [1977 Gremlin?] */
-	DRIVER( safari )	/* 57-66 [1977 Gremlin?] */
-	DRIVER( frogs )		/* 112-119 [1978 Gremlin?] */
-	DRIVER( sspaceat )	/* 155-162 (c) */
-	DRIVER( sspacatc )	/* 139-146 (c) */
-	DRIVER( headon )	/* 163-167/192-193 (c) Gremlin */
-	DRIVER( headonb )	/* 163-167/192-193 (c) Gremlin */
-	DRIVER( headon2 )	/* ???-??? (c) 1979 Sega */
-	/* ???-??? Fortress */
-	/* ???-??? Gee Bee */
-	/* 255-270  Head On 2 / Deep Scan */
-	DRIVER( invho2 )	/* 271-286 (c) 1979 Sega */
-	DRIVER( samurai )	/* 289-302 + upgrades (c) 1980 Sega */
-	DRIVER( invinco )	/* 310-318 (c) 1979 Sega */
-	DRIVER( invds )		/* 367-382 (c) 1979 Sega */
-	DRIVER( tranqgun )	/* 413-428 (c) 1980 Sega */
-	/* 450-465  Tranquilizer Gun (different version?) */
-	/* ???-??? Car Hunt / Deep Scan */
-	DRIVER( spacetrk )	/* 630-645 (c) 1980 Sega */
-	DRIVER( sptrekct )	/* (c) 1980 Sega */
-	DRIVER( carnival )	/* 651-666 (c) 1980 Sega */
-	DRIVER( carnvckt )	/* 501-516 (c) 1980 Sega */
-	DRIVER( digger )	/* 684-691 no copyright notice */
-	DRIVER( pulsar )	/* 790-805 (c) 1981 Sega */
-	DRIVER( heiankyo )	/* (c) [1979?] Denki Onkyo */
-
-	/* Sega G-80 vector games */
-	DRIVER( spacfury )	/* (c) 1981 */
-	DRIVER( spacfura )	/* no copyright notice */
-	DRIVER( zektor )	/* (c) 1982 */
-	DRIVER( tacscan )	/* (c) */
-	DRIVER( elim2 )		/* (c) 1981 Gremlin */
-	DRIVER( elim2a )	/* (c) 1981 Gremlin */
-	DRIVER( elim4 )		/* (c) 1981 Gremlin */
-	DRIVER( startrek )	/* (c) 1982 */
-
-	/* Sega G-80 raster games */
-	DRIVER( astrob )	/* (c) 1981 */
-	DRIVER( astrob1 )	/* (c) 1981 */
-	DRIVER( 005 )		/* (c) 1981 */
-	DRIVER( monsterb )	/* (c) 1982 */
-	DRIVER( spaceod )	/* (c) 1981 */
-	DRIVER( pignewt )	/* (c) 1983 */
-	DRIVER( pignewta )	/* (c) 1983 */
-	DRIVER( sindbadm )	/* 834-5244 (c) 1983 Sega */
-
-	/* Sega "Zaxxon hardware" games */
-	DRIVER( zaxxon )	/* (c) 1982 */
-	DRIVER( zaxxon2 )	/* (c) 1982 */
-	DRIVER( zaxxonb )	/* bootleg */
-	DRIVER( szaxxon )	/* (c) 1982 */
-	DRIVER( futspy )	/* (c) 1984 */
-	DRIVER( razmataz )	/* modified 834-0213, 834-0214 (c) 1983 */
-	DRIVER( congo )		/* 605-5167 (c) 1983 */
-	DRIVER( tiptop )	/* 605-5167 (c) 1983 */
-
-	/* Sega System 1 / System 2 games */
-	DRIVER( starjack )	/* 834-5191 (c) 1983 (S1) */
-	DRIVER( starjacs )	/* (c) 1983 Stern (S1) */
-	DRIVER( regulus )	/* 834-5328(c) 1983 (S1) */
-	DRIVER( regulusu )	/* 834-5328(c) 1983 (S1) */
-	DRIVER( upndown )	/* (c) 1983 (S1) */
-	DRIVER( mrviking )	/* 834-5383 (c) 1984 (S1) */
-	DRIVER( mrvikinj )	/* 834-5383 (c) 1984 (S1) */
-	DRIVER( swat )		/* 834-5388 (c) 1984 Coreland / Sega (S1) */
-	DRIVER( flicky )	/* (c) 1984 (S1) */
-	DRIVER( flicky2 )	/* (c) 1984 (S1) */
-	/* Water Match (S1) */
-	DRIVER( bullfgtj )	/* 834-5478 (c) 1984 Sega / Coreland (S1) */
-	DRIVER( pitfall2 )	/* 834-5627 [1985?] reprogrammed, (c) 1984 Activision (S1) */
-	DRIVER( pitfallu )	/* 834-5627 [1985?] reprogrammed, (c) 1984 Activision (S1) */
-	DRIVER( seganinj )	/* 834-5677 (c) 1985 (S1) */
-	DRIVER( seganinu )	/* 834-5677 (c) 1985 (S1) */
-	DRIVER( nprinces )	/* 834-5677 (c) 1985 (S1) */
-	DRIVER( nprincsu )	/* 834-5677 (c) 1985 (S1) */
-	DRIVER( nprincsb )	/* bootleg? (S1) */
-	DRIVER( imsorry )	/* 834-5707 (c) 1985 Coreland / Sega (S1) */
-	DRIVER( imsorryj )	/* 834-5707 (c) 1985 Coreland / Sega (S1) */
-	DRIVER( teddybb )	/* 834-5712 (c) 1985 (S1) */
-	DRIVER( hvymetal )	/* 834-5745 (c) 1985 (S2?) */
-	DRIVER( myhero )	/* 834-5755 (c) 1985 (S1) */
-	DRIVER( myheroj )	/* 834-5755 (c) 1985 Coreland / Sega (S1) */
-	DRIVER( myherok )	/* 834-5755 (c) 1985 Coreland / Sega (S1) */
-	DRIVER( shtngmst )	/* 834-5719/5720 (c) 1985 (S2) */
-	DRIVER( chplft )	/* 834-5795 (c) 1985, (c) 1982 Dan Gorlin (S2) */
-	DRIVER( chplftb )	/* 834-5795 (c) 1985, (c) 1982 Dan Gorlin (S2) */
-	DRIVER( chplftbl )	/* bootleg (S2) */
-	DRIVER( 4dwarrio )	/* 834-5918 (c) 1985 Coreland / Sega (S1) */
-	DRIVER( brain )		/* (c) 1986 Coreland / Sega (S2?) */
-	DRIVER( wboy )		/* 834-5984 (c) 1986 + Escape license (S1) */
-	DRIVER( wboy2 )		/* 834-5984 (c) 1986 + Escape license (S1) */
-	DRIVER( wboy3 )
-	DRIVER( wboy4 )		/* 834-5984 (c) 1986 + Escape license (S1) */
-	DRIVER( wboyu )		/* 834-5753 (? maybe a conversion) (c) 1986 + Escape license (S1) */
-	DRIVER( wboy4u )	/* 834-5984 (c) 1986 + Escape license (S1) */
-	DRIVER( wbdeluxe )	/* (c) 1986 + Escape license (S1) */
-	DRIVER( gardia )	/* 834-6119 (S2?) */
-	DRIVER( gardiab )	/* bootleg */
-	DRIVER( blockgal )	/* 834-6303 (S1) */
-	DRIVER( blckgalb )	/* bootleg */
-	DRIVER( tokisens )	/* (c) 1987 (from a bootleg board) (S2) */
-	DRIVER( wbml )		/* bootleg (S2) */
-	DRIVER( wbmlj )		/* (c) 1987 Sega/Westone (S2) */
-	DRIVER( wbmlj2 )	/* (c) 1987 Sega/Westone (S2) */
-	DRIVER( wbmlju )	/* bootleg? (S2) */
-	DRIVER( dakkochn )	/* 836-6483? (S2) */
-	DRIVER( ufosensi )	/* 834-6659 (S2) */
-/*
-other System 1 / System 2 games:
-
-WarBall
-Rafflesia
-Sanrin Sanchan
-DokiDoki Penguin Land *not confirmed
-*/
-
-	/* Sega System E games (Master System hardware) */
-/*
-???          834-5492 (??? not sure it's System E)
-Transformer  834-5803 (c) 1986
-Opa Opa
-Fantasy Zone 2
-Hang-On Jr.
-(more?)
-*/
-
-	/* other Sega 8-bit games */
-	DRIVER( turbo )		/* (c) 1981 Sega */
-	DRIVER( turboa )	/* (c) 1981 Sega */
-	DRIVER( turbob )	/* (c) 1981 Sega */
-TESTDRIVER( kopunch )	/* 834-0103 (c) 1981 Sega */
-	DRIVER( suprloco )	/* (c) 1982 Sega */
-	DRIVER( champbas )	/* (c) 1983 Sega */
-	DRIVER( champbb2 )
-	DRIVER( appoooh )	/* (c) 1984 Sega */
-	DRIVER( bankp )		/* (c) 1984 Sega */
-	DRIVER( dotrikun )	/* cabinet test board */
-	DRIVER( dotriku2 )	/* cabinet test board */
-
-	/* Sega System 16 games */
-	// Not working
-	DRIVER( alexkidd )	/* (c) 1986 (protected) */
-	DRIVER( aliensya )	/* (c) 1987 (protected) */
-	DRIVER( aliensyb )	/* (c) 1987 (protected) */
-	DRIVER( aliensyj )	/* (c) 1987 (protected. Japan) */
-	DRIVER( astorm )	/* (c) 1990 (protected) */
-	DRIVER( astorm2p )	/* (c) 1990 (protected 2 Players) */
-	DRIVER( auraila )	/* (c) 1990 Sega / Westone (protected) */
-	DRIVER( bayrouta )	/* (c) 1989 (protected) */
-	DRIVER( bayrtbl1 )	/* (c) 1989 (protected) (bootleg) */
-	DRIVER( bayrtbl2 )	/* (c) 1989 (protected) (bootleg) */
-	DRIVER( enduror )	/* (c) 1985 (protected) */
-	DRIVER( eswat )		/* (c) 1989 (protected) */
-	DRIVER( fpoint )	/* (c) 1989 (protected) */
-	DRIVER( goldnaxb )	/* (c) 1989 (protected) */
-	DRIVER( goldnaxc )	/* (c) 1989 (protected) */
-	DRIVER( goldnaxj )	/* (c) 1989 (protected. Japan) */
-	DRIVER( jyuohki )	/* (c) 1988 (protected. Altered Beast Japan) */
-	DRIVER( moonwalk )	/* (c) 1990 (protected) */
-	DRIVER( moonwlka )	/* (c) 1990 (protected) */
-	DRIVER( passsht )	/* (protected) */
-	DRIVER( sdioj )		/* (c) 1987 (protected. Japan) */
-	DRIVER( shangon )	/* (c) 1992 (protected) */
-	DRIVER( shinobia )	/* (c) 1987 (protected) */
-	DRIVER( shinobib )	/* (c) 1987 (protected) */
-	DRIVER( tetris )	/* (c) 1988 (protected) */
-	DRIVER( tetrisa )	/* (c) 1988 (protected) */
-	DRIVER( wb3a )		/* (c) 1988 Sega / Westone (protected) */
-
-TESTDRIVER( aceattac )	/* (protected) */
-TESTDRIVER( aburner )	/* */
-TESTDRIVER( aburner2 )  /* */
-TESTDRIVER( afighter )	/* (protected) */
-TESTDRIVER( bloxeed )	/* (protected) */
-TESTDRIVER( cltchitr )	/* (protected) */
-TESTDRIVER( cotton )	/* (protected) */
-TESTDRIVER( cottona )	/* (protected) */
-TESTDRIVER( ddcrew )	/* (protected) */
-TESTDRIVER( dunkshot )	/* (protected) */
-TESTDRIVER( exctleag )  /* (protected) */
-TESTDRIVER( lghost )	/* (protected) */
-TESTDRIVER( loffire )	/* (protected) */
-TESTDRIVER( mvp )		/* (protected) */
-TESTDRIVER( ryukyu )	/* (protected) */
-TESTDRIVER( suprleag )  /* (protected) */
-TESTDRIVER( thndrbld )	/* (protected) */
-TESTDRIVER( thndrbdj )  /* (protected?) */
-TESTDRIVER( toutrun )	/* (protected) */
-TESTDRIVER( toutruna )	/* (protected) */
-
-	// Working
-	DRIVER( alexkida )	/* (c) 1986 */
-	DRIVER( aliensyn )	/* (c) 1987 */
-	DRIVER( altbeas2 )	/* (c) 1988 */
-	DRIVER( altbeast )	/* (c) 1988 */
-	DRIVER( astormbl )	/* bootleg */
-	DRIVER( atomicp )	/* (c) 1990 Philko */
-	DRIVER( aurail )	/* (c) 1990 Sega / Westone */
-	DRIVER( bayroute )	/* (c) 1989 */
-	DRIVER( bodyslam )	/* (c) 1986 */
-	DRIVER( dduxbl )	/* (c) 1989 (Datsu bootleg) */
-	DRIVER( dumpmtmt )	/* (c) 1986 (Japan) */
-	DRIVER( endurob2 )	/* (c) 1985 (Beta bootleg) */
-	DRIVER( endurobl )	/* (c) 1985 (Herb bootleg) */
-	DRIVER( eswatbl )	/* (c) 1989 (but bootleg) */
-	DRIVER( fantzone )	/* (c) 1986 */
-	DRIVER( fantzono )	/* (c) 1986 */
-	DRIVER( fpointbl )	/* (c) 1989 (Datsu bootleg) */
-	DRIVER( goldnabl )	/* (c) 1989 (bootleg) */
-	DRIVER( goldnaxa )	/* (c) 1989 */
-	DRIVER( goldnaxe )	/* (c) 1989 */
-	DRIVER( hangon )	/* (c) 1985 */
-	DRIVER( hwchamp )	/* (c) 1987 */
-	DRIVER( mjleague )	/* (c) 1985 */
-	DRIVER( moonwlkb )	/* bootleg */
-	DRIVER( outrun )	/* (c) 1986 (bootleg)*/
-	DRIVER( outruna )	/* (c) 1986 (bootleg) */
-	DRIVER( outrunb )	/* (c) 1986 (protected beta bootleg) */
-	DRIVER( passht4b )	/* bootleg */
-	DRIVER( passshtb )	/* bootleg */
-	DRIVER( quartet )	/* (c) 1986 */
-	DRIVER( quartet2 )	/* (c) 1986 */
-	DRIVER( quartetj )	/* (c) 1986 */
-	DRIVER( riotcity )	/* (c) 1991 Sega / Westone */
-	DRIVER( sdi )		/* (c) 1987 */
-	DRIVER( shangonb )	/* (c) 1992 (but bootleg) */
-	DRIVER( sharrier )	/* (c) 1985 */
-	DRIVER( shdancbl )	/* (c) 1989 (but bootleg) */
-	DRIVER( shdancer )	/* (c) 1989 */
-	DRIVER( shdancrj )	/* (c) 1989 */
-	DRIVER( shinobi )	/* (c) 1987 */
-	DRIVER( shinobl )	/* (c) 1987 (but bootleg) */
-	DRIVER( tetrisbl )	/* (c) 1988 (but bootleg) */
-	DRIVER( timscanr )	/* (c) 1987 */
-	DRIVER( toryumon )	/* (c) 1995 */
-	DRIVER( tturf )		/* (c) 1989 Sega / Sunsoft */
-	DRIVER( tturfbl )	/* (c) 1989 (Datsu bootleg) */
-	DRIVER( tturfu )	/* (c) 1989 Sega / Sunsoft */
-	DRIVER( wb3 )		/* (c) 1988 Sega / Westone */
-	DRIVER( wb3bl )		/* (c) 1988 Sega / Westone (but bootleg) */
-	DRIVER( wrestwar )	/* (c) 1989 */
-
-	/* Data East "Burger Time hardware" games */
-	DRIVER( lnc )		/* (c) 1981 */
-	DRIVER( zoar )		/* (c) 1982 */
-	DRIVER( btime )		/* (c) 1982 */
-	DRIVER( btime2 )	/* (c) 1982 */
-	DRIVER( btimem )	/* (c) 1982 + Midway */
-	DRIVER( wtennis )	/* bootleg 1982 */
-	DRIVER( brubber )	/* (c) 1982 */
-	DRIVER( bnj )		/* (c) 1982 + Midway */
-	DRIVER( caractn )	/* bootleg */
-	DRIVER( disco )		/* (c) 1982 */
-	DRIVER( mmonkey )	/* (c) 1982 Technos Japan + Roller Tron */
-	/* cassette system */
-TESTDRIVER( decocass )
-	DRIVER( cookrace )	/* bootleg */
-
-	/* other Data East games */
-	DRIVER( astrof )	/* (c) [1980?] */
-	DRIVER( astrof2 )	/* (c) [1980?] */
-	DRIVER( astrof3 )	/* (c) [1980?] */
-	DRIVER( tomahawk )	/* (c) [1980?] */
-	DRIVER( tomahaw5 )	/* (c) [1980?] */
-	DRIVER( kchamp )	/* (c) 1984 Data East USA (US) */
-	DRIVER( karatedo )	/* (c) 1984 Data East Corporation (Japan) */
-	DRIVER( kchampvs )	/* (c) 1984 Data East USA (US) */
-	DRIVER( karatevs )	/* (c) 1984 Data East Corporation (Japan) */
-	DRIVER( firetrap )	/* (c) 1986 */
-	DRIVER( firetpbl )	/* bootleg */
-	DRIVER( brkthru )	/* (c) 1986 Data East USA (US) */
-	DRIVER( brkthruj )	/* (c) 1986 Data East Corporation (Japan) */
-	DRIVER( darwin )	/* (c) 1986 Data East Corporation (Japan) */
-	DRIVER( shootout )	/* (c) 1985 Data East USA (US) */
-	DRIVER( sidepckt )	/* (c) 1986 Data East Corporation */
-	DRIVER( sidepctj )	/* (c) 1986 Data East Corporation */
-	DRIVER( sidepctb )	/* bootleg */
-	DRIVER( exprraid )	/* (c) 1986 Data East USA (US) */
-	DRIVER( wexpress )	/* (c) 1986 Data East Corporation (World?) */
-	DRIVER( wexpresb )	/* bootleg */
-	DRIVER( pcktgal )	/* (c) 1987 Data East Corporation (Japan) */
-	DRIVER( pcktgalb )	/* bootleg */
-	DRIVER( pcktgal2 )	/* (c) 1989 Data East Corporation (World?) */
-	DRIVER( spool3 )	/* (c) 1989 Data East Corporation (World?) */
-	DRIVER( spool3i )	/* (c) 1990 Data East Corporation + I-Vics license */
-	DRIVER( actfancr )	/* (c) 1989 Data East Corporation (World) */
-	DRIVER( actfancj )	/* (c) 1989 Data East Corporation (Japan) */
-	DRIVER( triothep )	/* (c) 1989 Data East Corporation (Japan) */
-
-	/* Data East 8-bit games */
-	DRIVER( lastmiss )	/* (c) 1986 Data East USA (US) */
-	DRIVER( lastmss2 )	/* (c) 1986 Data East USA (US) */
-	DRIVER( shackled )	/* (c) 1986 Data East USA (US) */
-	DRIVER( breywood )	/* (c) 1986 Data East Corporation (Japan) */
-	DRIVER( csilver )	/* (c) 1987 Data East Corporation (Japan) */
-	DRIVER( ghostb )	/* (c) 1987 Data East USA (US) */
-	DRIVER( ghostb3 )	/* (c) 1987 Data East USA (US) */
-	DRIVER( meikyuh )	/* (c) 1987 Data East Corporation (Japan) */
-	DRIVER( srdarwin )	/* (c) 1987 Data East Corporation (Japan) */
-	DRIVER( gondo )		/* (c) 1987 Data East USA (US) */
-	DRIVER( makyosen )	/* (c) 1987 Data East Corporation (Japan) */
-	DRIVER( garyoret )	/* (c) 1987 Data East Corporation (Japan) */
-	DRIVER( cobracom )	/* (c) 1988 Data East Corporation (Japan) */
-	DRIVER( oscar )		/* (c) 1988 Data East USA (US) */
-	DRIVER( oscarj )	/* (c) 1987 Data East Corporation (Japan) */
-
-	/* Data East 16-bit games */
-	DRIVER( karnov )	/* (c) 1987 Data East USA (US) */
-	DRIVER( karnovj )	/* (c) 1987 Data East Corporation (Japan) */
-TESTDRIVER( wndrplnt )	/* (c) 1987 Data East Corporation (Japan) */
-	DRIVER( chelnov )	/* (c) 1988 Data East USA (US) */
-	DRIVER( chelnovj )	/* (c) 1988 Data East Corporation (Japan) */
-/* the following ones all run on similar hardware */
-	DRIVER( hbarrel )	/* (c) 1987 Data East USA (US) */
-	DRIVER( hbarrelw )	/* (c) 1987 Data East Corporation (World) */
-	DRIVER( baddudes )	/* (c) 1988 Data East USA (US) */
-	DRIVER( drgninja )	/* (c) 1988 Data East Corporation (Japan) */
-TESTDRIVER( birdtry )	/* (c) 1988 Data East Corporation (Japan) */
-	DRIVER( robocop )	/* (c) 1988 Data East Corporation (World) */
-	DRIVER( robocopu )	/* (c) 1988 Data East USA (US) */
-	DRIVER( robocpu0 )	/* (c) 1988 Data East USA (US) */
-	DRIVER( robocopb )	/* bootleg */
-	DRIVER( hippodrm )	/* (c) 1989 Data East USA (US) */
-	DRIVER( ffantasy )	/* (c) 1989 Data East Corporation (Japan) */
-	DRIVER( slyspy )	/* (c) 1989 Data East USA (US) */
-	DRIVER( slyspy2 )	/* (c) 1989 Data East USA (US) */
-	DRIVER( secretag )	/* (c) 1989 Data East Corporation (World) */
-TESTDRIVER( secretab )	/* bootleg */
-	DRIVER( midres )	/* (c) 1989 Data East Corporation (World) */
-	DRIVER( midresu )	/* (c) 1989 Data East USA (US) */
-	DRIVER( midresj )	/* (c) 1989 Data East Corporation (Japan) */
-	DRIVER( bouldash )	/* (c) 1990 Data East Corporation */
-/* end of similar hardware */
-	DRIVER( stadhero )	/* (c) 1988 Data East Corporation (Japan) */
-	DRIVER( madmotor )	/* (c) [1989] Mitchell */
-	/* All these games have a unique code stamped on the mask roms */
-	DRIVER( vaportra )	/* MAA (c) 1989 Data East Corporation (US) */
-	DRIVER( kuhga )		/* MAA (c) 1989 Data East Corporation (Japan) */
-	DRIVER( cbuster )	/* MAB (c) 1990 Data East Corporation (World) */
-	DRIVER( cbusterw )	/* MAB (c) 1990 Data East Corporation (World) */
-	DRIVER( cbusterj )	/* MAB (c) 1990 Data East Corporation (Japan) */
-	DRIVER( twocrude )	/* MAB (c) 1990 Data East USA (US) */
-	DRIVER( darkseal )	/* MAC (c) 1990 Data East Corporation (World) */
-	DRIVER( darksea1 )	/* MAC (c) 1990 Data East Corporation (World) */
-	DRIVER( darkseaj )	/* MAC (c) 1990 Data East Corporation (Japan) */
-	DRIVER( gatedoom )	/* MAC (c) 1990 Data East Corporation (US) */
-	DRIVER( gatedom1 )	/* MAC (c) 1990 Data East Corporation (US) */
-TESTDRIVER( edrandy )	/* MAD (c) 1990 Data East Corporation (World) */
-TESTDRIVER( edrandyj )	/* MAD (c) 1990 Data East Corporation (Japan) */
-	DRIVER( supbtime )	/* MAE (c) 1990 Data East Corporation (Japan) */
-	/* Mutant Fighter/Death Brade MAF (c) 1991 */
-	DRIVER( cninja )	/* MAG (c) 1991 Data East Corporation (World) */
-	DRIVER( cninja0 )	/* MAG (c) 1991 Data East Corporation (World) */
-	DRIVER( cninjau )	/* MAG (c) 1991 Data East Corporation (US) */
-	DRIVER( joemac )	/* MAG (c) 1991 Data East Corporation (Japan) */
-	DRIVER( stoneage )	/* bootleg */
-	/* Robocop 2           MAH (c) 1991 */
-	/* Desert Assault/Thunderzone MAJ (c) 1991 */
-	/* Rohga Armour Attack/Wolf Fang MAM (c) 1991 */
-	/* Captain America     MAN (c) 1991 */
-	DRIVER( tumblep )	/* MAP (c) 1991 Data East Corporation (World) */
-	DRIVER( tumblepb )	/* bootleg */
-	DRIVER( tumblep2 )	/* bootleg */
-	/* Dragon Gun/Dragoon  MAR (c) 1992 */
-	/* Wizard's Fire       MAS (c) 1992 */
-TESTDRIVER( funkyjet )	/* MAT (c) 1992 Mitchell */
-	/* Diet GoGo      	   MAY (c) 1993 */
- 	/* Fighter's History   MBF (c) 1993 */
-	/* Joe & Mac Return    MBN (c) 1994 */
-	/* Chain Reaction      MCC (c) 1994 */
-
-	/* Tehkan / Tecmo games (Tehkan became Tecmo in 1986) */
-	DRIVER( senjyo )	/* (c) 1983 Tehkan */
-	DRIVER( starforc )	/* (c) 1984 Tehkan */
-	DRIVER( starfore )	/* (c) 1984 Tehkan */
-	DRIVER( megaforc )	/* (c) 1985 Tehkan + Video Ware license */
-	DRIVER( baluba )	/* (c) 1986 Able Corp. */
-	DRIVER( bombjack )	/* (c) 1984 Tehkan */
-	DRIVER( bombjac2 )	/* (c) 1984 Tehkan */
-	DRIVER( pbaction )	/* (c) 1985 Tehkan */
-	DRIVER( pbactio2 )	/* (c) 1985 Tehkan */
-	DRIVER( pontoon )	/* 6011 - (c) 1985 Tehkan */
-	DRIVER( tehkanwc )	/* (c) 1985 Tehkan */
-	DRIVER( gridiron )	/* (c) 1985 Tehkan */
-	DRIVER( teedoff )	/* 6102 - (c) 1986 Tecmo */
-	DRIVER( solomon )	/* (c) 1986 Tecmo */
-	DRIVER( rygar )		/* 6002 - (c) 1986 Tecmo */
-	DRIVER( rygar2 )	/* 6002 - (c) 1986 Tecmo */
-	DRIVER( rygarj )	/* 6002 - (c) 1986 Tecmo */
-	DRIVER( gemini )	/* (c) 1987 Tecmo */
-	DRIVER( silkworm )	/* 6217 - (c) 1988 Tecmo */
-	DRIVER( silkwrm2 )	/* 6217 - (c) 1988 Tecmo */
-	DRIVER( gaiden )	/* 6215 - (c) 1988 Tecmo */
-	DRIVER( shadoww )	/* 6215 - (c) 1988 Tecmo */
-	DRIVER( tknight )	/* (c) 1989 Tecmo */
-	DRIVER( wildfang )	/* (c) 1989 Tecmo */
-	DRIVER( wc90 )		/* (c) 1989 Tecmo */
-	DRIVER( wc90b )		/* bootleg */
-
-/* Other Tehkan games:
-6009 Tank Busters
-*/
-
-	/* Konami bitmap games */
-	DRIVER( tutankhm )	/* GX350 (c) 1982 Konami */
-	DRIVER( tutankst )	/* GX350 (c) 1982 Stern */
-	DRIVER( junofrst )	/* GX310 (c) 1983 Konami */
-
-	/* Konami games */
-	DRIVER( pooyan )	/* GX320 (c) 1982 */
-	DRIVER( pooyans )	/* GX320 (c) 1982 Stern */
-	DRIVER( pootan )	/* bootleg */
-	DRIVER( timeplt )	/* GX393 (c) 1982 */
-	DRIVER( timepltc )	/* GX393 (c) 1982 + Centuri license*/
-	DRIVER( spaceplt )	/* bootleg */
-	DRIVER( psurge )	/* (c) 1988 unknown (NOT Konami) */
-	DRIVER( megazone )	/* GX319 (c) 1983 */
-	DRIVER( megaznik )	/* GX319 (c) 1983 + Interlogic / Kosuka */
-	DRIVER( pandoras )	/* GX328 (c) 1984 + Interlogic */
-	DRIVER( gyruss )	/* GX347 (c) 1983 */
-	DRIVER( gyrussce )	/* GX347 (c) 1983 + Centuri license */
-	DRIVER( venus )		/* bootleg */
-	DRIVER( trackfld )	/* GX361 (c) 1983 */
-	DRIVER( trackflc )	/* GX361 (c) 1983 + Centuri license */
-	DRIVER( hyprolym )	/* GX361 (c) 1983 */
-	DRIVER( hyprolyb )	/* bootleg */
-	DRIVER( rocnrope )	/* GX364 (c) 1983 */
-	DRIVER( rocnropk )	/* GX364 (c) 1983 + Kosuka */
-	DRIVER( circusc )	/* GX380 (c) 1984 */
-	DRIVER( circusc2 )	/* GX380 (c) 1984 */
-	DRIVER( circuscc )	/* GX380 (c) 1984 + Centuri license */
-	DRIVER( circusce )	/* GX380 (c) 1984 + Centuri license */
-	DRIVER( tp84 )		/* GX388 (c) 1984 */
-	DRIVER( tp84a )		/* GX388 (c) 1984 */
-	DRIVER( hyperspt )	/* GX330 (c) 1984 + Centuri */
-	DRIVER( hpolym84 )	/* GX330 (c) 1984 */
-	DRIVER( sbasketb )	/* GX405 (c) 1984 */
-	DRIVER( mikie )		/* GX469 (c) 1984 */
-	DRIVER( mikiej )	/* GX469 (c) 1984 */
-	DRIVER( mikiehs )	/* GX469 (c) 1984 */
-	DRIVER( roadf )		/* GX461 (c) 1984 */
-	DRIVER( roadf2 )	/* GX461 (c) 1984 */
-	DRIVER( yiear )		/* GX407 (c) 1985 */
-	DRIVER( yiear2 )	/* GX407 (c) 1985 */
-	DRIVER( kicker )	/* GX477 (c) 1985 */
-	DRIVER( shaolins )	/* GX477 (c) 1985 */
-	DRIVER( pingpong )	/* GX555 (c) 1985 */
-	DRIVER( gberet )	/* GX577 (c) 1985 */
-	DRIVER( rushatck )	/* GX577 (c) 1985 */
-	DRIVER( gberetb )	/* bootleg on different hardware */
-	DRIVER( mrgoemon )	/* GX621 (c) 1986 (Japan) */
-	DRIVER( jailbrek )	/* GX507 (c) 1986 */
-	DRIVER( finalizr )	/* GX523 (c) 1985 */
-	DRIVER( finalizb )	/* bootleg */
-	DRIVER( ironhors )	/* GX560 (c) 1986 */
-	DRIVER( dairesya )	/* GX560 (c) 1986 (Japan) */
-	DRIVER( farwest )
-	DRIVER( jackal )	/* GX631 (c) 1986 (World) */
-	DRIVER( topgunr )	/* GX631 (c) 1986 (US) */
-	DRIVER( jackalj )	/* GX631 (c) 1986 (Japan) */
-	DRIVER( topgunbl )	/* bootleg */
-	DRIVER( ddribble )	/* GX690 (c) 1986 */
-	DRIVER( contra )	/* GX633 (c) 1987 */
-	DRIVER( contrab )	/* bootleg */
-	DRIVER( contraj )	/* GX633 (c) 1987 (Japan) */
-	DRIVER( contrajb )	/* bootleg */
-	DRIVER( gryzor )	/* GX633 (c) 1987 */
-	DRIVER( combasc )	/* GX611 (c) 1988 */
-	DRIVER( combasct )	/* GX611 (c) 1987 */
-	DRIVER( combascj )	/* GX611 (c) 1987 (Japan) */
-	DRIVER( bootcamp )	/* GX611 (c) 1987 */
-	DRIVER( combascb )	/* bootleg */
-	DRIVER( rockrage )	/* GX620 (c) 1986 (World?) */
-	DRIVER( rockragj )	/* GX620 (c) 1986 (Japan) */
-	DRIVER( mx5000 )	/* GX669 (c) 1987 */
-	DRIVER( flkatck )	/* GX669 (c) 1987 (Japan) */
-	DRIVER( fastlane )	/* GX752 (c) 1987 */
-	DRIVER( thehustl )	/* GX765 (c) 1987 (Japan) */
-	DRIVER( thehustj )	/* GX765 (c) 1987 (Japan) */
-	DRIVER( battlnts )	/* GX777 (c) 1987 */
-	DRIVER( battlntj )	/* GX777 (c) 1987 (Japan) */
-	DRIVER( bladestl )	/* GX797 (c) 1987 */
-	DRIVER( bladstle )	/* GX797 (c) 1987 */
-	DRIVER( hcastle )	/* GX768 (c) 1988 */
-	DRIVER( hcastlea )	/* GX768 (c) 1988 */
-	DRIVER( hcastlej )	/* GX768 (c) 1988 (Japan) */
-	DRIVER( ajax )		/* GX770 (c) 1987 */
-	DRIVER( ajaxj )		/* GX770 (c) 1987 (Japan) */
-	DRIVER( scontra )	/* GX775 (c) 1988 */
-	DRIVER( scontraj )	/* GX775 (c) 1988 (Japan) */
-	DRIVER( thunderx )	/* GX873 (c) 1988 */
-	DRIVER( thnderxj )	/* GX873 (c) 1988 (Japan) */
-	DRIVER( mainevt )	/* GX799 (c) 1988 */
-	DRIVER( mainevt2 )	/* GX799 (c) 1988 */
-	DRIVER( ringohja )	/* GX799 (c) 1988 (Japan) */
-	DRIVER( devstors )	/* GX890 (c) 1988 */
-	DRIVER( devstor2 )	/* GX890 (c) 1988 */
-	DRIVER( devstor3 )	/* GX890 (c) 1988 */
-	DRIVER( garuka )	/* GX890 (c) 1988 (Japan) */
-	DRIVER( 88games )	/* GX861 (c) 1988 */
-	DRIVER( konami88 )	/* GX861 (c) 1988 */
-	DRIVER( gbusters )	/* GX878 (c) 1988 */
-	DRIVER( crazycop )	/* GX878 (c) 1988 (Japan) */
-	DRIVER( crimfght )	/* GX821 (c) 1989 (US) */
-	DRIVER( crimfgtj )	/* GX821 (c) 1989 (Japan) */
-	DRIVER( spy )		/* GX857 (c) 1989 (US) */
-	DRIVER( bottom9 )	/* GX891 (c) 1989 */
-	DRIVER( bottom9n )	/* GX891 (c) 1989 */
-	DRIVER( blockhl )	/* GX973 (c) 1989 */
-	DRIVER( quarth )	/* GX973 (c) 1989 (Japan) */
-	DRIVER( aliens )	/* GX875 (c) 1990 (World) */
-	DRIVER( aliens2 )	/* GX875 (c) 1990 (World) */
-	DRIVER( aliensu )	/* GX875 (c) 1990 (US) */
-	DRIVER( aliensj )	/* GX875 (c) 1990 (Japan) */
-	DRIVER( surpratk )	/* GX911 (c) 1990 (Japan) */
-	DRIVER( parodius )	/* GX955 (c) 1990 (Japan) */
-	DRIVER( rollerg )	/* GX999 (c) 1991 (US) */
-	DRIVER( rollergj )	/* GX999 (c) 1991 (Japan) */
-TESTDRIVER( xexex )		/* GX067 (c) 1991 */
-	DRIVER( simpsons )	/* GX072 (c) 1991 */
-	DRIVER( simpsn2p )	/* GX072 (c) 1991 */
-	DRIVER( simps2pj )	/* GX072 (c) 1991 (Japan) */
-	DRIVER( vendetta )	/* GX081 (c) 1991 (Asia) */
-	DRIVER( vendett2 )	/* GX081 (c) 1991 (Asia) */
-	DRIVER( vendettj )	/* GX081 (c) 1991 (Japan) */
-	DRIVER( wecleman )	/* GX602 (c) 1986 */
-	DRIVER( hotchase )	/* GX763 (c) 1988 */
-
-	/* Konami "Nemesis hardware" games */
-	DRIVER( nemesis )	/* GX456 (c) 1985 */
-	DRIVER( nemesuk )	/* GX456 (c) 1985 */
-	DRIVER( konamigt )	/* GX561 (c) 1985 */
-	DRIVER( salamand )	/* GX587 (c) 1986 */
-	DRIVER( lifefrce )	/* GX587 (c) 1986 */
-	DRIVER( lifefrcj )	/* GX587 (c) 1986 */
-	/* GX400 BIOS based games */
-	DRIVER( rf2 )		/* GX561 (c) 1985 */
-	DRIVER( twinbee )	/* GX412 (c) 1985 */
-	DRIVER( gradius )	/* GX456 (c) 1985 */
-	DRIVER( gwarrior )	/* GX578 (c) 1985 */
-
-	/* Konami "Twin 16" games */
-	DRIVER( devilw )	/* GX687 (c) 1987 */
-	DRIVER( darkadv )	/* GX687 (c) 1987 */
-	DRIVER( majuu )		/* GX687 (c) 1987 (Japan) */
-	DRIVER( vulcan )	/* GX785 (c) 1988 */
-	DRIVER( gradius2 )	/* GX785 (c) 1988 (Japan) */
-	DRIVER( grdius2a )	/* GX785 (c) 1988 (Japan) */
-	DRIVER( grdius2b )	/* GX785 (c) 1988 (Japan) */
-	DRIVER( cuebrick )	/* GX903 (c) 1989 */
-	DRIVER( fround )	/* GX870 (c) 1988 */
-	DRIVER( hpuncher )	/* GX870 (c) 1988 (Japan) */
-	DRIVER( miaj )		/* GX808 (c) 1989 (Japan) */
-
-	/* Konami Gradius III board */
-	DRIVER( gradius3 )	/* GX945 (c) 1989 (Japan) */
-	DRIVER( grdius3a )	/* GX945 (c) 1989 (Asia) */
-
-	/* (some) Konami 68000 games */
-	DRIVER( mia )		/* GX808 (c) 1989 */
-	DRIVER( mia2 )		/* GX808 (c) 1989 */
-	DRIVER( tmnt )		/* GX963 (c) 1989 (US) */
-	DRIVER( tmht )		/* GX963 (c) 1989 (UK) */
-	DRIVER( tmntj )		/* GX963 (c) 1989 (Japan) */
-	DRIVER( tmht2p )	/* GX963 (c) 1989 (UK) */
-	DRIVER( tmnt2pj )	/* GX963 (c) 1990 (Japan) */
-	DRIVER( punkshot )	/* GX907 (c) 1990 (US) */
-	DRIVER( punksht2 )	/* GX907 (c) 1990 (US) */
-	DRIVER( lgtnfght )	/* GX939 (c) 1990 (US) */
-	DRIVER( trigon )	/* GX939 (c) 1990 (Japan) */
-	DRIVER( blswhstl )	/* GX060 (c) 1991 */
-	DRIVER( detatwin )	/* GX060 (c) 1991 (Japan) */
-TESTDRIVER( glfgreat )	/* GX061 (c) 1991 */
-	DRIVER( tmnt2 )		/* GX063 (c) 1991 (US) */
-	DRIVER( tmnt22p )	/* GX063 (c) 1991 (US) */
-	DRIVER( tmnt2a )	/* GX063 (c) 1991 (Asia) */
-	DRIVER( ssriders )	/* GX064 (c) 1991 (World) */
-	DRIVER( ssrdrebd )	/* GX064 (c) 1991 (World) */
-	DRIVER( ssrdrebc )	/* GX064 (c) 1991 (World) */
-	DRIVER( ssrdruda )	/* GX064 (c) 1991 (US) */
-	DRIVER( ssrdruac )	/* GX064 (c) 1991 (US) */
-	DRIVER( ssrdrubc )	/* GX064 (c) 1991 (US) */
-	DRIVER( ssrdrabd )	/* GX064 (c) 1991 (Asia) */
-	DRIVER( ssrdrjbd )	/* GX064 (c) 1991 (Japan) */
-	DRIVER( xmen )		/* GX065 (c) 1992 (US) */
-	DRIVER( xmen6p )	/* GX065 (c) 1992 */
-	DRIVER( xmen2pj )	/* GX065 (c) 1992 (Japan) */
-	DRIVER( thndrx2 )	/* GX073 (c) 1991 (Japan) */
-
-/*
-Konami System GX game list
-1994.03 Racing Force (GX250)
-1994.03 Golfing Greats 2 (GX218)
-1994.04 Gokujou Parodius (GX321)
-1994.07 Taisen Puzzle-dama (GX315)
-1994.12 Soccer Super Stars (GX427)
-1995.04 TwinBee Yahhoo! (GX424)
-1995.08 Dragoon Might (GX417)
-1995.12 Tokimeki Memorial Taisen Puzzle-dama (GX515)
-1996.01 Salamander 2 (GX521)
-1996.02 Sexy Parodius (GX533)
-1996.03 Daisu-Kiss (GX535)
-1996.03 Slam Dunk 2 / Run & Gun 2 (GX505)
-1996.10 Taisen Tokkae-dama (GX615)
-1996.12 Versus Net Soccer (GX627)
-1997.07 Winning Spike (GX705)
-1997.11 Rushing Heroes (GX?. Not released in Japan)
-*/
-
-	/* Exidy games */
-	DRIVER( sidetrac )	/* (c) 1979 */
-	DRIVER( targ )		/* (c) 1980 */
-	DRIVER( spectar )	/* (c) 1980 */
-	DRIVER( spectar1 )	/* (c) 1980 */
-	DRIVER( venture )	/* (c) 1981 */
-	DRIVER( venture2 )	/* (c) 1981 */
-	DRIVER( venture4 )	/* (c) 1981 */
-	DRIVER( mtrap )		/* (c) 1981 */
-	DRIVER( mtrap3 )	/* (c) 1981 */
-	DRIVER( mtrap4 )	/* (c) 1981 */
-	DRIVER( pepper2 )	/* (c) 1982 */
-	DRIVER( hardhat )	/* (c) 1982 */
-	DRIVER( fax )		/* (c) 1983 */
-	DRIVER( circus )	/* no copyright notice [1977?] */
-	DRIVER( robotbwl )	/* no copyright notice */
-	DRIVER( crash )		/* Exidy [1979?] */
-	DRIVER( ripcord )	/* Exidy [1977?] */
-	DRIVER( starfire )	/* Exidy [1979?] */
-	DRIVER( fireone )	/* (c) 1979 Exidy */
-
-	/* Exidy 440 games */
-	DRIVER( crossbow )	/* (c) 1983 */
-	DRIVER( cheyenne )	/* (c) 1984 */
-	DRIVER( combat )	/* (c) 1985 */
-	DRIVER( cracksht )	/* (c) 1985 */
-	DRIVER( claypign )	/* (c) 1986 */
-	DRIVER( chiller )	/* (c) 1986 */
-	DRIVER( topsecex )	/* (c) 1986 */
-	DRIVER( hitnmiss )	/* (c) 1987 */
-	DRIVER( hitnmis2 )	/* (c) 1987 */
-	DRIVER( whodunit )	/* (c) 1988 */
-	DRIVER( showdown )	/* (c) 1988 */
-
-	/* Atari vector games */
-	DRIVER( asteroid )	/* (c) 1979 */
-	DRIVER( asteroi1 )	/* no copyright notice */
-	DRIVER( astdelux )	/* (c) 1980 */
-	DRIVER( astdelu1 )	/* (c) 1980 */
-	DRIVER( bwidow )	/* (c) 1982 */
-	DRIVER( bzone )		/* (c) 1980 */
-	DRIVER( bzone2 )	/* (c) 1980 */
-	DRIVER( gravitar )	/* (c) 1982 */
-	DRIVER( gravitr2 )	/* (c) 1982 */
-	DRIVER( llander )	/* no copyright notice */
-	DRIVER( llander1 )	/* no copyright notice */
-	DRIVER( redbaron )	/* (c) 1980 */
-	DRIVER( spacduel )	/* (c) 1980 */
-	DRIVER( tempest )	/* (c) 1980 */
-	DRIVER( tempest1 )	/* (c) 1980 */
-	DRIVER( tempest2 )	/* (c) 1980 */
-	DRIVER( temptube )	/* hack */
-	DRIVER( starwars )	/* (c) 1983 */
-	DRIVER( starwar1 )	/* (c) 1983 */
-	DRIVER( esb )		/* (c) 1985 */
-	DRIVER( mhavoc )	/* (c) 1983 */
-	DRIVER( mhavoc2 )	/* (c) 1983 */
-	DRIVER( mhavocp )	/* (c) 1983 */
-	DRIVER( mhavocrv )	/* hack */
-	DRIVER( quantum )	/* (c) 1982 */	/* made by Gencomp */
-	DRIVER( quantum1 )	/* (c) 1982 */	/* made by Gencomp */
-	DRIVER( quantump )	/* (c) 1982 */	/* made by Gencomp */
-
-	/* Atari b/w games */
-	DRIVER( sprint1 )	/* no copyright notice */
-	DRIVER( sprint2 )	/* no copyright notice */
-	DRIVER( sbrkout )	/* no copyright notice */
-	DRIVER( dominos )	/* no copyright notice */
-	DRIVER( nitedrvr )	/* no copyright notice [1976] */
-	DRIVER( bsktball )	/* no copyright notice */
-	DRIVER( copsnrob )	/* [1976] */
-	DRIVER( avalnche )	/* no copyright notice [1978] */
-	DRIVER( subs )		/* no copyright notice [1976] */
-	DRIVER( atarifb )	/* no copyright notice [1978] */
-	DRIVER( atarifb1 )	/* no copyright notice [1978] */
-	DRIVER( atarifb4 )	/* no copyright notice [1979] */
-	DRIVER( abaseb )	/* no copyright notice [1979] */
-	DRIVER( abaseb2 )	/* no copyright notice [1979] */
-	DRIVER( soccer )	/* no copyright notice */
-	DRIVER( canyon )	/* no copyright notice [1977] */
-	DRIVER( canbprot )	/* no copyright notice [1977] */
-	DRIVER( skydiver )	/* no copyright notice [1977] */
-
-	/* Atari "Centipede hardware" games */
-	DRIVER( warlord )	/* (c) 1980 */
-	DRIVER( centiped )	/* (c) 1980 */
-	DRIVER( centipd2 )	/* (c) 1980 */
-	DRIVER( centipdb )	/* bootleg */
-	DRIVER( centipb2 )	/* bootleg */
-	DRIVER( milliped )	/* (c) 1982 */
-	DRIVER( qwakprot )	/* (c) 1982 */
-
-	/* Atari "Kangaroo hardware" games */
-	DRIVER( kangaroo )	/* (c) 1982 */
-	DRIVER( kangarob )	/* bootleg */
-	DRIVER( arabian )	/* (c) 1983 Sun Electronics */
-	DRIVER( arabiana )	/* (c) 1983 */
-
-	/* Atari "Missile Command hardware" games */
-	DRIVER( missile )	/* (c) 1980 */
-	DRIVER( missile2 )	/* (c) 1980 */
-	DRIVER( suprmatk )	/* (c) 1980 + (c) 1981 Gencomp */
-
-	/* misc Atari games */
-	DRIVER( foodf )		/* (c) 1982 */	/* made by Gencomp */
-	DRIVER( liberatr )	/* (c) 1982 */
-TESTDRIVER( liberat2 )
-	DRIVER( ccastles )	/* (c) 1983 */
-	DRIVER( ccastle2 )	/* (c) 1983 */
-	DRIVER( cloak )		/* (c) 1983 */
-	DRIVER( cloud9 )	/* (c) 1983 */
-	DRIVER( jedi )		/* (c) 1984 */
-
-	/* Atari System 1 games */
-	DRIVER( marble )	/* (c) 1984 */
-	DRIVER( marble2 )	/* (c) 1984 */
-	DRIVER( marblea )	/* (c) 1984 */
-	DRIVER( peterpak )	/* (c) 1984 */
-	DRIVER( indytemp )	/* (c) 1985 */
-	DRIVER( indytem2 )	/* (c) 1985 */
-	DRIVER( indytem3 )	/* (c) 1985 */
-	DRIVER( indytem4 )	/* (c) 1985 */
-	DRIVER( roadrunn )	/* (c) 1985 */
-	DRIVER( roadblst )	/* (c) 1986, 1987 */
-
-	/* Atari System 2 games */
-	DRIVER( paperboy )	/* (c) 1984 */
-	DRIVER( ssprint )	/* (c) 1986 */
-	DRIVER( csprint )	/* (c) 1986 */
-	DRIVER( 720 )		/* (c) 1986 */
-	DRIVER( 720b )		/* (c) 1986 */
-	DRIVER( apb )		/* (c) 1987 */
-	DRIVER( apb2 )		/* (c) 1987 */
-
-	/* later Atari games */
-	DRIVER( gauntlet )	/* (c) 1985 */
-	DRIVER( gauntir1 )	/* (c) 1985 */
-	DRIVER( gauntir2 )	/* (c) 1985 */
-	DRIVER( gaunt2p )	/* (c) 1985 */
-	DRIVER( gaunt2 )	/* (c) 1986 */
-	DRIVER( vindctr2 )	/* (c) 1988 */
-	DRIVER( atetris )	/* (c) 1988 */
-	DRIVER( atetrisa )	/* (c) 1988 */
-	DRIVER( atetrisb )	/* bootleg */
-	DRIVER( atetcktl )	/* (c) 1989 */
-	DRIVER( atetckt2 )	/* (c) 1989 */
-	DRIVER( toobin )	/* (c) 1988 */
-	DRIVER( toobin2 )	/* (c) 1988 */
-	DRIVER( toobinp )	/* (c) 1988 */
-	DRIVER( vindictr )	/* (c) 1988 */
-	DRIVER( klax )		/* (c) 1989 */
-	DRIVER( klax2 )		/* (c) 1989 */
-	DRIVER( klax3 )		/* (c) 1989 */
-	DRIVER( klaxj )		/* (c) 1989 (Japan) */
-	DRIVER( blstroid )	/* (c) 1987 */
-	DRIVER( blstroi2 )	/* (c) 1987 */
-	DRIVER( xybots )	/* (c) 1987 */
-	DRIVER( eprom )		/* (c) 1989 */
-	DRIVER( eprom2 )	/* (c) 1989 */
-	DRIVER( skullxbo )	/* (c) 1989 */
-	DRIVER( skullxb2 )	/* (c) 1989 */
-	DRIVER( badlands )	/* (c) 1989 */
-	DRIVER( cyberbal )	/* (c) 1989 */
-	DRIVER( cyberbt )	/* (c) 1989 */
-	DRIVER( cyberb2p )	/* (c) 1989 */
-	DRIVER( rampart )	/* (c) 1990 */
-	DRIVER( ramprt2p )	/* (c) 1990 */
-	DRIVER( shuuz )		/* (c) 1990 */
-	DRIVER( shuuz2 )	/* (c) 1990 */
-	DRIVER( hydra )		/* (c) 1990 */
-	DRIVER( hydrap )	/* (c) 1990 */
-	DRIVER( pitfight )	/* (c) 1990 */
-	DRIVER( pitfigh3 )	/* (c) 1990 */
-	DRIVER( thunderj )	/* (c) 1990 */
-	DRIVER( batman )	/* (c) 1991 */
-	DRIVER( relief )	/* (c) 1992 */
-	DRIVER( relief2 )	/* (c) 1992 */
-	DRIVER( offtwall )	/* (c) 1991 */
-	DRIVER( offtwalc )	/* (c) 1991 */
-	DRIVER( arcadecl )	/* (c) 1992 */
-	DRIVER( sparkz )	/* (c) 1992 */
-
-	/* SNK / Rock-ola games */
-	DRIVER( sasuke )	/* [1980] Shin Nihon Kikaku (SNK) */
-	DRIVER( satansat )	/* (c) 1981 SNK */
-	DRIVER( zarzon )	/* (c) 1981 Taito, gameplay says SNK */
-	DRIVER( vanguard )	/* (c) 1981 SNK */
-	DRIVER( vangrdce )	/* (c) 1981 SNK + Centuri */
-	DRIVER( fantasy )	/* (c) 1981 Rock-ola */
-	DRIVER( fantasyj )	/* (c) 1981 SNK */
-	DRIVER( pballoon )	/* (c) 1982 SNK */
-	DRIVER( nibbler )	/* (c) 1982 Rock-ola */
-	DRIVER( nibblera )	/* (c) 1982 Rock-ola */
-
-	/* later SNK games, each game can be identified by PCB code and ROM
-	code, the ROM code is the same between versions, and usually based
-	upon the Japanese title. */
-	DRIVER( joyfulr )	/* A2001      (c) 1983 */
-	DRIVER( mnchmobl )	/* A2001      (c) 1983 + Centuri license */
-	DRIVER( marvins )	/* A2003      (c) 1983 */
-	DRIVER( madcrash )	/* A2005      (c) 1984 */
-	DRIVER( vangrd2 )	/*            (c) 1984 */
-	DRIVER( hal21 )		/*            (c) 1985 */
-	DRIVER( hal21j )	/*            (c) 1985 (Japan) */
-	DRIVER( aso )		/*            (c) 1985 */
-	DRIVER( tnk3 )		/* A5001      (c) 1985 */
-	DRIVER( tnk3j )		/* A5001      (c) 1985 */
-	DRIVER( athena )	/*       'UP' (c) 1986 */
-	DRIVER( fitegolf )	/*       'GU' (c) 1988 */
-	DRIVER( ikari )		/* A5004 'IW' (c) 1986 */
-	DRIVER( ikarijp )	/* A5004 'IW' (c) 1986 (Japan) */
-	DRIVER( ikarijpb )	/* bootleg */
-	DRIVER( victroad )	/*            (c) 1986 */
-	DRIVER( dogosoke )	/*            (c) 1986 */
-	DRIVER( gwar )		/* A7003 'GV' (c) 1987 */
-	DRIVER( gwarj )		/* A7003 'GV' (c) 1987 (Japan) */
-	DRIVER( gwara )		/* A7003 'GV' (c) 1987 */
-	DRIVER( gwarb )		/* bootleg */
-	DRIVER( bermudat )	/* A6003 'WW' (c) 1987 */
-	DRIVER( bermudaj )	/* A6003 'WW' (c) 1987 */
-	DRIVER( bermudaa )	/* A6003 'WW' (c) 1987 */
-	DRIVER( worldwar )	/* A6003 'WW' (c) 1987 */
-	DRIVER( psychos )	/*       'PS' (c) 1987 */
-	DRIVER( psychosj )	/*       'PS' (c) 1987 (Japan) */
-	DRIVER( chopper )	/* A7003 'KK' (c) 1988 */
-	DRIVER( legofair )	/* A7003 'KK' (c) 1988 */
-	DRIVER( ftsoccer )	/*            (c) 1988 */
-	DRIVER( tdfever )	/* A6006 'TD' (c) 1987 */
-	DRIVER( tdfeverj )	/* A6006 'TD' (c) 1987 */
-	DRIVER( ikari3 )	/* A7007 'IK3'(c) 1989 */
-	DRIVER( pow )		/* A7008 'DG' (c) 1988 */
-	DRIVER( powj )		/* A7008 'DG' (c) 1988 */
-	DRIVER( searchar )	/* A8007 'BH' (c) 1989 */
-	DRIVER( sercharu )	/* A8007 'BH' (c) 1989 */
-	DRIVER( streetsm )	/* A8007 'S2' (c) 1989 */
-	DRIVER( streets1 )	/* A7008 'S2' (c) 1989 */
-	DRIVER( streetsj )	/* A8007 'S2' (c) 1989 */
-	/* Mechanized Attack   A8002 'MA' (c) 1989 */
-	DRIVER( prehisle )	/* A8003 'GT' (c) 1989 */
-	DRIVER( prehislu )	/* A8003 'GT' (c) 1989 */
-	DRIVER( gensitou )	/* A8003 'GT' (c) 1989 */
-	/* Beast Busters       A9003 'BB' (c) 1989 */
-
-	/* SNK / Alpha 68K games */
-TESTDRIVER( kyros )
-TESTDRIVER( sstingry )
-TESTDRIVER( paddlema )	/* Alpha-68K96I  'PM' (c) 1988 SNK */
-	DRIVER( timesold )	/* Alpha-68K96II 'BT' (c) 1987 SNK / Romstar */
-	DRIVER( timesol1 )  /* Alpha-68K96II 'BT' (c) 1987 */
-	DRIVER( btlfield )  /* Alpha-68K96II 'BT' (c) 1987 */
-	DRIVER( skysoldr )	/* Alpha-68K96II 'SS' (c) 1988 SNK (Romstar with dip switch) */
-	DRIVER( goldmedl )	/* Alpha-68K96II 'GM' (c) 1988 SNK */
-TESTDRIVER( goldmedb )	/* Alpha-68K96II bootleg */
-	DRIVER( skyadvnt )	/* Alpha-68K96V  'SA' (c) 1989 SNK of America licensed from Alpha */
-	DRIVER( gangwars )	/* Alpha-68K96V       (c) 1989 Alpha */
-	DRIVER( gangwarb )	/* Alpha-68K96V bootleg */
-	DRIVER( sbasebal )	/* Alpha-68K96V       (c) 1989 SNK of America licensed from Alpha */
-
-	/* Technos games */
-	DRIVER( scregg )	/* TA-0001 (c) 1983 */
-	DRIVER( eggs )		/* TA-0002 (c) 1983 Universal USA */
-	DRIVER( bigprowr )	/* TA-0007 (c) 1983 */
-	DRIVER( tagteam )	/* TA-0007 (c) 1983 + Data East license */
-	DRIVER( ssozumo )	/* TA-0008 (c) 1984 */
-	DRIVER( mystston )	/* TA-0010 (c) 1984 */
-	/* TA-0011 Dog Fight (Data East) / Batten O'hara no Sucha-Raka Kuuchuu Sen 1985 */
-	DRIVER( bogeyman )	/* X-0204-0 (Data East part number) (c) [1985?] */
-	DRIVER( matmania )	/* TA-0015 (c) 1985 + Taito America license */
-	DRIVER( excthour )	/* TA-0015 (c) 1985 + Taito license */
-	DRIVER( maniach )	/* TA-0017 (c) 1986 + Taito America license */
-	DRIVER( maniach2 )	/* TA-0017 (c) 1986 + Taito America license */
-	DRIVER( renegade )	/* TA-0018 (c) 1986 + Taito America license */
-	DRIVER( kuniokun )	/* TA-0018 (c) 1986 */
-	DRIVER( kuniokub )	/* bootleg */
-	DRIVER( xsleena )	/* TA-0019 (c) 1986 */
-	DRIVER( xsleenab )	/* bootleg */
-	DRIVER( solarwar )	/* TA-0019 (c) 1986 Taito + Memetron license */
-	DRIVER( battlane )	/* TA-???? (c) 1986 + Taito license */
-	DRIVER( battlan2 )	/* TA-???? (c) 1986 + Taito license */
-	DRIVER( battlan3 )	/* TA-???? (c) 1986 + Taito license */
-	DRIVER( ddragon )
-	DRIVER( ddragonb )	/* TA-0021 bootleg */
-	/* TA-0022 Super Dodge Ball */
-	/* TA-0023 China Gate */
-	/* TA-0024 WWF Superstars */
-	/* TA-0025 Champ V'Ball */
-	DRIVER( ddragon2 )	/* TA-0026 (c) 1988 */
-	/* TA-0027 ???? */
-	DRIVER( ctribe )	/* TA-0028 (c) 1990 (US) */
-	DRIVER( ctribeb )	/* bootleg */
-	DRIVER( blockout )	/* TA-0029 (c) 1989 + California Dreams */
-	DRIVER( blckout2 )	/* TA-0029 (c) 1989 + California Dreams */
-	DRIVER( ddragon3 )	/* TA-0030 (c) 1990 */
-	DRIVER( ddrago3b )	/* bootleg */
-	/* TA-0031 WWF Wrestlefest */
-
-	/* Stern "Berzerk hardware" games */
-	DRIVER( berzerk )	/* (c) 1980 */
-	DRIVER( berzerk1 )	/* (c) 1980 */
-	DRIVER( frenzy )	/* (c) 1982 */
-
-	/* GamePlan games */
-	DRIVER( megatack )	/* (c) 1980 Centuri */
-	DRIVER( killcom )	/* (c) 1980 Centuri */
-	DRIVER( challeng )	/* (c) 1981 Centuri */
-	DRIVER( kaos )		/* (c) 1981 */
-
-	/* "stratovox hardware" games */
-	DRIVER( route16 )	/* (c) 1981 Tehkan/Sun + Centuri license */
-	DRIVER( route16b )	/* bootleg */
-	DRIVER( stratvox )	/* Taito */
-	DRIVER( stratvxb )	/* bootleg */
-	DRIVER( speakres )	/* no copyright notice */
-
-	/* Zaccaria games */
-	DRIVER( monymony )	/* (c) 1983 */
-	DRIVER( jackrabt )	/* (c) 1984 */
-	DRIVER( jackrab2 )	/* (c) 1984 */
-	DRIVER( jackrabs )	/* (c) 1984 */
-
-	/* UPL games */
-	DRIVER( nova2001 )	/* UPL-83005 (c) 1983 */
-	DRIVER( nov2001u )	/* UPL-83005 (c) [1983] + Universal license */
-	DRIVER( pkunwar )	/* [1985?] */
-	DRIVER( pkunwarj )	/* [1985?] */
-	DRIVER( ninjakd2 )	/* (c) 1987 */
-	DRIVER( ninjak2a )	/* (c) 1987 */
-	DRIVER( ninjak2b )	/* (c) 1987 */
-	DRIVER( rdaction )	/* (c) 1987 + World Games license */
-	DRIVER( mnight )	/* (c) 1987 distributed by Kawakus */
-	DRIVER( arkarea )	/* UPL-87007 (c) [1988?] */
-/*
-Urashima Mahjong    UPL-89052
-
-UPL Game List
-V1.2   May 27,1999
-
-   83 Mouser                              Kit 2P              Action   83001
- 3/84 Nova 2001                 Universal Kit 2P  8W+2B   HC  Shooter  85005
-   84 Penguin Wars (Kun)                      2P              Action
-   84 Ninja Kun                 Taito                                  85003
-   85 Raiders 5                 Taito                                  85004
- 8/87 Mission XX                          Kit 2P  8W+2B   VC  Shooter  86001
-   87 Mutant Night                        Kit 2P  8W+2B   HC  Action
- 7/87 Rad Action/Ninja Taro   World Games Kit 2P  8W+2B   HC  Action   87003
- 7/87 Ninja Taro/Rad Action   World Games Kit 2P  8W+2B   HC  Action
-   87 Ninja Taro II                       Kit 2P  8W+2B   HC  Action
-   88 Aquaria                             Kit 2P  8W+2B
-   89 Ochichi Mahjong                     Kit 2P  8W+2B   HC  Mahjong
- 9/89 Omega Fighter        American Sammy Kit 2P  8W+2B   HC  Shooter  89016
-12/89 Task Force Harrier   American Sammy Kit 2P  8W+2B   VC  Shooter  89053
-   90 Atomic Robo-Kid      American Sammy Kit 2P  8W+2B   HC  Shooter  88013
-   90 Mustang - U.S.A.A.F./Fire Mustang   Kit 2P  8W+2B   HC  Shooter  90058
-   91 Acrobat Mission               Taito Kit 2P  8W+2B   VC  Shooter
-   91 Bio Ship Paladin/Spaceship Gomera   Kit 2P  8W+2B   HC  Shooter  90062
-   91 Black Heart                         Kit 2P  8W+2B   HC  Shooter
-   91 Van Dyke Fantasy                    Kit 2P  8W+2B
- 2/92 Strahl                              Kit 2P  8W+3B                91074
-      Thunder Dragon 2                                                 93091
-
-*/
-
-	/* Williams/Midway TMS34010 games */
-	DRIVER( narc )		/* (c) 1988 Williams */
-TESTDRIVER( narc3 )		/* (c) 1988 Williams */
-	DRIVER( trog )		/* (c) 1990 Midway */
-	DRIVER( trog3 )		/* (c) 1990 Midway */
-	DRIVER( trogp )		/* (c) 1990 Midway */
-	DRIVER( smashtv )	/* (c) 1990 Williams */
-	DRIVER( smashtv6 )	/* (c) 1990 Williams */
-	DRIVER( smashtv5 )	/* (c) 1990 Williams */
-	DRIVER( smashtv4 )	/* (c) 1990 Williams */
-	DRIVER( hiimpact )	/* (c) 1990 Williams */
-	DRIVER( shimpact )	/* (c) 1991 Midway */
-	DRIVER( strkforc )	/* (c) 1991 Midway */
-	DRIVER( mk )		/* (c) 1992 Midway */
-	DRIVER( mkla1 )		/* (c) 1992 Midway */
-	DRIVER( mkla2 )		/* (c) 1992 Midway */
-	DRIVER( mkla3 )		/* (c) 1992 Midway */
-	DRIVER( mkla4 )		/* (c) 1992 Midway */
-	DRIVER( term2 )		/* (c) 1992 Midway */
-	DRIVER( totcarn )	/* (c) 1992 Midway */
-	DRIVER( totcarnp )	/* (c) 1992 Midway */
-	DRIVER( mk2 )		/* (c) 1993 Midway */
-	DRIVER( mk2r32 )	/* (c) 1993 Midway */
-	DRIVER( mk2r14 )	/* (c) 1993 Midway */
-	DRIVER( nbajam )	/* (c) 1993 Midway */
-
-	/* Cinematronics raster games */
-	DRIVER( jack )		/* (c) 1982 Cinematronics */
-	DRIVER( jack2 )		/* (c) 1982 Cinematronics */
-	DRIVER( jack3 )		/* (c) 1982 Cinematronics */
-	DRIVER( treahunt )	/* (c) 1982 Hara Ind. */
-	DRIVER( zzyzzyxx )	/* (c) 1982 Cinematronics + Advanced Microcomputer Systems */
-	DRIVER( zzyzzyx2 )	/* (c) 1982 Cinematronics + Advanced Microcomputer Systems */
-	DRIVER( brix )		/* (c) 1982 Cinematronics + Advanced Microcomputer Systems */
-	DRIVER( freeze )	/* Cinematronics */
-	DRIVER( sucasino )	/* (c) 1982 Data Amusement */
-
-	/* Cinematronics vector games */
-	DRIVER( spacewar )
-	DRIVER( barrier )
-	DRIVER( starcas )	/* (c) 1980 */
-	DRIVER( starcas1 )	/* (c) 1980 */
-	DRIVER( tailg )
-	DRIVER( ripoff )
-	DRIVER( armora )
-	DRIVER( wotw )
-	DRIVER( warrior )
-	DRIVER( starhawk )
-	DRIVER( solarq )	/* (c) 1981 */
-	DRIVER( boxingb )	/* (c) 1981 */
-	DRIVER( speedfrk )
-	DRIVER( sundance )
-	DRIVER( demon )		/* (c) 1982 Rock-ola */
-	/* this one uses 68000+Z80 instead of the Cinematronics CPU */
-	DRIVER( cchasm )
-	DRIVER( cchasm1 )	/* (c) 1983 Cinematronics / GCE */
-
-	/* "The Pit hardware" games */
-	DRIVER( roundup )	/* (c) 1981 Amenip/Centuri */
-	DRIVER( fitter )	/* (c) 1981 Taito */
-	DRIVER( thepit )	/* (c) 1982 Centuri */
-	DRIVER( intrepid )	/* (c) 1983 Nova Games Ltd. */
-	DRIVER( intrepi2 )	/* (c) 1983 Nova Games Ltd. */
-	DRIVER( portman )	/* (c) 1982 Nova Games Ltd. */
-	DRIVER( suprmous )	/* (c) 1982 Taito */
-	DRIVER( suprmou2 )	/* (c) 1982 Chu Co. Ltd. */
-	DRIVER( machomou )	/* (c) 1982 Techstar */
-
-	/* Valadon Automation games */
-	DRIVER( bagman )	/* (c) 1982 */
-	DRIVER( bagnard )	/* (c) 1982 */
-	DRIVER( bagmans )	/* (c) 1982 + Stern license */
-	DRIVER( bagmans2 )	/* (c) 1982 + Stern license */
-	DRIVER( sbagman )	/* (c) 1984 */
-	DRIVER( sbagmans )	/* (c) 1984 + Stern license */
-	DRIVER( pickin )	/* (c) 1983 */
-
-	/* Seibu Denshi / Seibu Kaihatsu games */
-	DRIVER( stinger )	/* (c) 1983 Seibu Denshi */
-	DRIVER( scion )		/* (c) 1984 Seibu Denshi */
-	DRIVER( scionc )	/* (c) 1984 Seibu Denshi + Cinematronics license */
-	DRIVER( wiz )		/* (c) 1985 Seibu Kaihatsu */
-	DRIVER( wizt )		/* (c) 1985 Taito Corporation */
-	DRIVER( empcity )	/* (c) 1986 Seibu Kaihatsu (bootleg?) */
-	DRIVER( empcityj )	/* (c) 1986 Taito Corporation (Japan) */
-	DRIVER( stfight )	/* (c) 1986 Seibu Kaihatsu (Germany) (bootleg?) */
-	DRIVER( dynduke )	/* (c) 1989 Seibu Kaihatsu + Fabtek license */
-	DRIVER( dbldyn )	/* (c) 1989 Seibu Kaihatsu + Fabtek license */
-	DRIVER( raiden )	/* (c) 1990 Seibu Kaihatsu */
-	DRIVER( raidena )	/* (c) 1990 Seibu Kaihatsu */
-	DRIVER( raidenk )	/* (c) 1990 Seibu Kaihatsu + IBL Corporation license */
-	DRIVER( dcon )		/* (c) 1992 Success */
-
-/* Seibu STI System games:
-
-	Viper: Phase 1 					(c) 1995
-	Viper: Phase 1 (New version)	(c) 1996
-	Battle Balls					(c) 1996
-	Raiden Fighters					(c) 1996
-	Raiden Fighters 2 				(c) 1997
-	Senku							(c) 1997
-
-*/
-
-	/* Tad games (Tad games run on Seibu hardware) */
-	DRIVER( cabal )		/* (c) 1988 Tad + Fabtek license */
-	DRIVER( cabal2 )	/* (c) 1988 Tad + Fabtek license */
-	DRIVER( cabalbl )	/* bootleg */
-	DRIVER( toki )		/* (c) 1989 Tad */
-	DRIVER( toki2 )		/* (c) 1989 Tad */
-	DRIVER( toki3 )		/* (c) 1989 Tad */
-	DRIVER( tokiu )		/* (c) 1989 Tad + Fabtek license */
-	DRIVER( tokib )		/* bootleg */
-	DRIVER( bloodbro )	/* (c) 1990 Tad */
-	DRIVER( weststry )	/* bootleg */
-
-	/* Jaleco games */
-	DRIVER( exerion )	/* (c) 1983 Jaleco */
-	DRIVER( exeriont )	/* (c) 1983 Jaleco + Taito America license */
-	DRIVER( exerionb )	/* bootleg */
-	DRIVER( formatz )	/* (c) 1984 Jaleco */
-	DRIVER( aeroboto )	/* (c) 1984 Williams */
-	DRIVER( citycon )	/* (c) 1985 Jaleco */
-	DRIVER( citycona )	/* (c) 1985 Jaleco */
-	DRIVER( cruisin )	/* (c) 1985 Jaleco/Kitkorp */
-	DRIVER( pinbo )		/* (c) 1984 Jaleco */
-	DRIVER( pinbos )	/* (c) 1985 Strike */
-	DRIVER( psychic5 )	/* (c) 1987 Jaleco */
-	DRIVER( ginganin )	/* (c) 1987 Jaleco */
-	DRIVER( cischeat )	/* (c) 1990 Jaleco */
-	DRIVER( f1gpstar )	/* (c) 1991 Jaleco */
-
-	/* Jaleco Mega System 1 games */
-	DRIVER( lomakai )	/* (c) 1988 (World) */
-	DRIVER( makaiden )	/* (c) 1988 (Japan) */
-	DRIVER( p47 )		/* (c) 1988 */
-	DRIVER( p47j )		/* (c) 1988 (Japan) */
-	DRIVER( kickoff )	/* (c) 1988 (Japan) */
-	DRIVER( astyanax )	/* (c) 1989 */
-	DRIVER( lordofk )	/* (c) 1989 (Japan) */
-	DRIVER( hachoo )	/* (c) 1989 */
-	DRIVER( plusalph )	/* (c) 1989 */
-	DRIVER( stdragon )	/* (c) 1989 */
-	DRIVER( iganinju )	/* (c) 1989 (Japan) */
-	DRIVER( rodland )	/* (c) 1990 */
-	DRIVER( rodlandj )	/* (c) 1990 (Japan) */
-	DRIVER( 64street )	/* (c) 1991 */
-	DRIVER( 64streej )	/* (c) 1991 (Japan) */
-	DRIVER( edf )		/* (c) 1991 */
-	DRIVER( avspirit )	/* (c) 1991 */
-	DRIVER( phantasm )	/* (c) 1991 (Japan) */
-	DRIVER( bigstrik )	/* (c) 1992 */
-	DRIVER( chimerab )	/* (c) 1993 */
-	DRIVER( cybattlr )	/* (c) 1993 */
-	DRIVER( peekaboo )	/* (c) 1993 */
-	DRIVER( soldamj )	/* (c) 1992 (Japan) */
-
-	/* Video System Co. games */
-	DRIVER( pspikes )	/* (c) 1991 */
-	DRIVER( svolly91 )	/* (c) 1991 */
-	DRIVER( turbofrc )	/* (c) 1991 */
-	DRIVER( aerofgt )	/* (c) 1992 */
-	DRIVER( aerofgtb )	/* (c) 1992 */
-	DRIVER( aerofgtc )	/* (c) 1992 */
-TESTDRIVER( unkvsys )
-
-	/* Orca games */
-	DRIVER( marineb )	/* (c) 1982 Orca */
-	DRIVER( changes )	/* (c) 1982 Orca */
-	DRIVER( looper )	/* (c) 1982 Orca */
-	DRIVER( springer )	/* (c) 1982 Orca */
-	DRIVER( hoccer )	/* (c) 1983 Eastern Micro Electronics, Inc. */
-	DRIVER( hoccer2 )	/* (c) 1983 Eastern Micro Electronics, Inc. */
-	DRIVER( hopprobo )	/* (c) 1983 Sega */
-	DRIVER( wanted )	/* (c) 1984 Sigma Ent. Inc. */
-	DRIVER( funkybee )	/* (c) 1982 Orca */
-	DRIVER( skylancr )	/* (c) 1983 Orca + Esco Trading Co license */
-	DRIVER( zodiack )	/* (c) 1983 Orca + Esco Trading Co license */
-	DRIVER( dogfight )	/* (c) 1983 Thunderbolt */
-	DRIVER( moguchan )	/* (c) 1982 Orca + Eastern Commerce Inc. license (doesn't appear on screen) */
-	DRIVER( percuss )	/* (c) 1981 Orca */
-	DRIVER( espial )	/* (c) 1983 Thunderbolt, Orca logo is hidden in title screen */
-	DRIVER( espiale )	/* (c) 1983 Thunderbolt, Orca logo is hidden in title screen */
-	/* Vastar was made by Orca, but when it was finished, Orca had already bankrupted. */
-	/* So they sold this game as "Made by Sesame Japan" because they couldn't use */
-	/* the name "Orca" */
-	DRIVER( vastar )	/* (c) 1983 Sesame Japan */
-	DRIVER( vastar2 )	/* (c) 1983 Sesame Japan */
-/*
-   other Orca games:
-   82 Battle Cross                         Kit 2P
-   82 River Patrol Empire Mfg/Kerstens Ind Ded 2P        HC Action
-   82 Slalom                               Kit 2P        HC Action
-   82 The Bounty                           Ded 2P
-   83 Net Wars                                 2P
-   83 Super Crush                          Kit 2P           Action
-*/
-
-	/* Gaelco games */
-	DRIVER( splash )	/* (c) 1992 Gaelco */
-/*
-Gaelco Game list:
-=================
-
-1987:	Master Boy
-1991:	Big Karnak, Master Boy 2
-1992:	Splash, Thunder Hoop, Squash
-1993:	World Rally, Glass
-1994:	Strike Back, Target Hits, Thunder Hoop 2
-1995:	Alligator Hunt, Toy, World Rally 2, Salter, Touch & Go
-1996:	Maniac Square, Snow Board, Speed Up
-1997:	Surf Planet
-1998:	Radikal Bikers
-1999:	Rolling Extreme
-
-All games newer than Splash are heavily protected.
-*/
-
-	/* Kaneko "AX System" games */
-	DRIVER( berlwall )	/* (c) 1991 Kaneko */
-	DRIVER( gtmr )		/* (c) 1994 Kaneko */
-	DRIVER( gtmralt )	/* (c) 1994 Kaneko */
-TESTDRIVER( gtmr2 )
-TESTDRIVER( shogwarr )
-
-	/* other Kaneko games */
-	DRIVER( galpanic )	/* (c) 1990 Kaneko */
-	DRIVER( airbustr )	/* (c) 1990 Kaneko */
-
-	DRIVER( pong )
-	DRIVER( spacefb )	/* (c) [1980?] Nintendo */
-	DRIVER( spacefbg )	/* 834-0031 (c) 1980 Gremlin */
-	DRIVER( spacefbb )	/* bootleg */
-	DRIVER( spacebrd )	/* bootleg */
-	DRIVER( spacedem )	/* (c) 1980 Nintendo / Fortrek */
-	DRIVER( blueprnt )	/* (c) 1982 Bally Midway (Zilec in ROM 3U, and the programmer names) */
-	DRIVER( blueprnj )	/* (c) 1982 Jaleco (Zilec in ROM 3U, and the programmer names) */
-	DRIVER( saturn )	/* (c) 1983 Jaleco (Zilec in ROM R6, and the programmer names) */
-	DRIVER( omegrace )	/* (c) 1981 Midway */
-	DRIVER( dday )		/* (c) 1982 Olympia */
-	DRIVER( ddayc )		/* (c) 1982 Olympia + Centuri license */
-	DRIVER( gundealr )	/* (c) 1990 Dooyong */
-	DRIVER( gundeala )	/* (c) Dooyong */
-	DRIVER( yamyam )	/* (c) 1990 Dooyong */
-	DRIVER( wiseguy )	/* (c) 1990 Dooyong */
-	DRIVER( leprechn )	/* (c) 1982 Tong Electronic */
-	DRIVER( potogold )	/* (c) 1982 Tong Electronic */
-	DRIVER( hexa )		/* D. R. Korea */
-	DRIVER( redalert )	/* (c) 1981 Irem (GDI game) */
-	DRIVER( irobot )	/* (c) 1983 Atari */
-	DRIVER( spiders )	/* (c) 1981 Sigma Ent. Inc. */
-	DRIVER( spiders2 )	/* (c) 1981 Sigma Ent. Inc. */
-	DRIVER( stactics )	/* [1981 Sega] */
-	DRIVER( exterm )	/* (c) 1989 Premier Technology - a Gottlieb game */
-	DRIVER( sharkatt )	/* (c) Pacific Novelty */
-	DRIVER( kingofb )	/* (c) 1985 Woodplace Inc. */
-	DRIVER( ringking )	/* (c) 1985 Data East USA */
-	DRIVER( ringkin2 )
-	DRIVER( ringkin3 )	/* (c) 1985 Data East USA */
-	DRIVER( zerozone )	/* (c) 1993 Comad */
-	DRIVER( exctsccr )	/* (c) 1983 Alpha Denshi Co. */
-	DRIVER( exctscca )	/* (c) 1983 Alpha Denshi Co. */
-	DRIVER( exctsccb )	/* bootleg */
-	DRIVER( exctscc2 )
-	DRIVER( speedbal )	/* (c) 1987 Tecfri */
-	DRIVER( sauro )		/* (c) 1987 Tecfri */
-	DRIVER( ambush )	/* (c) 1983 Nippon Amuse Co-Ltd */
-	DRIVER( starcrus )	/* [1977 Ramtek] */
-	DRIVER( shanghai )	/* (c) 1988 Sun Electronics */
-	DRIVER( goindol )	/* (c) 1987 Sun a Electronics */
-	DRIVER( homo )		/* bootleg */
-TESTDRIVER( dlair )
-	DRIVER( goldstar )	/* IGS */
-	DRIVER( goldstbl )	/* IGS */
-	DRIVER( csk227it )	/* (c) [1993] IGS */
-	DRIVER( csk234it )	/* (c) [1993] IGS */
-	DRIVER( meteor )	/* (c) 1981 Venture Line */
-	DRIVER( bjtwin )	/* (c) 1993 NMK */
-	DRIVER( aztarac )	/* (c) 1983 Centuri (vector game) */
-
-
-#endif /* NEOMAME */
-
-#ifndef NEOFREE
-
-	/* Neo Geo games */
-	/* the four digits number is the game ID stored at address 0x0108 of the program ROM */
-	DRIVER( nam1975 )	/* 0001 (c) 1990 SNK */
-	DRIVER( bstars )	/* 0002 (c) 1990 SNK */
-	DRIVER( tpgolf )	/* 0003 (c) 1990 SNK */
-	DRIVER( mahretsu )	/* 0004 (c) 1990 SNK */
-	DRIVER( maglord )	/* 0005 (c) 1990 Alpha Denshi Co */
-	DRIVER( maglordh )	/* 0005 (c) 1990 Alpha Denshi Co */
-	DRIVER( ridhero )	/* 0006 (c) 1990 SNK */
-	DRIVER( alpham2 )	/* 0007 (c) 1991 SNK */
-	/* 0008 */
-	DRIVER( ncombat )	/* 0009 (c) 1990 Alpha Denshi Co */
-	DRIVER( cyberlip )	/* 0010 (c) 1990 SNK */
-	DRIVER( superspy )	/* 0011 (c) 1990 SNK */
-	/* 0012 */
-	/* 0013 */
-	DRIVER( mutnat )	/* 0014 (c) 1992 SNK */
-	/* 0015 */
-	DRIVER( kotm )		/* 0016 (c) 1991 SNK */
-	DRIVER( sengoku )	/* 0017 (c) 1991 SNK */
-	DRIVER( sengokh )	/* 0017 (c) 1991 SNK */
-	DRIVER( burningf )	/* 0018 (c) 1991 SNK */
-	DRIVER( burningh )	/* 0018 (c) 1991 SNK */
-	DRIVER( lbowling )	/* 0019 (c) 1990 SNK */
-	DRIVER( gpilots )	/* 0020 (c) 1991 SNK */
-	DRIVER( joyjoy )	/* 0021 (c) 1990 SNK */
-	DRIVER( bjourney )	/* 0022 (c) 1990 Alpha Denshi Co */
-	DRIVER( quizdais )	/* 0023 (c) 1991 SNK */
-	DRIVER( lresort )	/* 0024 (c) 1992 SNK */
-	DRIVER( eightman )	/* 0025 (c) 1991 SNK / Pallas */
-	/* 0026 Fun Fun Brothers - prototype? */
-	DRIVER( minasan )	/* 0027 (c) 1990 Monolith Corp. */
-	/* 0028 */
-	DRIVER( legendos )	/* 0029 (c) 1991 SNK */
-	DRIVER( 2020bb )	/* 0030 (c) 1991 SNK / Pallas */
-	DRIVER( 2020bbh )	/* 0030 (c) 1991 SNK / Pallas */
-	DRIVER( socbrawl )	/* 0031 (c) 1991 SNK */
-	DRIVER( roboarmy )	/* 0032 (c) 1991 SNK */
-	DRIVER( fatfury1 )	/* 0033 (c) 1991 SNK */
-	DRIVER( fbfrenzy )	/* 0034 (c) 1992 SNK */
-	/* 0035 */
-	DRIVER( bakatono )	/* 0036 (c) 1991 Monolith Corp. */
-	DRIVER( crsword )	/* 0037 (c) 1991 Alpha Denshi Co */
-	DRIVER( trally )	/* 0038 (c) 1991 Alpha Denshi Co */
-	DRIVER( kotm2 )		/* 0039 (c) 1992 SNK */
-	DRIVER( sengoku2 )	/* 0040 (c) 1993 SNK */
-	DRIVER( bstars2 )	/* 0041 (c) 1992 SNK */
-	DRIVER( quizdai2 )	/* 0042 (c) 1992 SNK */
-	DRIVER( 3countb )	/* 0043 (c) 1993 SNK */
-	DRIVER( aof )		/* 0044 (c) 1992 SNK */
-	DRIVER( samsho )	/* 0045 (c) 1993 SNK */
-	DRIVER( tophuntr )	/* 0046 (c) 1994 SNK */
-	DRIVER( fatfury2 )	/* 0047 (c) 1992 SNK */
-	DRIVER( janshin )	/* 0048 (c) 1994 Aicom */
-	DRIVER( androdun )	/* 0049 (c) 1992 Visco */
-	DRIVER( ncommand )	/* 0050 (c) 1992 Alpha Denshi Co */
-	DRIVER( viewpoin )	/* 0051 (c) 1992 Sammy */
-	DRIVER( ssideki )	/* 0052 (c) 1992 SNK */
-	DRIVER( wh1 )		/* 0053 (c) 1992 Alpha Denshi Co */
-	/* 0054 Crossed Swords 2 (CD only) */
-	DRIVER( kof94 )		/* 0055 (c) 1994 SNK */
-	DRIVER( aof2 )		/* 0056 (c) 1994 SNK */
-	DRIVER( wh2 )		/* 0057 (c) 1993 ADK */
-	DRIVER( fatfursp )	/* 0058 (c) 1993 SNK */
-	DRIVER( savagere )	/* 0059 (c) 1995 SNK */
-	DRIVER( fightfev )	/* 0060 (c) 1994 Viccom */
-	DRIVER( ssideki2 )	/* 0061 (c) 1994 SNK */
-	DRIVER( spinmast )	/* 0062 (c) 1993 Data East Corporation */
-	DRIVER( samsho2 )	/* 0063 (c) 1994 SNK */
-	DRIVER( wh2j )		/* 0064 (c) 1994 ADK / SNK */
-	DRIVER( wjammers )	/* 0065 (c) 1994 Data East Corporation */
-	DRIVER( karnovr )	/* 0066 (c) 1994 Data East Corporation */
-	DRIVER( gururin )	/* 0067 (c) 1994 Face */
-	DRIVER( pspikes2 )	/* 0068 (c) 1994 Video System Co. */
-	DRIVER( fatfury3 )	/* 0069 (c) 1995 SNK */
-	/* 0070 */
-	/* 0071 */
-	/* 0072 */
-	DRIVER( panicbom )	/* 0073 (c) 1994 Eighting / Hudson */
-	DRIVER( aodk )		/* 0074 (c) 1994 ADK / SNK */
-	DRIVER( sonicwi2 )	/* 0075 (c) 1994 Video System Co. */
-	DRIVER( zedblade )	/* 0076 (c) 1994 NMK */
-	/* 0077 */
-	DRIVER( galaxyfg )	/* 0078 (c) 1995 Sunsoft */
-	DRIVER( strhoop )	/* 0079 (c) 1994 Data East Corporation */
-	DRIVER( quizkof )	/* 0080 (c) 1995 Saurus */
-	DRIVER( ssideki3 )	/* 0081 (c) 1995 SNK */
-	DRIVER( doubledr )	/* 0082 (c) 1995 Technos */
-	DRIVER( pbobble )	/* 0083 (c) 1994 Taito */
-	DRIVER( kof95 )		/* 0084 (c) 1995 SNK */
-	/* 0085 Shinsetsu Samurai Spirits Bushidoretsuden / Samurai Shodown RPG (CD only) */
-	DRIVER( tws96 )		/* 0086 (c) 1996 Tecmo */
-	DRIVER( samsho3 )	/* 0087 (c) 1995 SNK */
-	DRIVER( stakwin )	/* 0088 (c) 1995 Saurus */
-	DRIVER( pulstar )	/* 0089 (c) 1995 Aicom */
-	DRIVER( whp )		/* 0090 (c) 1995 ADK / SNK */
-	/* 0091 */
-	DRIVER( kabukikl )	/* 0092 (c) 1995 Hudson */
-	DRIVER( neobombe )	/* 0093 (c) 1997 Hudson */
-	DRIVER( gowcaizr )	/* 0094 (c) 1995 Technos */
-	DRIVER( rbff1 )		/* 0095 (c) 1995 SNK */
-	DRIVER( aof3 )		/* 0096 (c) 1996 SNK */
-	DRIVER( sonicwi3 )	/* 0097 (c) 1995 Video System Co. */
-	/* 0098 Idol Mahjong - final romance 2 (CD only? not confirmed, MVS might exist) */
-	/* 0099 */
-	DRIVER( turfmast )	/* 0200 (c) 1996 Nazca */
-	DRIVER( mslug )		/* 0201 (c) 1996 Nazca */
-	DRIVER( puzzledp )	/* 0202 (c) 1995 Taito (Visco license) */
-	DRIVER( mosyougi )	/* 0203 (c) 1995 ADK / SNK */
-	/* 0204 ADK World (CD only) */
-	/* 0205 Neo-Geo CD Special (CD only) */
-	DRIVER( marukodq )	/* 0206 (c) 1995 Takara */
-	DRIVER( neomrdo )	/* 0207 (c) 1996 Visco */
-	DRIVER( sdodgeb )	/* 0208 (c) 1996 Technos */
-	DRIVER( goalx3 )	/* 0209 (c) 1995 Visco */
-	/* 0210 */
-	/* 0211 Oshidashi Zintrick (CD only? not confirmed, MVS might exist) */
-	DRIVER( overtop )	/* 0212 (c) 1996 ADK */
-	DRIVER( neodrift )	/* 0213 (c) 1996 Visco */
-	DRIVER( kof96 )		/* 0214 (c) 1996 SNK */
-	DRIVER( ssideki4 )	/* 0215 (c) 1996 SNK */
-	DRIVER( kizuna )	/* 0216 (c) 1996 SNK */
-	DRIVER( ninjamas )	/* 0217 (c) 1996 ADK / SNK */
-	DRIVER( ragnagrd )	/* 0218 (c) 1996 Saurus */
-	DRIVER( pgoal )		/* 0219 (c) 1996 Saurus */
-	/* 0220 Choutetsu Brikin'ger - iron clad (CD only? not confirmed, MVS might exist) */
-	DRIVER( magdrop2 )	/* 0221 (c) 1996 Data East Corporation */
-	DRIVER( samsho4 )	/* 0222 (c) 1996 SNK */
-	DRIVER( rbffspec )	/* 0223 (c) 1996 SNK */
-	DRIVER( twinspri )	/* 0224 (c) 1996 ADK */
-	DRIVER( wakuwak7 )	/* 0225 (c) 1996 Sunsoft */
-	/* 0226 */
-	DRIVER( stakwin2 )	/* 0227 (c) 1996 Saurus */
-	/* 0228 */
-	/* 0229 King of Fighters '96 CD Collection (CD only) */
-	DRIVER( breakers )	/* 0230 (c) 1996 Visco */
-	DRIVER( miexchng )	/* 0231 (c) 1997 Face */
-	DRIVER( kof97 )		/* 0232 (c) 1997 SNK */
-	DRIVER( magdrop3 )	/* 0233 (c) 1997 Data East Corporation */
-	DRIVER( lastblad )	/* 0234 (c) 1997 SNK */
-	DRIVER( puzzldpr )	/* 0235 (c) 1997 Taito (Visco license) */
-	DRIVER( irrmaze )	/* 0236 (c) 1997 SNK / Saurus */
-	DRIVER( popbounc )	/* 0237 (c) 1997 Video System Co. */
-	DRIVER( shocktro )	/* 0238 (c) 1997 Saurus */
-	DRIVER( blazstar )	/* 0239 (c) 1998 Yumekobo */
-	DRIVER( rbff2 )		/* 0240 (c) 1998 SNK */
-	DRIVER( mslug2 )	/* 0241 (c) 1998 SNK */
-	DRIVER( kof98 )		/* 0242 (c) 1998 SNK */
-	DRIVER( lastbld2 )	/* 0243 (c) 1998 SNK */
-	DRIVER( neocup98 )	/* 0244 (c) 1998 SNK */
-	DRIVER( breakrev )	/* 0245 (c) 1998 Visco */
-	DRIVER( shocktr2 )	/* 0246 (c) 1998 Saurus */
-	DRIVER( flipshot )	/* 0247 (c) 1998 Visco */
-TESTDRIVER( pbobbl2n )	/* 0248 (c) 1999 Taito (SNK license) */
-TESTDRIVER( ctomaday )	/* 0249 (c) 1999 Visco */
-TESTDRIVER( mslugx )	/* 0250 (c) 1999 SNK */
-TESTDRIVER( kof99 )		/* 0251 (c) 1999 SNK */
-
-#endif	/* NEOFREE */
-
-#endif	/* DRIVER_RECURSIVE */
-
-#endif	/* TINY_COMPILE */
+/******************************************************************************
+
+  driver.c
+
+  The list of all available drivers. Drivers have to be included here to be
+  recognized by the executable.
+
+  To save some typing, we use a hack here. This file is recursively #included
+  twice, with different definitions of the DRIVER() macro. The first one
+  declares external references to the drivers; the second one builds an array
+  storing all the drivers.
+
+******************************************************************************/
+
+#include "driver.h"
+
+
+#ifndef DRIVER_RECURSIVE
+
+/* The "root" driver, defined so we can have &driver_##NAME in macros. */
+struct GameDriver driver_0 =
+{
+	__FILE__,
+	0,
+	"",
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	NOT_A_DRIVER
+};
+
+#endif
+
+#ifdef TINY_COMPILE
+extern struct GameDriver TINY_NAME;
+
+const struct GameDriver *drivers[] =
+{
+	&TINY_NAME,
+	0	/* end of array */
+};
+
+#else
+
+#ifndef DRIVER_RECURSIVE
+
+#define DRIVER_RECURSIVE
+
+/* step 1: declare all external references */
+#define DRIVER(NAME) extern struct GameDriver driver_##NAME;
+#define TESTDRIVER(NAME) extern struct GameDriver driver_##NAME;
+#include "driver.c"
+
+/* step 2: define the drivers[] array */
+#undef DRIVER
+#undef TESTDRIVER
+#define DRIVER(NAME) &driver_##NAME,
+#define TESTDRIVER(NAME)
+const struct GameDriver *drivers[] =
+{
+#include "driver.c"
+	0	/* end of array */
+};
+
+#else	/* DRIVER_RECURSIVE */
+
+#if 1 /* force tiny compile */
+	DRIVER( pacman )    /* (c) 1980 Namco */
+#else
+
+#ifndef NEOMAME
+
+	/* "Pacman hardware" games */
+	DRIVER( pacman )	/* (c) 1980 Namco */
+	DRIVER( pacmanjp )	/* (c) 1980 Namco */
+	DRIVER( pacmanm )	/* (c) 1980 Midway */
+	DRIVER( npacmod )	/* (c) 1981 Namco */
+	DRIVER( pacmod )	/* (c) 1981 Midway */
+	DRIVER( hangly )	/* hack */
+	DRIVER( hangly2 )	/* hack */
+	DRIVER( puckman )	/* hack */
+	DRIVER( pacheart )	/* hack */
+	DRIVER( piranha )	/* hack */
+	DRIVER( pacplus )
+	DRIVER( mspacman )	/* (c) 1981 Midway (but it's a bootleg) */	/* made by Gencomp */
+	DRIVER( mspacatk )	/* hack */
+	DRIVER( pacgal )	/* hack */
+	DRIVER( maketrax )	/* (c) 1981 Williams, high score table says KRL (fur Kural) */
+	DRIVER( crush )		/* (c) 1981 Kural Samno Electric Ltd */
+	DRIVER( crush2 )	/* (c) 1981 Kural Esco Electric Ltd - bootleg? */
+	DRIVER( crush3 )	/* Kural Electric Ltd - bootleg? */
+	DRIVER( mbrush )	/* 1981 bootleg */
+	DRIVER( paintrlr )	/* 1981 bootleg */
+	DRIVER( eyes )		/* (c) 1982 Digitrex Techstar + "Rockola presents" */
+	DRIVER( eyes2 )		/* (c) 1982 Techstar + "Rockola presents" */
+	DRIVER( mrtnt )		/* (c) 1983 Telko */
+	DRIVER( ponpoko )	/* (c) 1982 Sigma Ent. Inc. */
+	DRIVER( ponpokov )	/* (c) 1982 Sigma Ent. Inc. + Venture Line license */
+	DRIVER( lizwiz )	/* (c) 1985 Techstar + "Sunn presents" */
+	DRIVER( theglob )	/* (c) 1983 Epos Corporation */
+	DRIVER( beastf )	/* (c) 1984 Epos Corporation */
+	DRIVER( jumpshot )
+	DRIVER( vanvan )	/* (c) 1983 Karateco (bootleg?) */
+	DRIVER( vanvanb )	/* bootleg */
+	DRIVER( alibaba )	/* (c) 1982 Sega */
+	DRIVER( pengo )		/* 834-0386 (c) 1982 Sega */
+	DRIVER( pengo2 )	/* 834-0386 (c) 1982 Sega */
+	DRIVER( pengo2u )	/* 834-0386 (c) 1982 Sega */
+	DRIVER( penta )		/* bootleg */
+	DRIVER( jrpacman )	/* (c) 1983 Midway */
+
+	/* "Galaxian hardware" games */
+	DRIVER( galaxian )	/* (c) Namco */
+	DRIVER( galmidw )	/* (c) Midway */
+	DRIVER( superg )	/* hack */
+	DRIVER( galaxb )	/* bootleg */
+	DRIVER( galapx )	/* hack */
+	DRIVER( galap1 )	/* hack */
+	DRIVER( galap4 )	/* hack */
+	DRIVER( galturbo )	/* hack */
+	DRIVER( swarm )		/* hack */
+	DRIVER( pisces )	/* ? */
+	DRIVER( uniwars )	/* (c) Irem */
+	DRIVER( gteikoku )	/* (c) Irem */
+	DRIVER( spacbatt )	/* bootleg */
+	DRIVER( warofbug )	/* (c) 1981 Armenia */
+	DRIVER( redufo )	/* ? */
+	DRIVER( pacmanbl )	/* bootleg */
+	DRIVER( devilfsg )	/* (c) 1984 Vision / Artic (bootleg?) */
+	DRIVER( zigzag )	/* (c) 1982 LAX */
+	DRIVER( zigzag2 )	/* (c) 1982 LAX */
+	DRIVER( jumpbug )	/* (c) 1981 Rock-ola */
+	DRIVER( jumpbugb )	/* (c) 1981 Sega */
+	DRIVER( levers )	/* (c) 1983 Rock-ola */
+	DRIVER( azurian )	/* (c) 1982 Rait Electronics Ltd */
+	DRIVER( orbitron )	/* Signatron USA */
+	DRIVER( mooncrgx )	/* bootleg */
+	DRIVER( mooncrst )	/* (c) 1980 Nichibutsu */
+	DRIVER( mooncrsg )	/* (c) 1980 Gremlin */
+	DRIVER( smooncrs )	/* Gremlin */
+	DRIVER( mooncrsb )	/* bootleg */
+	DRIVER( mooncrs2 )	/* bootleg */
+	DRIVER( fantazia )	/* bootleg */
+	DRIVER( eagle )		/* (c) Centuri */
+	DRIVER( eagle2 )	/* (c) Centuri */
+	DRIVER( moonqsr )	/* (c) 1980 Nichibutsu */
+	DRIVER( checkman )	/* (c) 1982 Zilec-Zenitone */
+	DRIVER( checkmaj )	/* (c) 1982 Jaleco (Zenitone/Zilec in ROM CM4, and the programmer names) */
+	DRIVER( streakng )	/* [1980] Shoei */
+	DRIVER( blkhole )	/* TDS (Tokyo Denshi Sekkei) */
+	DRIVER( moonal2 )	/* Nichibutsu */
+	DRIVER( moonal2b )	/* Nichibutsu */
+	DRIVER( kingball )	/* (c) 1980 Namco */
+	DRIVER( kingbalj )	/* (c) 1980 Namco */
+
+	/* "Scramble hardware" (and variations) games */
+	DRIVER( scramble )	/* GX387 (c) 1981 Konami */
+	DRIVER( scrambls )	/* GX387 (c) 1981 Stern */
+	DRIVER( scramblb )	/* bootleg */
+	DRIVER( atlantis )	/* (c) 1981 Comsoft */
+	DRIVER( atlants2 )	/* (c) 1981 Comsoft */
+	DRIVER( theend )	/* (c) 1980 Konami */
+	DRIVER( theends )	/* (c) 1980 Stern */
+	DRIVER( ckongs )	/* bootleg */
+	DRIVER( froggers )	/* bootleg */
+	DRIVER( amidars )	/* (c) 1982 Konami */
+	DRIVER( triplep )	/* (c) 1982 KKI */
+	DRIVER( knockout )	/* (c) 1982 KKK */
+	DRIVER( mariner )	/* (c) 1981 Amenip */
+	DRIVER( mars )		/* (c) 1981 Artic */
+	DRIVER( devilfsh )	/* (c) 1982 Artic */
+	DRIVER( newsin7 )	/* (c) 1983 ATW USA, Inc. */
+	DRIVER( hotshock )	/* (c) 1982 E.G. Felaco */
+	DRIVER( hunchbks )	/* (c) 1983 Century */
+	DRIVER( scobra )	/* GX316 (c) 1981 Konami */
+	DRIVER( scobras )	/* GX316 (c) 1981 Stern */
+	DRIVER( scobrab )	/* GX316 (c) 1981 Karateco (bootleg?) */
+	DRIVER( stratgyx )	/* GX306 (c) 1981 Konami */
+	DRIVER( stratgys )	/* GX306 (c) 1981 Stern */
+	DRIVER( armorcar )	/* (c) 1981 Stern */
+	DRIVER( armorca2 )	/* (c) 1981 Stern */
+	DRIVER( moonwar2 )	/* (c) 1981 Stern */
+	DRIVER( monwar2a )	/* (c) 1981 Stern */
+	DRIVER( spdcoin )	/* (c) 1984 Stern */
+	DRIVER( darkplnt )	/* (c) 1982 Stern */
+	DRIVER( tazmania )	/* (c) 1982 Stern */
+	DRIVER( tazmani2 )	/* (c) 1982 Stern */
+	DRIVER( calipso )	/* (c) 1982 Tago */
+	DRIVER( anteater )	/* (c) 1982 Tago */
+	DRIVER( rescue )	/* (c) 1982 Stern */
+	DRIVER( minefld )	/* (c) 1983 Stern */
+	DRIVER( losttomb )	/* (c) 1982 Stern */
+	DRIVER( losttmbh )	/* (c) 1982 Stern */
+	DRIVER( superbon )	/* bootleg */
+	DRIVER( hustler )	/* GX343 (c) 1981 Konami */
+	DRIVER( billiard )	/* bootleg */
+	DRIVER( hustlerb )	/* bootleg */
+	DRIVER( frogger )	/* GX392 (c) 1981 Konami */
+	DRIVER( frogseg1 )	/* (c) 1981 Sega */
+	DRIVER( frogseg2 )	/* 834-0068 (c) 1981 Sega */
+	DRIVER( froggrmc )	/* 800-3110 (c) 1981 Sega */
+	DRIVER( amidar )	/* GX337 (c) 1981 Konami */
+	DRIVER( amidaru )	/* GX337 (c) 1982 Konami + Stern license */
+	DRIVER( amidaro )	/* GX337 (c) 1982 Konami + Olympia license */
+	DRIVER( amigo )		/* bootleg */
+	DRIVER( turtles )	/* (c) 1981 Stern */
+	DRIVER( turpin )	/* (c) 1981 Sega */
+	DRIVER( 600 )		/* GX353 (c) 1981 Konami */
+	DRIVER( flyboy )	/* (c) 1982 Kaneko */
+	DRIVER( flyboyb )	/* bootleg */
+	DRIVER( fastfred )	/* (c) 1982 Atari */
+	DRIVER( jumpcoas )	/* (c) 1983 Kaneko */
+
+	/* "Crazy Climber hardware" games */
+	DRIVER( cclimber )	/* (c) 1980 Nichibutsu */
+	DRIVER( cclimbrj )	/* (c) 1980 Nichibutsu */
+	DRIVER( ccboot )	/* bootleg */
+	DRIVER( ccboot2 )	/* bootleg */
+	DRIVER( ckong )		/* (c) 1981 Falcon */
+	DRIVER( ckonga )	/* (c) 1981 Falcon */
+	DRIVER( ckongjeu )	/* bootleg */
+	DRIVER( ckongo )	/* bootleg */
+	DRIVER( ckongalc )	/* bootleg */
+	DRIVER( monkeyd )	/* bootleg */
+	DRIVER( rpatrolb )	/* bootleg */
+	DRIVER( silvland )	/* Falcon */
+	DRIVER( yamato )	/* (c) 1983 Sega */
+	DRIVER( yamato2 )	/* (c) 1983 Sega */
+	DRIVER( swimmer )	/* (c) 1982 Tehkan */
+	DRIVER( swimmera )	/* (c) 1982 Tehkan */
+	DRIVER( guzzler )	/* (c) 1983 Tehkan */
+
+	/* Nichibutsu games */
+	DRIVER( friskyt )	/* (c) 1981 */
+	DRIVER( radrad )	/* (c) 1982 Nichibutsu USA */
+	DRIVER( seicross )	/* (c) 1984 + Alice */
+	DRIVER( sectrzon )	/* (c) 1984 + Alice */
+	DRIVER( wiping )	/* (c) 1982 */
+	DRIVER( rugrats )	/* (c) 1983 */
+	DRIVER( cop01 )		/* (c) 1985 */
+	DRIVER( cop01a )	/* (c) 1985 */
+	DRIVER( terracre )	/* (c) 1985 */
+	DRIVER( terracrb )	/* (c) 1985 */
+	DRIVER( terracra )	/* (c) 1985 */
+	DRIVER( galivan )	/* (c) 1985 */
+	DRIVER( galivan2 )	/* (c) 1985 */
+	DRIVER( dangar )	/* (c) 1986 */
+	DRIVER( dangar2 )	/* (c) 1986 */
+	DRIVER( dangarb )	/* bootleg */
+	DRIVER( ninjemak )	/* (c) 1986 (US?) */
+	DRIVER( youma )		/* (c) 1986 (Japan) */
+	DRIVER( terraf )	/* (c) 1987 */
+	DRIVER( terrafu )	/* (c) 1987 Nichibutsu USA */
+	DRIVER( kodure )	/* (c) 1987 (Japan) */
+	DRIVER( armedf )	/* (c) 1988 */
+	DRIVER( cclimbr2 )	/* (c) 1988 (Japan) */
+
+	/* "Phoenix hardware" (and variations) games */
+	DRIVER( phoenix )	/* (c) 1980 Amstar */
+	DRIVER( phoenixa )	/* (c) 1980 Amstar + Centuri license */
+	DRIVER( phoenixt )	/* (c) 1980 Taito */
+	DRIVER( phoenix3 )	/* bootleg */
+	DRIVER( phoenixc )	/* bootleg */
+	DRIVER( pleiads )	/* (c) 1981 Tehkan */
+	DRIVER( pleiadbl )	/* bootleg */
+	DRIVER( pleiadce )	/* (c) 1981 Centuri + Tehkan */
+	DRIVER( naughtyb )	/* (c) 1982 Jaleco */
+	DRIVER( naughtya )	/* bootleg */
+	DRIVER( naughtyc )	/* (c) 1982 Jaleco + Cinematronics */
+	DRIVER( popflame )	/* (c) 1982 Jaleco */
+	DRIVER( popflama )	/* (c) 1982 Jaleco */
+
+	/* Namco games (plus some intruders on similar hardware) */
+	DRIVER( geebee )	/* [1978] Namco */
+	DRIVER( geebeeg )	/* [1978] Gremlin */
+	DRIVER( bombbee )	/* [1979] Namco */
+	DRIVER( cutieq )	/* (c) 1979 Namco */
+	DRIVER( navalone )	/* (c) 1980 Namco */
+	DRIVER( kaitei )	/* [1980] K.K. Tokki */
+	DRIVER( kaitein )	/* [1980] Namco */
+	DRIVER( sos )		/* [1980] Namco */
+	DRIVER( tankbatt )	/* (c) 1980 Namco */
+	DRIVER( warpwarp )	/* (c) 1981 Namco */
+	DRIVER( warpwarr )	/* (c) 1981 Rock-ola - the high score table says "NAMCO" */
+	DRIVER( warpwar2 )	/* (c) 1981 Rock-ola - the high score table says "NAMCO" */
+	DRIVER( rallyx )	/* (c) 1980 Namco */
+	DRIVER( rallyxm )	/* (c) 1980 Midway */
+	DRIVER( nrallyx )	/* (c) 1981 Namco */
+	DRIVER( jungler )	/* GX327 (c) 1981 Konami */
+	DRIVER( junglers )	/* GX327 (c) 1981 Stern */
+	DRIVER( locomotn )	/* GX359 (c) 1982 Konami + Centuri license */
+	DRIVER( gutangtn )	/* GX359 (c) 1982 Konami + Sega license */
+	DRIVER( cottong )	/* bootleg */
+	DRIVER( commsega )	/* (c) 1983 Sega */
+	/* the following ones all have a custom I/O chip */
+	DRIVER( bosco )		/* (c) 1981 */
+	DRIVER( boscomd )	/* (c) 1981 Midway */
+	DRIVER( boscomdo )	/* (c) 1981 Midway */
+	DRIVER( galaga )	/* (c) 1981 */
+	DRIVER( galagamw )	/* (c) 1981 Midway */
+	DRIVER( galagads )	/* hack */
+	DRIVER( gallag )	/* bootleg */
+	DRIVER( galagab2 )	/* bootleg */
+	DRIVER( galaga84 )	/* hack */
+	DRIVER( nebulbee )	/* hack */
+	DRIVER( digdug )	/* (c) 1982 */
+	DRIVER( digdugb )	/* (c) 1982 */
+	DRIVER( digdugat )	/* (c) 1982 Atari */
+	DRIVER( dzigzag )	/* bootleg */
+	DRIVER( xevious )	/* (c) 1982 */
+	DRIVER( xeviousa )	/* (c) 1982 + Atari license */
+	DRIVER( xevios )	/* bootleg */
+	DRIVER( sxevious )	/* (c) 1984 */
+	DRIVER( superpac )	/* (c) 1982 */
+	DRIVER( superpcm )	/* (c) 1982 Midway */
+	DRIVER( pacnpal )	/* (c) 1983 */
+	DRIVER( pacnchmp )	/* (c) 1983 */
+	DRIVER( phozon )	/* (c) 1983 */
+	DRIVER( mappy )		/* (c) 1983 */
+	DRIVER( mappyjp )	/* (c) 1983 */
+	DRIVER( digdug2 )	/* (c) 1985 */
+	DRIVER( digdug2a )	/* (c) 1985 */
+	DRIVER( todruaga )	/* (c) 1984 */
+	DRIVER( todruagb )	/* (c) 1984 */
+	DRIVER( motos )		/* (c) 1985 */
+	DRIVER( grobda )	/* (c) 1984 */
+	DRIVER( grobda2 )	/* (c) 1984 */
+	DRIVER( grobda3 )	/* (c) 1984 */
+	DRIVER( gaplus )	/* (c) 1984 */
+	DRIVER( gaplusa )	/* (c) 1984 */
+	DRIVER( galaga3 )	/* (c) 1984 */
+	DRIVER( galaga3a )	/* (c) 1984 */
+	/* Z8000 games */
+	DRIVER( polepos )	/* (c) 1982  */
+	DRIVER( poleposa )	/* (c) 1982 + Atari license */
+	DRIVER( polepos1 )	/* (c) 1982 Atari */
+	DRIVER( topracer )	/* bootleg */
+	DRIVER( polepos2 )	/* (c) 1983 + Atari license */
+	DRIVER( poleps2a )	/* (c) 1983 + Atari license */
+	/* no custom I/O in the following, HD63701 (or compatible) microcontroller instead */
+	DRIVER( pacland )	/* (c) 1984 */
+	DRIVER( pacland2 )	/* (c) 1984 */
+	DRIVER( pacland3 )	/* (c) 1984 */
+	DRIVER( paclandm )	/* (c) 1984 Midway */
+	DRIVER( drgnbstr )	/* (c) 1984 */
+	DRIVER( skykid )	/* (c) 1985 */
+	DRIVER( baraduke )	/* (c) 1985 */
+	DRIVER( metrocrs )	/* (c) 1985 */
+
+	/* Namco System 86 games */
+	DRIVER( hopmappy )	/* (c) 1986 */
+	DRIVER( skykiddx )	/* (c) 1986 */
+	DRIVER( skykiddo )	/* (c) 1986 */
+	DRIVER( roishtar )	/* (c) 1986 */
+	DRIVER( genpeitd )	/* (c) 1986 */
+	DRIVER( rthunder )	/* (c) 1986 new version */
+	DRIVER( rthundro )	/* (c) 1986 old version */
+	DRIVER( wndrmomo )	/* (c) 1987 */
+
+	/* Namco System 1 games */
+	DRIVER( shadowld )	/* (c) 1987 */
+	DRIVER( youkaidk )	/* (c) 1987 (Japan) */
+	DRIVER( dspirit )	/* (c) 1987 new version */
+	DRIVER( dspirito )	/* (c) 1987 old version */
+	DRIVER( blazer )	/* (c) 1987 (Japan) */
+	/* 1987 Quester */
+	DRIVER( pacmania )	/* (c) 1987 */
+	DRIVER( pacmanij )	/* (c) 1987 (Japan) */
+	DRIVER( galaga88 )	/* (c) 1987 */
+	DRIVER( galag88b )	/* (c) 1987 */
+	DRIVER( galag88j )	/* (c) 1987 (Japan) */
+	/* 1988 World Stadium */
+TESTDRIVER( berabohm )	/* (c) 1988 */
+	/* 1988 Alice in Wonderland (English version of Marchen maze) */
+	DRIVER( mmaze )		/* (c) 1988 (Japan) */
+TESTDRIVER( bakutotu )	/* (c) 1988 */
+	DRIVER( wldcourt )	/* (c) 1988 (Japan) */
+	DRIVER( splatter )	/* (c) 1988 (Japan) */
+	/* 1988 Face Off */
+	DRIVER( rompers )	/* (c) 1989 (Japan) */
+	DRIVER( blastoff )	/* (c) 1989 (Japan) */
+	/* World Stadium '89 */
+	DRIVER( dangseed )	/* (c) 1989 (Japan) */
+	DRIVER( ws90 )		/* (c) 1990 (Japan) */
+	DRIVER( pistoldm )	/* (c) 1990 (Japan) */
+	DRIVER( soukobdx )	/* (c) 1990 (Japan) */
+	DRIVER( tankfrce )	/* (c) 1991 (US) */
+	DRIVER( tankfrcj )	/* (c) 1991 (Japan) */
+
+	/* Namco System 2 games */
+TESTDRIVER( finallap )	/* 87.12 Final Lap */
+TESTDRIVER( finalapd )	/* 87.12 Final Lap */
+TESTDRIVER( finalapc )	/* 87.12 Final Lap */
+TESTDRIVER( finlapjc )	/* 87.12 Final Lap */
+TESTDRIVER( finlapjb )	/* 87.12 Final Lap */
+	DRIVER( assault )	/* (c) 1988 */
+	DRIVER( assaultj )	/* (c) 1988 (Japan) */
+	DRIVER( assaultp )	/* (c) 1988 (Japan) */
+TESTDRIVER( metlhawk )	/* (c) 1988 */
+	DRIVER( mirninja )	/* (c) 1988 (Japan) */
+	DRIVER( ordyne )	/* (c) 1988 */
+	DRIVER( phelios )	/* (c) 1988 (Japan) */
+	DRIVER( burnforc )	/* (c) 1989 (Japan) */
+TESTDRIVER( dirtfoxj )	/* (c) 1989 (Japan) */
+	DRIVER( finehour )	/* (c) 1989 (Japan) */
+TESTDRIVER( fourtrax )	/* 89.11 */
+	DRIVER( marvland )	/* (c) 1989 (US) */
+	DRIVER( marvlanj )	/* (c) 1989 (Japan) */
+	DRIVER( valkyrie )	/* (c) 1989 (Japan) */
+	/* 90.5  [Kyuukai Douchuuki] (baseball game. uses character of Youkai Douchuuki) */
+	DRIVER( dsaber )	/* (c) 1990 */
+	DRIVER( dsaberj )	/* (c) 1990 (Japan) */
+	DRIVER( rthun2 )	/* (c) 1990 */
+	DRIVER( rthun2j )	/* (c) 1990 (Japan) */
+TESTDRIVER( finalap2 )	/* 90.8  Final Lap 2 */
+TESTDRIVER( finalp2j )	/* 90.8  Final Lap 2 (Japan) */
+	/* 91.3  Steel Gunner */
+	/* 91.7  Golly Ghost */
+	/* 91.9  Super World Stadium */
+TESTDRIVER( sgunner2 )	/* (c) 1991 (Japan) */
+	DRIVER( cosmogng )	/* (c) 1991 (US) */
+	DRIVER( cosmognj )	/* (c) 1991 (Japan) */
+TESTDRIVER( finalap3 )	/* 92.9  Final Lap 3 */
+TESTDRIVER( suzuka8h )
+	/* 92.8  Bubble Trouble */
+	DRIVER( sws92 )		/* (c) 1992 (Japan) */
+	/* 93.4  Lucky & Wild */
+	DRIVER( sws93 )		/* (c) 1993 (Japan) */
+	/* 93.6  Super World Stadium '93 */
+
+/*
+>other remaining Namco games
+>-----------------------------------------------------
+>Libble Rabble board
+>83.12 Libble Rabble (The first Japanese game that uses M68K)
+>86.4  Toy Pop
+>
+>-----------------------------------------------------
+>NA-1 system
+>92.10 F/A
+
+*/
+
+	/* Universal games */
+	DRIVER( cosmicg )	/* (c) 1979 */
+	DRIVER( cosmica )	/* (c) [1979] */
+	DRIVER( panic )		/* (c) 1980 */
+	DRIVER( panica )	/* (c) 1980 */
+	DRIVER( panicger )	/* (c) 1980 */
+	DRIVER( magspot2 )	/* (c) [1980?] */
+	DRIVER( devzone )	/* (c) [1980?] */
+	DRIVER( nomnlnd )	/* (c) [1980?] */
+	DRIVER( nomnlndg )	/* (c) [1980?] + Gottlieb */
+	DRIVER( cheekyms )	/* (c) [1980?] */
+	DRIVER( ladybug )	/* (c) 1981 */
+	DRIVER( ladybugb )	/* bootleg */
+	DRIVER( snapjack )	/* (c) */
+	DRIVER( cavenger )	/* (c) 1981 */
+	DRIVER( mrdo )		/* (c) 1982 */
+	DRIVER( mrdot )		/* (c) 1982 + Taito license */
+	DRIVER( mrdofix )	/* (c) 1982 + Taito license */
+	DRIVER( mrlo )		/* bootleg */
+	DRIVER( mrdu )		/* bootleg */
+	DRIVER( mrdoy )		/* bootleg */
+	DRIVER( yankeedo )	/* bootleg */
+	DRIVER( docastle )	/* (c) 1983 */
+	DRIVER( docastl2 )	/* (c) 1983 */
+	DRIVER( douni )		/* (c) 1983 */
+	DRIVER( dorunrun )	/* (c) 1984 */
+	DRIVER( dorunru2 )	/* (c) 1984 */
+	DRIVER( dorunruc )	/* (c) 1984 */
+	DRIVER( spiero )	/* (c) 1987 */
+	DRIVER( dowild )	/* (c) 1984 */
+	DRIVER( jjack )		/* (c) 1984 */
+	DRIVER( kickridr )	/* (c) 1984 */
+
+	/* Nintendo games */
+	DRIVER( radarscp )	/* (c) 1980 Nintendo */
+	DRIVER( dkong )		/* (c) 1981 Nintendo of America */
+	DRIVER( dkongjp )	/* (c) 1981 Nintendo */
+	DRIVER( dkongjpo )	/* (c) 1981 Nintendo */
+	DRIVER( dkongjr )	/* (c) 1982 Nintendo of America */
+	DRIVER( dkngjrjp )	/* no copyright notice */
+	DRIVER( dkjrjp )	/* (c) 1982 Nintendo */
+	DRIVER( dkjrbl )	/* (c) 1982 Nintendo of America */
+	DRIVER( dkong3 )	/* (c) 1983 Nintendo of America */
+	DRIVER( dkong3j )	/* (c) 1983 Nintendo */
+	DRIVER( mario )		/* (c) 1983 Nintendo of America */
+	DRIVER( mariojp )	/* (c) 1983 Nintendo */
+	DRIVER( masao )		/* bootleg */
+	DRIVER( hunchbkd )	/* (c) 1983 Century */
+	DRIVER( herbiedk )	/* (c) 1984 CVS */
+TESTDRIVER( herocast )
+	DRIVER( popeye )
+	DRIVER( popeye2 )
+	DRIVER( popeyebl )	/* bootleg */
+	DRIVER( punchout )	/* (c) 1984 */
+	DRIVER( spnchout )	/* (c) 1984 */
+	DRIVER( armwrest )	/* (c) 1985 */
+
+	/* Midway 8080 b/w games */
+	DRIVER( seawolf )	/* 596 [1976] */
+	DRIVER( gunfight )	/* 597 [1975] */
+	/* 603 - Top Gun [1976] */
+	DRIVER( tornbase )	/* 605 [1976] */
+	DRIVER( 280zzzap )	/* 610 [1976] */
+	DRIVER( maze )		/* 611 [1976] */
+	DRIVER( boothill )	/* 612 [1977] */
+	DRIVER( checkmat )	/* 615 [1977] */
+	/* 618 - Road Runner [1977] */
+	/* 618 - Desert Gun [1977] */
+	DRIVER( dplay )		/* 619 [1977] */
+	DRIVER( lagunar )	/* 622 [1977] */
+	DRIVER( gmissile )	/* 623 [1977] */
+	DRIVER( m4 )		/* 626 [1977] */
+	DRIVER( clowns )	/* 630 [1978] */
+	/* 640 - Space Walk [1978] */
+	DRIVER( einnings )	/* 642 [1978] Midway */
+	/* 643 - Shuffleboard [1978] */
+	DRIVER( dogpatch )	/* 644 [1977] */
+	DRIVER( spcenctr )	/* 645 (c) 1980 Midway */
+	DRIVER( phantom2 )	/* 652 [1979] */
+	DRIVER( bowler )	/* 730 [1978] Midway */
+	DRIVER( invaders )	/* 739 [1979] */
+	DRIVER( blueshrk )	/* 742 [1978] */
+	DRIVER( invad2ct )	/* 851 (c) 1980 Midway */
+	DRIVER( invadpt2 )	/* 852 [1980] Taito */
+	DRIVER( invdpt2m )	/* 852 [1980] Midway */
+	/* 870 - Space Invaders Deluxe cocktail */
+	DRIVER( earthinv )
+	DRIVER( spaceatt )
+	DRIVER( sinvemag )
+	DRIVER( jspecter )
+	DRIVER( invrvnge )
+	DRIVER( invrvnga )
+	DRIVER( galxwars )
+	DRIVER( starw )
+	DRIVER( lrescue )	/* (c) 1979 Taito */
+	DRIVER( grescue )	/* bootleg? */
+	DRIVER( desterth )	/* bootleg */
+	DRIVER( cosmicmo )	/* Universal */
+	DRIVER( rollingc )	/* Nichibutsu */
+	DRIVER( bandido )	/* (c) Exidy */
+	DRIVER( ozmawars )	/* Shin Nihon Kikaku (SNK) */
+	DRIVER( solfight )	/* bootleg */
+	DRIVER( spaceph )	/* Zilec Games */
+	DRIVER( schaser )	/* Taito */
+	DRIVER( lupin3 )	/* (c) 1980 Taito */
+	DRIVER( helifire )	/* (c) Nintendo */
+	DRIVER( helifira )	/* (c) Nintendo */
+	DRIVER( spacefev )
+	DRIVER( sfeverbw )
+	DRIVER( astlaser )
+	DRIVER( intruder )
+	DRIVER( polaris )	/* (c) 1980 Taito */
+	DRIVER( polarisa )	/* (c) 1980 Taito */
+	DRIVER( ballbomb )	/* (c) 1980 Taito */
+	DRIVER( m79amb )
+	DRIVER( alieninv )
+	DRIVER( si_tv )
+	DRIVER( si_cv )
+	DRIVER( si_sv )
+	DRIVER( sisv2 )
+	DRIVER( spacewr3 )
+	DRIVER( logitec )
+	DRIVER( yosakdon )
+	DRIVER( spceking )
+	DRIVER( spcewars )
+	DRIVER( spcewarl )
+
+	/* "Midway" Z80 b/w games */
+	DRIVER( astinvad )	/* (c) 1980 Stern */
+	DRIVER( kamikaze )	/* Leijac Corporation */
+	DRIVER( spaceint )	/* [1980] Shoei */
+
+	/* Meadows S2650 games */
+	DRIVER( lazercmd )	/* [1976?] */
+	DRIVER( deadeye )	/* [1978?] */
+	DRIVER( gypsyjug )	/* [1978?] */
+	DRIVER( medlanes )	/* [1977?] */
+
+	/* Midway "Astrocade" games */
+	DRIVER( wow )		/* (c) 1980 */
+	DRIVER( robby )		/* (c) 1981 */
+	DRIVER( gorf )		/* (c) 1981 */
+	DRIVER( gorfpgm1 )	/* (c) 1981 */
+	DRIVER( seawolf2 )
+	DRIVER( spacezap )	/* (c) 1980 */
+	DRIVER( ebases )
+
+	/* Bally Midway MCR games */
+	/* MCR1 */
+	DRIVER( solarfox )	/* (c) 1981 */
+	DRIVER( kick )		/* (c) 1981 */
+	DRIVER( kicka )		/* bootleg? */
+	/* MCR2 */
+	DRIVER( shollow )	/* (c) 1981 */
+	DRIVER( shollow2 )	/* (c) 1981 */
+	DRIVER( tron )		/* (c) 1982 */
+	DRIVER( tron2 )		/* (c) 1982 */
+	DRIVER( kroozr )	/* (c) 1982 */
+	DRIVER( domino )	/* (c) 1982 */
+	DRIVER( wacko )		/* (c) 1982 */
+	DRIVER( twotiger )	/* (c) 1984 */
+	/* MCR2 + MCR3 sprites */
+	DRIVER( journey )	/* (c) 1983 */
+	/* MCR3 */
+	DRIVER( tapper )	/* (c) 1983 */
+	DRIVER( tappera )	/* (c) 1983 */
+	DRIVER( sutapper )	/* (c) 1983 */
+	DRIVER( rbtapper )	/* (c) 1984 */
+	DRIVER( timber )	/* (c) 1984 */
+	DRIVER( dotron )	/* (c) 1983 */
+	DRIVER( dotrone )	/* (c) 1983 */
+	DRIVER( destderb )	/* (c) 1984 */
+	DRIVER( destderm )	/* (c) 1984 */
+	DRIVER( sarge )		/* (c) 1985 */
+	DRIVER( rampage )	/* (c) 1986 */
+	DRIVER( rampage2 )	/* (c) 1986 */
+	DRIVER( powerdrv )	/* (c) 1986 */
+	DRIVER( maxrpm )	/* (c) 1986 */
+	DRIVER( spyhunt )	/* (c) 1983 */
+	DRIVER( turbotag )	/* (c) 1985 */
+	DRIVER( crater )	/* (c) 1984 */
+	/* MCR 68000 */
+	DRIVER( zwackery )	/* (c) 1984 */
+	DRIVER( xenophob )	/* (c) 1987 */
+	DRIVER( spyhunt2 )	/* (c) 1987 */
+	DRIVER( blasted )	/* (c) 1988 */
+	DRIVER( archrivl )	/* (c) 1989 */
+	DRIVER( archriv2 )	/* (c) 1989 */
+	DRIVER( trisport )	/* (c) 1989 */
+	DRIVER( pigskin )	/* (c) 1990 */
+/* other possible MCR games:
+Black Belt
+Shoot the Bull
+Special Force
+MotorDome
+Six Flags (?)
+*/
+
+	/* Bally / Sente games */
+	DRIVER( sentetst )
+	DRIVER( cshift )	/* (c) 1984 */
+	DRIVER( gghost )	/* (c) 1984 */
+	DRIVER( hattrick )	/* (c) 1984 */
+	DRIVER( otwalls )	/* (c) 1984 */
+	DRIVER( snakepit )	/* (c) 1984 */
+	DRIVER( snakjack )	/* (c) 1984 */
+	DRIVER( stocker )	/* (c) 1984 */
+	DRIVER( triviag1 )	/* (c) 1984 */
+	DRIVER( triviag2 )	/* (c) 1984 */
+	DRIVER( triviasp )	/* (c) 1984 */
+	DRIVER( triviayp )	/* (c) 1984 */
+	DRIVER( triviabb )	/* (c) 1984 */
+	DRIVER( gimeabrk )	/* (c) 1985 */
+	DRIVER( minigolf )	/* (c) 1985 */
+	DRIVER( minigol2 )	/* (c) 1985 */
+	DRIVER( toggle )	/* (c) 1985 */
+	DRIVER( nametune )	/* (c) 1986 */
+	DRIVER( nstocker )	/* (c) 1986 */
+	DRIVER( sfootbal )	/* (c) 1986 */
+	DRIVER( spiker )	/* (c) 1986 */
+	DRIVER( rescraid )	/* (c) 1987 */
+
+	/* Irem games */
+	/* trivia: IREM means "International Rental Electronics Machines" */
+	DRIVER( skychut )	/* (c) [1980] */
+	DRIVER( mpatrol )	/* (c) 1982 */
+	DRIVER( mpatrolw )	/* (c) 1982 + Williams license */
+	DRIVER( mranger )	/* bootleg */
+	DRIVER( troangel )	/* (c) 1983 */
+	DRIVER( yard )		/* (c) 1983 */
+	DRIVER( vsyard )	/* (c) 1983/1984 */
+	DRIVER( vsyard2 )	/* (c) 1983/1984 */
+	DRIVER( travrusa )	/* (c) 1983 */
+	DRIVER( motorace )	/* (c) 1983 Williams license */
+	/* M62 */
+	DRIVER( kungfum )	/* (c) 1984 */
+	DRIVER( kungfud )	/* (c) 1984 + Data East license */
+	DRIVER( spartanx )	/* (c) 1984 */
+	DRIVER( kungfub )	/* bootleg */
+	DRIVER( kungfub2 )	/* bootleg */
+	DRIVER( battroad )	/* (c) 1984 */
+	DRIVER( ldrun )		/* (c) 1984 licensed from Broderbund */
+	DRIVER( ldruna )	/* (c) 1984 licensed from Broderbund */
+	DRIVER( ldrun2 )	/* (c) 1984 licensed from Broderbund */
+	DRIVER( ldrun3 )	/* (c) 1985 licensed from Broderbund */
+	DRIVER( ldrun4 )	/* (c) 1986 licensed from Broderbund */
+	DRIVER( lotlot )	/* (c) 1985 licensed from Tokuma Shoten */
+	DRIVER( kidniki )	/* (c) 1986 + Data East USA license */
+	DRIVER( yanchamr )	/* (c) 1986 (Japan) */
+	DRIVER( spelunkr )	/* (c) 1985 licensed from Broderbund */
+	DRIVER( spelunk2 )	/* (c) 1986 licensed from Broderbund */
+
+	DRIVER( vigilant )	/* (c) 1988 (World) */
+	DRIVER( vigilntu )	/* (c) 1988 (US) */
+	DRIVER( vigilntj )	/* (c) 1988 (Japan) */
+	DRIVER( kikcubic )	/* (c) 1988 (Japan) */
+	/* M72 (and derivatives) */
+	DRIVER( rtype )		/* (c) 1987 (Japan) */
+	DRIVER( rtypeu )	/* (c) 1987 + Nintendo USA license (US) */
+	DRIVER( rtypeb )	/* bootleg */
+	DRIVER( bchopper )	/* (c) 1987 */
+	DRIVER( mrheli )	/* (c) 1987 (Japan) */
+	DRIVER( nspirit )	/* (c) 1988 */
+	DRIVER( nspiritj )	/* (c) 1988 (Japan) */
+	DRIVER( imgfight )	/* (c) 1988 (Japan) */
+	DRIVER( loht )		/* (c) 1989 */
+	DRIVER( xmultipl )	/* (c) 1989 (Japan) */
+	DRIVER( dbreed )	/* (c) 1989 */
+	DRIVER( rtype2 )	/* (c) 1989 */
+	DRIVER( rtype2j )	/* (c) 1989 (Japan) */
+	DRIVER( majtitle )	/* (c) 1990 (Japan) */
+	DRIVER( hharry )	/* (c) 1990 (World) */
+	DRIVER( hharryu )	/* (c) 1990 Irem America (US) */
+	DRIVER( dkgensan )	/* (c) 1990 (Japan) */
+TESTDRIVER( kengo )
+	DRIVER( gallop )	/* (c) 1991 (Japan) */
+TESTDRIVER( poundfor )
+	/* not M72, but same sound hardware */
+	DRIVER( sichuan2 )	/* (c) 1989 Tamtex */
+	DRIVER( sichuana )	/* (c) 1989 Tamtex */
+	DRIVER( shisen )	/* (c) 1989 Tamtex */
+	/* M92 */
+	DRIVER( bmaster )	/* (c) 1991 Irem */
+	DRIVER( gunforce )	/* (c) 1991 Irem (World) */
+	DRIVER( gunforcu )	/* (c) 1991 Irem America (US) */
+	DRIVER( hook )		/* (c) 1992 Irem (World) */
+	DRIVER( hooku )		/* (c) 1992 Irem America (US) */
+	DRIVER( mysticri )	/* (c) 1992 Irem (World) */
+	DRIVER( gunhohki )	/* (c) 1992 Irem (Japan) */
+	DRIVER( uccops )	/* (c) 1992 Irem (World) */
+	DRIVER( uccopsj )	/* (c) 1992 Irem (Japan) */
+	DRIVER( rtypeleo )	/* (c) 1992 Irem (Japan) */
+	DRIVER( majtitl2 )	/* (c) 1992 Irem (World) */
+	DRIVER( skingame )	/* (c) 1992 Irem America (US) */
+	DRIVER( skingam2 )	/* (c) 1992 Irem America (US) */
+	DRIVER( inthunt )	/* (c) 1993 Irem (World) */
+	DRIVER( kaiteids )	/* (c) 1993 Irem (Japan) */
+TESTDRIVER( nbbatman )	/* (c) 1993 Irem America (US) */
+TESTDRIVER( leaguemn )	/* (c) 1993 Irem (Japan) */
+	DRIVER( lethalth )	/* (c) 1991 Irem (World) */
+	DRIVER( thndblst )	/* (c) 1991 Irem (Japan) */
+	DRIVER( psoldier )	/* (c) 1993 Irem (Japan) */
+	/* M97 */
+TESTDRIVER( riskchal )
+TESTDRIVER( gussun )
+TESTDRIVER( shisen2 )
+TESTDRIVER( quizf1 )
+TESTDRIVER( atompunk )
+TESTDRIVER( bbmanw )
+	/* M107 */
+TESTDRIVER( firebarr )	/* (c) 1993 Irem (Japan) */
+	DRIVER( dsoccr94 )	/* (c) 1994 Irem (Data East Corporation license) */
+
+	/* Gottlieb/Mylstar games (Gottlieb became Mylstar in 1983) */
+	DRIVER( reactor )	/* GV-100 (c) 1982 Gottlieb */
+	DRIVER( mplanets )	/* GV-102 (c) 1983 Gottlieb */
+	DRIVER( qbert )		/* GV-103 (c) 1982 Gottlieb */
+	DRIVER( qbertjp )	/* GV-103 (c) 1982 Gottlieb + Konami license */
+	DRIVER( sqbert )	/* (c) 1983 Mylstar - never released */
+	DRIVER( krull )		/* GV-105 (c) 1983 Gottlieb */
+	DRIVER( mach3 )		/* GV-109 (c) 1983 Mylstar */
+	DRIVER( usvsthem )	/* GV-??? (c) 198? Mylstar */
+	DRIVER( 3stooges )	/* GV-113 (c) 1984 Mylstar */
+	DRIVER( qbertqub )	/* GV-119 (c) 1983 Mylstar */
+	DRIVER( curvebal )	/* GV-134 (c) 1984 Mylstar */
+
+	/* older Taito games */
+	DRIVER( crbaloon )	/* (c) 1980 Taito Corporation */
+	DRIVER( crbalon2 )	/* (c) 1980 Taito Corporation */
+
+	/* Taito "Qix hardware" games */
+	DRIVER( qix )		/* (c) 1981 Taito America Corporation */
+	DRIVER( qixa )		/* (c) 1981 Taito America Corporation */
+	DRIVER( qixb )		/* (c) 1981 Taito America Corporation */
+	DRIVER( qix2 )		/* (c) 1981 Taito America Corporation */
+	DRIVER( sdungeon )	/* (c) 1981 Taito America Corporation */
+	DRIVER( elecyoyo )	/* (c) 1982 Taito America Corporation */
+	DRIVER( elecyoy2 )	/* (c) 1982 Taito America Corporation */
+	DRIVER( kram )		/* (c) 1982 Taito America Corporation */
+	DRIVER( kram2 )		/* (c) 1982 Taito America Corporation */
+	DRIVER( zookeep )	/* (c) 1982 Taito America Corporation */
+	DRIVER( zookeep2 )	/* (c) 1982 Taito America Corporation */
+	DRIVER( zookeep3 )	/* (c) 1982 Taito America Corporation */
+
+	/* Taito SJ System games */
+	DRIVER( spaceskr )	/* (c) 1981 Taito Corporation */
+	DRIVER( junglek )	/* (c) 1982 Taito Corporation */
+	DRIVER( junglkj2 )	/* (c) 1982 Taito Corporation */
+	DRIVER( jungleh )	/* (c) 1982 Taito America Corporation */
+	DRIVER( alpine )	/* (c) 1982 Taito Corporation */
+	DRIVER( alpinea )	/* (c) 1982 Taito Corporation */
+	DRIVER( timetunl )	/* (c) 1982 Taito Corporation */
+	DRIVER( wwestern )	/* (c) 1982 Taito Corporation */
+	DRIVER( wwester1 )	/* (c) 1982 Taito Corporation */
+	DRIVER( frontlin )	/* (c) 1982 Taito Corporation */
+	DRIVER( elevator )	/* (c) 1983 Taito Corporation */
+	DRIVER( elevatob )	/* bootleg */
+	DRIVER( tinstar )	/* (c) 1983 Taito Corporation */
+	DRIVER( waterski )	/* (c) 1983 Taito Corporation */
+	DRIVER( bioatack )	/* (c) 1983 Taito Corporation + Fox Video Games license */
+	DRIVER( hwrace )	/* (c) 1983 Taito Corporation */
+	DRIVER( sfposeid )	/* 1984 */
+	DRIVER( kikstart )
+
+	/* other Taito games */
+	DRIVER( bking2 )	/* (c) 1983 Taito Corporation */
+	DRIVER( gsword )	/* (c) 1984 Taito Corporation */
+	DRIVER( lkage )		/* (c) 1984 Taito Corporation */
+	DRIVER( lkageb )	/* bootleg */
+	DRIVER( retofinv )	/* (c) 1985 Taito Corporation */
+	DRIVER( retofin1 )	/* bootleg */
+	DRIVER( retofin2 )	/* bootleg */
+	DRIVER( tsamurai )	/* (c) 1985 Taito */
+	DRIVER( tsamura2 )	/* (c) 1985 Taito */
+	DRIVER( nunchaku )	/* (c) 1985 Taito */
+	DRIVER( yamagchi )	/* (c) 1985 Taito */
+TESTDRIVER( flstory )	/* (c) 1985 Taito */
+	DRIVER( gladiatr )	/* (c) 1986 Taito America Corporation (US) */
+	DRIVER( ogonsiro )	/* (c) 1986 Taito Corporation (Japan) */
+	DRIVER( bublbobl )	/* (c) 1986 Taito Corporation */
+	DRIVER( bublbobr )	/* (c) 1986 Taito America Corporation */
+	DRIVER( boblbobl )	/* bootleg */
+	DRIVER( sboblbob )	/* bootleg */
+	DRIVER( tokio )		/* 1986 */
+	DRIVER( tokiob )	/* bootleg */
+	DRIVER( kicknrun )	/* (c) 1986 Taito Corporation */
+	DRIVER( mexico86 )	/* bootleg (Micro Research) */
+	DRIVER( kikikai )	/* (c) 1986 Taito Corporation */
+	DRIVER( rastan )	/* (c) 1987 Taito Corporation Japan (World) */
+	DRIVER( rastanu )	/* (c) 1987 Taito America Corporation (US) */
+	DRIVER( rastanu2 )	/* (c) 1987 Taito America Corporation (US) */
+	DRIVER( rastsaga )	/* (c) 1987 Taito Corporation (Japan)*/
+	DRIVER( rainbow )	/* (c) 1987 Taito Corporation */
+	DRIVER( rainbowe )	/* (c) 1988 Taito Corporation */
+	DRIVER( jumping )	/* bootleg */
+	DRIVER( arkanoid )	/* (c) 1986 Taito Corporation Japan (World) */
+	DRIVER( arknoidu )	/* (c) 1986 Taito America Corporation + Romstar license (US) */
+	DRIVER( arknoidj )	/* (c) 1986 Taito Corporation (Japan) */
+	DRIVER( arkbl2 )	/* bootleg */
+TESTDRIVER( arkbl3 )	/* bootleg */
+	DRIVER( arkatayt )	/* bootleg */
+TESTDRIVER( arkblock )	/* bootleg */
+	DRIVER( arkbloc2 )	/* bootleg */
+	DRIVER( arkangc )	/* bootleg */
+	DRIVER( superqix )	/* 1987 */
+	DRIVER( sqixbl )	/* bootleg? but (c) 1987 */
+	DRIVER( superman )	/* (c) 1988 Taito Corporation */
+TESTDRIVER( footchmp )	/* (c) 1990 Taito Corporation Japan (World) */
+	DRIVER( minivadr )	/* cabinet test board */
+
+	/* Taito "tnzs" hardware */
+	DRIVER( extrmatn )	/* (c) 1987 World Games */
+	DRIVER( arkanoi2 )	/* (c) 1987 Taito Corporation Japan (World) */
+	DRIVER( ark2us )	/* (c) 1987 Taito America Corporation + Romstar license (US) */
+	DRIVER( ark2jp )	/* (c) 1987 Taito Corporation (Japan) */
+	DRIVER( plumppop )	/* (c) 1987 Taito Corporation (Japan) */
+	DRIVER( drtoppel )	/* (c) 1987 Taito Corporation (Japan) */
+	DRIVER( chukatai )	/* (c) 1988 Taito Corporation (Japan) */
+	DRIVER( tnzs )		/* (c) 1988 Taito Corporation (Japan) (new logo) */
+	DRIVER( tnzsb )		/* bootleg but Taito Corporation Japan (World) (new logo) */
+	DRIVER( tnzs2 )		/* (c) 1988 Taito Corporation Japan (World) (old logo) */
+	DRIVER( insectx )	/* (c) 1989 Taito Corporation Japan (World) */
+	DRIVER( kageki )	/* (c) 1988 Taito America Corporation + Romstar license (US) */
+	DRIVER( kagekij )	/* (c) 1988 Taito Corporation (Japan) */
+
+	/* Taito L-System games */
+	DRIVER( fhawk )		/* (c) 1988 Taito Corporation (Japan) */
+	DRIVER( raimais )	/* (c) 1988 Taito Corporation (Japan) */
+	DRIVER( champwr )	/* (c) 1989 Taito Corporation Japan (World) */
+	DRIVER( champwrj )	/* (c) 1989 Taito Corporation (Japan) */
+	DRIVER( puzznic )	/* (c) 1989 Taito Corporation (Japan) */
+	DRIVER( plotting )	/* (c) 1989 Taito Corporation Japan (World) */
+	DRIVER( palamed )	/* (c) 1990 Taito Corporation (Japan) */
+	DRIVER( horshoes )	/* (c) 1990 Taito America Corporation (US) */
+	DRIVER( cachat )	/* (c) 1993 Taito Corporation (Japan) */
+
+	/* Taito F2 games */
+	DRIVER( ssi )		/* (c) 1990 Taito Corporation Japan (World) */
+	/* Majestic 12 (c) 1990 Taito America Corporation (US) */
+	DRIVER( majest12 )	/* (c) 1990 Taito Corporation (Japan) */
+TESTDRIVER( finalb )
+TESTDRIVER( megab )
+	DRIVER( liquidk )	/* (c) 1990 Taito Corporation Japan (World) */
+	DRIVER( liquidku )	/* (c) 1990 Taito America Corporation (US) */
+	DRIVER( mizubaku )	/* (c) 1990 Taito Corporation (Japan) */
+	DRIVER( growl )		/* (c) 1990 Taito Corporation Japan (World) */
+	DRIVER( growlu )	/* (c) 1990 Taito America Corporation (US) */
+	DRIVER( runark )	/* (c) 1990 Taito Corporation (Japan) */
+
+	/* Toaplan games */
+	DRIVER( tigerh )	/* GX-551 [not a Konami board!] */
+	DRIVER( tigerh2 )	/* GX-551 [not a Konami board!] */
+	DRIVER( tigerhb1 )	/* bootleg but (c) 1985 Taito Corporation */
+	DRIVER( tigerhb2 )	/* bootleg but (c) 1985 Taito Corporation */
+	DRIVER( slapfigh )	/* TP-??? */
+	DRIVER( slapbtjp )	/* bootleg but (c) 1986 Taito Corporation */
+	DRIVER( slapbtuk )	/* bootleg but (c) 1986 Taito Corporation */
+	DRIVER( alcon )		/* TP-??? */
+	DRIVER( getstar )	/* TP-??? bootleg but (c) 1986 Taito Corporation */
+
+	DRIVER( fshark )	/* TP-007 (c) 1987 Taito Corporation (World) */
+	DRIVER( skyshark )	/* TP-007 (c) 1987 Taito America Corporation + Romstar license (US) */
+	DRIVER( hishouza )	/* TP-007 (c) 1987 Taito Corporation (Japan) */
+	DRIVER( fsharkbt )	/* bootleg */
+	DRIVER( wardner )	/* TP-??? (c) 1987 Taito Corporation Japan (World) */
+	DRIVER( pyros )		/* TP-??? (c) 1987 Taito America Corporation (US) */
+	DRIVER( wardnerj )	/* TP-??? (c) 1987 Taito Corporation Japan (Japan) */
+	DRIVER( twincobr )	/* TP-011 (c) 1987 Taito Corporation (World) */
+	DRIVER( twincobu )	/* TP-011 (c) 1987 Taito America Corporation + Romstar license (US) */
+	DRIVER( ktiger )	/* TP-011 (c) 1987 Taito Corporation (Japan) */
+
+	DRIVER( rallybik )	/* TP-012 (c) 1988 Taito */
+	DRIVER( truxton )	/* TP-013B (c) 1988 Taito */
+	DRIVER( hellfire )	/* TP-??? (c) 1989 Toaplan + Taito license */
+	DRIVER( zerowing )	/* TP-015 (c) 1989 Toaplan */
+	DRIVER( demonwld )	/* TP-016 (c) 1989 Toaplan + Taito license */
+	DRIVER( outzone )	/* TP-018 (c) 1990 Toaplan */
+	DRIVER( outzonep )	/* bootleg */
+	DRIVER( vimana )	/* TP-019 (c) 1991 Toaplan (+ Tecmo license when set to Japan) */
+	DRIVER( vimana2 )	/* TP-019 (c) 1991 Toaplan (+ Tecmo license when set to Japan)  */
+	DRIVER( vimanan )	/* TP-019 (c) 1991 Toaplan (+ Nova Apparate GMBH & Co license) */
+	DRIVER( snowbros )	/* MIN16-02 (c) 1990 Toaplan + Romstar license */
+	DRIVER( snowbroa )	/* MIN16-02 (c) 1990 Toaplan + Romstar license */
+	DRIVER( snowbrob )	/* MIN16-02 (c) 1990 Toaplan + Romstar license */
+	DRIVER( snowbroj )	/* MIN16-02 (c) 1990 Toaplan */
+
+/*
+Toa Plan's board list
+(translated from http://www.aianet.ne.jp/~eisetu/rom/rom_toha.html)
+
+Title              ROMno.   Remark(1)   Remark(2)
+--------------------------------------------------
+Tiger Heli           A47      GX-551
+Hishouzame           B02      TP-007
+Kyukyoku Tiger       B30      TP-011
+Dash Yarou           B45      TP-012
+Tatsujin             B65      TP-013B   M6100649A
+Zero Wing            O15      TP-015
+Horror Story         O16      TP-016
+Same!Same!Same!      O17      TP-017
+Out Zone                      TP-018
+Vimana                        TP-019
+Teki Paki            O20      TP-020
+Ghox               TP-21      TP-021
+Dogyuun                       TP-022
+Tatsujin Oh                   TP-024    *1
+Fixeight                      TP-026
+V-V                           TP-027
+
+*1 There is a doubt this game uses TP-024 board and TP-025 romsets.
+
+   86 Mahjong Sisters                                 Kit 2P 8W+2B     HC    Mahjong TP-
+   88 Dash                                            Kit 2P 8W+2B                   TP-
+   89 Fire Shark                                      Kit 2P 8W+2B     VC    Shooter TP-017
+   89 Twin Hawk                                       Kit 2P 8W+2B     VC    Shooter TP-
+   91 Whoopie                                         Kit 2P 8W+2B     HC    Action
+   92 Teki Paki                                       Kit 2P                         TP-020
+   92 Ghox                                            Kit 2P Paddle+1B VC    Action  TP-021
+10/92 Dogyuun                                         Kit 2P 8W+2B     VC    Shooter TP-022
+92/93 Knuckle Bash                 Atari Games        Kit 2P 8W+2B     HC    Action  TP-023
+10/92 Tatsujin II/Truxton II       Taito              Kit 2P 8W+2B     VC    Shooter TP-024
+10/92 Truxton II/Tatsujin II       Taito              Kit 2P 8W+2B     VC    Shooter TP-024
+      Pipi & Bipi                                                                    TP-025
+   92 Fix Eight                                       Kit 2P 8W+2B     VC    Action  TP-026
+12/92 V  -  V (5)/Grind Stormer                       Kit 2P 8W+2B     VC    Shooter TP-027
+ 1/93 Grind Stormer/V - V (Five)                      Kit 2P 8W+2B     VC    Shooter TP-027
+ 2/94 Batsugun                                        Kit 2P 8W+2B     VC            TP-
+ 4/94 Snow Bros. 2                                    Kit 2P 8W+2B     HC    Action  TP-
+*/
+
+	/* Kyugo games */
+	/* Kyugo only made four games: Repulse, Flash Gal, SRD Mission and Air Wolf. */
+	/* Gyrodine was made by Crux. Crux was antecedent of Toa Plan, and spin-off from Orca. */
+	DRIVER( gyrodine )	/* (c) 1984 Taito Corporation */
+	DRIVER( sonofphx )	/* (c) 1985 Associated Overseas MFR */
+	DRIVER( repulse )	/* (c) 1985 Sega */
+	DRIVER( 99lstwar )	/* (c) 1985 Proma */
+	DRIVER( 99lstwra )	/* (c) 1985 Proma */
+	DRIVER( flashgal )	/* (c) 1985 Sega */
+	DRIVER( srdmissn )	/* (c) 1986 Taito Corporation */
+	DRIVER( airwolf )	/* (c) 1987 Kyugo */
+	DRIVER( skywolf )	/* bootleg */
+	DRIVER( skywolf2 )	/* bootleg */
+
+	/* Williams games */
+	DRIVER( defender )	/* (c) 1980 */
+	DRIVER( defendg )	/* (c) 1980 */
+TESTDRIVER( defndjeu )	/* bootleg */
+	DRIVER( defcmnd )	/* bootleg */
+TESTDRIVER( defcomnd )	/* bootleg */
+	DRIVER( defence )	/* bootleg */
+	DRIVER( mayday )
+	DRIVER( maydaya )
+	DRIVER( colony7 )	/* (c) 1981 Taito */
+	DRIVER( colony7a )	/* (c) 1981 Taito */
+	DRIVER( stargate )	/* (c) 1981 */
+	DRIVER( robotron )	/* (c) 1982 */
+	DRIVER( robotryo )	/* (c) 1982 */
+	DRIVER( joust )		/* (c) 1982 */
+	DRIVER( joustr )	/* (c) 1982 */
+	DRIVER( joustwr )	/* (c) 1982 */
+	DRIVER( bubbles )	/* (c) 1982 */
+	DRIVER( bubblesr )	/* (c) 1982 */
+	DRIVER( splat )		/* (c) 1982 */
+	DRIVER( sinistar )	/* (c) 1982 */
+	DRIVER( sinista1 )	/* (c) 1982 */
+	DRIVER( sinista2 )	/* (c) 1982 */
+	DRIVER( blaster )	/* (c) 1983 */
+	DRIVER( mysticm )	/* (c) 1983 */
+	DRIVER( tshoot )	/* (c) 1984 */
+	DRIVER( inferno )	/* (c) 1984 */
+	DRIVER( joust2 )	/* (c) 1986 */
+	DRIVER( lottofun )	/* (c) 1987 H.A.R. Management */
+
+	/* Capcom games */
+	/* The following is a COMPLETE list of the Capcom games up to 1997, as shown on */
+	/* their web site. The list is sorted by production date. */
+	DRIVER( vulgus )	/*  5/1984 (c) 1984 */
+	DRIVER( vulgus2 )	/*  5/1984 (c) 1984 */
+	DRIVER( vulgusj )	/*  5/1984 (c) 1984 */
+	DRIVER( sonson )	/*  7/1984 (c) 1984 */
+	DRIVER( higemaru )	/*  9/1984 (c) 1984 */
+	DRIVER( 1942 )		/* 12/1984 (c) 1984 */
+	DRIVER( 1942a )		/* 12/1984 (c) 1984 */
+	DRIVER( 1942b )		/* 12/1984 (c) 1984 */
+	DRIVER( exedexes )	/*  2/1985 (c) 1985 */
+	DRIVER( savgbees )	/*  2/1985 (c) 1985 + Memetron license */
+	DRIVER( commando )	/*  5/1985 (c) 1985 (World) */
+	DRIVER( commandu )	/*  5/1985 (c) 1985 + Data East license (US) */
+	DRIVER( commandj )	/*  5/1985 (c) 1985 (Japan) */
+	DRIVER( spaceinv )	/* bootleg */
+	DRIVER( gng )		/*  9/1985 (c) 1985 */
+	DRIVER( gnga )		/*  9/1985 (c) 1985 */
+	DRIVER( gngt )		/*  9/1985 (c) 1985 */
+	DRIVER( makaimur )	/*  9/1985 (c) 1985 */
+	DRIVER( makaimuc )	/*  9/1985 (c) 1985 */
+	DRIVER( makaimug )	/*  9/1985 (c) 1985 */
+	DRIVER( diamond )	/* (c) 1989 KH Video (NOT A CAPCOM GAME but runs on GnG hardware) */
+	DRIVER( gunsmoke )	/* 11/1985 (c) 1985 (World) */
+	DRIVER( gunsmrom )	/* 11/1985 (c) 1985 + Romstar (US) */
+	DRIVER( gunsmoka )	/* 11/1985 (c) 1985 (US) */
+	DRIVER( gunsmokj )	/* 11/1985 (c) 1985 (Japan) */
+	DRIVER( sectionz )	/* 12/1985 (c) 1985 */
+	DRIVER( sctionza )	/* 12/1985 (c) 1985 */
+	DRIVER( trojan )	/*  4/1986 (c) 1986 (US) */
+	DRIVER( trojanr )	/*  4/1986 (c) 1986 + Romstar */
+	DRIVER( trojanj )	/*  4/1986 (c) 1986 (Japan) */
+	DRIVER( srumbler )	/*  9/1986 (c) 1986 */
+	DRIVER( srumblr2 )	/*  9/1986 (c) 1986 */
+	DRIVER( rushcrsh )	/*  9/1986 (c) 1986 */
+	DRIVER( lwings )	/* 11/1986 (c) 1986 */
+	DRIVER( lwings2 )	/* 11/1986 (c) 1986 */
+	DRIVER( lwingsjp )	/* 11/1986 (c) 1986 */
+	DRIVER( sidearms )	/* 12/1986 (c) 1986 (World) */
+	DRIVER( sidearmr )	/* 12/1986 (c) 1986 + Romstar license (US) */
+	DRIVER( sidearjp )	/* 12/1986 (c) 1986 (Japan) */
+	DRIVER( turtship )	/* (c) 1988 Philco (NOT A CAPCOM GAME but runs on modified Sidearms hardware) */
+	DRIVER( dyger )		/* (c) 1989 Philco (NOT A CAPCOM GAME but runs on modified Sidearms hardware) */
+	DRIVER( avengers )	/*  2/1987 (c) 1987 (US) */
+	DRIVER( avenger2 )	/*  2/1987 (c) 1987 (US) */
+	DRIVER( bionicc )	/*  3/1987 (c) 1987 (US) */
+	DRIVER( bionicc2 )	/*  3/1987 (c) 1987 (US) */
+	DRIVER( topsecrt )	/*  3/1987 (c) 1987 (Japan) */
+	DRIVER( 1943 )		/*  6/1987 (c) 1987 (US) */
+	DRIVER( 1943j )		/*  6/1987 (c) 1987 (Japan) */
+	DRIVER( blktiger )	/*  8/1987 (c) 1987 (US) */
+	DRIVER( bktigerb )	/* bootleg */
+	DRIVER( blkdrgon )	/*  8/1987 (c) 1987 (Japan) */
+	DRIVER( blkdrgnb )	/* bootleg, hacked to say Black Tiger */
+	DRIVER( sf1 )		/*  8/1987 (c) 1987 (World) */
+	DRIVER( sf1us )		/*  8/1987 (c) 1987 (US) */
+	DRIVER( sf1jp )		/*  8/1987 (c) 1987 (Japan) */
+	DRIVER( tigeroad )	/* 11/1987 (c) 1987 + Romstar (US) */
+	DRIVER( toramich )	/* 11/1987 (c) 1987 (Japan) */
+	DRIVER( f1dream )	/*  4/1988 (c) 1988 + Romstar */
+	DRIVER( f1dreamb )	/* bootleg */
+	DRIVER( 1943kai )	/*  6/1988 (c) 1987 (Japan) */
+	DRIVER( lastduel )	/*  7/1988 (c) 1988 (US) */
+	DRIVER( lstduela )	/*  7/1988 (c) 1988 (US) */
+	DRIVER( lstduelb )	/* bootleg */
+	DRIVER( madgear )	/*  2/1989 (c) 1989 (US) */
+	DRIVER( madgearj )	/*  2/1989 (c) 1989 (Japan) */
+	DRIVER( ledstorm )	/*  2/1989 (c) 1989 (US) */
+	/*  3/1989 Dokaben (baseball) - see below among "Mitchell" games */
+	/*  8/1989 Dokaben 2 (baseball) - see below among "Mitchell" games */
+	/* 10/1989 Capcom Baseball - see below among "Mitchell" games */
+	/* 11/1989 Capcom World - see below among "Mitchell" games */
+	/*  3/1990 Adventure Quiz 2 Hatena no Dai-Bouken - see below among "Mitchell" games */
+	/*  1/1991 Quiz Tonosama no Yabou - see below among "Mitchell" games */
+	/*  4/1991 Ashita Tenki ni Naare (golf) - see below among "Mitchell" games */
+	/*  5/1991 Ataxx - see below among "Leland" games */
+	/*  6/1991 Quiz Sangokushi - see below among "Mitchell" games */
+	/* 10/1991 Block Block - see below among "Mitchell" games */
+	/*  6/1995 Street Fighter - the Movie - see below among "Incredible Technologies" games */
+	/* 11/1995 Battle Arena Toshinden 2 (PSX hardware) */
+	/*  7/1996 Star Gladiator (PSX hardware?) */
+TESTDRIVER( sfex )		/* 12/1996 Street Fighter EX (PSX hardware) */
+	/*  4/1997 Street Fighter EX Plus (PSX hardware) */
+	/*  Rival Schools (PSX hardware) */
+	/*  Rival Schools 2 (PSX hardware) */
+
+	/* Capcom CPS1 games */
+	DRIVER( forgottn )	/*  7/1988 (c) 1988 (US) */
+	DRIVER( lostwrld )	/*  7/1988 (c) 1988 (Japan) */
+	DRIVER( ghouls )	/* 12/1988 (c) 1988 */
+	DRIVER( ghoulsj )	/* 12/1988 (c) 1988 */
+	DRIVER( strider )	/*  3/1989 (c) 1989 */
+	DRIVER( striderj )	/*  3/1989 (c) 1989 */
+	DRIVER( stridrja )	/*  3/1989 (c) 1989 */
+	DRIVER( dwj )		/*  4/1989 (c) 1989 */
+	DRIVER( willow )	/*  6/1989 (c) 1989 (Japan) */
+	DRIVER( willowj )	/*  6/1989 (c) 1989 (Japan) */
+	DRIVER( unsquad )	/*  8/1989 (c) 1989 */
+	DRIVER( area88 )	/*  8/1989 (c) 1989 */
+	DRIVER( ffight )	/* 12/1989 (c) (World) */
+	DRIVER( ffightu )	/* 12/1989 (c) (US)    */
+	DRIVER( ffightj )	/* 12/1989 (c) (Japan) */
+	DRIVER( 1941 )		/*  2/1990 (c) 1990 (World) */
+	DRIVER( 1941j )		/*  2/1990 (c) 1990 (Japan) */
+	DRIVER( mercs )		/*  3/ 2/1990 (c) 1990 (World) */
+	DRIVER( mercsu )	/*  3/ 2/1990 (c) 1990 (US)    */
+	DRIVER( mercsj )	/*  3/ 2/1990 (c) 1990 (Japan) */
+	DRIVER( mtwins )	/*  6/19/1990 (c) 1990 (World) */
+	DRIVER( chikij )	/*  6/19/1990 (c) 1990 (Japan) */
+	DRIVER( msword )	/*  7/25/1990 (c) 1990 (World) */
+	DRIVER( mswordu )	/*  7/25/1990 (c) 1990 (US)    */
+	DRIVER( mswordj )	/*  6/23/1990 (c) 1990 (Japan) */
+	DRIVER( cawing )	/* 10/12/1990 (c) 1990 (World) */
+	DRIVER( cawingj )	/* 10/12/1990 (c) 1990 (Japan) */
+	DRIVER( nemo )		/* 11/30/1990 (c) 1990 (World) */
+	DRIVER( nemoj )		/* 11/20/1990 (c) 1990 (Japan) */
+	DRIVER( sf2 )		/*  2/14/1991 (c) 1991 (World) */
+	DRIVER( sf2a )		/*  2/ 6/1991 (c) 1991 (US)    */
+	DRIVER( sf2b )		/*  2/14/1991 (c) 1991 (US)    */
+	DRIVER( sf2e )		/*  2/28/1991 (c) 1991 (US)    */
+	DRIVER( sf2j )		/* 12/10/1991 (c) 1991 (Japan) */
+	DRIVER( sf2jb )		/*  2/14/1991 (c) 1991 (Japan) */
+	DRIVER( 3wonders )	/*  5/20/1991 (c) 1991 (US) */
+	DRIVER( wonder3 )	/*  5/20/1991 (c) 1991 (Japan) */
+	DRIVER( kod )		/*  7/11/1991 (c) 1991 (World) */
+	DRIVER( kodj )		/*  8/ 5/1991 (c) 1991 (Japan) */
+	DRIVER( kodb )		/* bootleg */
+	DRIVER( captcomm )	/* 10/14/1991 (c) 1991 (World) */
+	DRIVER( captcomu )	/*  9/28/1991 (c) 1991 (US)    */
+	DRIVER( captcomj )	/* 12/ 2/1991 (c) 1991 (Japan) */
+	DRIVER( knights )	/* 11/27/1991 (c) 1991 (World) */
+	DRIVER( knightsj )	/* 11/27/1991 (c) 1991 (Japan) */
+	DRIVER( sf2ce )		/*  3/13/1992 (c) 1992 (World) */
+	DRIVER( sf2cea )	/*  3/13/1992 (c) 1992 (US)    */
+	DRIVER( sf2ceb )	/*  5/13/1992 (c) 1992 (US)    */
+	DRIVER( sf2cej )	/*  5/13/1992 (c) 1992 (Japan) */
+	DRIVER( sf2rb )		/* hack */
+	DRIVER( sf2red )	/* hack */
+	DRIVER( sf2accp2 )	/* hack */
+	DRIVER( varth )		/*  6/12/1992 (c) 1992 (World) */
+	DRIVER( varthj )	/*  7/14/1992 (c) 1992 (Japan) */
+	DRIVER( cworld2j )	/*  6/11/1992 (QUIZ 5) (c) 1992 (Japan) */
+	DRIVER( wof )		/* 10/ 2/1992 (c) 1992 (World) (CPS1 + QSound) */
+	DRIVER( wofj )		/* 10/31/1992 (c) 1992 (Japan) (CPS1 + QSound) */
+	DRIVER( sf2t )		/* 12/ 9/1992 (c) 1992 (US)    */
+	DRIVER( sf2tj )		/* 12/ 9/1992 (c) 1992 (Japan) */
+	DRIVER( dino )		/*  2/ 1/1993 (c) 1993 (World) (CPS1 + QSound) */
+	DRIVER( dinoj )		/*  2/ 1/1993 (c) 1993 (Japan) (CPS1 + QSound) */
+	DRIVER( punisher )	/*  4/22/1993 (c) 1993 (World) (CPS1 + QSound) */
+	DRIVER( punishru )	/*  4/22/1993 (c) 1993 (US)    (CPS1 + QSound) */
+	DRIVER( punishrj )	/*  4/22/1993 (c) 1993 (Japan) (CPS1 + QSound) */
+	DRIVER( slammast )	/*  7/13/1993 (c) 1993 (World) (CPS1 + QSound) */
+	DRIVER( mbomberj )	/*  7/13/1993 (c) 1993 (Japan) (CPS1 + QSound) */
+	DRIVER( mbombrd )	/* 12/ 6/1993 (c) 1993 (World) (CPS1 + QSound) */
+	DRIVER( mbombrdj )	/* 12/ 6/1993 (c) 1993 (Japan) (CPS1 + QSound) */
+	DRIVER( pnickj )	/*  6/ 8/1994 (c) 1994 + Compile license (Japan) not listed on Capcom's site */
+	DRIVER( qad )		/*  7/ 1/1992 (c) 1992 (US)    */
+	DRIVER( qadj )		/*  9/21/1994 (c) 1994 (Japan) */
+	DRIVER( qtono2 )	/*  1/23/1995 (c) 1995 (Japan) */
+	DRIVER( pang3 )		/*  5/11/1995 (c) 1995 Mitchell (Japan) not listed on Capcom's site */
+	DRIVER( megaman )	/* 10/ 6/1995 (c) 1995 (Asia)  */
+	DRIVER( rockmanj )	/*  9/22/1995 (c) 1995 (Japan) */
+	DRIVER( sfzch )		/* 10/20/1995 (c) 1995 (Japan) (CPS Changer) */
+
+	/* Capcom CPS2 games */
+	/* list completed by CPS2Shock */
+	/* http://cps2shock.retrogames.com */
+TESTDRIVER( ssf2 )		/* Super Street Fighter 2: The New Challengers (USA 930911) */
+TESTDRIVER( ssf2a )		/* Super Street Fighter 2: The New Challengers (Asia 930911) */
+TESTDRIVER( ssf2j )		/* Super Street Fighter 2: The New Challengers (Japan 930910) */
+TESTDRIVER( ecofe )		/* Eco Fighters (Etc 931203) */
+TESTDRIVER( ddtod )		/* Dungeons & Dragons: Tower of Doom (USA 940113) */
+TESTDRIVER( ddtoda )	/* Dungeons & Dragons: Tower of Doom (Asia 940113) */
+TESTDRIVER( ddtodr1 )	/* Dungeons & Dragons: Tower of Doom (USA 940125) */
+TESTDRIVER( ssf2t )		/* Super Street Fighter 2 Turbo (USA 940223) */
+TESTDRIVER( ssf2xj )	/* Super Street Fighter 2 X: Grand Master Challenge (Japan 940223) */
+TESTDRIVER( avsp )		/* Aliens Vs. Predator (USA 940520) */
+TESTDRIVER( vampj )		/* Vampire: The Night Warriors (Japan 940705) */
+TESTDRIVER( vampa )		/* Vampire: The Night Warriors (Asia 940705) */
+TESTDRIVER( dstlk )		/* DarkStalkers: The Night Warriors (USA 940818) */
+TESTDRIVER( slam2e )	/* Saturday Night Slammasters II: Ring of Destruction (Euro 940902) */
+TESTDRIVER( armwara )	/* Armoured Warriors (Asia 940920) */
+TESTDRIVER( xmcotaj )	/* X-Men: Children of the Atom (Japan 941219) */
+TESTDRIVER( xmcota )	/* X-Men: Children of the Atom (USA 950105) */
+TESTDRIVER( vhuntj )	/* Vampire Hunter: Darkstalkers 2 (Japan 950302) */
+TESTDRIVER( nwarr )		/* Night Warriors: DarkStalkers Revenge (USA 950406) */
+TESTDRIVER( cybotsj )	/* Cyberbots: Full Metal Madness (Japan 950420) */
+TESTDRIVER( sfa )		/* Street Fighter Alpha: The Warriors Dream (USA 950627) */
+TESTDRIVER( sfar1 )		/* Street Fighter Alpha: The Warriors Dream (USA 950727) */
+TESTDRIVER( sfzj )		/* Street Fighter Zero (Japan 950627) */
+TESTDRIVER( sfzjr1 )	/* Street Fighter Zero (Japan 950727) */
+TESTDRIVER( msh )		/* Marvel Super Heroes (USA 951024) */
+TESTDRIVER( 19xx )		/* 19XX: The Battle Against Destiny (USA 951207) */
+TESTDRIVER( ddsom )		/* Dungeons & Dragons 2: Shadow over Mystara (USA 960209) */
+TESTDRIVER( sfz2j )		/* Street Fighter Zero 2 (Japan 960227) */
+TESTDRIVER( spf2xj )	/* Super Puzzle Fighter 2 X (Japan 960531) */
+TESTDRIVER( spf2t )		/* Super Puzzle Fighter 2 Turbo (USA 960620) */
+TESTDRIVER( rckman2j )	/* Rockman 2: The Power Fighters (Japan 960708) */
+TESTDRIVER( sfz2a )		/* Street Fighter Zero 2 Alpha (Japan 960805) */
+						/*  9/1996 Quiz Naneiro Dreams */
+TESTDRIVER( xmvsf )		/* X-Men Vs. Street Fighter (USA 961004) */
+TESTDRIVER( batcirj )	/* Battle Circuit (Japan 970319) */
+TESTDRIVER( batcira )	/* Battle Circuit (Asia 970319) */
+TESTDRIVER( vsav )		/* Vampire Savior: The Lord of Vampire (USA 970519) */
+TESTDRIVER( vsavj )		/* Vampire Savior: The Lord of Vampire (Japan 970519) */
+TESTDRIVER( mshvsf )	/* Marvel Super Heroes Vs. Street Fighter (USA 970625) */
+TESTDRIVER( vhunt2 )	/* Vampire Hunter 2: Darkstalkers Revenge (Japan 970828) */
+TESTDRIVER( sgemf )		/* Super Gem Fighter Mini Mix (USA 970904) */
+TESTDRIVER( pfghtj )	/* Pocket Fighter (Japan 970904) */
+TESTDRIVER( vsav2 )		/* Vampire Savior 2: The Lord of Vampire (Japan 970913) */
+TESTDRIVER( mvsc )		/* Marvel Super Heroes vs. Capcom: Clash of Super Heroes (USA 980123) */
+TESTDRIVER( sfa3 )		/* Street Fighter Alpha 3 (USA 980629) */
+						/* 1999 Giga Wing */
+						/* Gulum Pa! */
+
+	/* Capcom CPS3 games */
+	/* 10/1996 Warzard */
+	/*  2/1997 Street Fighter III - New Generation */
+	/* ???? Jojo's Bizarre Adventure */
+	/* ???? Street Fighter 3: Second Impact ~giant attack~ */
+	/* ???? Street Fighter 3: Third Strike ~fight to the finish~ */
+
+	/* Mitchell games */
+	DRIVER( mgakuen )	/* (c) 1988 Yuga */
+	DRIVER( mgakuen2 )	/* (c) 1989 Face */
+	DRIVER( pkladies )	/* (c) 1989 Mitchell */
+	DRIVER( dokaben )	/*  3/1989 (c) 1989 Capcom (Japan) */
+	/*  8/1989 Dokaben 2 (baseball) */
+	DRIVER( pang )		/* (c) 1989 Mitchell (World) */
+	DRIVER( pangb )		/* bootleg */
+	DRIVER( bbros )		/* (c) 1989 Capcom (US) not listed on Capcom's site */
+	DRIVER( pompingw )	/* (c) 1989 Mitchell (Japan) */
+	DRIVER( cbasebal )	/* 10/1989 (c) 1989 Capcom (Japan) (different hardware) */
+	DRIVER( cworld )	/* 11/1989 (QUIZ 1) (c) 1989 Capcom */
+	DRIVER( hatena )	/*  2/28/1990 (QUIZ 2) (c) 1990 Capcom (Japan) */
+	DRIVER( spang )		/*  9/14/1990 (c) 1990 Mitchell (World) */
+	DRIVER( sbbros )	/* 10/ 1/1990 (c) 1990 Mitchell + Capcom (US) not listed on Capcom's site */
+	DRIVER( marukin )	/* 10/17/1990 (c) 1990 Yuga (Japan) */
+	DRIVER( qtono1 )	/* 12/25/1990 (QUIZ 3) (c) 1991 Capcom (Japan) */
+	/*  4/1991 Ashita Tenki ni Naare (golf) */
+	DRIVER( qsangoku )	/*  6/ 7/1991 (QUIZ 4) (c) 1991 Capcom (Japan) */
+	DRIVER( block )		/*  9/10/1991 (c) 1991 Capcom (World) */
+	DRIVER( blockj )	/*  9/10/1991 (c) 1991 Capcom (Japan) */
+	DRIVER( blockbl )	/* bootleg */
+
+	/* Incredible Technologies games */
+	DRIVER( capbowl )	/* (c) 1988 Incredible Technologies */
+	DRIVER( capbowl2 )	/* (c) 1988 Incredible Technologies */
+	DRIVER( clbowl )	/* (c) 1989 Incredible Technologies */
+	DRIVER( bowlrama )	/* (c) 1991 P & P Marketing */
+/*
+The Incredible Technologies game list
+http://www.itsgames.com/it/CorporateProfile/corporateprofile_main.htm
+
+ShuffleShot - (Incredible Technologies, Inc.)
+Peter Jacobsen's Golden Tee '97 - (Incredible Technologies, Inc.)
+World Class Bowling - (Incredible Technologies, Inc.)
+Peter Jacobsen's Golden Tee 3D Golf - (Incredible Technologies, Inc.)
+Street Fighter - "The Movie" (Capcom)
+PAIRS - (Strata)
+BloodStorm - (Strata)
+Driver's Edge - (Strata)
+NFL Hard Yardage - (Strata)
+Time Killers - (Strata)
+Neck 'n' Neck - (Bundra Games)
+Ninja Clowns - (Strata)
+Rim Rockin' Basketball - (Strata)
+Arlington Horse Racing - (Strata)
+Dyno Bop - (Grand Products)
+Poker Dice - (Strata)
+Peggle - (Strata)
+Slick Shot - (Grand Products)
+Golden Tee Golf II - (Strata)
+Hot Shots Tennis - (Strata)
+Strata Bowling - (Strata)
+Golden Tee Golf I - (Strata)
+Capcom Bowling - (Strata)
+*/
+
+	/* Leland games */
+TESTDRIVER( mayhem )	/* (c) 1985 Cinematronics */
+TESTDRIVER( wseries )	/* (c) 1985 Cinematronics Inc. */
+TESTDRIVER( dangerz )	/* (c) 1986 Cinematronics USA Inc. */
+TESTDRIVER( basebal2 )	/* (c) 1987 Cinematronics Inc. */
+TESTDRIVER( dblplay )	/* (c) 1987 Tradewest / The Leland Corp. */
+TESTDRIVER( teamqb )	/* (c) 1988 Leland Corp. */
+TESTDRIVER( strkzone )	/* (c) 1988 The Leland Corporation */
+TESTDRIVER( offroad )	/* (c) 1989 Leland Corp. */
+TESTDRIVER( offroadt )
+TESTDRIVER( pigout )	/* (c) 1990 The Leland Corporation */
+TESTDRIVER( pigoutj )	/* (c) 1990 The Leland Corporation */
+TESTDRIVER( redlin2p )
+TESTDRIVER( viper )
+TESTDRIVER( aafb )
+TESTDRIVER( aafb2p )
+TESTDRIVER( aafbu )
+TESTDRIVER( alleymas )
+TESTDRIVER( cerberus )
+TESTDRIVER( ataxx )
+TESTDRIVER( ataxxa )
+TESTDRIVER( indyheat )
+TESTDRIVER( wsf )
+
+	/* Gremlin 8080 games */
+	/* the numbers listed are the range of ROM part numbers */
+	DRIVER( blockade )	/* 1-4 [1977 Gremlin] */
+	DRIVER( comotion )	/* 5-7 [1977 Gremlin] */
+	DRIVER( hustle )	/* 16-21 [1977 Gremlin] */
+	DRIVER( blasto )	/* [1978 Gremlin] */
+
+	/* Gremlin/Sega "VIC dual game board" games */
+	/* the numbers listed are the range of ROM part numbers */
+	DRIVER( depthch )	/* 50-55 [1977 Gremlin?] */
+	DRIVER( safari )	/* 57-66 [1977 Gremlin?] */
+	DRIVER( frogs )		/* 112-119 [1978 Gremlin?] */
+	DRIVER( sspaceat )	/* 155-162 (c) */
+	DRIVER( sspacatc )	/* 139-146 (c) */
+	DRIVER( headon )	/* 163-167/192-193 (c) Gremlin */
+	DRIVER( headonb )	/* 163-167/192-193 (c) Gremlin */
+	DRIVER( headon2 )	/* ???-??? (c) 1979 Sega */
+	/* ???-??? Fortress */
+	/* ???-??? Gee Bee */
+	/* 255-270  Head On 2 / Deep Scan */
+	DRIVER( invho2 )	/* 271-286 (c) 1979 Sega */
+	DRIVER( samurai )	/* 289-302 + upgrades (c) 1980 Sega */
+	DRIVER( invinco )	/* 310-318 (c) 1979 Sega */
+	DRIVER( invds )		/* 367-382 (c) 1979 Sega */
+	DRIVER( tranqgun )	/* 413-428 (c) 1980 Sega */
+	/* 450-465  Tranquilizer Gun (different version?) */
+	/* ???-??? Car Hunt / Deep Scan */
+	DRIVER( spacetrk )	/* 630-645 (c) 1980 Sega */
+	DRIVER( sptrekct )	/* (c) 1980 Sega */
+	DRIVER( carnival )	/* 651-666 (c) 1980 Sega */
+	DRIVER( carnvckt )	/* 501-516 (c) 1980 Sega */
+	DRIVER( digger )	/* 684-691 no copyright notice */
+	DRIVER( pulsar )	/* 790-805 (c) 1981 Sega */
+	DRIVER( heiankyo )	/* (c) [1979?] Denki Onkyo */
+
+	/* Sega G-80 vector games */
+	DRIVER( spacfury )	/* (c) 1981 */
+	DRIVER( spacfura )	/* no copyright notice */
+	DRIVER( zektor )	/* (c) 1982 */
+	DRIVER( tacscan )	/* (c) */
+	DRIVER( elim2 )		/* (c) 1981 Gremlin */
+	DRIVER( elim2a )	/* (c) 1981 Gremlin */
+	DRIVER( elim4 )		/* (c) 1981 Gremlin */
+	DRIVER( startrek )	/* (c) 1982 */
+
+	/* Sega G-80 raster games */
+	DRIVER( astrob )	/* (c) 1981 */
+	DRIVER( astrob1 )	/* (c) 1981 */
+	DRIVER( 005 )		/* (c) 1981 */
+	DRIVER( monsterb )	/* (c) 1982 */
+	DRIVER( spaceod )	/* (c) 1981 */
+	DRIVER( pignewt )	/* (c) 1983 */
+	DRIVER( pignewta )	/* (c) 1983 */
+	DRIVER( sindbadm )	/* 834-5244 (c) 1983 Sega */
+
+	/* Sega "Zaxxon hardware" games */
+	DRIVER( zaxxon )	/* (c) 1982 */
+	DRIVER( zaxxon2 )	/* (c) 1982 */
+	DRIVER( zaxxonb )	/* bootleg */
+	DRIVER( szaxxon )	/* (c) 1982 */
+	DRIVER( futspy )	/* (c) 1984 */
+	DRIVER( razmataz )	/* modified 834-0213, 834-0214 (c) 1983 */
+	DRIVER( congo )		/* 605-5167 (c) 1983 */
+	DRIVER( tiptop )	/* 605-5167 (c) 1983 */
+
+	/* Sega System 1 / System 2 games */
+	DRIVER( starjack )	/* 834-5191 (c) 1983 (S1) */
+	DRIVER( starjacs )	/* (c) 1983 Stern (S1) */
+	DRIVER( regulus )	/* 834-5328(c) 1983 (S1) */
+	DRIVER( regulusu )	/* 834-5328(c) 1983 (S1) */
+	DRIVER( upndown )	/* (c) 1983 (S1) */
+	DRIVER( mrviking )	/* 834-5383 (c) 1984 (S1) */
+	DRIVER( mrvikinj )	/* 834-5383 (c) 1984 (S1) */
+	DRIVER( swat )		/* 834-5388 (c) 1984 Coreland / Sega (S1) */
+	DRIVER( flicky )	/* (c) 1984 (S1) */
+	DRIVER( flicky2 )	/* (c) 1984 (S1) */
+	/* Water Match (S1) */
+	DRIVER( bullfgtj )	/* 834-5478 (c) 1984 Sega / Coreland (S1) */
+	DRIVER( pitfall2 )	/* 834-5627 [1985?] reprogrammed, (c) 1984 Activision (S1) */
+	DRIVER( pitfallu )	/* 834-5627 [1985?] reprogrammed, (c) 1984 Activision (S1) */
+	DRIVER( seganinj )	/* 834-5677 (c) 1985 (S1) */
+	DRIVER( seganinu )	/* 834-5677 (c) 1985 (S1) */
+	DRIVER( nprinces )	/* 834-5677 (c) 1985 (S1) */
+	DRIVER( nprincsu )	/* 834-5677 (c) 1985 (S1) */
+	DRIVER( nprincsb )	/* bootleg? (S1) */
+	DRIVER( imsorry )	/* 834-5707 (c) 1985 Coreland / Sega (S1) */
+	DRIVER( imsorryj )	/* 834-5707 (c) 1985 Coreland / Sega (S1) */
+	DRIVER( teddybb )	/* 834-5712 (c) 1985 (S1) */
+	DRIVER( hvymetal )	/* 834-5745 (c) 1985 (S2?) */
+	DRIVER( myhero )	/* 834-5755 (c) 1985 (S1) */
+	DRIVER( myheroj )	/* 834-5755 (c) 1985 Coreland / Sega (S1) */
+	DRIVER( myherok )	/* 834-5755 (c) 1985 Coreland / Sega (S1) */
+	DRIVER( shtngmst )	/* 834-5719/5720 (c) 1985 (S2) */
+	DRIVER( chplft )	/* 834-5795 (c) 1985, (c) 1982 Dan Gorlin (S2) */
+	DRIVER( chplftb )	/* 834-5795 (c) 1985, (c) 1982 Dan Gorlin (S2) */
+	DRIVER( chplftbl )	/* bootleg (S2) */
+	DRIVER( 4dwarrio )	/* 834-5918 (c) 1985 Coreland / Sega (S1) */
+	DRIVER( brain )		/* (c) 1986 Coreland / Sega (S2?) */
+	DRIVER( wboy )		/* 834-5984 (c) 1986 + Escape license (S1) */
+	DRIVER( wboy2 )		/* 834-5984 (c) 1986 + Escape license (S1) */
+	DRIVER( wboy3 )
+	DRIVER( wboy4 )		/* 834-5984 (c) 1986 + Escape license (S1) */
+	DRIVER( wboyu )		/* 834-5753 (? maybe a conversion) (c) 1986 + Escape license (S1) */
+	DRIVER( wboy4u )	/* 834-5984 (c) 1986 + Escape license (S1) */
+	DRIVER( wbdeluxe )	/* (c) 1986 + Escape license (S1) */
+	DRIVER( gardia )	/* 834-6119 (S2?) */
+	DRIVER( gardiab )	/* bootleg */
+	DRIVER( blockgal )	/* 834-6303 (S1) */
+	DRIVER( blckgalb )	/* bootleg */
+	DRIVER( tokisens )	/* (c) 1987 (from a bootleg board) (S2) */
+	DRIVER( wbml )		/* bootleg (S2) */
+	DRIVER( wbmlj )		/* (c) 1987 Sega/Westone (S2) */
+	DRIVER( wbmlj2 )	/* (c) 1987 Sega/Westone (S2) */
+	DRIVER( wbmlju )	/* bootleg? (S2) */
+	DRIVER( dakkochn )	/* 836-6483? (S2) */
+	DRIVER( ufosensi )	/* 834-6659 (S2) */
+/*
+other System 1 / System 2 games:
+
+WarBall
+Rafflesia
+Sanrin Sanchan
+DokiDoki Penguin Land *not confirmed
+*/
+
+	/* Sega System E games (Master System hardware) */
+/*
+???          834-5492 (??? not sure it's System E)
+Transformer  834-5803 (c) 1986
+Opa Opa
+Fantasy Zone 2
+Hang-On Jr.
+(more?)
+*/
+
+	/* other Sega 8-bit games */
+	DRIVER( turbo )		/* (c) 1981 Sega */
+	DRIVER( turboa )	/* (c) 1981 Sega */
+	DRIVER( turbob )	/* (c) 1981 Sega */
+TESTDRIVER( kopunch )	/* 834-0103 (c) 1981 Sega */
+	DRIVER( suprloco )	/* (c) 1982 Sega */
+	DRIVER( champbas )	/* (c) 1983 Sega */
+	DRIVER( champbb2 )
+	DRIVER( appoooh )	/* (c) 1984 Sega */
+	DRIVER( bankp )		/* (c) 1984 Sega */
+	DRIVER( dotrikun )	/* cabinet test board */
+	DRIVER( dotriku2 )	/* cabinet test board */
+
+	/* Sega System 16 games */
+	// Not working
+	DRIVER( alexkidd )	/* (c) 1986 (protected) */
+	DRIVER( aliensya )	/* (c) 1987 (protected) */
+	DRIVER( aliensyb )	/* (c) 1987 (protected) */
+	DRIVER( aliensyj )	/* (c) 1987 (protected. Japan) */
+	DRIVER( astorm )	/* (c) 1990 (protected) */
+	DRIVER( astorm2p )	/* (c) 1990 (protected 2 Players) */
+	DRIVER( auraila )	/* (c) 1990 Sega / Westone (protected) */
+	DRIVER( bayrouta )	/* (c) 1989 (protected) */
+	DRIVER( bayrtbl1 )	/* (c) 1989 (protected) (bootleg) */
+	DRIVER( bayrtbl2 )	/* (c) 1989 (protected) (bootleg) */
+	DRIVER( enduror )	/* (c) 1985 (protected) */
+	DRIVER( eswat )		/* (c) 1989 (protected) */
+	DRIVER( fpoint )	/* (c) 1989 (protected) */
+	DRIVER( goldnaxb )	/* (c) 1989 (protected) */
+	DRIVER( goldnaxc )	/* (c) 1989 (protected) */
+	DRIVER( goldnaxj )	/* (c) 1989 (protected. Japan) */
+	DRIVER( jyuohki )	/* (c) 1988 (protected. Altered Beast Japan) */
+	DRIVER( moonwalk )	/* (c) 1990 (protected) */
+	DRIVER( moonwlka )	/* (c) 1990 (protected) */
+	DRIVER( passsht )	/* (protected) */
+	DRIVER( sdioj )		/* (c) 1987 (protected. Japan) */
+	DRIVER( shangon )	/* (c) 1992 (protected) */
+	DRIVER( shinobia )	/* (c) 1987 (protected) */
+	DRIVER( shinobib )	/* (c) 1987 (protected) */
+	DRIVER( tetris )	/* (c) 1988 (protected) */
+	DRIVER( tetrisa )	/* (c) 1988 (protected) */
+	DRIVER( wb3a )		/* (c) 1988 Sega / Westone (protected) */
+
+TESTDRIVER( aceattac )	/* (protected) */
+TESTDRIVER( aburner )	/* */
+TESTDRIVER( aburner2 )  /* */
+TESTDRIVER( afighter )	/* (protected) */
+TESTDRIVER( bloxeed )	/* (protected) */
+TESTDRIVER( cltchitr )	/* (protected) */
+TESTDRIVER( cotton )	/* (protected) */
+TESTDRIVER( cottona )	/* (protected) */
+TESTDRIVER( ddcrew )	/* (protected) */
+TESTDRIVER( dunkshot )	/* (protected) */
+TESTDRIVER( exctleag )  /* (protected) */
+TESTDRIVER( lghost )	/* (protected) */
+TESTDRIVER( loffire )	/* (protected) */
+TESTDRIVER( mvp )		/* (protected) */
+TESTDRIVER( ryukyu )	/* (protected) */
+TESTDRIVER( suprleag )  /* (protected) */
+TESTDRIVER( thndrbld )	/* (protected) */
+TESTDRIVER( thndrbdj )  /* (protected?) */
+TESTDRIVER( toutrun )	/* (protected) */
+TESTDRIVER( toutruna )	/* (protected) */
+
+	// Working
+	DRIVER( alexkida )	/* (c) 1986 */
+	DRIVER( aliensyn )	/* (c) 1987 */
+	DRIVER( altbeas2 )	/* (c) 1988 */
+	DRIVER( altbeast )	/* (c) 1988 */
+	DRIVER( astormbl )	/* bootleg */
+	DRIVER( atomicp )	/* (c) 1990 Philko */
+	DRIVER( aurail )	/* (c) 1990 Sega / Westone */
+	DRIVER( bayroute )	/* (c) 1989 */
+	DRIVER( bodyslam )	/* (c) 1986 */
+	DRIVER( dduxbl )	/* (c) 1989 (Datsu bootleg) */
+	DRIVER( dumpmtmt )	/* (c) 1986 (Japan) */
+	DRIVER( endurob2 )	/* (c) 1985 (Beta bootleg) */
+	DRIVER( endurobl )	/* (c) 1985 (Herb bootleg) */
+	DRIVER( eswatbl )	/* (c) 1989 (but bootleg) */
+	DRIVER( fantzone )	/* (c) 1986 */
+	DRIVER( fantzono )	/* (c) 1986 */
+	DRIVER( fpointbl )	/* (c) 1989 (Datsu bootleg) */
+	DRIVER( goldnabl )	/* (c) 1989 (bootleg) */
+	DRIVER( goldnaxa )	/* (c) 1989 */
+	DRIVER( goldnaxe )	/* (c) 1989 */
+	DRIVER( hangon )	/* (c) 1985 */
+	DRIVER( hwchamp )	/* (c) 1987 */
+	DRIVER( mjleague )	/* (c) 1985 */
+	DRIVER( moonwlkb )	/* bootleg */
+	DRIVER( outrun )	/* (c) 1986 (bootleg)*/
+	DRIVER( outruna )	/* (c) 1986 (bootleg) */
+	DRIVER( outrunb )	/* (c) 1986 (protected beta bootleg) */
+	DRIVER( passht4b )	/* bootleg */
+	DRIVER( passshtb )	/* bootleg */
+	DRIVER( quartet )	/* (c) 1986 */
+	DRIVER( quartet2 )	/* (c) 1986 */
+	DRIVER( quartetj )	/* (c) 1986 */
+	DRIVER( riotcity )	/* (c) 1991 Sega / Westone */
+	DRIVER( sdi )		/* (c) 1987 */
+	DRIVER( shangonb )	/* (c) 1992 (but bootleg) */
+	DRIVER( sharrier )	/* (c) 1985 */
+	DRIVER( shdancbl )	/* (c) 1989 (but bootleg) */
+	DRIVER( shdancer )	/* (c) 1989 */
+	DRIVER( shdancrj )	/* (c) 1989 */
+	DRIVER( shinobi )	/* (c) 1987 */
+	DRIVER( shinobl )	/* (c) 1987 (but bootleg) */
+	DRIVER( tetrisbl )	/* (c) 1988 (but bootleg) */
+	DRIVER( timscanr )	/* (c) 1987 */
+	DRIVER( toryumon )	/* (c) 1995 */
+	DRIVER( tturf )		/* (c) 1989 Sega / Sunsoft */
+	DRIVER( tturfbl )	/* (c) 1989 (Datsu bootleg) */
+	DRIVER( tturfu )	/* (c) 1989 Sega / Sunsoft */
+	DRIVER( wb3 )		/* (c) 1988 Sega / Westone */
+	DRIVER( wb3bl )		/* (c) 1988 Sega / Westone (but bootleg) */
+	DRIVER( wrestwar )	/* (c) 1989 */
+
+	/* Data East "Burger Time hardware" games */
+	DRIVER( lnc )		/* (c) 1981 */
+	DRIVER( zoar )		/* (c) 1982 */
+	DRIVER( btime )		/* (c) 1982 */
+	DRIVER( btime2 )	/* (c) 1982 */
+	DRIVER( btimem )	/* (c) 1982 + Midway */
+	DRIVER( wtennis )	/* bootleg 1982 */
+	DRIVER( brubber )	/* (c) 1982 */
+	DRIVER( bnj )		/* (c) 1982 + Midway */
+	DRIVER( caractn )	/* bootleg */
+	DRIVER( disco )		/* (c) 1982 */
+	DRIVER( mmonkey )	/* (c) 1982 Technos Japan + Roller Tron */
+	/* cassette system */
+TESTDRIVER( decocass )
+	DRIVER( cookrace )	/* bootleg */
+
+	/* other Data East games */
+	DRIVER( astrof )	/* (c) [1980?] */
+	DRIVER( astrof2 )	/* (c) [1980?] */
+	DRIVER( astrof3 )	/* (c) [1980?] */
+	DRIVER( tomahawk )	/* (c) [1980?] */
+	DRIVER( tomahaw5 )	/* (c) [1980?] */
+	DRIVER( kchamp )	/* (c) 1984 Data East USA (US) */
+	DRIVER( karatedo )	/* (c) 1984 Data East Corporation (Japan) */
+	DRIVER( kchampvs )	/* (c) 1984 Data East USA (US) */
+	DRIVER( karatevs )	/* (c) 1984 Data East Corporation (Japan) */
+	DRIVER( firetrap )	/* (c) 1986 */
+	DRIVER( firetpbl )	/* bootleg */
+	DRIVER( brkthru )	/* (c) 1986 Data East USA (US) */
+	DRIVER( brkthruj )	/* (c) 1986 Data East Corporation (Japan) */
+	DRIVER( darwin )	/* (c) 1986 Data East Corporation (Japan) */
+	DRIVER( shootout )	/* (c) 1985 Data East USA (US) */
+	DRIVER( sidepckt )	/* (c) 1986 Data East Corporation */
+	DRIVER( sidepctj )	/* (c) 1986 Data East Corporation */
+	DRIVER( sidepctb )	/* bootleg */
+	DRIVER( exprraid )	/* (c) 1986 Data East USA (US) */
+	DRIVER( wexpress )	/* (c) 1986 Data East Corporation (World?) */
+	DRIVER( wexpresb )	/* bootleg */
+	DRIVER( pcktgal )	/* (c) 1987 Data East Corporation (Japan) */
+	DRIVER( pcktgalb )	/* bootleg */
+	DRIVER( pcktgal2 )	/* (c) 1989 Data East Corporation (World?) */
+	DRIVER( spool3 )	/* (c) 1989 Data East Corporation (World?) */
+	DRIVER( spool3i )	/* (c) 1990 Data East Corporation + I-Vics license */
+	DRIVER( actfancr )	/* (c) 1989 Data East Corporation (World) */
+	DRIVER( actfancj )	/* (c) 1989 Data East Corporation (Japan) */
+	DRIVER( triothep )	/* (c) 1989 Data East Corporation (Japan) */
+
+	/* Data East 8-bit games */
+	DRIVER( lastmiss )	/* (c) 1986 Data East USA (US) */
+	DRIVER( lastmss2 )	/* (c) 1986 Data East USA (US) */
+	DRIVER( shackled )	/* (c) 1986 Data East USA (US) */
+	DRIVER( breywood )	/* (c) 1986 Data East Corporation (Japan) */
+	DRIVER( csilver )	/* (c) 1987 Data East Corporation (Japan) */
+	DRIVER( ghostb )	/* (c) 1987 Data East USA (US) */
+	DRIVER( ghostb3 )	/* (c) 1987 Data East USA (US) */
+	DRIVER( meikyuh )	/* (c) 1987 Data East Corporation (Japan) */
+	DRIVER( srdarwin )	/* (c) 1987 Data East Corporation (Japan) */
+	DRIVER( gondo )		/* (c) 1987 Data East USA (US) */
+	DRIVER( makyosen )	/* (c) 1987 Data East Corporation (Japan) */
+	DRIVER( garyoret )	/* (c) 1987 Data East Corporation (Japan) */
+	DRIVER( cobracom )	/* (c) 1988 Data East Corporation (Japan) */
+	DRIVER( oscar )		/* (c) 1988 Data East USA (US) */
+	DRIVER( oscarj )	/* (c) 1987 Data East Corporation (Japan) */
+
+	/* Data East 16-bit games */
+	DRIVER( karnov )	/* (c) 1987 Data East USA (US) */
+	DRIVER( karnovj )	/* (c) 1987 Data East Corporation (Japan) */
+TESTDRIVER( wndrplnt )	/* (c) 1987 Data East Corporation (Japan) */
+	DRIVER( chelnov )	/* (c) 1988 Data East USA (US) */
+	DRIVER( chelnovj )	/* (c) 1988 Data East Corporation (Japan) */
+/* the following ones all run on similar hardware */
+	DRIVER( hbarrel )	/* (c) 1987 Data East USA (US) */
+	DRIVER( hbarrelw )	/* (c) 1987 Data East Corporation (World) */
+	DRIVER( baddudes )	/* (c) 1988 Data East USA (US) */
+	DRIVER( drgninja )	/* (c) 1988 Data East Corporation (Japan) */
+TESTDRIVER( birdtry )	/* (c) 1988 Data East Corporation (Japan) */
+	DRIVER( robocop )	/* (c) 1988 Data East Corporation (World) */
+	DRIVER( robocopu )	/* (c) 1988 Data East USA (US) */
+	DRIVER( robocpu0 )	/* (c) 1988 Data East USA (US) */
+	DRIVER( robocopb )	/* bootleg */
+	DRIVER( hippodrm )	/* (c) 1989 Data East USA (US) */
+	DRIVER( ffantasy )	/* (c) 1989 Data East Corporation (Japan) */
+	DRIVER( slyspy )	/* (c) 1989 Data East USA (US) */
+	DRIVER( slyspy2 )	/* (c) 1989 Data East USA (US) */
+	DRIVER( secretag )	/* (c) 1989 Data East Corporation (World) */
+TESTDRIVER( secretab )	/* bootleg */
+	DRIVER( midres )	/* (c) 1989 Data East Corporation (World) */
+	DRIVER( midresu )	/* (c) 1989 Data East USA (US) */
+	DRIVER( midresj )	/* (c) 1989 Data East Corporation (Japan) */
+	DRIVER( bouldash )	/* (c) 1990 Data East Corporation */
+/* end of similar hardware */
+	DRIVER( stadhero )	/* (c) 1988 Data East Corporation (Japan) */
+	DRIVER( madmotor )	/* (c) [1989] Mitchell */
+	/* All these games have a unique code stamped on the mask roms */
+	DRIVER( vaportra )	/* MAA (c) 1989 Data East Corporation (US) */
+	DRIVER( kuhga )		/* MAA (c) 1989 Data East Corporation (Japan) */
+	DRIVER( cbuster )	/* MAB (c) 1990 Data East Corporation (World) */
+	DRIVER( cbusterw )	/* MAB (c) 1990 Data East Corporation (World) */
+	DRIVER( cbusterj )	/* MAB (c) 1990 Data East Corporation (Japan) */
+	DRIVER( twocrude )	/* MAB (c) 1990 Data East USA (US) */
+	DRIVER( darkseal )	/* MAC (c) 1990 Data East Corporation (World) */
+	DRIVER( darksea1 )	/* MAC (c) 1990 Data East Corporation (World) */
+	DRIVER( darkseaj )	/* MAC (c) 1990 Data East Corporation (Japan) */
+	DRIVER( gatedoom )	/* MAC (c) 1990 Data East Corporation (US) */
+	DRIVER( gatedom1 )	/* MAC (c) 1990 Data East Corporation (US) */
+TESTDRIVER( edrandy )	/* MAD (c) 1990 Data East Corporation (World) */
+TESTDRIVER( edrandyj )	/* MAD (c) 1990 Data East Corporation (Japan) */
+	DRIVER( supbtime )	/* MAE (c) 1990 Data East Corporation (Japan) */
+	/* Mutant Fighter/Death Brade MAF (c) 1991 */
+	DRIVER( cninja )	/* MAG (c) 1991 Data East Corporation (World) */
+	DRIVER( cninja0 )	/* MAG (c) 1991 Data East Corporation (World) */
+	DRIVER( cninjau )	/* MAG (c) 1991 Data East Corporation (US) */
+	DRIVER( joemac )	/* MAG (c) 1991 Data East Corporation (Japan) */
+	DRIVER( stoneage )	/* bootleg */
+	/* Robocop 2           MAH (c) 1991 */
+	/* Desert Assault/Thunderzone MAJ (c) 1991 */
+	/* Rohga Armour Attack/Wolf Fang MAM (c) 1991 */
+	/* Captain America     MAN (c) 1991 */
+	DRIVER( tumblep )	/* MAP (c) 1991 Data East Corporation (World) */
+	DRIVER( tumblepb )	/* bootleg */
+	DRIVER( tumblep2 )	/* bootleg */
+	/* Dragon Gun/Dragoon  MAR (c) 1992 */
+	/* Wizard's Fire       MAS (c) 1992 */
+TESTDRIVER( funkyjet )	/* MAT (c) 1992 Mitchell */
+	/* Diet GoGo      	   MAY (c) 1993 */
+ 	/* Fighter's History   MBF (c) 1993 */
+	/* Joe & Mac Return    MBN (c) 1994 */
+	/* Chain Reaction      MCC (c) 1994 */
+
+	/* Tehkan / Tecmo games (Tehkan became Tecmo in 1986) */
+	DRIVER( senjyo )	/* (c) 1983 Tehkan */
+	DRIVER( starforc )	/* (c) 1984 Tehkan */
+	DRIVER( starfore )	/* (c) 1984 Tehkan */
+	DRIVER( megaforc )	/* (c) 1985 Tehkan + Video Ware license */
+	DRIVER( baluba )	/* (c) 1986 Able Corp. */
+	DRIVER( bombjack )	/* (c) 1984 Tehkan */
+	DRIVER( bombjac2 )	/* (c) 1984 Tehkan */
+	DRIVER( pbaction )	/* (c) 1985 Tehkan */
+	DRIVER( pbactio2 )	/* (c) 1985 Tehkan */
+	DRIVER( pontoon )	/* 6011 - (c) 1985 Tehkan */
+	DRIVER( tehkanwc )	/* (c) 1985 Tehkan */
+	DRIVER( gridiron )	/* (c) 1985 Tehkan */
+	DRIVER( teedoff )	/* 6102 - (c) 1986 Tecmo */
+	DRIVER( solomon )	/* (c) 1986 Tecmo */
+	DRIVER( rygar )		/* 6002 - (c) 1986 Tecmo */
+	DRIVER( rygar2 )	/* 6002 - (c) 1986 Tecmo */
+	DRIVER( rygarj )	/* 6002 - (c) 1986 Tecmo */
+	DRIVER( gemini )	/* (c) 1987 Tecmo */
+	DRIVER( silkworm )	/* 6217 - (c) 1988 Tecmo */
+	DRIVER( silkwrm2 )	/* 6217 - (c) 1988 Tecmo */
+	DRIVER( gaiden )	/* 6215 - (c) 1988 Tecmo */
+	DRIVER( shadoww )	/* 6215 - (c) 1988 Tecmo */
+	DRIVER( tknight )	/* (c) 1989 Tecmo */
+	DRIVER( wildfang )	/* (c) 1989 Tecmo */
+	DRIVER( wc90 )		/* (c) 1989 Tecmo */
+	DRIVER( wc90b )		/* bootleg */
+
+/* Other Tehkan games:
+6009 Tank Busters
+*/
+
+	/* Konami bitmap games */
+	DRIVER( tutankhm )	/* GX350 (c) 1982 Konami */
+	DRIVER( tutankst )	/* GX350 (c) 1982 Stern */
+	DRIVER( junofrst )	/* GX310 (c) 1983 Konami */
+
+	/* Konami games */
+	DRIVER( pooyan )	/* GX320 (c) 1982 */
+	DRIVER( pooyans )	/* GX320 (c) 1982 Stern */
+	DRIVER( pootan )	/* bootleg */
+	DRIVER( timeplt )	/* GX393 (c) 1982 */
+	DRIVER( timepltc )	/* GX393 (c) 1982 + Centuri license*/
+	DRIVER( spaceplt )	/* bootleg */
+	DRIVER( psurge )	/* (c) 1988 unknown (NOT Konami) */
+	DRIVER( megazone )	/* GX319 (c) 1983 */
+	DRIVER( megaznik )	/* GX319 (c) 1983 + Interlogic / Kosuka */
+	DRIVER( pandoras )	/* GX328 (c) 1984 + Interlogic */
+	DRIVER( gyruss )	/* GX347 (c) 1983 */
+	DRIVER( gyrussce )	/* GX347 (c) 1983 + Centuri license */
+	DRIVER( venus )		/* bootleg */
+	DRIVER( trackfld )	/* GX361 (c) 1983 */
+	DRIVER( trackflc )	/* GX361 (c) 1983 + Centuri license */
+	DRIVER( hyprolym )	/* GX361 (c) 1983 */
+	DRIVER( hyprolyb )	/* bootleg */
+	DRIVER( rocnrope )	/* GX364 (c) 1983 */
+	DRIVER( rocnropk )	/* GX364 (c) 1983 + Kosuka */
+	DRIVER( circusc )	/* GX380 (c) 1984 */
+	DRIVER( circusc2 )	/* GX380 (c) 1984 */
+	DRIVER( circuscc )	/* GX380 (c) 1984 + Centuri license */
+	DRIVER( circusce )	/* GX380 (c) 1984 + Centuri license */
+	DRIVER( tp84 )		/* GX388 (c) 1984 */
+	DRIVER( tp84a )		/* GX388 (c) 1984 */
+	DRIVER( hyperspt )	/* GX330 (c) 1984 + Centuri */
+	DRIVER( hpolym84 )	/* GX330 (c) 1984 */
+	DRIVER( sbasketb )	/* GX405 (c) 1984 */
+	DRIVER( mikie )		/* GX469 (c) 1984 */
+	DRIVER( mikiej )	/* GX469 (c) 1984 */
+	DRIVER( mikiehs )	/* GX469 (c) 1984 */
+	DRIVER( roadf )		/* GX461 (c) 1984 */
+	DRIVER( roadf2 )	/* GX461 (c) 1984 */
+	DRIVER( yiear )		/* GX407 (c) 1985 */
+	DRIVER( yiear2 )	/* GX407 (c) 1985 */
+	DRIVER( kicker )	/* GX477 (c) 1985 */
+	DRIVER( shaolins )	/* GX477 (c) 1985 */
+	DRIVER( pingpong )	/* GX555 (c) 1985 */
+	DRIVER( gberet )	/* GX577 (c) 1985 */
+	DRIVER( rushatck )	/* GX577 (c) 1985 */
+	DRIVER( gberetb )	/* bootleg on different hardware */
+	DRIVER( mrgoemon )	/* GX621 (c) 1986 (Japan) */
+	DRIVER( jailbrek )	/* GX507 (c) 1986 */
+	DRIVER( finalizr )	/* GX523 (c) 1985 */
+	DRIVER( finalizb )	/* bootleg */
+	DRIVER( ironhors )	/* GX560 (c) 1986 */
+	DRIVER( dairesya )	/* GX560 (c) 1986 (Japan) */
+	DRIVER( farwest )
+	DRIVER( jackal )	/* GX631 (c) 1986 (World) */
+	DRIVER( topgunr )	/* GX631 (c) 1986 (US) */
+	DRIVER( jackalj )	/* GX631 (c) 1986 (Japan) */
+	DRIVER( topgunbl )	/* bootleg */
+	DRIVER( ddribble )	/* GX690 (c) 1986 */
+	DRIVER( contra )	/* GX633 (c) 1987 */
+	DRIVER( contrab )	/* bootleg */
+	DRIVER( contraj )	/* GX633 (c) 1987 (Japan) */
+	DRIVER( contrajb )	/* bootleg */
+	DRIVER( gryzor )	/* GX633 (c) 1987 */
+	DRIVER( combasc )	/* GX611 (c) 1988 */
+	DRIVER( combasct )	/* GX611 (c) 1987 */
+	DRIVER( combascj )	/* GX611 (c) 1987 (Japan) */
+	DRIVER( bootcamp )	/* GX611 (c) 1987 */
+	DRIVER( combascb )	/* bootleg */
+	DRIVER( rockrage )	/* GX620 (c) 1986 (World?) */
+	DRIVER( rockragj )	/* GX620 (c) 1986 (Japan) */
+	DRIVER( mx5000 )	/* GX669 (c) 1987 */
+	DRIVER( flkatck )	/* GX669 (c) 1987 (Japan) */
+	DRIVER( fastlane )	/* GX752 (c) 1987 */
+	DRIVER( thehustl )	/* GX765 (c) 1987 (Japan) */
+	DRIVER( thehustj )	/* GX765 (c) 1987 (Japan) */
+	DRIVER( battlnts )	/* GX777 (c) 1987 */
+	DRIVER( battlntj )	/* GX777 (c) 1987 (Japan) */
+	DRIVER( bladestl )	/* GX797 (c) 1987 */
+	DRIVER( bladstle )	/* GX797 (c) 1987 */
+	DRIVER( hcastle )	/* GX768 (c) 1988 */
+	DRIVER( hcastlea )	/* GX768 (c) 1988 */
+	DRIVER( hcastlej )	/* GX768 (c) 1988 (Japan) */
+	DRIVER( ajax )		/* GX770 (c) 1987 */
+	DRIVER( ajaxj )		/* GX770 (c) 1987 (Japan) */
+	DRIVER( scontra )	/* GX775 (c) 1988 */
+	DRIVER( scontraj )	/* GX775 (c) 1988 (Japan) */
+	DRIVER( thunderx )	/* GX873 (c) 1988 */
+	DRIVER( thnderxj )	/* GX873 (c) 1988 (Japan) */
+	DRIVER( mainevt )	/* GX799 (c) 1988 */
+	DRIVER( mainevt2 )	/* GX799 (c) 1988 */
+	DRIVER( ringohja )	/* GX799 (c) 1988 (Japan) */
+	DRIVER( devstors )	/* GX890 (c) 1988 */
+	DRIVER( devstor2 )	/* GX890 (c) 1988 */
+	DRIVER( devstor3 )	/* GX890 (c) 1988 */
+	DRIVER( garuka )	/* GX890 (c) 1988 (Japan) */
+	DRIVER( 88games )	/* GX861 (c) 1988 */
+	DRIVER( konami88 )	/* GX861 (c) 1988 */
+	DRIVER( gbusters )	/* GX878 (c) 1988 */
+	DRIVER( crazycop )	/* GX878 (c) 1988 (Japan) */
+	DRIVER( crimfght )	/* GX821 (c) 1989 (US) */
+	DRIVER( crimfgtj )	/* GX821 (c) 1989 (Japan) */
+	DRIVER( spy )		/* GX857 (c) 1989 (US) */
+	DRIVER( bottom9 )	/* GX891 (c) 1989 */
+	DRIVER( bottom9n )	/* GX891 (c) 1989 */
+	DRIVER( blockhl )	/* GX973 (c) 1989 */
+	DRIVER( quarth )	/* GX973 (c) 1989 (Japan) */
+	DRIVER( aliens )	/* GX875 (c) 1990 (World) */
+	DRIVER( aliens2 )	/* GX875 (c) 1990 (World) */
+	DRIVER( aliensu )	/* GX875 (c) 1990 (US) */
+	DRIVER( aliensj )	/* GX875 (c) 1990 (Japan) */
+	DRIVER( surpratk )	/* GX911 (c) 1990 (Japan) */
+	DRIVER( parodius )	/* GX955 (c) 1990 (Japan) */
+	DRIVER( rollerg )	/* GX999 (c) 1991 (US) */
+	DRIVER( rollergj )	/* GX999 (c) 1991 (Japan) */
+TESTDRIVER( xexex )		/* GX067 (c) 1991 */
+	DRIVER( simpsons )	/* GX072 (c) 1991 */
+	DRIVER( simpsn2p )	/* GX072 (c) 1991 */
+	DRIVER( simps2pj )	/* GX072 (c) 1991 (Japan) */
+	DRIVER( vendetta )	/* GX081 (c) 1991 (Asia) */
+	DRIVER( vendett2 )	/* GX081 (c) 1991 (Asia) */
+	DRIVER( vendettj )	/* GX081 (c) 1991 (Japan) */
+	DRIVER( wecleman )	/* GX602 (c) 1986 */
+	DRIVER( hotchase )	/* GX763 (c) 1988 */
+
+	/* Konami "Nemesis hardware" games */
+	DRIVER( nemesis )	/* GX456 (c) 1985 */
+	DRIVER( nemesuk )	/* GX456 (c) 1985 */
+	DRIVER( konamigt )	/* GX561 (c) 1985 */
+	DRIVER( salamand )	/* GX587 (c) 1986 */
+	DRIVER( lifefrce )	/* GX587 (c) 1986 */
+	DRIVER( lifefrcj )	/* GX587 (c) 1986 */
+	/* GX400 BIOS based games */
+	DRIVER( rf2 )		/* GX561 (c) 1985 */
+	DRIVER( twinbee )	/* GX412 (c) 1985 */
+	DRIVER( gradius )	/* GX456 (c) 1985 */
+	DRIVER( gwarrior )	/* GX578 (c) 1985 */
+
+	/* Konami "Twin 16" games */
+	DRIVER( devilw )	/* GX687 (c) 1987 */
+	DRIVER( darkadv )	/* GX687 (c) 1987 */
+	DRIVER( majuu )		/* GX687 (c) 1987 (Japan) */
+	DRIVER( vulcan )	/* GX785 (c) 1988 */
+	DRIVER( gradius2 )	/* GX785 (c) 1988 (Japan) */
+	DRIVER( grdius2a )	/* GX785 (c) 1988 (Japan) */
+	DRIVER( grdius2b )	/* GX785 (c) 1988 (Japan) */
+	DRIVER( cuebrick )	/* GX903 (c) 1989 */
+	DRIVER( fround )	/* GX870 (c) 1988 */
+	DRIVER( hpuncher )	/* GX870 (c) 1988 (Japan) */
+	DRIVER( miaj )		/* GX808 (c) 1989 (Japan) */
+
+	/* Konami Gradius III board */
+	DRIVER( gradius3 )	/* GX945 (c) 1989 (Japan) */
+	DRIVER( grdius3a )	/* GX945 (c) 1989 (Asia) */
+
+	/* (some) Konami 68000 games */
+	DRIVER( mia )		/* GX808 (c) 1989 */
+	DRIVER( mia2 )		/* GX808 (c) 1989 */
+	DRIVER( tmnt )		/* GX963 (c) 1989 (US) */
+	DRIVER( tmht )		/* GX963 (c) 1989 (UK) */
+	DRIVER( tmntj )		/* GX963 (c) 1989 (Japan) */
+	DRIVER( tmht2p )	/* GX963 (c) 1989 (UK) */
+	DRIVER( tmnt2pj )	/* GX963 (c) 1990 (Japan) */
+	DRIVER( punkshot )	/* GX907 (c) 1990 (US) */
+	DRIVER( punksht2 )	/* GX907 (c) 1990 (US) */
+	DRIVER( lgtnfght )	/* GX939 (c) 1990 (US) */
+	DRIVER( trigon )	/* GX939 (c) 1990 (Japan) */
+	DRIVER( blswhstl )	/* GX060 (c) 1991 */
+	DRIVER( detatwin )	/* GX060 (c) 1991 (Japan) */
+TESTDRIVER( glfgreat )	/* GX061 (c) 1991 */
+	DRIVER( tmnt2 )		/* GX063 (c) 1991 (US) */
+	DRIVER( tmnt22p )	/* GX063 (c) 1991 (US) */
+	DRIVER( tmnt2a )	/* GX063 (c) 1991 (Asia) */
+	DRIVER( ssriders )	/* GX064 (c) 1991 (World) */
+	DRIVER( ssrdrebd )	/* GX064 (c) 1991 (World) */
+	DRIVER( ssrdrebc )	/* GX064 (c) 1991 (World) */
+	DRIVER( ssrdruda )	/* GX064 (c) 1991 (US) */
+	DRIVER( ssrdruac )	/* GX064 (c) 1991 (US) */
+	DRIVER( ssrdrubc )	/* GX064 (c) 1991 (US) */
+	DRIVER( ssrdrabd )	/* GX064 (c) 1991 (Asia) */
+	DRIVER( ssrdrjbd )	/* GX064 (c) 1991 (Japan) */
+	DRIVER( xmen )		/* GX065 (c) 1992 (US) */
+	DRIVER( xmen6p )	/* GX065 (c) 1992 */
+	DRIVER( xmen2pj )	/* GX065 (c) 1992 (Japan) */
+	DRIVER( thndrx2 )	/* GX073 (c) 1991 (Japan) */
+
+/*
+Konami System GX game list
+1994.03 Racing Force (GX250)
+1994.03 Golfing Greats 2 (GX218)
+1994.04 Gokujou Parodius (GX321)
+1994.07 Taisen Puzzle-dama (GX315)
+1994.12 Soccer Super Stars (GX427)
+1995.04 TwinBee Yahhoo! (GX424)
+1995.08 Dragoon Might (GX417)
+1995.12 Tokimeki Memorial Taisen Puzzle-dama (GX515)
+1996.01 Salamander 2 (GX521)
+1996.02 Sexy Parodius (GX533)
+1996.03 Daisu-Kiss (GX535)
+1996.03 Slam Dunk 2 / Run & Gun 2 (GX505)
+1996.10 Taisen Tokkae-dama (GX615)
+1996.12 Versus Net Soccer (GX627)
+1997.07 Winning Spike (GX705)
+1997.11 Rushing Heroes (GX?. Not released in Japan)
+*/
+
+	/* Exidy games */
+	DRIVER( sidetrac )	/* (c) 1979 */
+	DRIVER( targ )		/* (c) 1980 */
+	DRIVER( spectar )	/* (c) 1980 */
+	DRIVER( spectar1 )	/* (c) 1980 */
+	DRIVER( venture )	/* (c) 1981 */
+	DRIVER( venture2 )	/* (c) 1981 */
+	DRIVER( venture4 )	/* (c) 1981 */
+	DRIVER( mtrap )		/* (c) 1981 */
+	DRIVER( mtrap3 )	/* (c) 1981 */
+	DRIVER( mtrap4 )	/* (c) 1981 */
+	DRIVER( pepper2 )	/* (c) 1982 */
+	DRIVER( hardhat )	/* (c) 1982 */
+	DRIVER( fax )		/* (c) 1983 */
+	DRIVER( circus )	/* no copyright notice [1977?] */
+	DRIVER( robotbwl )	/* no copyright notice */
+	DRIVER( crash )		/* Exidy [1979?] */
+	DRIVER( ripcord )	/* Exidy [1977?] */
+	DRIVER( starfire )	/* Exidy [1979?] */
+	DRIVER( fireone )	/* (c) 1979 Exidy */
+
+	/* Exidy 440 games */
+	DRIVER( crossbow )	/* (c) 1983 */
+	DRIVER( cheyenne )	/* (c) 1984 */
+	DRIVER( combat )	/* (c) 1985 */
+	DRIVER( cracksht )	/* (c) 1985 */
+	DRIVER( claypign )	/* (c) 1986 */
+	DRIVER( chiller )	/* (c) 1986 */
+	DRIVER( topsecex )	/* (c) 1986 */
+	DRIVER( hitnmiss )	/* (c) 1987 */
+	DRIVER( hitnmis2 )	/* (c) 1987 */
+	DRIVER( whodunit )	/* (c) 1988 */
+	DRIVER( showdown )	/* (c) 1988 */
+
+	/* Atari vector games */
+	DRIVER( asteroid )	/* (c) 1979 */
+	DRIVER( asteroi1 )	/* no copyright notice */
+	DRIVER( astdelux )	/* (c) 1980 */
+	DRIVER( astdelu1 )	/* (c) 1980 */
+	DRIVER( bwidow )	/* (c) 1982 */
+	DRIVER( bzone )		/* (c) 1980 */
+	DRIVER( bzone2 )	/* (c) 1980 */
+	DRIVER( gravitar )	/* (c) 1982 */
+	DRIVER( gravitr2 )	/* (c) 1982 */
+	DRIVER( llander )	/* no copyright notice */
+	DRIVER( llander1 )	/* no copyright notice */
+	DRIVER( redbaron )	/* (c) 1980 */
+	DRIVER( spacduel )	/* (c) 1980 */
+	DRIVER( tempest )	/* (c) 1980 */
+	DRIVER( tempest1 )	/* (c) 1980 */
+	DRIVER( tempest2 )	/* (c) 1980 */
+	DRIVER( temptube )	/* hack */
+	DRIVER( starwars )	/* (c) 1983 */
+	DRIVER( starwar1 )	/* (c) 1983 */
+	DRIVER( esb )		/* (c) 1985 */
+	DRIVER( mhavoc )	/* (c) 1983 */
+	DRIVER( mhavoc2 )	/* (c) 1983 */
+	DRIVER( mhavocp )	/* (c) 1983 */
+	DRIVER( mhavocrv )	/* hack */
+	DRIVER( quantum )	/* (c) 1982 */	/* made by Gencomp */
+	DRIVER( quantum1 )	/* (c) 1982 */	/* made by Gencomp */
+	DRIVER( quantump )	/* (c) 1982 */	/* made by Gencomp */
+
+	/* Atari b/w games */
+	DRIVER( sprint1 )	/* no copyright notice */
+	DRIVER( sprint2 )	/* no copyright notice */
+	DRIVER( sbrkout )	/* no copyright notice */
+	DRIVER( dominos )	/* no copyright notice */
+	DRIVER( nitedrvr )	/* no copyright notice [1976] */
+	DRIVER( bsktball )	/* no copyright notice */
+	DRIVER( copsnrob )	/* [1976] */
+	DRIVER( avalnche )	/* no copyright notice [1978] */
+	DRIVER( subs )		/* no copyright notice [1976] */
+	DRIVER( atarifb )	/* no copyright notice [1978] */
+	DRIVER( atarifb1 )	/* no copyright notice [1978] */
+	DRIVER( atarifb4 )	/* no copyright notice [1979] */
+	DRIVER( abaseb )	/* no copyright notice [1979] */
+	DRIVER( abaseb2 )	/* no copyright notice [1979] */
+	DRIVER( soccer )	/* no copyright notice */
+	DRIVER( canyon )	/* no copyright notice [1977] */
+	DRIVER( canbprot )	/* no copyright notice [1977] */
+	DRIVER( skydiver )	/* no copyright notice [1977] */
+
+	/* Atari "Centipede hardware" games */
+	DRIVER( warlord )	/* (c) 1980 */
+	DRIVER( centiped )	/* (c) 1980 */
+	DRIVER( centipd2 )	/* (c) 1980 */
+	DRIVER( centipdb )	/* bootleg */
+	DRIVER( centipb2 )	/* bootleg */
+	DRIVER( milliped )	/* (c) 1982 */
+	DRIVER( qwakprot )	/* (c) 1982 */
+
+	/* Atari "Kangaroo hardware" games */
+	DRIVER( kangaroo )	/* (c) 1982 */
+	DRIVER( kangarob )	/* bootleg */
+	DRIVER( arabian )	/* (c) 1983 Sun Electronics */
+	DRIVER( arabiana )	/* (c) 1983 */
+
+	/* Atari "Missile Command hardware" games */
+	DRIVER( missile )	/* (c) 1980 */
+	DRIVER( missile2 )	/* (c) 1980 */
+	DRIVER( suprmatk )	/* (c) 1980 + (c) 1981 Gencomp */
+
+	/* misc Atari games */
+	DRIVER( foodf )		/* (c) 1982 */	/* made by Gencomp */
+	DRIVER( liberatr )	/* (c) 1982 */
+TESTDRIVER( liberat2 )
+	DRIVER( ccastles )	/* (c) 1983 */
+	DRIVER( ccastle2 )	/* (c) 1983 */
+	DRIVER( cloak )		/* (c) 1983 */
+	DRIVER( cloud9 )	/* (c) 1983 */
+	DRIVER( jedi )		/* (c) 1984 */
+
+	/* Atari System 1 games */
+	DRIVER( marble )	/* (c) 1984 */
+	DRIVER( marble2 )	/* (c) 1984 */
+	DRIVER( marblea )	/* (c) 1984 */
+	DRIVER( peterpak )	/* (c) 1984 */
+	DRIVER( indytemp )	/* (c) 1985 */
+	DRIVER( indytem2 )	/* (c) 1985 */
+	DRIVER( indytem3 )	/* (c) 1985 */
+	DRIVER( indytem4 )	/* (c) 1985 */
+	DRIVER( roadrunn )	/* (c) 1985 */
+	DRIVER( roadblst )	/* (c) 1986, 1987 */
+
+	/* Atari System 2 games */
+	DRIVER( paperboy )	/* (c) 1984 */
+	DRIVER( ssprint )	/* (c) 1986 */
+	DRIVER( csprint )	/* (c) 1986 */
+	DRIVER( 720 )		/* (c) 1986 */
+	DRIVER( 720b )		/* (c) 1986 */
+	DRIVER( apb )		/* (c) 1987 */
+	DRIVER( apb2 )		/* (c) 1987 */
+
+	/* later Atari games */
+	DRIVER( gauntlet )	/* (c) 1985 */
+	DRIVER( gauntir1 )	/* (c) 1985 */
+	DRIVER( gauntir2 )	/* (c) 1985 */
+	DRIVER( gaunt2p )	/* (c) 1985 */
+	DRIVER( gaunt2 )	/* (c) 1986 */
+	DRIVER( vindctr2 )	/* (c) 1988 */
+	DRIVER( atetris )	/* (c) 1988 */
+	DRIVER( atetrisa )	/* (c) 1988 */
+	DRIVER( atetrisb )	/* bootleg */
+	DRIVER( atetcktl )	/* (c) 1989 */
+	DRIVER( atetckt2 )	/* (c) 1989 */
+	DRIVER( toobin )	/* (c) 1988 */
+	DRIVER( toobin2 )	/* (c) 1988 */
+	DRIVER( toobinp )	/* (c) 1988 */
+	DRIVER( vindictr )	/* (c) 1988 */
+	DRIVER( klax )		/* (c) 1989 */
+	DRIVER( klax2 )		/* (c) 1989 */
+	DRIVER( klax3 )		/* (c) 1989 */
+	DRIVER( klaxj )		/* (c) 1989 (Japan) */
+	DRIVER( blstroid )	/* (c) 1987 */
+	DRIVER( blstroi2 )	/* (c) 1987 */
+	DRIVER( xybots )	/* (c) 1987 */
+	DRIVER( eprom )		/* (c) 1989 */
+	DRIVER( eprom2 )	/* (c) 1989 */
+	DRIVER( skullxbo )	/* (c) 1989 */
+	DRIVER( skullxb2 )	/* (c) 1989 */
+	DRIVER( badlands )	/* (c) 1989 */
+	DRIVER( cyberbal )	/* (c) 1989 */
+	DRIVER( cyberbt )	/* (c) 1989 */
+	DRIVER( cyberb2p )	/* (c) 1989 */
+	DRIVER( rampart )	/* (c) 1990 */
+	DRIVER( ramprt2p )	/* (c) 1990 */
+	DRIVER( shuuz )		/* (c) 1990 */
+	DRIVER( shuuz2 )	/* (c) 1990 */
+	DRIVER( hydra )		/* (c) 1990 */
+	DRIVER( hydrap )	/* (c) 1990 */
+	DRIVER( pitfight )	/* (c) 1990 */
+	DRIVER( pitfigh3 )	/* (c) 1990 */
+	DRIVER( thunderj )	/* (c) 1990 */
+	DRIVER( batman )	/* (c) 1991 */
+	DRIVER( relief )	/* (c) 1992 */
+	DRIVER( relief2 )	/* (c) 1992 */
+	DRIVER( offtwall )	/* (c) 1991 */
+	DRIVER( offtwalc )	/* (c) 1991 */
+	DRIVER( arcadecl )	/* (c) 1992 */
+	DRIVER( sparkz )	/* (c) 1992 */
+
+	/* SNK / Rock-ola games */
+	DRIVER( sasuke )	/* [1980] Shin Nihon Kikaku (SNK) */
+	DRIVER( satansat )	/* (c) 1981 SNK */
+	DRIVER( zarzon )	/* (c) 1981 Taito, gameplay says SNK */
+	DRIVER( vanguard )	/* (c) 1981 SNK */
+	DRIVER( vangrdce )	/* (c) 1981 SNK + Centuri */
+	DRIVER( fantasy )	/* (c) 1981 Rock-ola */
+	DRIVER( fantasyj )	/* (c) 1981 SNK */
+	DRIVER( pballoon )	/* (c) 1982 SNK */
+	DRIVER( nibbler )	/* (c) 1982 Rock-ola */
+	DRIVER( nibblera )	/* (c) 1982 Rock-ola */
+
+	/* later SNK games, each game can be identified by PCB code and ROM
+	code, the ROM code is the same between versions, and usually based
+	upon the Japanese title. */
+	DRIVER( joyfulr )	/* A2001      (c) 1983 */
+	DRIVER( mnchmobl )	/* A2001      (c) 1983 + Centuri license */
+	DRIVER( marvins )	/* A2003      (c) 1983 */
+	DRIVER( madcrash )	/* A2005      (c) 1984 */
+	DRIVER( vangrd2 )	/*            (c) 1984 */
+	DRIVER( hal21 )		/*            (c) 1985 */
+	DRIVER( hal21j )	/*            (c) 1985 (Japan) */
+	DRIVER( aso )		/*            (c) 1985 */
+	DRIVER( tnk3 )		/* A5001      (c) 1985 */
+	DRIVER( tnk3j )		/* A5001      (c) 1985 */
+	DRIVER( athena )	/*       'UP' (c) 1986 */
+	DRIVER( fitegolf )	/*       'GU' (c) 1988 */
+	DRIVER( ikari )		/* A5004 'IW' (c) 1986 */
+	DRIVER( ikarijp )	/* A5004 'IW' (c) 1986 (Japan) */
+	DRIVER( ikarijpb )	/* bootleg */
+	DRIVER( victroad )	/*            (c) 1986 */
+	DRIVER( dogosoke )	/*            (c) 1986 */
+	DRIVER( gwar )		/* A7003 'GV' (c) 1987 */
+	DRIVER( gwarj )		/* A7003 'GV' (c) 1987 (Japan) */
+	DRIVER( gwara )		/* A7003 'GV' (c) 1987 */
+	DRIVER( gwarb )		/* bootleg */
+	DRIVER( bermudat )	/* A6003 'WW' (c) 1987 */
+	DRIVER( bermudaj )	/* A6003 'WW' (c) 1987 */
+	DRIVER( bermudaa )	/* A6003 'WW' (c) 1987 */
+	DRIVER( worldwar )	/* A6003 'WW' (c) 1987 */
+	DRIVER( psychos )	/*       'PS' (c) 1987 */
+	DRIVER( psychosj )	/*       'PS' (c) 1987 (Japan) */
+	DRIVER( chopper )	/* A7003 'KK' (c) 1988 */
+	DRIVER( legofair )	/* A7003 'KK' (c) 1988 */
+	DRIVER( ftsoccer )	/*            (c) 1988 */
+	DRIVER( tdfever )	/* A6006 'TD' (c) 1987 */
+	DRIVER( tdfeverj )	/* A6006 'TD' (c) 1987 */
+	DRIVER( ikari3 )	/* A7007 'IK3'(c) 1989 */
+	DRIVER( pow )		/* A7008 'DG' (c) 1988 */
+	DRIVER( powj )		/* A7008 'DG' (c) 1988 */
+	DRIVER( searchar )	/* A8007 'BH' (c) 1989 */
+	DRIVER( sercharu )	/* A8007 'BH' (c) 1989 */
+	DRIVER( streetsm )	/* A8007 'S2' (c) 1989 */
+	DRIVER( streets1 )	/* A7008 'S2' (c) 1989 */
+	DRIVER( streetsj )	/* A8007 'S2' (c) 1989 */
+	/* Mechanized Attack   A8002 'MA' (c) 1989 */
+	DRIVER( prehisle )	/* A8003 'GT' (c) 1989 */
+	DRIVER( prehislu )	/* A8003 'GT' (c) 1989 */
+	DRIVER( gensitou )	/* A8003 'GT' (c) 1989 */
+	/* Beast Busters       A9003 'BB' (c) 1989 */
+
+	/* SNK / Alpha 68K games */
+TESTDRIVER( kyros )
+TESTDRIVER( sstingry )
+TESTDRIVER( paddlema )	/* Alpha-68K96I  'PM' (c) 1988 SNK */
+	DRIVER( timesold )	/* Alpha-68K96II 'BT' (c) 1987 SNK / Romstar */
+	DRIVER( timesol1 )  /* Alpha-68K96II 'BT' (c) 1987 */
+	DRIVER( btlfield )  /* Alpha-68K96II 'BT' (c) 1987 */
+	DRIVER( skysoldr )	/* Alpha-68K96II 'SS' (c) 1988 SNK (Romstar with dip switch) */
+	DRIVER( goldmedl )	/* Alpha-68K96II 'GM' (c) 1988 SNK */
+TESTDRIVER( goldmedb )	/* Alpha-68K96II bootleg */
+	DRIVER( skyadvnt )	/* Alpha-68K96V  'SA' (c) 1989 SNK of America licensed from Alpha */
+	DRIVER( gangwars )	/* Alpha-68K96V       (c) 1989 Alpha */
+	DRIVER( gangwarb )	/* Alpha-68K96V bootleg */
+	DRIVER( sbasebal )	/* Alpha-68K96V       (c) 1989 SNK of America licensed from Alpha */
+
+	/* Technos games */
+	DRIVER( scregg )	/* TA-0001 (c) 1983 */
+	DRIVER( eggs )		/* TA-0002 (c) 1983 Universal USA */
+	DRIVER( bigprowr )	/* TA-0007 (c) 1983 */
+	DRIVER( tagteam )	/* TA-0007 (c) 1983 + Data East license */
+	DRIVER( ssozumo )	/* TA-0008 (c) 1984 */
+	DRIVER( mystston )	/* TA-0010 (c) 1984 */
+	/* TA-0011 Dog Fight (Data East) / Batten O'hara no Sucha-Raka Kuuchuu Sen 1985 */
+	DRIVER( bogeyman )	/* X-0204-0 (Data East part number) (c) [1985?] */
+	DRIVER( matmania )	/* TA-0015 (c) 1985 + Taito America license */
+	DRIVER( excthour )	/* TA-0015 (c) 1985 + Taito license */
+	DRIVER( maniach )	/* TA-0017 (c) 1986 + Taito America license */
+	DRIVER( maniach2 )	/* TA-0017 (c) 1986 + Taito America license */
+	DRIVER( renegade )	/* TA-0018 (c) 1986 + Taito America license */
+	DRIVER( kuniokun )	/* TA-0018 (c) 1986 */
+	DRIVER( kuniokub )	/* bootleg */
+	DRIVER( xsleena )	/* TA-0019 (c) 1986 */
+	DRIVER( xsleenab )	/* bootleg */
+	DRIVER( solarwar )	/* TA-0019 (c) 1986 Taito + Memetron license */
+	DRIVER( battlane )	/* TA-???? (c) 1986 + Taito license */
+	DRIVER( battlan2 )	/* TA-???? (c) 1986 + Taito license */
+	DRIVER( battlan3 )	/* TA-???? (c) 1986 + Taito license */
+	DRIVER( ddragon )
+	DRIVER( ddragonb )	/* TA-0021 bootleg */
+	/* TA-0022 Super Dodge Ball */
+	/* TA-0023 China Gate */
+	/* TA-0024 WWF Superstars */
+	/* TA-0025 Champ V'Ball */
+	DRIVER( ddragon2 )	/* TA-0026 (c) 1988 */
+	/* TA-0027 ???? */
+	DRIVER( ctribe )	/* TA-0028 (c) 1990 (US) */
+	DRIVER( ctribeb )	/* bootleg */
+	DRIVER( blockout )	/* TA-0029 (c) 1989 + California Dreams */
+	DRIVER( blckout2 )	/* TA-0029 (c) 1989 + California Dreams */
+	DRIVER( ddragon3 )	/* TA-0030 (c) 1990 */
+	DRIVER( ddrago3b )	/* bootleg */
+	/* TA-0031 WWF Wrestlefest */
+
+	/* Stern "Berzerk hardware" games */
+	DRIVER( berzerk )	/* (c) 1980 */
+	DRIVER( berzerk1 )	/* (c) 1980 */
+	DRIVER( frenzy )	/* (c) 1982 */
+
+	/* GamePlan games */
+	DRIVER( megatack )	/* (c) 1980 Centuri */
+	DRIVER( killcom )	/* (c) 1980 Centuri */
+	DRIVER( challeng )	/* (c) 1981 Centuri */
+	DRIVER( kaos )		/* (c) 1981 */
+
+	/* "stratovox hardware" games */
+	DRIVER( route16 )	/* (c) 1981 Tehkan/Sun + Centuri license */
+	DRIVER( route16b )	/* bootleg */
+	DRIVER( stratvox )	/* Taito */
+	DRIVER( stratvxb )	/* bootleg */
+	DRIVER( speakres )	/* no copyright notice */
+
+	/* Zaccaria games */
+	DRIVER( monymony )	/* (c) 1983 */
+	DRIVER( jackrabt )	/* (c) 1984 */
+	DRIVER( jackrab2 )	/* (c) 1984 */
+	DRIVER( jackrabs )	/* (c) 1984 */
+
+	/* UPL games */
+	DRIVER( nova2001 )	/* UPL-83005 (c) 1983 */
+	DRIVER( nov2001u )	/* UPL-83005 (c) [1983] + Universal license */
+	DRIVER( pkunwar )	/* [1985?] */
+	DRIVER( pkunwarj )	/* [1985?] */
+	DRIVER( ninjakd2 )	/* (c) 1987 */
+	DRIVER( ninjak2a )	/* (c) 1987 */
+	DRIVER( ninjak2b )	/* (c) 1987 */
+	DRIVER( rdaction )	/* (c) 1987 + World Games license */
+	DRIVER( mnight )	/* (c) 1987 distributed by Kawakus */
+	DRIVER( arkarea )	/* UPL-87007 (c) [1988?] */
+/*
+Urashima Mahjong    UPL-89052
+
+UPL Game List
+V1.2   May 27,1999
+
+   83 Mouser                              Kit 2P              Action   83001
+ 3/84 Nova 2001                 Universal Kit 2P  8W+2B   HC  Shooter  85005
+   84 Penguin Wars (Kun)                      2P              Action
+   84 Ninja Kun                 Taito                                  85003
+   85 Raiders 5                 Taito                                  85004
+ 8/87 Mission XX                          Kit 2P  8W+2B   VC  Shooter  86001
+   87 Mutant Night                        Kit 2P  8W+2B   HC  Action
+ 7/87 Rad Action/Ninja Taro   World Games Kit 2P  8W+2B   HC  Action   87003
+ 7/87 Ninja Taro/Rad Action   World Games Kit 2P  8W+2B   HC  Action
+   87 Ninja Taro II                       Kit 2P  8W+2B   HC  Action
+   88 Aquaria                             Kit 2P  8W+2B
+   89 Ochichi Mahjong                     Kit 2P  8W+2B   HC  Mahjong
+ 9/89 Omega Fighter        American Sammy Kit 2P  8W+2B   HC  Shooter  89016
+12/89 Task Force Harrier   American Sammy Kit 2P  8W+2B   VC  Shooter  89053
+   90 Atomic Robo-Kid      American Sammy Kit 2P  8W+2B   HC  Shooter  88013
+   90 Mustang - U.S.A.A.F./Fire Mustang   Kit 2P  8W+2B   HC  Shooter  90058
+   91 Acrobat Mission               Taito Kit 2P  8W+2B   VC  Shooter
+   91 Bio Ship Paladin/Spaceship Gomera   Kit 2P  8W+2B   HC  Shooter  90062
+   91 Black Heart                         Kit 2P  8W+2B   HC  Shooter
+   91 Van Dyke Fantasy                    Kit 2P  8W+2B
+ 2/92 Strahl                              Kit 2P  8W+3B                91074
+      Thunder Dragon 2                                                 93091
+
+*/
+
+	/* Williams/Midway TMS34010 games */
+	DRIVER( narc )		/* (c) 1988 Williams */
+TESTDRIVER( narc3 )		/* (c) 1988 Williams */
+	DRIVER( trog )		/* (c) 1990 Midway */
+	DRIVER( trog3 )		/* (c) 1990 Midway */
+	DRIVER( trogp )		/* (c) 1990 Midway */
+	DRIVER( smashtv )	/* (c) 1990 Williams */
+	DRIVER( smashtv6 )	/* (c) 1990 Williams */
+	DRIVER( smashtv5 )	/* (c) 1990 Williams */
+	DRIVER( smashtv4 )	/* (c) 1990 Williams */
+	DRIVER( hiimpact )	/* (c) 1990 Williams */
+	DRIVER( shimpact )	/* (c) 1991 Midway */
+	DRIVER( strkforc )	/* (c) 1991 Midway */
+	DRIVER( mk )		/* (c) 1992 Midway */
+	DRIVER( mkla1 )		/* (c) 1992 Midway */
+	DRIVER( mkla2 )		/* (c) 1992 Midway */
+	DRIVER( mkla3 )		/* (c) 1992 Midway */
+	DRIVER( mkla4 )		/* (c) 1992 Midway */
+	DRIVER( term2 )		/* (c) 1992 Midway */
+	DRIVER( totcarn )	/* (c) 1992 Midway */
+	DRIVER( totcarnp )	/* (c) 1992 Midway */
+	DRIVER( mk2 )		/* (c) 1993 Midway */
+	DRIVER( mk2r32 )	/* (c) 1993 Midway */
+	DRIVER( mk2r14 )	/* (c) 1993 Midway */
+	DRIVER( nbajam )	/* (c) 1993 Midway */
+
+	/* Cinematronics raster games */
+	DRIVER( jack )		/* (c) 1982 Cinematronics */
+	DRIVER( jack2 )		/* (c) 1982 Cinematronics */
+	DRIVER( jack3 )		/* (c) 1982 Cinematronics */
+	DRIVER( treahunt )	/* (c) 1982 Hara Ind. */
+	DRIVER( zzyzzyxx )	/* (c) 1982 Cinematronics + Advanced Microcomputer Systems */
+	DRIVER( zzyzzyx2 )	/* (c) 1982 Cinematronics + Advanced Microcomputer Systems */
+	DRIVER( brix )		/* (c) 1982 Cinematronics + Advanced Microcomputer Systems */
+	DRIVER( freeze )	/* Cinematronics */
+	DRIVER( sucasino )	/* (c) 1982 Data Amusement */
+
+	/* Cinematronics vector games */
+	DRIVER( spacewar )
+	DRIVER( barrier )
+	DRIVER( starcas )	/* (c) 1980 */
+	DRIVER( starcas1 )	/* (c) 1980 */
+	DRIVER( tailg )
+	DRIVER( ripoff )
+	DRIVER( armora )
+	DRIVER( wotw )
+	DRIVER( warrior )
+	DRIVER( starhawk )
+	DRIVER( solarq )	/* (c) 1981 */
+	DRIVER( boxingb )	/* (c) 1981 */
+	DRIVER( speedfrk )
+	DRIVER( sundance )
+	DRIVER( demon )		/* (c) 1982 Rock-ola */
+	/* this one uses 68000+Z80 instead of the Cinematronics CPU */
+	DRIVER( cchasm )
+	DRIVER( cchasm1 )	/* (c) 1983 Cinematronics / GCE */
+
+	/* "The Pit hardware" games */
+	DRIVER( roundup )	/* (c) 1981 Amenip/Centuri */
+	DRIVER( fitter )	/* (c) 1981 Taito */
+	DRIVER( thepit )	/* (c) 1982 Centuri */
+	DRIVER( intrepid )	/* (c) 1983 Nova Games Ltd. */
+	DRIVER( intrepi2 )	/* (c) 1983 Nova Games Ltd. */
+	DRIVER( portman )	/* (c) 1982 Nova Games Ltd. */
+	DRIVER( suprmous )	/* (c) 1982 Taito */
+	DRIVER( suprmou2 )	/* (c) 1982 Chu Co. Ltd. */
+	DRIVER( machomou )	/* (c) 1982 Techstar */
+
+	/* Valadon Automation games */
+	DRIVER( bagman )	/* (c) 1982 */
+	DRIVER( bagnard )	/* (c) 1982 */
+	DRIVER( bagmans )	/* (c) 1982 + Stern license */
+	DRIVER( bagmans2 )	/* (c) 1982 + Stern license */
+	DRIVER( sbagman )	/* (c) 1984 */
+	DRIVER( sbagmans )	/* (c) 1984 + Stern license */
+	DRIVER( pickin )	/* (c) 1983 */
+
+	/* Seibu Denshi / Seibu Kaihatsu games */
+	DRIVER( stinger )	/* (c) 1983 Seibu Denshi */
+	DRIVER( scion )		/* (c) 1984 Seibu Denshi */
+	DRIVER( scionc )	/* (c) 1984 Seibu Denshi + Cinematronics license */
+	DRIVER( wiz )		/* (c) 1985 Seibu Kaihatsu */
+	DRIVER( wizt )		/* (c) 1985 Taito Corporation */
+	DRIVER( empcity )	/* (c) 1986 Seibu Kaihatsu (bootleg?) */
+	DRIVER( empcityj )	/* (c) 1986 Taito Corporation (Japan) */
+	DRIVER( stfight )	/* (c) 1986 Seibu Kaihatsu (Germany) (bootleg?) */
+	DRIVER( dynduke )	/* (c) 1989 Seibu Kaihatsu + Fabtek license */
+	DRIVER( dbldyn )	/* (c) 1989 Seibu Kaihatsu + Fabtek license */
+	DRIVER( raiden )	/* (c) 1990 Seibu Kaihatsu */
+	DRIVER( raidena )	/* (c) 1990 Seibu Kaihatsu */
+	DRIVER( raidenk )	/* (c) 1990 Seibu Kaihatsu + IBL Corporation license */
+	DRIVER( dcon )		/* (c) 1992 Success */
+
+/* Seibu STI System games:
+
+	Viper: Phase 1 					(c) 1995
+	Viper: Phase 1 (New version)	(c) 1996
+	Battle Balls					(c) 1996
+	Raiden Fighters					(c) 1996
+	Raiden Fighters 2 				(c) 1997
+	Senku							(c) 1997
+
+*/
+
+	/* Tad games (Tad games run on Seibu hardware) */
+	DRIVER( cabal )		/* (c) 1988 Tad + Fabtek license */
+	DRIVER( cabal2 )	/* (c) 1988 Tad + Fabtek license */
+	DRIVER( cabalbl )	/* bootleg */
+	DRIVER( toki )		/* (c) 1989 Tad */
+	DRIVER( toki2 )		/* (c) 1989 Tad */
+	DRIVER( toki3 )		/* (c) 1989 Tad */
+	DRIVER( tokiu )		/* (c) 1989 Tad + Fabtek license */
+	DRIVER( tokib )		/* bootleg */
+	DRIVER( bloodbro )	/* (c) 1990 Tad */
+	DRIVER( weststry )	/* bootleg */
+
+	/* Jaleco games */
+	DRIVER( exerion )	/* (c) 1983 Jaleco */
+	DRIVER( exeriont )	/* (c) 1983 Jaleco + Taito America license */
+	DRIVER( exerionb )	/* bootleg */
+	DRIVER( formatz )	/* (c) 1984 Jaleco */
+	DRIVER( aeroboto )	/* (c) 1984 Williams */
+	DRIVER( citycon )	/* (c) 1985 Jaleco */
+	DRIVER( citycona )	/* (c) 1985 Jaleco */
+	DRIVER( cruisin )	/* (c) 1985 Jaleco/Kitkorp */
+	DRIVER( pinbo )		/* (c) 1984 Jaleco */
+	DRIVER( pinbos )	/* (c) 1985 Strike */
+	DRIVER( psychic5 )	/* (c) 1987 Jaleco */
+	DRIVER( ginganin )	/* (c) 1987 Jaleco */
+	DRIVER( cischeat )	/* (c) 1990 Jaleco */
+	DRIVER( f1gpstar )	/* (c) 1991 Jaleco */
+
+	/* Jaleco Mega System 1 games */
+	DRIVER( lomakai )	/* (c) 1988 (World) */
+	DRIVER( makaiden )	/* (c) 1988 (Japan) */
+	DRIVER( p47 )		/* (c) 1988 */
+	DRIVER( p47j )		/* (c) 1988 (Japan) */
+	DRIVER( kickoff )	/* (c) 1988 (Japan) */
+	DRIVER( astyanax )	/* (c) 1989 */
+	DRIVER( lordofk )	/* (c) 1989 (Japan) */
+	DRIVER( hachoo )	/* (c) 1989 */
+	DRIVER( plusalph )	/* (c) 1989 */
+	DRIVER( stdragon )	/* (c) 1989 */
+	DRIVER( iganinju )	/* (c) 1989 (Japan) */
+	DRIVER( rodland )	/* (c) 1990 */
+	DRIVER( rodlandj )	/* (c) 1990 (Japan) */
+	DRIVER( 64street )	/* (c) 1991 */
+	DRIVER( 64streej )	/* (c) 1991 (Japan) */
+	DRIVER( edf )		/* (c) 1991 */
+	DRIVER( avspirit )	/* (c) 1991 */
+	DRIVER( phantasm )	/* (c) 1991 (Japan) */
+	DRIVER( bigstrik )	/* (c) 1992 */
+	DRIVER( chimerab )	/* (c) 1993 */
+	DRIVER( cybattlr )	/* (c) 1993 */
+	DRIVER( peekaboo )	/* (c) 1993 */
+	DRIVER( soldamj )	/* (c) 1992 (Japan) */
+
+	/* Video System Co. games */
+	DRIVER( pspikes )	/* (c) 1991 */
+	DRIVER( svolly91 )	/* (c) 1991 */
+	DRIVER( turbofrc )	/* (c) 1991 */
+	DRIVER( aerofgt )	/* (c) 1992 */
+	DRIVER( aerofgtb )	/* (c) 1992 */
+	DRIVER( aerofgtc )	/* (c) 1992 */
+TESTDRIVER( unkvsys )
+
+	/* Orca games */
+	DRIVER( marineb )	/* (c) 1982 Orca */
+	DRIVER( changes )	/* (c) 1982 Orca */
+	DRIVER( looper )	/* (c) 1982 Orca */
+	DRIVER( springer )	/* (c) 1982 Orca */
+	DRIVER( hoccer )	/* (c) 1983 Eastern Micro Electronics, Inc. */
+	DRIVER( hoccer2 )	/* (c) 1983 Eastern Micro Electronics, Inc. */
+	DRIVER( hopprobo )	/* (c) 1983 Sega */
+	DRIVER( wanted )	/* (c) 1984 Sigma Ent. Inc. */
+	DRIVER( funkybee )	/* (c) 1982 Orca */
+	DRIVER( skylancr )	/* (c) 1983 Orca + Esco Trading Co license */
+	DRIVER( zodiack )	/* (c) 1983 Orca + Esco Trading Co license */
+	DRIVER( dogfight )	/* (c) 1983 Thunderbolt */
+	DRIVER( moguchan )	/* (c) 1982 Orca + Eastern Commerce Inc. license (doesn't appear on screen) */
+	DRIVER( percuss )	/* (c) 1981 Orca */
+	DRIVER( espial )	/* (c) 1983 Thunderbolt, Orca logo is hidden in title screen */
+	DRIVER( espiale )	/* (c) 1983 Thunderbolt, Orca logo is hidden in title screen */
+	/* Vastar was made by Orca, but when it was finished, Orca had already bankrupted. */
+	/* So they sold this game as "Made by Sesame Japan" because they couldn't use */
+	/* the name "Orca" */
+	DRIVER( vastar )	/* (c) 1983 Sesame Japan */
+	DRIVER( vastar2 )	/* (c) 1983 Sesame Japan */
+/*
+   other Orca games:
+   82 Battle Cross                         Kit 2P
+   82 River Patrol Empire Mfg/Kerstens Ind Ded 2P        HC Action
+   82 Slalom                               Kit 2P        HC Action
+   82 The Bounty                           Ded 2P
+   83 Net Wars                                 2P
+   83 Super Crush                          Kit 2P           Action
+*/
+
+	/* Gaelco games */
+	DRIVER( splash )	/* (c) 1992 Gaelco */
+/*
+Gaelco Game list:
+=================
+
+1987:	Master Boy
+1991:	Big Karnak, Master Boy 2
+1992:	Splash, Thunder Hoop, Squash
+1993:	World Rally, Glass
+1994:	Strike Back, Target Hits, Thunder Hoop 2
+1995:	Alligator Hunt, Toy, World Rally 2, Salter, Touch & Go
+1996:	Maniac Square, Snow Board, Speed Up
+1997:	Surf Planet
+1998:	Radikal Bikers
+1999:	Rolling Extreme
+
+All games newer than Splash are heavily protected.
+*/
+
+	/* Kaneko "AX System" games */
+	DRIVER( berlwall )	/* (c) 1991 Kaneko */
+	DRIVER( gtmr )		/* (c) 1994 Kaneko */
+	DRIVER( gtmralt )	/* (c) 1994 Kaneko */
+TESTDRIVER( gtmr2 )
+TESTDRIVER( shogwarr )
+
+	/* other Kaneko games */
+	DRIVER( galpanic )	/* (c) 1990 Kaneko */
+	DRIVER( airbustr )	/* (c) 1990 Kaneko */
+
+	DRIVER( pong )
+	DRIVER( spacefb )	/* (c) [1980?] Nintendo */
+	DRIVER( spacefbg )	/* 834-0031 (c) 1980 Gremlin */
+	DRIVER( spacefbb )	/* bootleg */
+	DRIVER( spacebrd )	/* bootleg */
+	DRIVER( spacedem )	/* (c) 1980 Nintendo / Fortrek */
+	DRIVER( blueprnt )	/* (c) 1982 Bally Midway (Zilec in ROM 3U, and the programmer names) */
+	DRIVER( blueprnj )	/* (c) 1982 Jaleco (Zilec in ROM 3U, and the programmer names) */
+	DRIVER( saturn )	/* (c) 1983 Jaleco (Zilec in ROM R6, and the programmer names) */
+	DRIVER( omegrace )	/* (c) 1981 Midway */
+	DRIVER( dday )		/* (c) 1982 Olympia */
+	DRIVER( ddayc )		/* (c) 1982 Olympia + Centuri license */
+	DRIVER( gundealr )	/* (c) 1990 Dooyong */
+	DRIVER( gundeala )	/* (c) Dooyong */
+	DRIVER( yamyam )	/* (c) 1990 Dooyong */
+	DRIVER( wiseguy )	/* (c) 1990 Dooyong */
+	DRIVER( leprechn )	/* (c) 1982 Tong Electronic */
+	DRIVER( potogold )	/* (c) 1982 Tong Electronic */
+	DRIVER( hexa )		/* D. R. Korea */
+	DRIVER( redalert )	/* (c) 1981 Irem (GDI game) */
+	DRIVER( irobot )	/* (c) 1983 Atari */
+	DRIVER( spiders )	/* (c) 1981 Sigma Ent. Inc. */
+	DRIVER( spiders2 )	/* (c) 1981 Sigma Ent. Inc. */
+	DRIVER( stactics )	/* [1981 Sega] */
+	DRIVER( exterm )	/* (c) 1989 Premier Technology - a Gottlieb game */
+	DRIVER( sharkatt )	/* (c) Pacific Novelty */
+	DRIVER( kingofb )	/* (c) 1985 Woodplace Inc. */
+	DRIVER( ringking )	/* (c) 1985 Data East USA */
+	DRIVER( ringkin2 )
+	DRIVER( ringkin3 )	/* (c) 1985 Data East USA */
+	DRIVER( zerozone )	/* (c) 1993 Comad */
+	DRIVER( exctsccr )	/* (c) 1983 Alpha Denshi Co. */
+	DRIVER( exctscca )	/* (c) 1983 Alpha Denshi Co. */
+	DRIVER( exctsccb )	/* bootleg */
+	DRIVER( exctscc2 )
+	DRIVER( speedbal )	/* (c) 1987 Tecfri */
+	DRIVER( sauro )		/* (c) 1987 Tecfri */
+	DRIVER( ambush )	/* (c) 1983 Nippon Amuse Co-Ltd */
+	DRIVER( starcrus )	/* [1977 Ramtek] */
+	DRIVER( shanghai )	/* (c) 1988 Sun Electronics */
+	DRIVER( goindol )	/* (c) 1987 Sun a Electronics */
+	DRIVER( homo )		/* bootleg */
+TESTDRIVER( dlair )
+	DRIVER( goldstar )	/* IGS */
+	DRIVER( goldstbl )	/* IGS */
+	DRIVER( csk227it )	/* (c) [1993] IGS */
+	DRIVER( csk234it )	/* (c) [1993] IGS */
+	DRIVER( meteor )	/* (c) 1981 Venture Line */
+	DRIVER( bjtwin )	/* (c) 1993 NMK */
+	DRIVER( aztarac )	/* (c) 1983 Centuri (vector game) */
+
+
+#endif /* NEOMAME */
+
+#ifndef NEOFREE
+
+	/* Neo Geo games */
+	/* the four digits number is the game ID stored at address 0x0108 of the program ROM */
+	DRIVER( nam1975 )	/* 0001 (c) 1990 SNK */
+	DRIVER( bstars )	/* 0002 (c) 1990 SNK */
+	DRIVER( tpgolf )	/* 0003 (c) 1990 SNK */
+	DRIVER( mahretsu )	/* 0004 (c) 1990 SNK */
+	DRIVER( maglord )	/* 0005 (c) 1990 Alpha Denshi Co */
+	DRIVER( maglordh )	/* 0005 (c) 1990 Alpha Denshi Co */
+	DRIVER( ridhero )	/* 0006 (c) 1990 SNK */
+	DRIVER( alpham2 )	/* 0007 (c) 1991 SNK */
+	/* 0008 */
+	DRIVER( ncombat )	/* 0009 (c) 1990 Alpha Denshi Co */
+	DRIVER( cyberlip )	/* 0010 (c) 1990 SNK */
+	DRIVER( superspy )	/* 0011 (c) 1990 SNK */
+	/* 0012 */
+	/* 0013 */
+	DRIVER( mutnat )	/* 0014 (c) 1992 SNK */
+	/* 0015 */
+	DRIVER( kotm )		/* 0016 (c) 1991 SNK */
+	DRIVER( sengoku )	/* 0017 (c) 1991 SNK */
+	DRIVER( sengokh )	/* 0017 (c) 1991 SNK */
+	DRIVER( burningf )	/* 0018 (c) 1991 SNK */
+	DRIVER( burningh )	/* 0018 (c) 1991 SNK */
+	DRIVER( lbowling )	/* 0019 (c) 1990 SNK */
+	DRIVER( gpilots )	/* 0020 (c) 1991 SNK */
+	DRIVER( joyjoy )	/* 0021 (c) 1990 SNK */
+	DRIVER( bjourney )	/* 0022 (c) 1990 Alpha Denshi Co */
+	DRIVER( quizdais )	/* 0023 (c) 1991 SNK */
+	DRIVER( lresort )	/* 0024 (c) 1992 SNK */
+	DRIVER( eightman )	/* 0025 (c) 1991 SNK / Pallas */
+	/* 0026 Fun Fun Brothers - prototype? */
+	DRIVER( minasan )	/* 0027 (c) 1990 Monolith Corp. */
+	/* 0028 */
+	DRIVER( legendos )	/* 0029 (c) 1991 SNK */
+	DRIVER( 2020bb )	/* 0030 (c) 1991 SNK / Pallas */
+	DRIVER( 2020bbh )	/* 0030 (c) 1991 SNK / Pallas */
+	DRIVER( socbrawl )	/* 0031 (c) 1991 SNK */
+	DRIVER( roboarmy )	/* 0032 (c) 1991 SNK */
+	DRIVER( fatfury1 )	/* 0033 (c) 1991 SNK */
+	DRIVER( fbfrenzy )	/* 0034 (c) 1992 SNK */
+	/* 0035 */
+	DRIVER( bakatono )	/* 0036 (c) 1991 Monolith Corp. */
+	DRIVER( crsword )	/* 0037 (c) 1991 Alpha Denshi Co */
+	DRIVER( trally )	/* 0038 (c) 1991 Alpha Denshi Co */
+	DRIVER( kotm2 )		/* 0039 (c) 1992 SNK */
+	DRIVER( sengoku2 )	/* 0040 (c) 1993 SNK */
+	DRIVER( bstars2 )	/* 0041 (c) 1992 SNK */
+	DRIVER( quizdai2 )	/* 0042 (c) 1992 SNK */
+	DRIVER( 3countb )	/* 0043 (c) 1993 SNK */
+	DRIVER( aof )		/* 0044 (c) 1992 SNK */
+	DRIVER( samsho )	/* 0045 (c) 1993 SNK */
+	DRIVER( tophuntr )	/* 0046 (c) 1994 SNK */
+	DRIVER( fatfury2 )	/* 0047 (c) 1992 SNK */
+	DRIVER( janshin )	/* 0048 (c) 1994 Aicom */
+	DRIVER( androdun )	/* 0049 (c) 1992 Visco */
+	DRIVER( ncommand )	/* 0050 (c) 1992 Alpha Denshi Co */
+	DRIVER( viewpoin )	/* 0051 (c) 1992 Sammy */
+	DRIVER( ssideki )	/* 0052 (c) 1992 SNK */
+	DRIVER( wh1 )		/* 0053 (c) 1992 Alpha Denshi Co */
+	/* 0054 Crossed Swords 2 (CD only) */
+	DRIVER( kof94 )		/* 0055 (c) 1994 SNK */
+	DRIVER( aof2 )		/* 0056 (c) 1994 SNK */
+	DRIVER( wh2 )		/* 0057 (c) 1993 ADK */
+	DRIVER( fatfursp )	/* 0058 (c) 1993 SNK */
+	DRIVER( savagere )	/* 0059 (c) 1995 SNK */
+	DRIVER( fightfev )	/* 0060 (c) 1994 Viccom */
+	DRIVER( ssideki2 )	/* 0061 (c) 1994 SNK */
+	DRIVER( spinmast )	/* 0062 (c) 1993 Data East Corporation */
+	DRIVER( samsho2 )	/* 0063 (c) 1994 SNK */
+	DRIVER( wh2j )		/* 0064 (c) 1994 ADK / SNK */
+	DRIVER( wjammers )	/* 0065 (c) 1994 Data East Corporation */
+	DRIVER( karnovr )	/* 0066 (c) 1994 Data East Corporation */
+	DRIVER( gururin )	/* 0067 (c) 1994 Face */
+	DRIVER( pspikes2 )	/* 0068 (c) 1994 Video System Co. */
+	DRIVER( fatfury3 )	/* 0069 (c) 1995 SNK */
+	/* 0070 */
+	/* 0071 */
+	/* 0072 */
+	DRIVER( panicbom )	/* 0073 (c) 1994 Eighting / Hudson */
+	DRIVER( aodk )		/* 0074 (c) 1994 ADK / SNK */
+	DRIVER( sonicwi2 )	/* 0075 (c) 1994 Video System Co. */
+	DRIVER( zedblade )	/* 0076 (c) 1994 NMK */
+	/* 0077 */
+	DRIVER( galaxyfg )	/* 0078 (c) 1995 Sunsoft */
+	DRIVER( strhoop )	/* 0079 (c) 1994 Data East Corporation */
+	DRIVER( quizkof )	/* 0080 (c) 1995 Saurus */
+	DRIVER( ssideki3 )	/* 0081 (c) 1995 SNK */
+	DRIVER( doubledr )	/* 0082 (c) 1995 Technos */
+	DRIVER( pbobble )	/* 0083 (c) 1994 Taito */
+	DRIVER( kof95 )		/* 0084 (c) 1995 SNK */
+	/* 0085 Shinsetsu Samurai Spirits Bushidoretsuden / Samurai Shodown RPG (CD only) */
+	DRIVER( tws96 )		/* 0086 (c) 1996 Tecmo */
+	DRIVER( samsho3 )	/* 0087 (c) 1995 SNK */
+	DRIVER( stakwin )	/* 0088 (c) 1995 Saurus */
+	DRIVER( pulstar )	/* 0089 (c) 1995 Aicom */
+	DRIVER( whp )		/* 0090 (c) 1995 ADK / SNK */
+	/* 0091 */
+	DRIVER( kabukikl )	/* 0092 (c) 1995 Hudson */
+	DRIVER( neobombe )	/* 0093 (c) 1997 Hudson */
+	DRIVER( gowcaizr )	/* 0094 (c) 1995 Technos */
+	DRIVER( rbff1 )		/* 0095 (c) 1995 SNK */
+	DRIVER( aof3 )		/* 0096 (c) 1996 SNK */
+	DRIVER( sonicwi3 )	/* 0097 (c) 1995 Video System Co. */
+	/* 0098 Idol Mahjong - final romance 2 (CD only? not confirmed, MVS might exist) */
+	/* 0099 */
+	DRIVER( turfmast )	/* 0200 (c) 1996 Nazca */
+	DRIVER( mslug )		/* 0201 (c) 1996 Nazca */
+	DRIVER( puzzledp )	/* 0202 (c) 1995 Taito (Visco license) */
+	DRIVER( mosyougi )	/* 0203 (c) 1995 ADK / SNK */
+	/* 0204 ADK World (CD only) */
+	/* 0205 Neo-Geo CD Special (CD only) */
+	DRIVER( marukodq )	/* 0206 (c) 1995 Takara */
+	DRIVER( neomrdo )	/* 0207 (c) 1996 Visco */
+	DRIVER( sdodgeb )	/* 0208 (c) 1996 Technos */
+	DRIVER( goalx3 )	/* 0209 (c) 1995 Visco */
+	/* 0210 */
+	/* 0211 Oshidashi Zintrick (CD only? not confirmed, MVS might exist) */
+	DRIVER( overtop )	/* 0212 (c) 1996 ADK */
+	DRIVER( neodrift )	/* 0213 (c) 1996 Visco */
+	DRIVER( kof96 )		/* 0214 (c) 1996 SNK */
+	DRIVER( ssideki4 )	/* 0215 (c) 1996 SNK */
+	DRIVER( kizuna )	/* 0216 (c) 1996 SNK */
+	DRIVER( ninjamas )	/* 0217 (c) 1996 ADK / SNK */
+	DRIVER( ragnagrd )	/* 0218 (c) 1996 Saurus */
+	DRIVER( pgoal )		/* 0219 (c) 1996 Saurus */
+	/* 0220 Choutetsu Brikin'ger - iron clad (CD only? not confirmed, MVS might exist) */
+	DRIVER( magdrop2 )	/* 0221 (c) 1996 Data East Corporation */
+	DRIVER( samsho4 )	/* 0222 (c) 1996 SNK */
+	DRIVER( rbffspec )	/* 0223 (c) 1996 SNK */
+	DRIVER( twinspri )	/* 0224 (c) 1996 ADK */
+	DRIVER( wakuwak7 )	/* 0225 (c) 1996 Sunsoft */
+	/* 0226 */
+	DRIVER( stakwin2 )	/* 0227 (c) 1996 Saurus */
+	/* 0228 */
+	/* 0229 King of Fighters '96 CD Collection (CD only) */
+	DRIVER( breakers )	/* 0230 (c) 1996 Visco */
+	DRIVER( miexchng )	/* 0231 (c) 1997 Face */
+	DRIVER( kof97 )		/* 0232 (c) 1997 SNK */
+	DRIVER( magdrop3 )	/* 0233 (c) 1997 Data East Corporation */
+	DRIVER( lastblad )	/* 0234 (c) 1997 SNK */
+	DRIVER( puzzldpr )	/* 0235 (c) 1997 Taito (Visco license) */
+	DRIVER( irrmaze )	/* 0236 (c) 1997 SNK / Saurus */
+	DRIVER( popbounc )	/* 0237 (c) 1997 Video System Co. */
+	DRIVER( shocktro )	/* 0238 (c) 1997 Saurus */
+	DRIVER( blazstar )	/* 0239 (c) 1998 Yumekobo */
+	DRIVER( rbff2 )		/* 0240 (c) 1998 SNK */
+	DRIVER( mslug2 )	/* 0241 (c) 1998 SNK */
+	DRIVER( kof98 )		/* 0242 (c) 1998 SNK */
+	DRIVER( lastbld2 )	/* 0243 (c) 1998 SNK */
+	DRIVER( neocup98 )	/* 0244 (c) 1998 SNK */
+	DRIVER( breakrev )	/* 0245 (c) 1998 Visco */
+	DRIVER( shocktr2 )	/* 0246 (c) 1998 Saurus */
+	DRIVER( flipshot )	/* 0247 (c) 1998 Visco */
+TESTDRIVER( pbobbl2n )	/* 0248 (c) 1999 Taito (SNK license) */
+TESTDRIVER( ctomaday )	/* 0249 (c) 1999 Visco */
+TESTDRIVER( mslugx )	/* 0250 (c) 1999 SNK */
+TESTDRIVER( kof99 )		/* 0251 (c) 1999 SNK */
+
+#endif	/* NEOFREE */
+
+#endif /* force tiny compile */
+
+#endif	/* DRIVER_RECURSIVE */
+
+#endif	/* TINY_COMPILE */
diff -Naur ../mmmmm/m36b16/src/unix/arch-defines-used.txt mame-0.36b16/src/unix/arch-defines-used.txt
--- ../mmmmm/m36b16/src/unix/arch-defines-used.txt	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/arch-defines-used.txt	2023-07-07 14:20:22.688001896 -0400
@@ -0,0 +1,9 @@
+src/unix/joystick-drivers/joy_i386.c:#elif defined __ARCH_linux
+src/unix/video-drivers/svgalib.c:#ifdef __CPU_i386
+src/unix/video-drivers/svgalib.c:#endif /* ifdef __CPU_i386 */
+src/unix/video-drivers/svgalib.c:#ifdef __CPU_i386
+src/unix/video-drivers/svgalib.c:#ifdef __CPU_i386
+src/unix/sysdep/dsp-drivers/oss.c:#ifdef __ARCH_freebsd
+src/unix/joystick-drivers/joy_i386.c:#ifdef __ARCH_netbsd
+src/unix/joystick-drivers/joy_i386.c:#ifdef __ARCH_netbsd
+src/unix/joystick-drivers/joy_i386.c:#ifdef __ARCH_netbsd
diff -Naur ../mmmmm/m36b16/src/unix/config.c mame-0.36b16/src/unix/config.c
--- ../mmmmm/m36b16/src/unix/config.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/config.c	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,665 @@
+/*
+ * X-mame config-file and commandline parsing
+ * We don't use stderr_file resp stdout_file in here since we don't know if 
+ * it's valid yet.
+ */
+
+#define __CONFIG_C_
+#include <time.h>
+#include "xmame.h"
+#include "driver.h"
+#include "audit.h"
+#include "sysdep/sysdep_dsp.h"
+#include "sysdep/sysdep_mixer.h"
+#include "sysdep/misc.h"
+
+/* from ... */
+extern char *cheatfile;
+//RB: extern char *db_filename;
+extern char *history_filename;
+extern char *mameinfo_filename;
+
+/* some local vars */
+static int showconfig = 0;
+static int showmanusage = 0;
+static int showversion = 0;
+static int showusage  = 0;
+static int use_fuzzycmp = 1;
+static int loadconfig = 1;
+static char *language = NULL;
+static char *gamename = NULL;
+#ifndef MESS
+static char *defaultgamename;
+#else
+static int iodevice_type = 0;
+static char crcfilename[BUF_SIZE] = "";
+const char *crcfile = crcfilename;
+static char pcrcfilename[BUF_SIZE] = "";
+const char *pcrcfile = pcrcfilename;
+#endif
+static struct rc_struct *rc;
+
+static int config_handle_arg(char *arg);
+static int config_handle_debug_size(struct rc_option *option, const char *arg,
+   int priority);
+void show_usage(void);
+
+/* struct definitions */
+static struct rc_option opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { NULL,		NULL,			rc_link,	video_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL,		NULL,			rc_link,	sound_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL,		NULL,			rc_link,	input_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL,		NULL,			rc_link,	network_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL,		NULL,			rc_link,	fileio_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+#ifdef MESS
+   { "Mess Related",	NULL,			rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "rom",		"cart",			rc_set_int,	&iodevice_type,
+     NULL,		IO_CARTSLOT,		0,		NULL,
+     "All following images/roms are seen as carts/roms" }, 
+   { "floppy",		NULL,			rc_set_int,	&iodevice_type,
+     NULL,		IO_FLOPPY,		0,		NULL,
+     "All following images/roms are seen as floppies" }, 
+   { "casette",		NULL,			rc_set_int,	&iodevice_type,
+     NULL,		IO_CASSETTE,		0,		NULL,
+     "All following images/roms are seen as casettes" }, 
+   { "printer",		NULL,			rc_set_int,	&iodevice_type,
+     NULL,		IO_PRINTER,		0,		NULL,
+     "All following images/roms are seen as carts/roms" }, 
+   { "serial",		NULL,			rc_set_int,	&iodevice_type,
+     NULL,		IO_SERIAL,		0,		NULL,
+     "All following images/roms are seen as serial ports??" }, 
+   { "snapshot",        NULL,                   rc_set_int,     &iodevice_type,
+     NULL,              IO_SNAPSHOT,            0,              NULL,
+     "All following images/roms are seen as snapshots" },
+#else
+   { "Mame Related",	NULL,			rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "defaultgame",	"def",			rc_string,	&defaultgamename,
+     "pacman",		0,			0,		NULL,
+     "Set the default game started when no game is given on the commandline, only usefull for in the configfiles" },
+#endif
+   { "language",	"lang",			rc_string,	&language,
+     "english",		0,			0,		NULL,
+     "Select the language for the menu's and osd" },
+   { "fuzzycmp",	"fc",			rc_bool,	&use_fuzzycmp,
+     "1",		0,			0,		NULL,
+     "Enable/disable use of fuzzy gamename matching when there is no exact match" },
+   { "cheat",		"c",			rc_bool,	&options.cheat,
+     "0",		0,			0,		NULL,
+     "Enable/disable cheat subsystem" },
+#ifdef MAME_DEBUG     
+   { "debug",		"d",			rc_bool,	&options.mame_debug,
+     NULL,		0,			0,		NULL,
+     "Enable/disable debugger" },
+   { "debug-size",	"ds",			rc_use_function, NULL,
+     "640x480",		0,			0,		config_handle_debug_size,
+     "Specify the resolution/ windowsize to use for the debugger(window) in the form of XRESxYRES (minimum size = 640x480)" },
+#endif
+   { NULL,		NULL,			rc_link,	frontend_list_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL,		NULL,			rc_link,	frontend_ident_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "General Options",	NULL,			rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "loadconfig",	"lc",			rc_bool,	&loadconfig,
+     "1",		0,			0,		NULL,
+     "Load (don't load) configfiles" },
+   { "showconfig",	"sc",			rc_set_int,	&showconfig,
+     NULL,		1,			0,		NULL,
+     "Display Running parameters in rc style" },
+   { "manhelp",		"mh",			rc_set_int,	&showmanusage,
+     NULL,		1,			0,		NULL,
+     "Print commandline help in man format, usefull for manpage creation" },
+   { "version",		"V",			rc_set_int,	&showversion,
+     NULL,		1,			0,		NULL,
+     "Display version" },
+   { "help",		"?",			rc_set_int,	&showusage,
+     NULL,		1,			0,		NULL,
+     "Show this help" },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+/* fuzzy string compare, compare short string against long string        */
+/* e.g. astdel == "Asteroids Deluxe". The return code is the fuzz index, */
+/* we simply count the gaps between maching chars.                       */
+static int fuzzycmp (const char *s, const char *l)
+{
+   int gaps = 0;
+   int match = 0;
+   int last = 1;
+
+   for (; *s && *l; l++)
+   {
+       if (*s == *l)
+           match = 1;
+       else if (*s >= 'a' && *s <= 'z' && (*s - 'a') == (*l - 'A'))
+           match = 1;
+       else if (*s >= 'A' && *s <= 'Z' && (*s - 'A') == (*l - 'a'))
+           match = 1;
+       else
+           match = 0;
+
+       if (match)
+           s++;
+
+       if (match != last)
+       {
+           last = match;
+           if (!match)
+               gaps++;
+       }
+   }
+
+   /* penalty if short string does not completely fit in */
+   for (; *s; s++)
+       gaps++;
+
+   return gaps;
+}
+
+/* for verify roms which is used for the random game selection */
+static int config_printf(const char *fmt, ...)
+{
+   return 0;
+}
+
+static int config_handle_arg(char *arg)
+{
+   static int got_gamename = 0;
+   
+   if (!got_gamename) /* notice: for MESS game means system */
+   {
+      gamename     = arg;
+      got_gamename = 1;
+   }
+   else
+#ifdef MESS
+   {
+      if( options.image_count >= MAX_IMAGES )
+      {
+         fprintf(stderr, "error: too many image names specified!\n");
+         return -1;
+      }
+      options.image_files[options.image_count].type = iodevice_type;
+      options.image_files[options.image_count].name = arg;
+      options.image_count++;
+   }
+#else
+   {
+      fprintf(stderr,"error: duplicate gamename: %s\n", arg);
+      return -1;
+   }
+#endif
+
+   return 0;
+}
+
+#if 0 /* RB */
+static int config_handle_debug_size(struct rc_option *option, const char *arg,
+   int priority)
+{
+  int width, height;
+  
+  if (sscanf(arg, "%dx%d", &width, &height) == 2)
+  {
+     if((width >= 640) && (height >= 480))
+     {
+        options.debug_width  = width;
+        options.debug_height = height;
+        return 0;
+     }
+  }
+  fprintf(stderr,
+      "error: invalid debugger size or too small (minimum size = 640x480): \"%s\".\n",
+      arg);
+  return -1;
+}
+#endif /* RB */
+
+/*
+ * get configuration from configfile and env.
+ */
+int config_init (int argc, char *argv[])
+{
+   char buffer[BUF_SIZE];
+   unsigned char lsb_test[2]={0,1};
+   INP_HEADER inp_header;
+   int i;
+   
+   memset(&options,0,sizeof(options));
+   
+   /* Lett's see of the endians of this arch is correct otherwise
+      YELL about it and bail out. */
+#ifdef LSB_FIRST
+   if(*((unsigned short*)lsb_test) != 0x0100)
+#else	
+   if(*((unsigned short*)lsb_test) != 0x0001)
+#endif
+   {
+      fprintf(stderr, "error: compiled byte ordering doesn't match machine byte ordering\n"
+         "are you sure you choose the right arch?\n"
+#ifdef LSB_FIRST
+         "compiled for lsb-first, are you sure you choose the right cpu in makefile.unix\n");
+#else
+         "compiled for msb-first, are you sure you choose the right cpu in makefile.unix\n");
+#endif
+      return OSD_NOT_OK;
+   }
+
+   /* some settings which are static for xmame and thus aren't controled
+      by options */
+   options.use_emulated_ym3812 = TRUE;
+   options.gui_host = 1;
+   cheatfile = NULL;
+//RB:   db_filename = NULL;
+   history_filename = NULL;
+   mameinfo_filename = NULL;
+
+   /* create the rc object */
+   if (!(rc = rc_create()))
+      return OSD_NOT_OK;
+      
+   if(sysdep_dsp_init(rc, NULL))
+      return OSD_NOT_OK;
+      
+   if(sysdep_mixer_init(rc, NULL))
+      return OSD_NOT_OK;
+      
+   if(rc_register(rc, opts))
+      return OSD_NOT_OK;
+   
+   /* get the homedir */
+   if(!(home_dir = rc_get_home_dir()))
+      return OSD_NOT_OK;
+   
+   /* check the nescesarry dirs exist, and create them if nescesarry */
+   snprintf(buffer, BUF_SIZE, "%s/.%s", home_dir, NAME);
+   if (rc_check_and_create_dir(buffer))
+      return OSD_NOT_OK;
+   snprintf(buffer, BUF_SIZE, "%s/.%s/%s", home_dir, NAME, "cfg");
+   if (rc_check_and_create_dir(buffer))
+      return OSD_NOT_OK;
+   snprintf(buffer, BUF_SIZE, "%s/.%s/%s", home_dir, NAME, "mem");
+   if (rc_check_and_create_dir(buffer))
+      return OSD_NOT_OK;
+   snprintf(buffer, BUF_SIZE, "%s/.%s/%s", home_dir, NAME, "sta");
+   if (rc_check_and_create_dir(buffer))
+      return OSD_NOT_OK;
+   snprintf(buffer, BUF_SIZE, "%s/.%s/%s", home_dir, NAME, "nvram");
+   if (rc_check_and_create_dir(buffer))
+      return OSD_NOT_OK;
+   snprintf(buffer, BUF_SIZE, "%s/.%s/%s", home_dir, NAME, "rc");
+   
+   /* parse the commandline */
+   if (rc_parse_commandline(rc, argc, argv, 2, config_handle_arg))
+      return OSD_NOT_OK;
+      
+   /* parse the various configfiles, starting with the one with the
+      lowest priority */
+   if(loadconfig)
+   {
+      snprintf(buffer, BUF_SIZE, "%s/%src", XMAMEROOT, NAME);
+      if(rc_load(rc, buffer, 1, 1))
+         return OSD_NOT_OK;
+      snprintf(buffer, BUF_SIZE, "%s/.%s/%src", home_dir, NAME, NAME);
+      if(rc_load(rc, buffer, 1, 1))
+         return OSD_NOT_OK;
+      snprintf(buffer, BUF_SIZE, "%s/%s-%src", XMAMEROOT, NAME, DISPLAY_METHOD);
+      if(rc_load(rc, buffer, 1, 1))
+         return OSD_NOT_OK;
+      snprintf(buffer, BUF_SIZE, "%s/.%s/%s-%src", home_dir, NAME, NAME,
+         DISPLAY_METHOD);
+      if(rc_load(rc, buffer, 1, 1))
+         return OSD_NOT_OK;
+   }
+   
+   /* setup stderr_file and stdout_file */
+   if (!stderr_file) stderr_file = stderr;
+   if (!stdout_file) stdout_file = stdout;
+   
+   if (showconfig)
+   {
+      rc_write(rc, stdout_file, NAME" running parameters");
+      return OSD_OK;
+   }
+   
+   if (showmanusage)
+   {
+      rc_print_man_options(rc, stdout_file);
+      return OSD_OK;
+   }
+   
+   if (showversion)
+   {
+      fprintf(stdout_file, "%s\n", title);
+      return OSD_OK;
+   }
+
+   if (showusage)
+   {
+      show_usage();
+      return OSD_OK;
+   }
+   
+   /* must be done after showconfig, since this modifies the rompath rc_string,
+      but before any of the frontend options are handled */
+   init_rom_path();
+
+   /* handle frontend options */
+   if ( (i=frontend_list(gamename)) != 1234)
+      return i;
+   
+   if ( (i=frontend_ident(gamename)) != 1234)
+      return i;
+   
+   if (options.playback)
+   {
+      /* read the playback header */
+      osd_fread(options.playback, &inp_header, sizeof(INP_HEADER));
+      if (!isalnum(inp_header.name[0]))
+      {
+         /* old .inp file - no header */
+         osd_fseek(options.playback, 0, SEEK_SET); 
+         if(!gamename)
+         {
+            fprintf(stderr_file, "error: old type .inp file and no game specified\n");
+            return OSD_NOT_OK;
+         }
+      }
+      else
+      {
+         if(gamename)
+         {
+            if(strcmp(gamename, inp_header.name))
+            {
+               fprintf(stderr_file, "Error: Input file is for a different game as specified\n");
+               return OSD_NOT_OK;
+            }
+            else
+               fprintf(stderr_file, "Hint: with new .inp files you don't have to specify a game anymore\n");
+         }
+         gamename = inp_header.name;
+      }
+   }
+   
+   /* handle the game selection */
+   game_index = -1;
+
+   if (!gamename)
+#ifdef MESS
+   {
+      show_usage();
+      return OSD_NOT_OK;
+   }
+#else
+      gamename = defaultgamename;
+
+   /* random game? */
+   if (strcasecmp(gamename, "random") == 0)
+   {
+      for (i=0; drivers[i]; i++) ; /* count available drivers */
+
+      srand(time(NULL));
+      
+      for(;;)
+      {
+         game_index = (float)rand()*i/RAND_MAX;
+      
+         fprintf(stdout_file, "Random game selected: %s (%s)\n  verifying roms... ",drivers[game_index]->name,drivers[game_index]->description);
+         if(VerifyRomSet (game_index, (verify_printf_proc)config_printf) == CORRECT)
+         {
+            fprintf(stdout_file, "OK\n");
+            break;
+         }
+         else
+            fprintf(stdout_file, "FAILED\n");
+      }
+   }
+   else
+#endif
+   /* do we have a driver for this? */
+   for (i = 0; drivers[i]; i++)
+      if (strcasecmp(gamename,drivers[i]->name) == 0)
+      {
+         game_index = i;
+         break;
+      }
+
+   /* educated guess on what the user wants to play */
+   if ( (game_index == -1) && use_fuzzycmp)
+   {
+       int fuzz = 9999; /*best fuzz factor so far*/
+
+       for (i = 0; (drivers[i] != 0); i++)
+       {
+           int tmp;
+           tmp = fuzzycmp(gamename, drivers[i]->description);
+           /* continue if the fuzz index is worse */
+           if (tmp > fuzz)
+               continue;
+           /* on equal fuzz index, we prefear working, original games */
+           if (tmp == fuzz)
+           {
+               /* game is a clone */
+               if (drivers[i]->clone_of != 0 && !(drivers[i]->clone_of->flags & NOT_A_DRIVER))
+               {
+                   if ((!drivers[game_index]->flags & GAME_NOT_WORKING) || (drivers[i]->flags & GAME_NOT_WORKING))
+                       continue;
+               }
+               else continue;
+           }
+
+
+           /* we found a better match */
+           game_index = i;
+           fuzz = tmp;
+       }
+
+       if (game_index != -1)
+           fprintf(stdout_file,
+              "fuzzy name compare, running %s\n", drivers[game_index]->name);
+   }
+
+   if (game_index == -1)
+   {
+      fprintf(stderr_file, "\"%s\" not supported\n", gamename);
+      return OSD_NOT_OK;
+   }
+   
+   /* now that we've got the gamename parse the game specific configfile */
+   if (loadconfig)
+   {
+      snprintf(buffer, BUF_SIZE, "%s/rc/%src", XMAMEROOT,
+         drivers[game_index]->name);
+      if(rc_load(rc, buffer, 1, 1))
+         return OSD_NOT_OK;
+      snprintf(buffer, BUF_SIZE, "%s/.%s/rc/%src", home_dir, NAME,
+         drivers[game_index]->name);
+      if(rc_load(rc, buffer, 1, 1))
+         return OSD_NOT_OK;
+   }
+   
+#ifdef MESS
+   /* Build the CRC database filename */
+   snprintf(crcfilename, BUF_SIZE, "%s/%s.crc", crcdir, drivers[game_index]->name);
+   if(drivers[game_index]->clone_of &&
+      !(drivers[game_index]->clone_of->flags & NOT_A_DRIVER) &&
+      drivers[game_index]->clone_of->name)
+   {
+      snprintf(pcrcfilename, BUF_SIZE, "%s/%s.crc", crcdir,
+         drivers[game_index]->clone_of->name);
+   }
+   
+   /* set the image type if nescesarry */
+   for(i=0; i<options.image_count; i++)
+   {
+      if(options.image_files[i].type)
+      {
+         logerror("User specified %s for %s\n",
+               device_typename(options.image_files[i].type),
+               options.image_files[i].name);
+      }
+      else
+      {
+         char *ext;
+         char name[BUF_SIZE];
+         
+         /* make a copy of the name */
+         strncpy(name, options.image_files[i].name, BUF_SIZE);
+         /* strncpy is buggy */
+         name[BUF_SIZE-1]=0;
+         
+         /* get ext, skip .gz */
+         ext = strrchr(name, '.');
+         if( ext && !strcmp(ext, ".gz") )
+         {
+            *ext = 0;
+            ext = strrchr(name, '.');
+         }
+         
+         /* Look up the filename extension in the drivers device list */
+         if(ext && drivers[game_index]->dev)
+         {
+            const struct IODevice *dev = drivers[game_index]->dev;
+            
+            ext++; /* skip the "." */
+            
+            while (dev->type != IO_END)
+            {
+               const char *dst = dev->file_extensions;
+               /* scan supported extensions for this device */
+               while (dst && *dst)
+               {
+                  if (strcasecmp(dst,ext) == 0)
+                  {
+                     logerror("Extension match %s [%s] for %s\n",
+                           device_typename(dev->type), dst,
+                           options.image_files[i].name);
+                           
+                     options.image_files[i].type = dev->type;
+                  }
+                  /* skip '\0' once in the list of extensions */
+                  dst += strlen(dst) + 1;
+               }
+               dev++;
+            }
+         }
+         if(!options.image_files[i].type)
+            options.image_files[i].type = IO_CARTSLOT;
+      }
+   }
+#endif
+   
+   if (options.record)
+   {
+      memset(&inp_header, '\0', sizeof(INP_HEADER));
+      strcpy(inp_header.name, drivers[game_index]->name);
+      /* MAME32 stores the MAME version numbers at bytes 9 - 11
+       * MAME DOS and xmame keeps this information in a rc_string, the
+       * Windows code defines them in the Makefile.
+      inp_header.version[0] = 0;
+      inp_header.version[1] = VERSION;
+      inp_header.version[2] = BETA_VERSION;
+      */
+      osd_fwrite(options.record, &inp_header, sizeof(INP_HEADER));
+   }
+#if 0 /* RB */
+   if(language)
+      options.language_file = osd_fopen(0,language,OSD_FILETYPE_LANGUAGE,0);
+#endif
+   return 1234;
+}
+
+void config_exit(void)
+{
+   if(rc)
+   {
+      sysdep_mixer_exit();
+      sysdep_dsp_exit();
+      rc_destroy(rc);
+   }
+   
+   if(home_dir)
+      free(home_dir);
+      
+   /* close open files */
+   if (options.playback) osd_fclose (options.playback);
+   if (options.record)   osd_fclose (options.record);
+#if 0 /* RB */
+   if (options.language_file) osd_fclose (options.language_file);
+#endif
+}
+
+/* 
+ * show help and exit
+ */
+void show_usage(void) 
+{
+  /* header */
+  fprintf(stdout_file, 
+#ifdef MESS
+     "Usage: xmess <system> [game] [options]\n"
+#else
+     "Usage: xmame [game] [options]\n"
+#endif 
+     "Options:\n");
+  
+  /* actual help message */
+  rc_print_help(rc, stdout_file);
+  
+  /* footer */
+  fprintf(stdout_file, "\nFiles:\n\n");
+  fprintf(stdout_file, "Config Files are parsed in the following order:\n");
+  fprint_colums(stdout_file, XMAMEROOT"/"NAME"rc",
+     "Global configuration config file");
+  fprint_colums(stdout_file, "${HOME}/."NAME"/"NAME"rc",
+     "User configuration config file");
+  fprint_colums(stdout_file, XMAMEROOT"/"NAME"-"DISPLAY_METHOD"rc",
+     "Global per display method config file");
+  fprint_colums(stdout_file, "${HOME}/."NAME"/"NAME"-"DISPLAY_METHOD"rc",
+     "User per display method config file");
+  fprint_colums(stdout_file, XMAMEROOT"/rc/<game>rc",
+     "Global per game config file");
+  fprint_colums(stdout_file, "${HOME}/."NAME"/rc/<game>rc",
+     "User per game config file");
+/*  fprintf(stdout_file, "\nEnvironment variables:\n\n");
+  fprint_colums(stdout_file, "ROMPATH", "Rom search path"); */
+  fprintf(stdout_file, "\n"
+#ifdef MESS
+     "M.E.S.S. - Multi-Emulator Super System\n"
+     "Copyright (C) 1998-2000 by the MESS team\n"
+#else
+     "M.A.M.E. - Multiple Arcade Machine Emulator\n"
+     "Copyright (C) 1997-2000 by Nicola Salmoria and the MAME Team\n"
+#endif
+     "%s port maintained by Hans de Goede\n", NAME);
+}
+
+#ifdef MESS
+/* Function to handle Aliases in the MESS.CFG file */
+char* get_alias(const char *driver_name, char *argv)
+{
+	/* we don't do aliases, feel free to write support for it if you want
+	   it */
+	return NULL;
+}
+#endif
diff -Naur ../mmmmm/m36b16/src/unix/ddribble.patch mame-0.36b16/src/unix/ddribble.patch
--- ../mmmmm/m36b16/src/unix/ddribble.patch	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/ddribble.patch	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,28 @@
+diff -ur mame-0.37b5.orig.fixed/src/drivers/ddrible.c xmame-0.37b5.1/src/drivers/ddrible.c
+--- mame-0.37b5.orig.fixed/src/drivers/ddrible.c	Fri Aug 25 19:25:58 2000
++++ xmame-0.37b5.1/src/drivers/ddrible.c	Tue Aug 22 10:29:22 2000
+@@ -10,8 +10,8 @@
+ #include "cpu/m6809/m6809.h"
+ #include "vidhrdw/generic.h"
+ 
+-extern int ddrible_int_enable_0;
+-extern int ddrible_int_enable_1;
++int ddrible_int_enable_0;
++int ddrible_int_enable_1;
+ 
+ static unsigned char *ddrible_sharedram;
+ static unsigned char *ddrible_snd_sharedram;
+diff -ur mame-0.37b5.orig.fixed/src/machine/ddrible.c xmame-0.37b5.1/src/machine/ddrible.c
+--- mame-0.37b5.orig.fixed/src/machine/ddrible.c	Fri Aug 25 19:25:56 2000
++++ xmame-0.37b5.1/src/machine/ddrible.c	Tue Aug 22 10:29:22 2000
+@@ -12,7 +12,9 @@
+ 
+ unsigned char *ddrible_sharedram;
+ unsigned char *ddrible_snd_sharedram;
+-int ddrible_int_enable_0, ddrible_int_enable_1;
++
++extern int ddrible_int_enable_0;
++extern int ddrible_int_enable_1;
+ 
+ void ddrible_init_machine( void )
+ {
diff -Naur ../mmmmm/m36b16/src/unix/devices.c mame-0.36b16/src/unix/devices.c
--- ../mmmmm/m36b16/src/unix/devices.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/devices.c	2023-07-07 14:20:22.688001896 -0400
@@ -0,0 +1,393 @@
+/*
+ * file devices.c
+ *
+ * Routines for Pointers device processing
+ *
+ * Joystick and Mouse
+ *
+ * original idea from Chris Sharp <sharp@uk.ibm.com>
+ *
+ */
+
+#define __DEVICES_C_
+#include "xmame.h"
+#include "devices.h"
+#include "input.h"
+#include "keyboard.h"
+
+/* local variables */
+static struct JoystickInfo joy_list[JOY_LIST_LEN+MOUSE_LIST_LEN+1];
+/* will be used to store names for the above */
+static char joy_list_names[JOY_LIST_LEN+MOUSE_LIST_LEN][JOY_NAME_LEN];
+static int analogstick = 0;
+
+/* input relelated options */
+struct rc_option input_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "Input Related",	NULL,			rc_seperator,	NULL,
+      NULL,		0,			0,		NULL,
+      NULL },
+   { "joytype",		"jt",			rc_int,		&joytype,
+      "0",      	0,			5,		NULL,
+      "Select type of joysticksupport to use:\n0 No joystick\n1 i386 style joystick driver (if compiled in)\n2 Fm Town Pad support (if compiled in)\n3 X11 input extension joystick (if compiled in)\n4 new i386 linux 1.x.x joystick driver(if compiled in)\n5 NetBSD USB joystick driver (if compiled in)" },
+   { "analogstick",	"as",			rc_bool,	&analogstick,
+     "0",		0,			0,		NULL,
+     "Use Joystick as analog for analog controls" },
+   { NULL,		NULL,			rc_link,	joy_i386_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL,		NULL,			rc_link,	joy_pad_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL,		NULL,			rc_link,	joy_x11_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL,		NULL,			rc_link,	joy_usb_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "mouse",		"m",			rc_bool,	&use_mouse,
+     "1",		0,			0,		NULL,
+     "Enable/disable mouse (if supported)" },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+
+static int joy_list_equiv[][2] =
+{
+	{ JOY_AXIS_CODE(0,0,0), JOYCODE_1_LEFT },
+	{ JOY_AXIS_CODE(0,0,1), JOYCODE_1_RIGHT },
+	{ JOY_AXIS_CODE(0,1,0), JOYCODE_1_UP },
+	{ JOY_AXIS_CODE(0,1,1), JOYCODE_1_DOWN },
+	{ JOY_BUTTON_CODE(0,0), JOYCODE_1_BUTTON1 },
+	{ JOY_BUTTON_CODE(0,1), JOYCODE_1_BUTTON2 },
+	{ JOY_BUTTON_CODE(0,2), JOYCODE_1_BUTTON3 },
+	{ JOY_BUTTON_CODE(0,3), JOYCODE_1_BUTTON4 },
+	{ JOY_BUTTON_CODE(0,4), JOYCODE_1_BUTTON5 },
+	{ JOY_BUTTON_CODE(0,5), JOYCODE_1_BUTTON6 },
+	{ JOY_AXIS_CODE(1,0,0), JOYCODE_2_LEFT },
+	{ JOY_AXIS_CODE(1,0,1), JOYCODE_2_RIGHT },
+	{ JOY_AXIS_CODE(1,1,0), JOYCODE_2_UP },
+	{ JOY_AXIS_CODE(1,1,1), JOYCODE_2_DOWN },
+	{ JOY_BUTTON_CODE(1,0), JOYCODE_2_BUTTON1 },
+	{ JOY_BUTTON_CODE(1,1), JOYCODE_2_BUTTON2 },
+	{ JOY_BUTTON_CODE(1,2), JOYCODE_2_BUTTON3 },
+	{ JOY_BUTTON_CODE(1,3), JOYCODE_2_BUTTON4 },
+	{ JOY_BUTTON_CODE(1,4), JOYCODE_2_BUTTON5 },
+	{ JOY_BUTTON_CODE(1,5), JOYCODE_2_BUTTON6 },
+	{ JOY_AXIS_CODE(2,0,0), JOYCODE_3_LEFT },
+	{ JOY_AXIS_CODE(2,0,1), JOYCODE_3_RIGHT },
+	{ JOY_AXIS_CODE(2,1,0), JOYCODE_3_UP },
+	{ JOY_AXIS_CODE(2,1,1), JOYCODE_3_DOWN },
+	{ JOY_BUTTON_CODE(2,0), JOYCODE_3_BUTTON1 },
+	{ JOY_BUTTON_CODE(2,1), JOYCODE_3_BUTTON2 },
+	{ JOY_BUTTON_CODE(2,2), JOYCODE_3_BUTTON3 },
+	{ JOY_BUTTON_CODE(2,3), JOYCODE_3_BUTTON4 },
+	{ JOY_BUTTON_CODE(2,4), JOYCODE_3_BUTTON5 },
+	{ JOY_BUTTON_CODE(2,5), JOYCODE_3_BUTTON6 },
+	{ JOY_AXIS_CODE(3,0,0), JOYCODE_4_LEFT },
+	{ JOY_AXIS_CODE(3,0,1), JOYCODE_4_RIGHT },
+	{ JOY_AXIS_CODE(3,1,0), JOYCODE_4_UP },
+	{ JOY_AXIS_CODE(3,1,1), JOYCODE_4_DOWN },
+	{ JOY_BUTTON_CODE(3,0), JOYCODE_4_BUTTON1 },
+	{ JOY_BUTTON_CODE(3,1), JOYCODE_4_BUTTON2 },
+	{ JOY_BUTTON_CODE(3,2), JOYCODE_4_BUTTON3 },
+	{ JOY_BUTTON_CODE(3,3), JOYCODE_4_BUTTON4 },
+	{ JOY_BUTTON_CODE(3,4), JOYCODE_4_BUTTON5 },
+	{ JOY_BUTTON_CODE(3,5), JOYCODE_4_BUTTON6 },
+	{ 0,0 }
+};
+
+/* 2 init routines one for creating the display and one after that, since some
+   (most) init stuff needs a display */
+
+int osd_input_initpre (void)
+{
+   int i, j, k, joy_list_count = 0;
+   
+   joy_poll_func = NULL;
+   
+   memset(joy_data,   0, sizeof(joy_data));
+   memset(mouse_data, 0, sizeof(mouse_data));
+   
+   for(i=0; i<JOY; i++)
+   {
+      joy_data[i].fd = -1;
+      for(j=0; j<JOY_AXIS; j++)
+      {
+         joy_data[i].axis[j].min = -10;
+         joy_data[i].axis[j].max =  10;
+         for(k=0; k<JOY_DIRS; k++)
+         {
+            snprintf(joy_list_names[joy_list_count], JOY_NAME_LEN,
+               "Joy %d axis %d %s", i+1, j+1, (k)? "pos":"neg");
+            joy_list_count++;
+         }
+      }
+      for(j=0; j<JOY_BUTTONS; j++)
+      {
+         snprintf(joy_list_names[joy_list_count], JOY_NAME_LEN,
+            "Joy %d button %d", i+1 ,j+1);
+         joy_list_count++;
+      }
+   }
+   
+   for(i=0; i<MOUSE; i++)
+   {
+      for(j=0; j<MOUSE_BUTTONS; j++)
+      {
+         snprintf(joy_list_names[joy_list_count], JOY_NAME_LEN,
+            "Mouse %d button %d", i+1, j+1);
+         joy_list_count++;
+      }
+   }
+   
+   /* terminate array */
+   joy_list[joy_list_count].name = 0;
+   joy_list[joy_list_count].code = 0;
+   joy_list[joy_list_count].standardcode = 0;
+   
+   /* fill in codes */
+   for (i=0; i<joy_list_count; i++)
+   {
+      joy_list[i].code = i;
+      joy_list[i].name = joy_list_names[i];
+      joy_list[i].standardcode = JOYCODE_OTHER;
+
+      for(j=0; joy_list_equiv[j][1]; j++)
+      {
+         if (joy_list_equiv[j][0] == joy_list[i].code)
+         {
+            joy_list[i].standardcode = joy_list_equiv[j][1];
+            break;
+         }
+      }
+   }
+   
+   if (use_mouse)
+      fprintf (stderr_file, "Mouse/Trakball selected.\n");
+   
+   return OSD_OK;
+}
+
+int osd_input_initpost (void)
+{
+   int i;
+   
+   /* init the keyboard */
+   if (keyboard_init())
+      return OSD_NOT_OK;
+   
+   /* joysticks */
+   switch (joytype)
+   {
+      case JOY_NONE:
+         break;
+#ifdef I386_JOYSTICK
+      case JOY_I386NEW:
+      case JOY_I386:
+         joy_i386_init();
+         break;
+#endif
+#ifdef LIN_FM_TOWNS
+      case JOY_PAD:
+         joy_pad_init ();
+         break;
+#endif
+#ifdef X11_JOYSTICK
+      case JOY_X11:
+         joy_x11_init();
+         break;
+#endif
+#ifdef USB_JOYSTICK
+      case JOY_USB:
+         joy_usb_init();
+         break;
+#endif
+      default:
+         fprintf (stderr_file, "OSD: Warning: unknown joytype: %d, or joytype not compiled in.\n"
+            "   Disabling joystick support.\n", joytype);
+         joytype = JOY_NONE;
+         return OSD_OK;
+   }
+   
+   if(joytype)
+   {
+      int found = FALSE;
+      
+      for (i=0; i<JOY; i++)
+      {
+         if(joy_data[i].num_axis || joy_data[i].num_buttons)
+         {
+            fprintf(stderr_file, "OSD: Info: Joystick %d, %d axis, %d buttons\n",
+               i, joy_data[i].num_axis, joy_data[i].num_buttons);
+            found = TRUE;
+         }
+      }
+   
+      if (!found)
+      {
+         fprintf(stderr_file, "OSD: Warning: No joysticks found disabling joystick support\n");
+         joytype = JOY_NONE;
+      }
+   }
+   
+   return OSD_OK;
+}
+
+void osd_input_close (void)
+{
+   int i;
+   
+   keyboard_exit();
+   
+   for(i=0;i<JOY;i++)
+      if(joy_data[i].fd >= 0)
+         close(joy_data[i].fd);
+}
+
+/* return a list of all available joys */
+const struct JoystickInfo *osd_get_joy_list(void)
+{
+	return joy_list;
+}
+
+void osd_trak_read(int player,int *deltax,int *deltay)
+{
+   if (player < MOUSE && use_mouse)
+   {
+      *deltax = mouse_data[player].deltas[0];
+      *deltay = mouse_data[player].deltas[1];
+   }
+   else
+   {
+      *deltax = 0;
+      *deltay = 0;
+   }
+}
+
+void osd_poll_joysticks (void)
+{
+   if (use_mouse)
+      sysdep_mouse_poll ();
+   if (joytype)
+      (*joy_poll_func) ();
+}
+
+int osd_is_joy_pressed (int joycode)
+{
+   if (joycode >= (JOY_LIST_LEN+MOUSE_LIST_LEN))
+      return FALSE;
+      
+   if (MOUSE_IS_BUTTON(joycode))
+   {
+      int mouse  = MOUSE_GET_MOUSE(joycode);
+      int button = MOUSE_GET_BUTTON(joycode);
+      return mouse_data[mouse].buttons[button];
+   }
+   else
+   {
+      int joy = JOY_GET_JOY(joycode);
+      
+      if (JOY_IS_AXIS(joycode))
+      {
+         int axis = JOY_GET_AXIS(joycode);
+         int dir  = JOY_GET_DIR(joycode);
+         return joy_data[joy].axis[axis].dirs[dir];
+      }
+      else
+      {
+         int button = JOY_GET_BUTTON(joycode);
+         return joy_data[joy].buttons[button];
+      }
+   }
+}
+
+/*
+ * given a new x an y joystick axis value convert it to a move definition
+ */
+
+void joy_evaluate_moves (void)
+{
+   int i, j, treshold;
+
+   for (i=0; i<JOY; i++)
+   {
+      for (j=0; j<joy_data[i].num_axis; j++)
+      {
+         memset(joy_data[i].axis[j].dirs, FALSE, JOY_DIRS*sizeof(int));
+
+         /* auto calibrate */
+         if (joy_data[i].axis[j].val > joy_data[i].axis[j].max)
+            joy_data[i].axis[j].max = joy_data[i].axis[j].val;
+         else if (joy_data[i].axis[j].val < joy_data[i].axis[j].min)
+            joy_data[i].axis[j].min = joy_data[i].axis[j].val;
+
+         treshold = (joy_data[i].axis[j].max - joy_data[i].axis[j].center) >> 1;
+
+         if (joy_data[i].axis[j].val < (joy_data[i].axis[j].center - treshold))
+            joy_data[i].axis[j].dirs[0] = TRUE;
+         else if (joy_data[i].axis[j].val > (joy_data[i].axis[j].center + treshold))
+            joy_data[i].axis[j].dirs[1] = TRUE;
+      }
+   }
+}
+
+/* 
+ * return a value in the range -128 .. 128 (yes, 128, not 127)
+ */
+void osd_analogjoy_read(int player,int *analog_x, int *analog_y)
+{
+   int i,val;
+   
+   if (player < JOY && analogstick && joy_data[player].num_axis >= 2)
+   {
+      for (i=0; i<2; i++)
+      {
+         if (joy_data[player].axis[i].val > joy_data[player].axis[i].center)
+            val = (128 *
+                   (joy_data[player].axis[i].val - joy_data[player].axis[i].center)) /
+                  (joy_data[player].axis[i].max - joy_data[player].axis[i].center);
+         else
+            val = (128 *
+                   (joy_data[player].axis[i].val - joy_data[player].axis[i].center)) /
+                  (joy_data[player].axis[i].center - joy_data[player].axis[i].min);
+         switch(i)
+         {
+            case 0:
+               *analog_x = val;
+               break;
+            case 1:
+               *analog_y = val;
+               break;
+         }
+      }
+   }
+   else
+      *analog_x = *analog_y = 0;
+}
+
+int osd_joystick_needs_calibration (void)
+{
+   /* xmame uses the kernels joystick drivers calibration, or autocalibration
+      and thus never needs this */
+   return 0;
+}
+
+void osd_joystick_start_calibration (void)
+{
+}
+
+char *osd_joystick_calibrate_next (void)
+{
+   return NULL;
+}
+
+void osd_joystick_calibrate (void)
+{
+}
+
+void osd_joystick_end_calibration (void)
+{
+}
diff -Naur ../mmmmm/m36b16/src/unix/devices.h mame-0.36b16/src/unix/devices.h
--- ../mmmmm/m36b16/src/unix/devices.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/devices.h	2023-07-07 14:20:22.688001896 -0400
@@ -0,0 +1,125 @@
+#ifndef __DEVICES_H_
+#define __DEVICES_H_
+
+#ifdef __DEVICES_C_
+#define EXTERN
+#else
+#define EXTERN extern
+#endif
+
+#define JOY 6
+#define JOY_BUTTONS 16
+#define JOY_AXIS 8
+#define JOY_DIRS 2
+#define JOY_LIST_AXIS_ENTRIES (JOY_AXIS * JOY_DIRS)
+#define JOY_LIST_TOTAL_ENTRIES (JOY_LIST_AXIS_ENTRIES + JOY_BUTTONS)
+#define JOY_LIST_LEN (JOY * JOY_LIST_TOTAL_ENTRIES)
+#define JOY_NAME_LEN 20
+
+/* only one mouse for now */
+#define MOUSE 1
+#define MOUSE_BUTTONS 8
+#define MOUSE_AXIS 8
+
+/* now axis entries in the mouse_list, these are get through another way,
+   like the analog joy-values */
+#define MOUSE_LIST_TOTAL_ENTRIES MOUSE_BUTTONS
+#define MOUSE_LIST_LEN (MOUSE * MOUSE_LIST_TOTAL_ENTRIES)
+
+
+#define JOY_BUTTON_CODE(joy, button) \
+ (joy * JOY_LIST_TOTAL_ENTRIES + JOY_LIST_AXIS_ENTRIES + button)
+
+#define MOUSE_BUTTON_CODE(mouse, button) \
+ (JOY_LIST_LEN + mouse * MOUSE_LIST_TOTAL_ENTRIES + button)
+  
+#define JOY_AXIS_CODE(joy, axis, dir) \
+ (joy * JOY_LIST_TOTAL_ENTRIES + JOY_DIRS * axis + dir)
+
+/* mouse doesn't support axis this way */
+ 
+#define JOY_GET_JOY(code) \
+ (code / JOY_LIST_TOTAL_ENTRIES)
+
+#define MOUSE_GET_MOUSE(code) \
+ ((code - JOY_LIST_LEN) / MOUSE_LIST_TOTAL_ENTRIES)
+ 
+#define JOY_IS_AXIS(code) \
+ ((code < JOY_LIST_LEN) && \
+  ((code % JOY_LIST_TOTAL_ENTRIES) <  JOY_LIST_AXIS_ENTRIES))
+  
+/* mouse doesn't support axis */
+
+#define JOY_IS_BUTTON(code) \
+ ((code < JOY_LIST_LEN) && \
+  (((code % JOY_LIST_TOTAL_ENTRIES) >= JOY_LIST_AXIS_ENTRIES))
+
+#define MOUSE_IS_BUTTON(code) \
+ (code >= JOY_LIST_LEN) 
+
+#define JOY_GET_AXIS(code) \
+ ((code % JOY_LIST_TOTAL_ENTRIES) / JOY_DIRS)
+ 
+/* mouse doesn't support axis this way */
+ 
+#define JOY_GET_DIR(code) \
+ ((code % JOY_LIST_TOTAL_ENTRIES) % JOY_DIRS)
+ 
+/* mouse doesn't support axis this way */
+
+#define JOY_GET_BUTTON(code) \
+ ((code % JOY_LIST_TOTAL_ENTRIES) -  JOY_LIST_AXIS_ENTRIES)
+
+#define MOUSE_GET_BUTTON(code) \
+ ((code - JOY_LIST_LEN) % MOUSE_LIST_TOTAL_ENTRIES)
+
+enum { JOY_NONE, JOY_I386, JOY_PAD, JOY_X11, JOY_I386NEW, JOY_USB };
+
+/*** variables ***/
+
+struct axisdata_struct
+{
+   /* current value */
+   int val;
+   /* calibration data */
+   int min;
+   int center;
+   int max;
+   /* boolean values */
+   int dirs[JOY_DIRS];
+};
+
+struct joydata_struct
+{
+   int fd;
+   int num_axis;
+   int num_buttons;
+   struct axisdata_struct axis[JOY_AXIS];
+   int buttons[JOY_BUTTONS];
+};
+
+struct mousedata_struct
+{
+   int buttons[MOUSE_BUTTONS];
+   int deltas[MOUSE_AXIS];
+};
+
+EXTERN struct joydata_struct joy_data[JOY];
+EXTERN struct mousedata_struct mouse_data[MOUSE];
+EXTERN void (*joy_poll_func) (void);
+EXTERN int joytype;
+
+extern struct rc_option joy_i386_opts[];
+extern struct rc_option joy_pad_opts[];
+extern struct rc_option joy_x11_opts[];
+extern struct rc_option joy_usb_opts[];
+
+/*** prototypes ***/
+void joy_evaluate_moves(void);
+void joy_i386_init(void);
+void joy_pad_init(void);
+void joy_x11_init(void);
+void joy_usb_init(void);
+
+#undef EXTERN
+#endif
diff -Naur ../mmmmm/m36b16/src/unix/dirio.c mame-0.36b16/src/unix/dirio.c
--- ../mmmmm/m36b16/src/unix/dirio.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/dirio.c	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,167 @@
+#include "xmame.h"
+#include <stdarg.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <zlib.h>
+
+#ifdef BSD43 /* old style directory handling */
+#include <sys/types.h>
+#include <sys/dir.h>
+#define dirent direct
+#endif
+
+/* #define FILEIO_DEBUG */
+#define MAXPATHC 20 /* at most 20 path entries */
+#define MAXPATHL BUF_SIZE /* at most BUF_SIZE-1 character path length */
+ 
+#ifdef MESS
+int osd_num_devices(void)
+{
+   return 0; /* unix doesn't have devices ( a device = a: b: etc) */
+}
+
+void osd_change_device(const char *device)
+{
+}
+
+const char *osd_get_device_name(int idx)
+{
+   return "";
+}
+
+
+struct osd_dir {
+   DIR *dir;
+   char dirname[MAXPATHL];
+   char filemask[MAXPATHL];
+};
+
+void *osd_dir_open(const char *dirname, const char *filemask)
+{
+  struct osd_dir *dir = NULL;
+  
+  if(!(dir = calloc(1, sizeof(struct osd_dir))))
+     return NULL;
+  
+  if(!(dir->dir = opendir(dirname)))
+  {
+     osd_dir_close(dir);
+     return NULL;
+  }
+  
+  strncpy(dir->dirname,  dirname,  MAXPATHL-1);
+  strncpy(dir->filemask, filemask, MAXPATHL-1);
+  
+  return dir;
+}
+
+void osd_dir_close(void *dir)
+{
+  struct osd_dir *my_dir = dir;
+  
+  if(my_dir->dir)
+    closedir(my_dir->dir);
+  
+  free(my_dir);
+}
+
+static int fnmatch(const char *f1, const char *f2)
+{
+	while (*f1 && *f2)
+	{
+		if (*f1 == '*')
+		{
+			/* asterisk is not the last character? */
+			if (f1[1])
+			{
+				/* skip until first occurance of the character after the asterisk */
+                while (*f2 && toupper(f1[1]) != toupper(*f2))
+					f2++;
+				/* skip repetitions of the character after the asterisk */
+				while (*f2 && toupper(f1[1]) == toupper(f2[1]))
+					f2++;
+			}
+			else
+			{
+				/* skip until end of string */
+                while (*f2)
+					f2++;
+			}
+        }
+		else
+		if (*f1 == '?')
+		{
+			/* skip one character */
+            f2++;
+		}
+		else
+		{
+			/* mismatch? */
+            if (toupper(*f1) != toupper(*f2))
+				return 0;
+            /* skip one character */
+			f2++;
+		}
+		/* skip mask */
+        f1++;
+	}
+	/* no match if anything is left */
+	if (*f1 || *f2)
+		return 0;
+    return 1;
+}
+
+int osd_dir_get_entry(void *dir, char *name, int namelength, int *is_dir)
+{
+   struct osd_dir *my_dir = dir;
+   struct dirent *d = NULL;
+   struct stat stat_buf;
+   char buf[MAXPATHL];
+    
+   *is_dir = 0;
+  
+   while((d = readdir(my_dir->dir)))
+   {
+      snprintf(buf, MAXPATHL, "%s/%s", my_dir->dirname, d->d_name);
+      
+      /* stat it */
+      if(stat(buf, &stat_buf))
+         continue;
+         
+      /* check that it is a dir or matches our filemask */
+#ifdef BSD43
+      if(S_IFDIR & stat_buf.st_mode)
+#else
+      if(S_ISDIR(stat_buf.st_mode))
+#endif
+      {
+         *is_dir = 1;
+      }
+      else if (!fnmatch(my_dir->filemask, d->d_name))
+         continue;
+      
+      strncpy(name, d->d_name, namelength-1);
+      name[namelength-1] = 0;
+      return strlen(name);
+  }
+  
+  return 0;
+}
+
+void osd_change_directory(const char *directory)
+{
+   chdir(directory);
+}
+
+const char *osd_get_cwd(void)
+{
+   static char cwd[MAXPATHL];
+   
+   getcwd(cwd, MAXPATHL);
+
+   return cwd;
+}
+
+#endif
diff -Naur ../mmmmm/m36b16/src/unix/dirty.c mame-0.36b16/src/unix/dirty.c
--- ../mmmmm/m36b16/src/unix/dirty.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/dirty.c	2023-07-07 14:20:22.688001896 -0400
@@ -0,0 +1,95 @@
+#if !defined xgl
+#include "xmame.h"
+#include "driver.h"
+
+/* hmm no more way to find out what the width and height of the screenbitmap
+   are, so just define WIDTH and HEIGHT to be 2048 */
+
+#define WIDTH  (2048 / 8)
+#define HEIGHT (2048 / 8)
+
+int osd_dirty_init(void)
+{
+   dirty_lines      = NULL;
+   dirty_blocks     = NULL;
+   
+   /* vector games always need a dirty array */
+   if (use_dirty || (Machine->drv->video_attributes & VIDEO_TYPE_VECTOR))
+   {
+      int i;
+      
+      dirty_lines = malloc(HEIGHT);
+      if (!dirty_lines)
+      {
+         fprintf(stderr_file, "Error: couldn't allocate mem\n");
+         return OSD_NOT_OK;
+      }
+      memset(dirty_lines, 0, HEIGHT);
+   	
+      dirty_blocks = malloc(HEIGHT * sizeof(char *));
+      if (!dirty_blocks)
+      {
+         free(dirty_lines); dirty_lines = NULL;
+         fprintf(stderr_file, "Error: couldn't allocate mem\n");
+         return OSD_NOT_OK;
+      }
+   	   
+      for (i=0; i< HEIGHT; i++)
+      {
+         dirty_blocks[i] = malloc(WIDTH);
+         if (!dirty_blocks[i]) break;
+         memset(dirty_blocks[i], 0, WIDTH);
+      }
+      if (i!=HEIGHT)
+      { 
+         fprintf(stderr_file, "Error: couldn't allocate mem\n");
+         for(;i>=0;i--) free(dirty_blocks[i]);
+         free(dirty_blocks); dirty_blocks = NULL;
+         free(dirty_lines);  dirty_lines  = NULL;
+         return OSD_NOT_OK;
+      }
+   }
+   
+   return OSD_OK;
+}
+
+void osd_dirty_close(void)
+{
+   /* vector games always need a dirty array */
+   if (use_dirty || (Machine->drv->video_attributes & VIDEO_TYPE_VECTOR))
+   {
+      int i;
+      
+      if (!dirty_blocks) return;
+      
+      for (i=0; i< HEIGHT; i++) free(dirty_blocks[i]);
+      free (dirty_blocks);
+      free (dirty_lines);
+   }
+}
+
+void osd_mark_dirty(int x1, int y1, int x2, int y2, int ui)
+{
+	int y,x;
+	if (use_dirty)
+	{
+	   if (x1 < visual.min_x) x1=visual.min_x;
+	   if (y1 < visual.min_y) y1=visual.min_y;
+	   if (x2 > visual.max_x) x2=visual.max_x;
+	   if (y2 > visual.max_y) y2=visual.max_y;
+	   x1 >>= 3;
+	   y1 >>= 3;
+	   x2 = (x2 + 8) >> 3;
+	   y2 = (y2 + 8) >> 3;
+ 	   for (y=y1; y<y2; y++)
+	   {
+	      dirty_lines[y] = 1;
+	      for(x=x1; x<x2; x++)
+              {
+	         dirty_blocks[y][x] = 1;
+	      }
+	   }
+	}
+}
+
+#endif /* #if !defined xgl */
diff -Naur ../mmmmm/m36b16/src/unix/fileio.c mame-0.36b16/src/unix/fileio.c
--- ../mmmmm/m36b16/src/unix/fileio.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/fileio.c	2023-07-07 14:20:22.684001892 -0400
@@ -0,0 +1,879 @@
+#include "xmame.h"
+#include <stdarg.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <zlib.h>
+
+#ifdef BSD43 /* old style directory handling */
+#include <sys/types.h>
+#include <sys/dir.h>
+#define dirent direct
+#endif
+
+/* #define FILEIO_DEBUG */
+#define MAXPATHC 20 /* at most 20 path entries */
+#define MAXPATHL BUF_SIZE /* at most BUF_SIZE-1 character path length */
+
+int load_zipped_file (const char *zipfile,const char *filename, unsigned char **buf, unsigned int *length);
+int checksum_zipped_file (const char *zipfile, const char *filename, unsigned int *length, unsigned int *sum);
+static int config_handle_inputfile(struct rc_option *option, const char *arg,
+   int priority);
+
+/* from ... */
+extern char *cheatfile;
+//RB: extern char *db_filename;
+extern char *history_filename;
+extern char *mameinfo_filename;
+
+/* local vars */
+static char *rompathv[MAXPATHC];
+static int   rompathc = 0;
+static char *rompath = NULL;
+static char *spooldir = NULL; /* directory to store high scores */
+static char *screenshot_dir = NULL;
+//RB: static FILE *errorlog = NULL;
+
+#ifdef MESS
+static char *cheatdir = NULL;
+#endif
+
+/* struct definitions */
+typedef enum
+{
+	kPlainFile,
+	kRamFile
+} eFileType;
+
+typedef struct
+{
+	FILE		*file;
+	unsigned char	*data;
+	unsigned int	offset;
+	unsigned int	length;
+	unsigned int	crc;
+ 	eFileType	type;
+} FakeFileHandle;
+
+struct rc_option fileio_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "Fileio Related",	NULL,			rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "rompath",		"rp",			rc_string,	&rompath,
+     XMAMEROOT,		0,			0,		NULL,
+     "Set the rom search path" },
+   { "spooldir",	"sd",			rc_string,	&spooldir,
+     XMAMEROOT,		0,			0,		NULL,
+     "Set highscore spooldir" },
+   { "screenshotdir",	"ssd",			rc_string,	&screenshot_dir,
+     ".",		0,			0,		NULL,
+     "Set dir to store screenshots in" },
+#ifdef MESS
+   { "cheatdir",	NULL,			rc_string,	&cheatdir,
+     XMAMEROOT"/cheat",	0,			0,		NULL,
+     "Set dir to look for cheat files in" },
+   { "crcdir",		NULL,			rc_string,	&crcdir,
+     XMAMEROOT"/crc",	0,			0,		NULL,
+     "Set dir to look for crc files in" },
+   { "cheatfile",	"cf",			rc_string,	&cheatfile,
+     "cheat.cdb",	 0,			0,		NULL,
+     "Set the file to use as cheat database" },
+#else
+   { "cheatfile",	"cf",			rc_string,	&cheatfile,
+     XMAMEROOT"/cheat.dat", 0,			0,		NULL,
+     "Set the file to use as cheat database" },
+#endif
+//RB:   { "hiscorefile",	"hif",			rc_string,	&db_filename,
+//RB:      XMAMEROOT"/hiscore.dat",	0,		0,		NULL,
+//RB:      "Set the file to use as high score database" },
+   { "historyfile",	"hf",			rc_string,	&history_filename,
+     XMAMEROOT"/history.dat", 0,		0,		NULL,
+     "Set the file to use as history database" },
+   { "mameinfofile",	"mf",			rc_string,	&mameinfo_filename,
+     XMAMEROOT"/mameinfo.dat", 0,		0,		NULL,
+     "Set the file to use as mameinfo database" },
+   { "record",		"rec",			rc_use_function, &options.record,
+     NULL,		1,			0,		config_handle_inputfile,
+     "Set a file to record keypresses into" },
+   { "playback",	"pb",			rc_use_function, &options.playback,
+     NULL,		0,			0,		config_handle_inputfile,
+     "Set a file to playback keypresses from" },
+   { "stdout-file",	"out",			rc_file,	&stdout_file,
+     NULL,		1,			0,		NULL,
+     "Set a file to redirect stderr to" },
+   { "stderr-file",	"err",			rc_file,	&stderr_file,
+     NULL,		1,			0,		NULL,
+     "Set a file to redirect stdout to" },
+   { "log",		"L",			rc_file,	&errorlog,
+     NULL,		1,			0,		NULL,
+     "Set a file to log debug info to" },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+static int config_handle_inputfile(struct rc_option *option, const char *arg,
+   int priority)
+{
+   if (*(void **)option->dest)
+      osd_fclose(*(void **)option->dest);
+
+   *(void **)option->dest = osd_fopen(NULL, arg, OSD_FILETYPE_INPUTLOG,
+      option->min);
+   if (*(void **)option->dest == NULL)
+   {
+      fprintf(stderr, "error: couldn't open %s\n", arg);
+      return -1;
+   }
+
+   option->priority = priority;
+
+   return 0;
+}
+
+
+/* unix helper functions */
+
+/* helper function which decomposes a path list into a vector of paths */
+void init_rom_path(void)
+{
+	char *token = strtok(rompath, ":");
+	while ((rompathc < MAXPATHC) && token)
+	{
+		rompathv[rompathc] = token;
+		rompathc++;
+		token = strtok (NULL, ":");
+	}
+}
+
+/*
+ * Search file caseinsensitively
+ *
+ * Arguments:
+ *	char * path - complete pathname to the desired file. The string will
+ *	              be modified during search (and contains the final output).
+ *
+ * Return TRUE if found, FALSE otherwise.
+ */
+static int filesearch(char *path)
+{
+    DIR *dirp;
+    struct dirent *de = NULL;
+    char *ep, *dp, *fp;
+
+    ep = strrchr(path, '/');
+    if (ep) {
+	*ep = '\0';	/* I guess root directory is not supported */
+	dp = path;
+	fp = ep + 1;
+    } else {
+	dp = "."; /* well, what should be the correct name for "current dir" */
+	fp = path;
+    }
+
+    if (*fp == '\0') {
+	return FALSE;
+    }
+
+    /* jamc: code to perform a upper/lowercase rom search */
+    /* try to open directory */
+    if ((dirp = opendir(dp)) == (DIR *) 0) {
+	return FALSE;
+    }
+
+    /* search entry and upcasecompare to desired file name */
+    for (de = readdir(dirp); de; de = readdir(dirp))
+	if (!strcasecmp(de->d_name, fp)) break;
+    if (de) strcpy(fp, de->d_name);
+    closedir(dirp);
+
+    if (ep) *ep = '/';
+
+    if (de) return TRUE;
+    return FALSE;
+}
+
+#define GZIP_BLOCK_SIZE 8192
+
+/* Try to load the normal or gzipped file "name" into FakeFileHandle "f",
+   converting it into a ram-file allowing it to be crc'd.
+   return 1 on success 0 otherwise. */
+static int open_gzip_file (FakeFileHandle *f, char *name)
+{
+    int read;
+
+#ifdef FILEIO_DEBUG
+    fprintf(stderr_file, "Trying to open: %s\n", name);
+#endif
+
+    if(!filesearch(name))
+       return 0;
+
+    if((f->file = gzopen(name, "r")) == NULL)
+       return 0;
+
+    f->data   = malloc(GZIP_BLOCK_SIZE);
+    if (!f->data) goto gzip_error;
+
+    while ((read = gzread(f->file, f->data+f->length, GZIP_BLOCK_SIZE)) == GZIP_BLOCK_SIZE)
+    {
+        unsigned char *tmp;
+        f->length += GZIP_BLOCK_SIZE;
+        if (!(tmp = realloc(f->data, f->length + GZIP_BLOCK_SIZE)))
+            goto gzip_error;
+        f->data = tmp;
+    }
+    if (read == -1) goto gzip_error;
+    f->length += read;
+    f->crc  = crc32(0L, f->data, f->length);
+    f->type = kRamFile;
+    gzclose(f->file);
+    return 1;
+
+gzip_error:
+    if (f->data) free(f->data);
+    gzclose(f->file);
+    memset(f,0,sizeof(FakeFileHandle));
+    return 0;
+}
+
+/* Try to load "name" from the zipfile "zipname" into FakeFileHandle "f".
+   return 1 on success 0 otherwise. */
+static int open_zip_file (FakeFileHandle *f, char *zipname, const char *name)
+{
+    const char *my_name;
+
+#ifdef FILEIO_DEBUG
+    fprintf(stderr_file, "Trying to open: %s, in %s\n", name, zipname);
+#endif
+
+    if(!filesearch(zipname))
+       return 0;
+
+    if ( (my_name=strrchr(name, '/')) )
+       my_name = my_name + 1;
+    else
+       my_name = name;
+
+    if(load_zipped_file(zipname, my_name, &f->data, &f->length) == 0)
+    {
+	f->crc  = crc32(0L, f->data, f->length);
+	f->type = kRamFile;
+	f->file = (FILE *)-1;
+	return 1;
+    }
+
+    memset(f,0,sizeof(FakeFileHandle));
+    return 0;
+}
+
+#ifdef MESS
+/* Try to load the normal file "name" into FakeFileHandle "f".
+   return 1 on success 0 otherwise. */
+static int open_normal_file (FakeFileHandle *f, char *name, int write)
+{
+    int read;
+    char *modes[4] = {"r", "w", "r+", "r+"};
+
+#ifdef FILEIO_DEBUG
+    fprintf(stderr_file, "Trying to open: %s\n", name);
+#endif
+
+    switch(write)
+    {
+       case OSD_FOPEN_READ:
+          if (filesearch(name))
+             f->file = fopen(name, "r");
+          break;
+       case OSD_FOPEN_WRITE:
+          /* try to overwrite the same name with a different case,
+             if we're faking case insensitivity, fake it all the way ;) */
+          filesearch(name);
+          f->file = fopen(name, "w");
+          break;
+       case OSD_FOPEN_RW:
+          if (filesearch(name))
+             f->file = fopen(name, "r+");
+          break;
+       case OSD_FOPEN_RW_CREATE:
+          if (filesearch(name))
+             f->file = fopen(name, "r+");
+          else
+             f->file = fopen(name, "w+");
+          break;
+    }
+
+    if(f->file)
+       return 1;
+
+    return 0;
+}
+#endif
+
+
+/* osd functions */
+
+/*
+ * check if roms/samples for a game exist at all
+ * return 1 on success, otherwise 0
+ */
+int osd_faccess(const char *filename, int filetype)
+{
+	char name[MAXPATHL];
+	int i;
+
+	switch (filetype)
+	{
+		case OSD_FILETYPE_ROM:
+		case OSD_FILETYPE_SAMPLE:
+		    for(i=0;i<rompathc;i++)
+		    {
+			/* try filename.zip */
+			snprintf(name, MAXPATHL, "%s/%s.zip", rompathv[i], filename);
+			if (access(name, F_OK) == 0) return 1;
+
+			/* try filename dir */
+			snprintf(name, MAXPATHL, "%s/%s",rompathv[i],filename);
+			if (access(name, F_OK) == 0) return 1;
+		    }
+		    break;
+		case OSD_FILETYPE_SCREENSHOT:
+		    snprintf(name, MAXPATHL, "%s/%s.png",screenshot_dir ,filename);
+		    if (access(name, F_OK) == 0) return 1;
+		    break;
+	}
+
+	return 0;
+}
+
+/*
+ * file handling routines
+ *
+ * gamename holds the driver name, filename is only used for ROMs and samples.
+ * if 'write' is not 0, the file is opened for write. Otherwise it is opened
+ * for read.
+ */
+void *osd_fopen(const char *gamename, const char *filename, int filetype,
+     int write)
+{
+	char name[MAXPATHL];
+	FakeFileHandle *f;
+	int i;
+	char *pt;
+
+	f = (FakeFileHandle *)calloc(1, sizeof(FakeFileHandle));
+	if (f == NULL) return f;
+
+	switch (filetype)
+	{
+#ifdef MESS
+		case OSD_FILETYPE_IMAGE_RW:
+		    /* writable images are only supported as normal files */
+		    if (write)
+		    {
+			/* try filename.ext */
+			snprintf(name, MAXPATHL, "%s", filename);
+			if (open_normal_file(f, name, write))
+			    break;
+			for(i=0; i < rompathc; i++)
+			{
+			    /* try <rompath>/filename.ext */
+			    snprintf(name, MAXPATHL, "%s/%s", rompathv[i], filename);
+			    if (open_normal_file(f, name, write))
+				break;
+
+			    /* try <rompath>/<systemname>/filename.ext */
+			    snprintf(name, MAXPATHL, "%s/%s/%s", rompathv[i], gamename,
+			        filename);
+			    if (open_normal_file(f, name, write))
+				break;;
+			}
+		        break;
+		    }
+		    /* fall through for non writable images */
+		case OSD_FILETYPE_IMAGE_R:
+		    if (write)
+		    {
+			logerror("Error trying to open ro image %s in write mode\n", filename);
+			break;
+		    }
+		    /* try relative and absolute filenames */
+
+		    /* try filename.ext */
+		    snprintf(name, MAXPATHL, "%s", filename);
+		    if (open_gzip_file(f, name))
+		        break;
+
+		    /* try filename.ext.gz */
+		    snprintf(name, MAXPATHL, "%s.gz", filename);
+		    if (open_gzip_file(f, name))
+		        break;
+
+		    /* try filename.zip */
+		    snprintf(name, MAXPATHL, "%s", filename);
+		    if ( (pt=strrchr(name, '.')) ) *pt = 0;
+		    strncat(name, ".zip", (MAXPATHL - 1) - strlen(name));
+		    if (open_zip_file(f, name, filename))
+		        break;
+		    /* fall through */
+#endif
+		case OSD_FILETYPE_ARTWORK:
+		    if (write)
+		    {
+//RB:			logerror("Error trying to open ro image %s in write mode\n", filename);
+			break;
+		    }
+		    for(i=0; i < rompathc; i++)
+		    {
+		        /* try <rompath>/filename.ext */
+			snprintf(name, MAXPATHL, "%s/%s", rompathv[i], filename);
+			if (open_gzip_file(f, name))
+			    break;
+
+			/* try <rompath>/filename.ext.gz */
+			snprintf(name, MAXPATHL, "%s/%s.gz", rompathv[i], filename);
+			if (open_gzip_file(f, name))
+			    break;
+
+		        /* try <rompath>/filename.zip */
+		        snprintf(name, MAXPATHL, "%s/%s", rompathv[i], filename);
+		        if ( (pt=strrchr(name, '.')) ) *pt = 0;
+			strncat(name, ".zip", (MAXPATHL - 1) - strlen(name));
+		        if (open_zip_file(f, name, filename))
+		            break;
+		    }
+		    if(f->file)
+			break;
+		    /* fall through */
+		case OSD_FILETYPE_ROM:
+		case OSD_FILETYPE_SAMPLE:
+		    if (write)
+		    {
+//RB:			logerror("Error trying to open rom/sample %s in write mode\n", filename);
+			break;
+		    }
+
+		    for(i=0; i < rompathc; i++)
+		    {
+			/* try <rompath>/gamename.zip */
+			snprintf(name, MAXPATHL, "%s/%s.zip", rompathv[i], gamename);
+			if (open_zip_file(f, name, filename))
+			    break;
+
+		        /* try <rompath>/<gamename>/filename.ext */
+			snprintf(name, MAXPATHL, "%s/%s/%s", rompathv[i], gamename,
+			    filename);
+			if (open_gzip_file(f, name))
+			    break;
+
+			/* try <rompath>/<gamename>/filename.ext.gz */
+			snprintf(name, MAXPATHL, "%s/%s/%s.gz", rompathv[i], gamename,
+			    filename);
+			if (open_gzip_file(f, name))
+			    break;
+
+			/* really only usefull for mess, but to keep
+			   both the src and the docs clean we try it always */
+		        /* try <rompath>/<gamename>/filename.zip */
+		        snprintf(name, MAXPATHL, "%s/%s/%s", rompathv[i], gamename,
+		            filename);
+		        if ( (pt=strrchr(name, '.')) ) *pt = 0;
+			strncat(name, ".zip", (MAXPATHL - 1) - strlen(name));
+		        if (open_zip_file(f, name, filename))
+		            break;
+		    }
+		    break;
+		case OSD_FILETYPE_CONFIG:
+		    snprintf(name, MAXPATHL, "%s/.%s/cfg/%s.cfg", home_dir, NAME, gamename);
+		    f->file = fopen(name,write ? "w" : "r");
+		    break;
+		case OSD_FILETYPE_STATE:
+		    snprintf(name, MAXPATHL, "%s/.%s/sta/%s.sta", home_dir, NAME, gamename);
+		    f->file = fopen(name,write ? "w" : "r");
+		    break;
+		case OSD_FILETYPE_NVRAM:
+		    snprintf(name, MAXPATHL, "%s/.%s/nvram/%s.nv", home_dir, NAME, gamename);
+		    f->file = fopen(name,write ? "w" : "r");
+		    break;
+		case OSD_FILETYPE_MEMCARD:
+		    snprintf(name, MAXPATHL, "%s/.%s/mem/%s.mem", home_dir, NAME, filename);
+		    f->file = fopen(name,write ? "w" : "r");
+		    break;
+		case OSD_FILETYPE_HIGHSCORE:
+		    if (mame_highscore_enabled())
+		    {
+			snprintf(name, MAXPATHL, "%s/%s.hi", spooldir, gamename);
+			f->file = fopen(name,write ? "w" : "r");
+		    }
+		    break;
+		case OSD_FILETYPE_SCREENSHOT:
+		    /* only for writing */
+		    if (!write) break;
+
+		    snprintf(name, MAXPATHL, "%s/%s.png", screenshot_dir, filename);
+		    f->file = fopen(name, "w");
+		    break;
+		case OSD_FILETYPE_INPUTLOG:
+		    f->file = fopen(filename,write ? "w" : "r");
+		    break;
+#if 0 /* RB */
+		case OSD_FILETYPE_HIGHSCORE_DB:
+		case OSD_FILETYPE_HISTORY:
+		    /* only for reading */
+		    if (write) break;
+
+		    f->file = fopen (filename, "r");
+		    break;
+		case OSD_FILETYPE_CHEAT:
+		    /* only for reading */
+		    if (write) break;
+#ifdef MESS
+		    snprintf(name, MAXPATHL, "%s/%s", cheatdir, filename);
+		    f->file = fopen (name, "r");
+#else
+		    f->file = fopen (filename, "r");
+#endif
+		    break;
+		case OSD_FILETYPE_LANGUAGE:
+		    /* only for reading */
+		    if (write) break;
+
+		    snprintf (name, MAXPATHL, "%s.lng", filename);
+		    f->file = fopen (name, "r");
+		    break;
+#endif /* RB */
+	}
+
+	if (f->file == NULL)
+	{
+		free(f);
+		return NULL;
+	}
+
+	return f;
+}
+
+int osd_fread(void *file,void *buffer,int length)
+{
+	FakeFileHandle *f = (FakeFileHandle *)file;
+
+	switch (f->type)
+	{
+		case kPlainFile:
+			return fread(buffer,1,length,f->file);
+			break;
+		case kRamFile:
+			/* reading from the uncompressed image of a zipped file */
+			if (f->data)
+			{
+				if (length + f->offset > f->length)
+					length = f->length - f->offset;
+				memcpy(buffer, f->offset + f->data, length);
+				f->offset += length;
+				return length;
+			}
+			break;
+	}
+
+	return 0;
+}
+
+int osd_fread_swap(void *file,void *buffer,int length)
+{
+	int i;
+	unsigned char *buf;
+	unsigned char temp;
+	int res;
+
+	res = osd_fread(file,buffer,length);
+
+	buf = buffer;
+	for (i = 0;i < length;i+=2)
+	{
+		temp = buf[i];
+		buf[i] = buf[i+1];
+		buf[i+1] = temp;
+	}
+
+	return res;
+}
+
+int osd_fread_scatter(void *file,void *buffer,int length,int increment)
+{
+	unsigned char *buf = buffer;
+	FakeFileHandle *f = (FakeFileHandle *)file;
+	unsigned char tempbuf[4096];
+	int totread,r,i;
+
+	switch (f->type)
+	{
+		case kPlainFile:
+			totread = 0;
+			while (length)
+			{
+				r = length;
+				if (r > 4096) r = 4096;
+				r = fread(tempbuf,1,r,f->file);
+				if (r == 0) return totread;	/* error */
+				for (i = 0;i < r;i++)
+				{
+					*buf = tempbuf[i];
+					buf += increment;
+				}
+				totread += r;
+				length -= r;
+			}
+			return totread;
+			break;
+		case kRamFile:
+			/* reading from the RAM image of a file */
+			if (f->data)
+			{
+				if (length + f->offset > f->length)
+					length = f->length - f->offset;
+				for (i = 0;i < length;i++)
+				{
+					*buf = f->data[f->offset + i];
+					buf += increment;
+				}
+				f->offset += length;
+				return length;
+			}
+			break;
+	}
+
+	return 0;
+}
+
+int osd_fwrite(void *file,const void *buffer,int length)
+{
+	FakeFileHandle *f = (FakeFileHandle *)file;
+
+	switch (f->type)
+	{
+		case kPlainFile:
+			return fwrite(buffer,1,length,f->file);
+		default:
+			return -1; /* note dos returns 0, but this is incorrect */
+	}
+}
+
+int osd_fwrite_swap(void *file,const void *buffer,int length)
+{
+	int i;
+	unsigned char *buf;
+	unsigned char temp;
+	int res;
+
+	buf = (unsigned char *)buffer;
+	for (i = 0;i < length;i+=2)
+	{
+		temp = buf[i];
+		buf[i] = buf[i+1];
+		buf[i+1] = temp;
+	}
+
+	res = osd_fwrite(file,buffer,length);
+
+	for (i = 0;i < length;i+=2)
+	{
+		temp = buf[i];
+		buf[i] = buf[i+1];
+		buf[i+1] = temp;
+	}
+
+	return res;
+}
+
+int osd_fseek(void *file,int offset,int whence)
+{
+	FakeFileHandle *f = (FakeFileHandle *)file;
+
+	switch (f->type)
+	{
+		case kPlainFile:
+			return fseek(((FakeFileHandle *)file)->file,offset,whence);
+			break;
+		case kRamFile:
+			/* seeking within the uncompressed image of a zipped file */
+			switch (whence)
+			{
+				case SEEK_SET:
+					f->offset = offset;
+					return 0;
+					break;
+				case SEEK_CUR:
+					f->offset += offset;
+					return 0;
+					break;
+				case SEEK_END:
+					f->offset = f->length + offset;
+					return 0;
+					break;
+			}
+			break;
+	}
+
+	return -1;
+}
+
+int osd_fgetc(void *file)
+{
+	FakeFileHandle *f = (FakeFileHandle *) file;
+
+	if (f->type == kPlainFile && f->file)
+		return fgetc(f->file);
+	else
+		return EOF;
+}
+
+int osd_ungetc(int c, void *file)
+{
+	FakeFileHandle *f = (FakeFileHandle *) file;
+
+	if (f->type == kPlainFile && f->file)
+		return ungetc(c,f->file);
+	else
+		return EOF;
+}
+
+char *osd_fgets(char *s, int n, void *file)
+{
+	FakeFileHandle *f = (FakeFileHandle *) file;
+
+	if (f->type == kPlainFile && f->file)
+		return fgets(s,n,f->file);
+	else
+		return NULL;
+}
+
+int osd_feof(void *file)
+{
+	FakeFileHandle *f = (FakeFileHandle *) file;
+
+	if (f->type == kPlainFile && f->file)
+		return feof(f->file);
+	else
+		return 1;
+}
+
+int osd_ftell(void *file)
+{
+	FakeFileHandle *f = (FakeFileHandle *) file;
+
+	if (f->type == kPlainFile && f->file)
+		return ftell(f->file);
+	else
+		return -1L;
+}
+
+void osd_fclose(void *file)
+{
+	FakeFileHandle *f = (FakeFileHandle *) file;
+
+	switch(f->type)
+	{
+		case kPlainFile:
+			fclose(f->file);
+			break;
+		case kRamFile:
+			if (f->data)
+				free(f->data);
+			break;
+	}
+	free(f);
+}
+
+int osd_fsize(void *file)
+{
+	int position, end;
+	FakeFileHandle *f = (FakeFileHandle *) file;
+
+	switch(f->type)
+	{
+		case kPlainFile:
+			position = ftell(f->file);
+			fseek(f->file, 0, SEEK_END);
+			end = ftell(f->file);
+			fseek(f->file, position, SEEK_SET);
+			return end;
+			break;
+		case kRamFile:
+			return f->length;
+			break;
+	}
+
+	return 0;
+}
+
+unsigned int osd_fcrc (void *file)
+{
+	FakeFileHandle *f = (FakeFileHandle *)file;
+	return f->crc;
+}
+
+int osd_fchecksum (const char *game, const char *filename, unsigned int *length, unsigned int *sum)
+{
+  char name[MAXPATHL];
+  FakeFileHandle *f;
+  int i;
+
+  for(i=0;i<rompathc;i++)
+  {
+    snprintf(name, MAXPATHL, "%s/%s.zip",rompathv[i], game);
+
+    if (access(name, R_OK)==0)
+    {
+      if (checksum_zipped_file(name, filename, length, sum) == 0)
+        return 0;
+    }
+  }
+
+  f = osd_fopen(game, filename, OSD_FILETYPE_ROM, 0);
+  if (f==NULL) return -1;
+  *sum    = osd_fcrc(f);
+  *length = osd_fsize(f);
+  osd_fclose(f);
+  return 0;
+}
+
+/* called while loading ROMs. It is called a last time with name == 0 to signal */
+/* that the ROM loading process is finished. */
+/* return non-zero to abort loading */
+int osd_display_loading_rom_message(const char *name,int current,int total)
+{
+	static int count = 0;
+
+	if (name)
+		fprintf(stderr_file,"loading rom %d: %-12s\n", count, name);
+	else
+		fprintf(stderr_file,"done\n");
+
+	fflush(stderr_file);
+	count++;
+
+	return 0;
+}
+
+#if 0 /* RB: in mame.c */
+void logerror(const char *text, ...)
+{
+	va_list arg;
+
+	if (errorlog)
+	{
+		va_start(arg, text);
+		vfprintf(errorlog, text, arg);
+		va_end(arg);
+	}
+}
+#endif /* RB */
+
+#ifdef MESS
+int osd_select_file(int sel, char *filename)
+{
+	return 0;
+}
+#endif
diff -Naur ../mmmmm/m36b16/src/unix/frameskip-drivers/barath.c mame-0.36b16/src/unix/frameskip-drivers/barath.c
--- ../mmmmm/m36b16/src/unix/frameskip-drivers/barath.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/frameskip-drivers/barath.c	2023-07-07 14:20:22.688001896 -0400
@@ -0,0 +1,157 @@
+#include <math.h>
+#include "xmame.h"
+#include "driver.h"
+#include "profiler.h"
+#include "sysdep/misc.h"
+//#include "usrintrf.h" /* RB */
+/* don't define this for a production version
+#define barath_debug
+ */
+
+static int modframe = 0;
+
+static int barath_skip_this_frame(void)
+{
+  return (modframe >= FRAMESKIP_LEVELS);
+}
+
+int barath_skip_next_frame(int showfps /* , struct osd_bitmap *bitmap */)
+{
+  static uclock_t curr = 0;
+  static uclock_t prev = 0;
+  static uclock_t avg_uclocks = 0;
+  static int frames_skipped = 0;
+  static int sysload = 0;
+  static float framerate = 1;
+  static float speed = 1;
+  static float lag_rate = -30;
+
+  int skip_this_frame = barath_skip_this_frame();
+  int scratch_time = uclock();
+#ifdef barath_debug
+  int debug_value;
+  static float slow_speed = 1;
+  int uclocks_per_frame = slow_speed * UCLOCKS_PER_SEC / Machine->drv->frames_per_second;
+#else
+  int uclocks_per_frame = UCLOCKS_PER_SEC / Machine->drv->frames_per_second;
+#endif
+  /* project target display time of this frame */
+  uclock_t target = prev + (frames_skipped + 1) * uclocks_per_frame;
+
+  /* if lagging by more than 2 frames don't try to make up for it */
+  while (scratch_time - target > uclocks_per_frame * 2) {
+    target += uclocks_per_frame;
+    lag_rate++;
+  }
+  lag_rate *= 0.99;
+
+  {
+    static float framerateavg = 0;
+    framerateavg = (framerateavg * 5 + 1 - skip_this_frame) / 6.0;
+    framerate = (framerate * 5 + framerateavg) / 6.0;
+  }
+  if (throttle) {
+    int leading = ((sysload > 33) && sleep_idle) ? 0 : uclocks_per_frame;
+    int sparetime = target - scratch_time;
+
+    /* test for load-induced lags and set sysload */
+    if (autoframeskip && sleep_idle) {
+      /* if lag is excessive and framerate is low then we have a system hiccup */
+      if ((sysload < 100) && (lag_rate > 3) && (frameskip < max_autoframeskip)) {
+	sysload++;
+	lag_rate = 3;
+      }
+      /* after ~2000 frames of no lag start lowering sysload */
+      else if (sysload && (fabs(lag_rate) < .00001)) {
+	sysload--;
+	lag_rate = .000011;	/* wait ~10 frames */
+      }
+    }
+    if (autoframeskip) {
+      /* this is an attempt at proportionate feedback to smooth things out */
+      int feedback = ((sparetime - uclocks_per_frame / 2) / (uclocks_per_frame / 3));
+
+      frameskip = ((1.0 - framerate) * (FRAMESKIP_LEVELS - 1)) - feedback;
+
+#ifdef barath_debug
+      debug_value = feedback;
+#endif
+      if (frameskip > max_autoframeskip)
+	frameskip = max_autoframeskip;
+      else if (frameskip < 0)
+	frameskip = 0;
+    }
+    if (sparetime > 0) {
+      /* if we're more than 2 frames ahead we need to resynch */
+      if (sparetime > uclocks_per_frame * 2)
+	target = scratch_time;
+      else {
+	/* idle until we hit frame ETA or leading */
+	profiler_mark(PROFILER_IDLE);
+	while (target - uclock() > leading)
+	  if (sleep_idle)
+	    usleep(100);
+	profiler_mark(PROFILER_END);
+      }
+    }
+    /* if we are behind we should force a skip: */
+    else if (autoframeskip && (frameskip < max_autoframeskip)
+	     && (frames_skipped < 1))
+      modframe = FRAMESKIP_LEVELS * 2 - frameskip;
+
+  }				/* if (throttle) */
+  if (skip_this_frame && (frames_skipped < FRAMESKIP_LEVELS))
+    frames_skipped++;
+  else {
+    /* update frame timer */
+    prev = target;
+
+    /* calculate average running speed for display purposes */
+    scratch_time = curr;
+    curr = uclock();
+    avg_uclocks = (avg_uclocks * 5 + curr - scratch_time) / (6 + frames_skipped);
+    speed = (speed * 5 + (float) uclocks_per_frame / avg_uclocks) / 6.0;
+    /* double-forward average  */
+
+    if (showfps) {
+      static char buf[80] = "";
+      static int showme = 0;
+
+      if (showme++ > 5) {
+	int fps = (Machine->drv->frames_per_second * framerate * speed + .5);
+#ifdef barath_debug
+	sprintf(buf, "%2d %d %s%s%s%2d %3d%%(%3d/%3d)", debug_value, sysload,
+		throttle ? "T" : "", (throttle && sleep_idle) ? "S" : "",
+		(throttle && autoframeskip) ? "A" : "F", frameskip,
+		(int) (speed * 100 + .5), (int) (fps / slow_speed),
+		(int) (Machine->drv->frames_per_second / slow_speed));
+
+	/* set game speed based on manual frameskip setting */
+	if (!throttle && !autoframeskip)
+	  slow_speed = (.25 + 3 * frameskip / (float) FRAMESKIP_LEVELS);
+#else
+	sprintf(buf, " %s%s%sfskp%2d %3d%%(%2d/%d fps)",
+	      throttle ? "T " : "", (throttle && sleep_idle) ? "S " : "",
+		(throttle && autoframeskip) ? "auto" : "", frameskip,
+	 (int) (speed * 100 + .5), fps, (int)Machine->drv->frames_per_second);
+#endif
+	showme = 0;
+      }
+      ui_text(buf, Machine->uiwidth - strlen(buf) * Machine->uifontwidth, 0);
+    }
+    frames_skipped = 0;
+  }
+
+  /* give a little grace in case something else sets it off */
+  if (sleep_idle && autoframeskip && (sysload > 33)) {
+    profiler_mark(PROFILER_IDLE);
+    usleep(100);
+    profiler_mark(PROFILER_END);
+  }
+  /* advance frameskip counter */
+  if (modframe >= FRAMESKIP_LEVELS)
+    modframe -= FRAMESKIP_LEVELS;
+  modframe += frameskip;
+
+  return barath_skip_this_frame();
+}
diff -Naur ../mmmmm/m36b16/src/unix/frameskip-drivers/dos.c mame-0.36b16/src/unix/frameskip-drivers/dos.c
--- ../mmmmm/m36b16/src/unix/frameskip-drivers/dos.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/frameskip-drivers/dos.c	2023-07-07 14:20:22.688001896 -0400
@@ -0,0 +1,149 @@
+#include "xmame.h"
+#include "driver.h"
+#include "profiler.h"
+#include "sysdep/misc.h"
+
+static int frameskip_counter = 0;
+
+int dos_skip_next_frame(int show_fps_counter /* , struct osd_bitmap *bitmap */)
+{
+	static const int skiptable[FRAMESKIP_LEVELS][FRAMESKIP_LEVELS] =
+	{
+		{ 0,0,0,0,0,0,0,0,0,0,0,0 },
+		{ 0,0,0,0,0,0,0,0,0,0,0,1 },
+		{ 0,0,0,0,0,1,0,0,0,0,0,1 },
+		{ 0,0,0,1,0,0,0,1,0,0,0,1 },
+		{ 0,0,1,0,0,1,0,0,1,0,0,1 },
+		{ 0,1,0,0,1,0,1,0,0,1,0,1 },
+		{ 0,1,0,1,0,1,0,1,0,1,0,1 },
+		{ 0,1,0,1,1,0,1,0,1,1,0,1 },
+		{ 0,1,1,0,1,1,0,1,1,0,1,1 },
+		{ 0,1,1,1,0,1,1,1,0,1,1,1 },
+		{ 0,1,1,1,1,1,0,1,1,1,1,1 },
+		{ 0,1,1,1,1,1,1,1,1,1,1,1 }
+	};
+	static const int waittable[FRAMESKIP_LEVELS][FRAMESKIP_LEVELS] =
+	{
+		{ 1,1,1,1,1,1,1,1,1,1,1,1 },
+		{ 2,1,1,1,1,1,1,1,1,1,1,0 },
+		{ 2,1,1,1,1,0,2,1,1,1,1,0 },
+		{ 2,1,1,0,2,1,1,0,2,1,1,0 },
+		{ 2,1,0,2,1,0,2,1,0,2,1,0 },
+		{ 2,0,2,1,0,2,0,2,1,0,2,0 },
+		{ 2,0,2,0,2,0,2,0,2,0,2,0 },
+		{ 2,0,2,0,0,3,0,2,0,0,3,0 },
+		{ 3,0,0,3,0,0,3,0,0,3,0,0 },
+		{ 4,0,0,0,4,0,0,0,4,0,0,0 },
+		{ 6,0,0,0,0,0,6,0,0,0,0,0 },
+		{12,0,0,0,0,0,0,0,0,0,0,0 }
+	};
+	int i;
+	uclock_t curr;
+	static uclock_t prev_frames[FRAMESKIP_LEVELS]={0,0,0,0,0,0,0,0,0,0,0,0};
+	static uclock_t prev=0;
+	static int speed=100;
+
+	/* now wait until it's time to update the screen */
+	if (skiptable[frameskip][frameskip_counter] == 0)
+	{
+        	if (throttle)
+        	{
+        		uclock_t target,target2;
+        		profiler_mark(PROFILER_IDLE);
+
+        		/* wait until enough time has passed since last frame... */
+        		target = prev +
+        			waittable[frameskip][frameskip_counter] * UCLOCKS_PER_SEC/Machine->drv->frames_per_second;
+
+        		/* ... OR since FRAMESKIP_LEVELS frames ago. This way, if a frame takes */
+        		/* longer than the allotted time, we can compensate in the following frames. */
+        		target2 = prev_frames[frameskip_counter] +
+        			FRAMESKIP_LEVELS * UCLOCKS_PER_SEC/Machine->drv->frames_per_second;
+
+        		if (target - target2 > 0) target = target2;
+
+        		curr = uclock();
+
+        		/* If we need to sleep more then half a second,
+        		   we've somehow got totally out of sync. So
+        		   if this happens we reset all counters */
+        		if ((target - curr) > (UCLOCKS_PER_SEC / 2))
+        		   for (i=0; i < FRAMESKIP_LEVELS; i++)
+        		      prev_frames[i] = curr;
+        		else
+        		   while ((curr - target) < 0)
+        		   {
+        		      curr = uclock();
+        		      if ((target - curr) > (UCLOCKS_PER_SEC / 1000) &&
+        		          sleep_idle)
+        		         usleep(100);
+        		   }
+
+        		profiler_mark(PROFILER_END);
+        	}
+        	else curr = uclock();
+
+        	if (frameskip_counter == 0 && (curr - prev_frames[frameskip_counter]))
+        	{
+        		int divdr;
+
+        		divdr = Machine->drv->frames_per_second * (curr - prev_frames[frameskip_counter]) / (100 * FRAMESKIP_LEVELS);
+        		speed = (UCLOCKS_PER_SEC + divdr/2) / divdr;
+        	}
+
+        	prev = curr;
+        	for (i = 0;i < waittable[frameskip][frameskip_counter];i++)
+        		prev_frames[(frameskip_counter + FRAMESKIP_LEVELS - i) % FRAMESKIP_LEVELS] = curr;
+
+        	if (show_fps_counter)
+        	{
+        		int fps;
+        		char buf[30];
+        		int divdr;
+
+        		divdr = 100 * FRAMESKIP_LEVELS;
+        		fps = (Machine->drv->frames_per_second * (FRAMESKIP_LEVELS - frameskip) * speed + (divdr / 2)) / divdr;
+        		sprintf(buf,"%s%s%s%2d %3d%%(%2d/%d fps)", throttle?"T ":"",
+			(throttle && sleep_idle)?"S ":"",
+			(throttle && autoframeskip)?"autofskp":"fskp",
+			frameskip,speed,fps,(int)Machine->drv->frames_per_second);
+        		ui_text(buf,Machine->uiwidth-strlen(buf)*Machine->uifontwidth,0);
+        	}
+
+		if (throttle && autoframeskip && frameskip_counter == 0)
+		{
+			static int frameskipadjust;
+
+			if (speed >= 100)
+			{
+				frameskipadjust++;
+				if (frameskipadjust >= 3)
+				{
+					frameskipadjust = 0;
+					if (frameskip > 0) frameskip--;
+				}
+			}
+			else
+			{
+				if (speed < 80)
+					frameskipadjust -= (90 - speed) / 5;
+				else
+				{
+					/* don't push frameskip too far if we are close to 100% speed */
+					if (frameskip < 8)
+						frameskipadjust--;
+				}
+
+				while (frameskipadjust <= -2)
+				{
+					frameskipadjust += 2;
+					if (frameskip < max_autoframeskip) frameskip++;
+				}
+			}
+		}
+	}
+
+	frameskip_counter = (frameskip_counter + 1) % FRAMESKIP_LEVELS;
+
+	return skiptable[frameskip][frameskip_counter];
+}
diff -Naur ../mmmmm/m36b16/src/unix/fronthlp.c mame-0.36b16/src/unix/fronthlp.c
--- ../mmmmm/m36b16/src/unix/fronthlp.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/fronthlp.c	2023-07-07 14:23:59.818627230 -0400
@@ -0,0 +1,1054 @@
+#include <stdarg.h> /* prolly should go in xmame.h */
+#include "xmame.h"
+#include "driver.h"
+#include "audit.h"
+#include "common.h"
+#include "info.h"
+
+static int frontend_list_clones(char *gamename);
+static int frontend_list_cpu(void);
+static int frontend_list_gamelistheader(void);
+
+static int list       = 0;
+static int showclones = 1;
+static int verbose    = 1;
+static int correct    = 0;
+static int incorrect  = 0;
+static int not_found  = 0;
+
+enum {
+   /* standard list commands */
+   LIST_LIST = 1, LIST_FULL, LIST_GAMES, LIST_DETAILS, LIST_GAMELIST,
+   LIST_SOURCEFILE, LIST_COLORS, LIST_EXTENSIONS, LIST_ROMSIZE, LIST_ROMS,
+   LIST_CRC, LIST_SAMPLES, LIST_SAMDIR, VERIFY_ROMS, VERIFY_ROMSETS,
+   VERIFY_SAMPLES, VERIFY_SAMPLESETS,
+   /* internal verification list commands (developers only) */
+   LIST_MISSINGROMS, LIST_DUPCRC, LIST_WRONGORIENTATION, LIST_WRONGMERGE,
+   LIST_WRONGFPS,
+   /* standard listcommands which require special handling */
+   LIST_CLONES, LIST_INFO, LIST_CPU, LIST_GAMELISTHEADER
+};
+
+/* Mame frontend interface & commandline */
+/* parsing rountines by Maurizio Zanello */
+
+struct rc_option frontend_list_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "Frontend Related", NULL,			rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "list",		"l",			rc_set_int,	&list,
+     NULL,		LIST_LIST,		0,		NULL,
+     "List supported games matching gamename, or all, gamename may contain * and ? wildcards" },
+   { "listfull",	"lf",			rc_set_int,	&list,
+     NULL,		LIST_FULL,		0,		NULL,
+     "Like -list, with full description" },
+   { "listgames",	"lg",			rc_set_int,	&list,
+     NULL,		LIST_GAMES,		0,		NULL,
+     "Like -list, with manufacturer and year" },
+   { "listdetails",	"ld",			rc_set_int,	&list,
+     NULL,		LIST_DETAILS,		0,		NULL,
+     "Like -list, with detailed info" },
+   { "listgamelist",	"lgl",			rc_set_int,	&list,
+     NULL,		LIST_GAMELIST,		0,		NULL,
+     "Like -list, with specialy formatted extra info for generating gamelist.mame, also see -listgamelistheader" },
+   { "listsourcefile",	"lsf",			rc_set_int,	&list,
+     NULL,		LIST_SOURCEFILE,	0,		NULL,
+     "Like -list, with driver sourcefile" },
+   { "listcolors",	"lcol",			rc_set_int,	&list,
+     NULL,		LIST_COLORS,		0,		NULL,
+     "Like -list, with the number of colors used" },
+#ifdef MESS
+   { "listextensions",	NULL,			rc_set_int,	&list,
+     NULL,		LIST_EXTENSIONS,	0,		NULL,
+     "Like -list, with devices and image file extensions supported" },
+#endif
+   { "listromsize",	"lrs",			rc_set_int,	&list,
+     NULL,		LIST_ROMSIZE,		0,		NULL,
+     "Like -list, with the year and size of the roms used" },
+   { "listroms",	"lr",			rc_set_int,	&list,
+     NULL,		LIST_ROMS,		0,		NULL,
+     "Like -list, but lists used ROMS" },
+   { "listcrc",		"lcrc",			rc_set_int,	&list,
+     NULL,		LIST_CRC,		0,		NULL,
+     "Like -list, but lists used ROMS with crc" },
+#if (HAS_SAMPLES)
+   { "listsamples",	"ls",			rc_set_int,	&list,
+     NULL,		LIST_SAMPLES,		0,		NULL,
+     "Like -list, but lists used audio samples" },
+   { "listsamdir",	"lsd",			rc_set_int,	&list,
+     NULL,		LIST_SAMDIR,		0,		NULL,
+     "Like -list, but lists dir where samples are taken from" },
+#endif
+   { "verifyroms",	"vr",			rc_set_int,	&list,
+     NULL,		VERIFY_ROMS,		0,		NULL,
+     "Verify ROMS for games matching gamename, or all, gamename may contain * and ? wildcards" },
+   { "verifyromsets",	"vrs",			rc_set_int,	&list,
+     NULL,		VERIFY_ROMSETS,		0,		NULL,
+     "Like -verifyroms, but less verbose" },
+#if (HAS_SAMPLES)
+   { "verifysamples",	"vs",			rc_set_int,	&list,
+     NULL,		VERIFY_SAMPLES,		0,		NULL,
+     "Like -verifyroms but verify audio samples instead" },
+   { "verifysamplesets", "vss",			rc_set_int,	&list,
+     NULL,		VERIFY_SAMPLESETS,	0,		NULL,
+     "Like -verifysamples, but less verbose" },
+#endif
+   { "clones",		"cl",			rc_bool,	&showclones,
+     "1",		0,			0,		NULL,
+     "Show / don't show bootlegs/clones in the above list commands" },
+   { "listclones",	"lcl",			rc_set_int,	&list,
+     NULL,		LIST_CLONES,		0,		NULL,
+     "Like -list, but lists the clones of the specified game" },
+   { "listinfo",        "li",			rc_set_int,	&list,
+     NULL,		LIST_INFO,		0,		NULL,
+     "List all available info on drivers" },
+   { "listcpu",		"lc",			rc_set_int,	&list,
+     NULL,		LIST_CPU,		0,		NULL,
+     "List cpu usage statics per year" },
+   { "listgamelistheader", "lgh",		rc_set_int,	&list,
+     NULL,		LIST_GAMELISTHEADER,	0,		NULL,
+     "Print header for generating gamelist.mame, also see -listgamelist" },
+   { "Internal verification list commands (only for developers)", NULL, rc_seperator, NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "listmissingroms",	"lmr",			rc_set_int,	&list,
+     NULL,		LIST_MISSINGROMS,		0,		NULL,
+     "Like -list, but lists ROMS missing" },
+   { "listdupcrc",	"ldc",			rc_set_int,	&list,
+     NULL,		LIST_DUPCRC,		0,		NULL,
+     "Like -list, but lists ROMS with identical crc" },
+   { "listwrongorientation", "lwo",			rc_set_int,	&list,
+     NULL,		LIST_WRONGORIENTATION,	0,		NULL,
+     "Like -list, but lists any games which use the orientation flags wrongly" },
+   { "listwrongmerge",	"lwm",			rc_set_int,	&list,
+     NULL,		LIST_WRONGMERGE,	0,		NULL,
+     "Like -list, but lists any games which use the clone_of field wrongly" },
+   { "listwrongfps",	"lwf",			rc_set_int,	&list,
+     NULL,		LIST_WRONGFPS,		0,		NULL,
+     "Like -list, but lists any games which use the FPS field wrongly" },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+/* compare string[8] using standard(?) wildchars ('?' & '*')          */
+/* for this to work correctly, the shells internal wildcard expansion */
+/* mechanism has to be disabled, use quotes */
+int strwildcmp(const char *sp1, const char *sp2)
+{
+   char s1[9], s2[9];
+   int i, l1, l2;
+   char *p;
+
+   strncpy(s1, sp1, 8); s1[8] = 0; if (s1[0] == 0) strcpy(s1, "*");
+
+   strncpy(s2, sp2, 8); s2[8] = 0; if (s2[0] == 0) strcpy(s2, "*");
+
+   p = strchr(s1, '*');
+   if (p)
+   {
+      for (i = p - s1; i < 8; i++) s1[i] = '?';
+      s1[8] = 0;
+   }
+
+   p = strchr(s2, '*');
+   if (p)
+   {
+      for (i = p - s2; i < 8; i++) s2[i] = '?';
+      s2[8] = 0;
+   }
+
+   l1 = strlen(s1);
+   if (l1 < 8)
+   {
+      for (i = l1 + 1; i < 8; i++) s1[i] = ' ';
+      s1[8] = 0;
+   }
+
+   l2 = strlen(s2);
+   if (l2 < 8)
+   {
+      for (i = l2 + 1; i < 8; i++) s2[i] = ' ';
+      s2[8] = 0;
+   }
+
+   for (i = 0; i < 8; i++)
+   {
+      if (s1[i] == '?' && s2[i] != '?') s1[i] = s2[i];
+      if (s2[i] == '?' && s1[i] != '?') s2[i] = s1[i];
+   }
+
+   return stricmp(s1, s2);
+}
+
+static int myprintf(char *fmt, ...) {
+  int i = 0;
+  va_list args;
+
+  if(verbose)
+  {
+     va_start(args, fmt);
+     i = vfprintf(stdout_file, fmt, args);
+     va_end(args);
+  }
+  return i;
+}
+
+static void frontend_verify(int driver, int rom)
+{
+   int status;
+
+   if(rom)
+      status = VerifyRomSet(driver, (verify_printf_proc)myprintf);
+   else
+      status = VerifySampleSet(driver, (verify_printf_proc)myprintf);
+
+   if (verbose)
+      fprintf(stdout_file, "%s %s ", rom? "romset":"sampleset",
+         drivers[driver]->name);
+   else
+      fprintf(stdout_file, "%-8s  ", drivers[driver]->name);
+
+   switch (status)
+   {
+      case BEST_AVAILABLE:
+         fprintf(stdout_file, "best available\n");
+         correct++;
+         break;
+      case CORRECT:
+         fprintf(stdout_file, "correct\n");
+         correct++;
+         break;
+      case NOTFOUND:
+      case CLONE_NOTFOUND:
+         fprintf(stdout_file, "not found\n");
+         not_found++;
+         break;
+      case INCORRECT:
+         fprintf(stdout_file, "incorrect\n");
+         incorrect++;
+         break;
+   }
+}
+
+static int frontend_uses_roms(int driver)
+{
+   const struct RomModule *romp = drivers[driver]->rom;
+   int total_roms = 0;
+
+   while(romp && (romp->name || romp->offset || romp->length))
+   {
+      if (romp->name && romp->name != (char *)-1)
+         total_roms++;
+
+      romp++;
+   }
+
+   return total_roms;
+}
+
+char *get_description(int driver)
+{
+   char *p;
+   char copy[BUF_SIZE];
+   static char description[BUF_SIZE];
+
+   snprintf(copy, BUF_SIZE, drivers[driver]->description);
+
+   /* Remove the additonal description if any */
+   if ((p = strstr(copy, " (")))
+      *p = 0;
+
+   /* Move leading "The" to the end */
+   if (strncmp(copy, "The ", 4) == 0)
+      snprintf(description, BUF_SIZE, "%s, The", copy+4);
+   else if (strncmp(copy, "Le ", 3) == 0)
+      snprintf(description, BUF_SIZE, "%s, Le", copy+3);
+   else
+      snprintf(description, BUF_SIZE, copy);
+
+   /* Print the additional description only if we are listing clones */
+   if (showclones && p)
+   {
+      int len = strlen(description);
+
+      *p = ' ';
+      snprintf(description + len, BUF_SIZE - len, p);
+   }
+
+   return description;
+}
+
+int frontend_list(char *gamename)
+{
+   int i, j=0;
+   const char *header[] = {
+/*** standard list commands ***/
+/* list             */ NAME" currently supports:\n",
+/* listfull         */ "name      description\n"
+                       "--------  -----------\n",
+/* listgames        */ "name      year  manufacturer                          description\n"
+                       "--------  ----  ------------------------------------  -----------\n",
+/* listdetails      */ "name      driver      cpu 1    cpu 2    cpu 3    cpu 4    cpu 5    cpu 6    cpu 7    cpu 8     sound 1     sound 2     sound 3     sound 4     sound 5      description\n"
+                       "--------  ----------  -------- -------- -------- -------- -------- -------- -------- --------  ----------- ----------- ----------- ----------- -----------  -----------\n",
+/* listgamelist     */ "+----------------------------------+-------+-------+-------+-------+----------+\n"
+                       "|                                  |       |Correct|       |Screen | Internal |\n"
+                       "| Game Name                        |Working|Colors | Sound | Flip  |   Name   |\n"
+                       "+----------------------------------+-------+-------+-------+-------+----------+\n",
+/* listsourcefile   */ "name      sourcefile\n"
+                       "--------  ----------\n",
+/* listcolors       */ "name      colors\n"
+                       "--------  ------\n",
+/* listextensions   */ "name      device      image file extensions supported\n"
+                       "--------  ----------  -------------------------------\n",
+/* listromsize      */ "name      year  size\n"
+                       "--------  ----  ----\n",
+/* listroms         */ "",
+/* listcrc          */ "CRC       filename      description\n"
+                       "--------  ------------  -----------\n",
+/* listsamples      */ "",
+/* listsamdir       */ "name      samples dir\n"
+                       "--------  -----------\n",
+/* verifyroms       */ "",
+/* verifyromsets    */ "name      result\n"
+                       "--------  ------\n",
+/* verifysamples    */ "",
+/* verifysamplesets */ "name      result\n"
+                       "--------  ------\n",
+/*** internal verification list commands (developers only) ***/
+/* listmissingroms  */ "name      clone of  description\n"
+                       "--------  --------  -----------\n",
+/* listdupcrc       */ "CRC       filename1    name1        filename2    name2\n"
+                       "--------  ------------ --------     ------------ --------\n",
+/* wrongorientation */ "",
+/* wrongmerge       */ "CRC       filename1    name1        filename2    name2\n"
+                       "--------  ------------ --------     ------------ --------\n",
+/* wrongfps         */ "name      resolution  fps\n"
+                       "--------  ----------  ---\n"
+   };
+
+   int matching     = 0;
+   int skipped      = 0;
+
+   if (!gamename)
+      gamename = "";
+
+   /* listcommands which require special handling */
+   switch(list)
+   {
+      /* no list requested */
+      case 0:
+         return 1234;
+      /* listclones is a special case since the strwildcmp */
+      /* also has to be done on clone_of. */
+      case LIST_CLONES:
+         return frontend_list_clones(gamename);
+      /* listinfo is handled by the core */
+      case LIST_INFO:
+         print_mame_info( stdout_file, drivers );
+         return OSD_OK;
+      case LIST_CPU:
+         return frontend_list_cpu();
+      case LIST_GAMELISTHEADER:
+         return frontend_list_gamelistheader();
+   }
+
+   fprintf(stdout_file, header[list-1]);
+
+   for (i=0;drivers[i];i++)
+   {
+         if ( (showclones || (drivers[i]->clone_of == 0) ||
+                (drivers[i]->clone_of->flags & NOT_A_DRIVER)) &&
+              !strwildcmp(gamename, drivers[i]->name) )
+         {
+            matching++;
+
+            switch(list)
+            {
+               /*** standard list commands ***/
+               case LIST_LIST: /* simple games list */
+                  fprintf(stdout_file, "%-8s ", drivers[i]->name);
+                  if (!(matching % 8)) fprintf(stdout_file, "\n");
+                  break;
+               case LIST_FULL: /* games list with descriptions */
+                  fprintf(stdout_file, "%-8s  %s\n", drivers[i]->name,
+                     get_description(i));
+                  break;
+               case LIST_GAMES:
+               {
+                  fprintf(stdout_file, "%-8s  %-4s  %-36s  %s\n",
+                     drivers[i]->name,
+                     drivers[i]->year, drivers[i]->manufacturer,
+                     get_description(i));
+                  break;
+               }
+               case LIST_DETAILS: /* A detailed MAMELIST.TXT type roms lister */
+                  /* First, the rom name */
+                  fprintf(stdout_file, "%-8s  ",drivers[i]->name);
+
+#ifndef MESS
+                  /* source file (skip the leading "src/drivers/" */
+                  fprintf(stdout_file, "%-10s  ",&drivers[i]->source_file[12]);
+#else
+                  /* source file (skip the leading "src/mess/systems/" */
+                  fprintf(stdout_file, "%-10s  ",&drivers[i]->source_file[17]);
+#endif
+
+                  /* Then, cpus */
+                  for(j=0;j<MAX_CPU;j++)
+                  {
+                     const struct MachineCPU *x_cpu = drivers[i]->drv->cpu;
+                     if (x_cpu[j].cpu_type & CPU_AUDIO_CPU)
+                        fprintf(stdout_file, "[%-6s] ",cputype_name(x_cpu[j].cpu_type));
+                      else
+                        fprintf(stdout_file, "%-8s ",cputype_name(x_cpu[j].cpu_type));
+                  }
+                  fprintf(stdout_file, " ");
+
+                  for(j=0;j<MAX_SOUND;j++)
+                  {
+                     const struct MachineSound *x_sound = drivers[i]->drv->sound;
+                     if (sound_num(&x_sound[j]))
+                     {
+                        fprintf(stdout_file, "%dx",sound_num(&x_sound[j]));
+                        fprintf(stdout_file, "%-9s ",sound_name(&x_sound[j]));
+                     }
+                     else
+                        fprintf(stdout_file, "%-11s ",sound_name(&x_sound[j]));
+                  }
+
+                  /* Lastly, the name of the game and a \newline */
+                  fprintf(stdout_file, " %s\n", get_description(i));
+                  break;
+               case LIST_GAMELIST:
+                  {
+                     fprintf(stdout_file, "| %-33.33s", get_description(i));
+
+                     if (drivers[i]->flags & GAME_NOT_WORKING)
+                     {
+                        const struct GameDriver *maindrv;
+                        int foundworking;
+
+                        if (drivers[i]->clone_of && !(drivers[i]->clone_of->flags & NOT_A_DRIVER))
+                           maindrv = drivers[i]->clone_of;
+                        else maindrv = drivers[i];
+
+                        foundworking = 0;
+                        j = 0;
+                        while (drivers[j])
+                        {
+                           if (drivers[j] == maindrv || drivers[j]->clone_of == maindrv)
+                           {
+                              if ((drivers[j]->flags & GAME_NOT_WORKING) == 0)
+                              {
+                                 foundworking = 1;
+                                 break;
+                              }
+                           }
+                           j++;
+                        }
+
+                        if (foundworking)
+                           fprintf(stdout_file, "| No(1) ");
+                        else
+                           fprintf(stdout_file, "|   No  ");
+                     }
+                     else
+                        fprintf(stdout_file, "|  Yes  ");
+
+                     if (drivers[i]->flags & GAME_WRONG_COLORS)
+                        fprintf(stdout_file, "|   No  ");
+                     else if (drivers[i]->flags & GAME_IMPERFECT_COLORS)
+                        fprintf(stdout_file, "| Close ");
+                     else
+                        fprintf(stdout_file, "|  Yes  ");
+
+                     {
+                        const char **samplenames = 0;
+#if (HAS_SAMPLES || HAS_VLM5030)
+                        for (j = 0;drivers[i]->drv->sound[j].sound_type && j < MAX_SOUND; j++)
+                        {
+#if (HAS_SAMPLES)
+                           if (drivers[i]->drv->sound[j].sound_type == SOUND_SAMPLES)
+                           {
+                              samplenames = ((struct Samplesinterface *)drivers[i]->drv->sound[j].sound_interface)->samplenames;
+                              break;
+                           }
+#endif
+#if (HAS_VLM5030)
+                           if (drivers[i]->drv->sound[j].sound_type == SOUND_VLM5030)
+                           {
+                              samplenames = ((struct Samplesinterface *)drivers[i]->drv->sound[j].sound_interface)->samplenames;
+                              break;
+                           }
+#endif
+
+                        }
+#endif
+                        if (drivers[i]->flags & GAME_NO_SOUND)
+                           fprintf(stdout_file, "|   No  ");
+                        else if (drivers[i]->flags & GAME_IMPERFECT_SOUND)
+                        {
+                           if (samplenames)
+                              fprintf(stdout_file, "|Part(2)");
+                           else
+                              fprintf(stdout_file, "|Partial");
+                        }
+                        else
+                        {
+                           if (samplenames)
+                              fprintf(stdout_file, "| Yes(2)");
+                           else
+                              fprintf(stdout_file, "|  Yes  ");
+                        }
+                     }
+#if 0 /* RB */
+                     if (drivers[i]->flags & GAME_NO_COCKTAIL)
+                        fprintf(stdout_file, "|   No  ");
+                     else
+                        fprintf(stdout_file, "|  Yes  ");
+#endif
+                     fprintf(stdout_file, "| %-8s |\n",drivers[i]->name);
+
+                  }
+                  break;
+               case LIST_SOURCEFILE:
+                  fprintf(stdout_file, "%-8s  %s\n", drivers[i]->name,
+                     drivers[i]->source_file);
+                  break;
+               case LIST_COLORS:
+                  fprintf(stdout_file, "%-8s  %d\n", drivers[i]->name,
+                     drivers[i]->drv->total_colors);
+                  break;
+#ifdef MESS
+               case LIST_EXTENSIONS: /* list extensions */
+                   if(drivers[i]->dev && (drivers[i]->dev->type != IO_END))
+                   {
+                      const struct IODevice *dev = drivers[i]->dev;
+
+                      j = 0;
+
+                      fprintf(stdout_file, "%-8s  ", drivers[i]->name);
+
+                      while (dev->type != IO_END)
+                      {
+                         const char *src = dev->file_extensions;
+
+                         if (!j) /* first time ? */
+                            fprintf(stdout_file, "%-10s  ",
+                               device_typename(dev->type));
+                         else
+                            fprintf(stdout_file, "%-8s  %-10s  ", "",
+                               device_typename(dev->type));
+
+                         while (*src)
+                         {
+                            fprintf(stdout_file, ".%-3s  ", src);
+                            src += strlen(src) + 1;
+                         }
+                         fprintf(stdout_file, "\n");
+                         j++;
+                         dev++;
+                      }
+                   }
+                   else
+                      skipped++;
+                   break;
+#endif
+               case LIST_ROMSIZE:
+                  {
+                     const struct RomModule *romp;
+                     j = 0;
+
+                     romp = drivers[i]->rom;
+
+                     while (romp && (romp->name || romp->offset || romp->length))
+                     {
+                        j += romp->length & ~ROMFLAG_MASK;
+                        romp++;
+                     }
+                     printf("%-8s  %-4s  %u\n", drivers[i]->name,
+                        drivers[i]->year, j);
+                  }
+                  break;
+               case LIST_ROMS: /* game roms list */
+                  if(!frontend_uses_roms(i))
+                  {
+                     skipped++;
+                     continue;
+                  }
+
+                  printromlist(drivers[i]->rom, drivers[i]->name);
+                  fprintf(stdout_file, "\n");
+                  break;
+               case LIST_CRC: /* list all crc-32 */
+                  {
+                     const struct RomModule *romp = drivers[i]->rom;
+
+                     if(!frontend_uses_roms(i))
+                     {
+                        skipped++;
+                        continue;
+                     }
+
+                     while (romp->name || romp->offset || romp->length)
+                     {
+                        if (romp->name && romp->name != (char *)-1)
+                        {
+                           fprintf(stdout_file, "%08x  %-12s  %s\n", romp->crc,
+                              romp->name, get_description(i));
+                        }
+                        romp++;
+                     }
+                  }
+                  break;
+#if (HAS_SAMPLES || HAS_VLM5030)
+               case LIST_SAMPLES: /* game samples list */
+               case LIST_SAMDIR:  /* games list with samples directories */
+                  {
+                     int found = 0;
+
+                     for( j = 0; drivers[i]->drv->sound[j].sound_type && j < MAX_SOUND; j++ )
+                     {
+                        const char **samplenames = NULL;
+#if (HAS_SAMPLES)
+                        if( drivers[i]->drv->sound[j].sound_type == SOUND_SAMPLES )
+                           samplenames = ((struct Samplesinterface *)drivers[i]->drv->sound[j].sound_interface)->samplenames;
+#endif
+#if (HAS_VLM5030)
+                        if( drivers[i]->drv->sound[j].sound_type == SOUND_VLM5030 )
+                           samplenames = ((struct Samplesinterface *)drivers[i]->drv->sound[j].sound_interface)->samplenames;
+#endif
+                        if (samplenames && samplenames[0])
+                        {
+                           found = 1;
+
+                           if(list == LIST_SAMPLES)
+                           {
+                              int k = 0;
+
+                              while (samplenames[k] != 0)
+                              {
+                                 printf("%s\n", samplenames[k]);
+                                 k++;
+                              }
+                           }
+                           else
+                           {
+                              printf("%-10s",drivers[i]->name);
+                              if (samplenames[0][0] == '*')
+                                 printf("%s\n",samplenames[0]+1);
+                              else
+                                 printf("%s\n",drivers[i]->name);
+                           }
+                        }
+                     }
+                     if (!found)
+                        skipped++;
+                  }
+                  break;
+               case VERIFY_SAMPLESETS:
+                  verbose = 0;
+                  /* fall through */
+               case VERIFY_SAMPLES:
+                  {
+                     const char **samplenames = NULL;
+
+                     for( j = 0; drivers[i]->drv->sound[j].sound_type && j < MAX_SOUND; j++ )
+                     {
+#ifdef HAS_SAMPLES
+                        if( drivers[i]->drv->sound[j].sound_type == SOUND_SAMPLES )
+                           samplenames = ((struct Samplesinterface *)drivers[i]->drv->sound[j].sound_interface)->samplenames;
+#endif
+#ifdef HAS_VLM5030
+                        if( drivers[i]->drv->sound[j].sound_type == SOUND_VLM5030 )
+                           samplenames = ((struct Samplesinterface *)drivers[i]->drv->sound[j].sound_interface)->samplenames;
+#endif
+                     }
+
+                     /* ignore games that need no samples */
+                     if (samplenames == NULL || samplenames[0] == NULL)
+                        skipped++;
+                     else
+                        frontend_verify(i, 0);
+                  }
+                  break;
+#endif
+               case VERIFY_ROMSETS:
+                  verbose = 0;
+                  /* fall through */
+               case VERIFY_ROMS:
+                  /* ignore games that need no roms */
+                  if (!frontend_uses_roms(i))
+                     skipped++;
+                  else
+                     frontend_verify(i, 1);
+                  break;
+
+               /*** internal verification list commands (developers only) ***/
+               case LIST_MISSINGROMS:
+                  if (RomsetMissing (i))
+                  {
+                     fprintf(stdout_file, "%-8s  %-8s  %s\n", drivers[i]->name,
+                        (drivers[i]->clone_of) ? drivers[i]->clone_of->name : "",
+                        get_description(i));
+                     not_found++;
+                  }
+                  break;
+               case LIST_DUPCRC:
+                  {
+                     const struct RomModule *romp = drivers[i]->rom;
+                     int found = 0;
+
+                     if(!frontend_uses_roms(i))
+                     {
+                        skipped++;
+                        continue;
+                     }
+
+                     while (romp->name || romp->offset || romp->length)
+                     {
+                        if (romp->name && romp->name != (char *)-1 && romp->crc)
+                        {
+                           j = i+1;
+                           while (drivers[j])
+                           {
+                              const struct RomModule *romp1 = drivers[j]->rom;
+
+                              while (romp1->name || romp1->offset || romp1->length)
+                              {
+                                 if (romp1->name && romp1->name != (char *)-1 &&
+                                    strcmp(romp->name,romp1->name) &&
+                                    romp1->crc == romp->crc)
+                                 {
+                                    fprintf(stdout_file, "%08x  %-12s %-8s <-> %-12s %-8s\n",romp->crc,
+                                       romp->name,drivers[i]->name, romp1->name,drivers[j]->name);
+                                    found = 1;
+                                 }
+                                 romp1++;
+                              }
+                              j++;
+                           }
+                        }
+                        romp++;
+                     }
+                     if (found)
+                        incorrect++;
+                     else
+                        correct++;
+                  }
+                  break;
+               case LIST_WRONGORIENTATION: /* list drivers which incorrectly use the orientation and visible area fields */
+                  if(!(drivers[i]->drv->video_attributes & VIDEO_TYPE_VECTOR) &&
+                     ((drivers[i]->drv->visible_area.max_x - drivers[i]->drv->visible_area.min_x + 1) <=
+                      (drivers[i]->drv->visible_area.max_y - drivers[i]->drv->visible_area.min_y + 1)) &&
+                     /* list of valid exceptions */
+                     strcmp(drivers[i]->name,"crater") &&
+                     strcmp(drivers[i]->name,"mpatrol") &&
+                     strcmp(drivers[i]->name,"troangel") &&
+                     strcmp(drivers[i]->name,"travrusa") &&
+                     strcmp(drivers[i]->name,"kungfum") &&
+                     strcmp(drivers[i]->name,"battroad") &&
+                     strcmp(drivers[i]->name,"vigilant") &&
+                     strcmp(drivers[i]->name,"sonson") &&
+                     strcmp(drivers[i]->name,"brkthru") &&
+                     strcmp(drivers[i]->name,"darwin") &&
+                     strcmp(drivers[i]->name,"exprraid") &&
+                     strcmp(drivers[i]->name,"sidetrac") &&
+                     strcmp(drivers[i]->name,"targ") &&
+                     strcmp(drivers[i]->name,"spectar") &&
+                     strcmp(drivers[i]->name,"venture") &&
+                     strcmp(drivers[i]->name,"mtrap") &&
+                     strcmp(drivers[i]->name,"pepper2") &&
+                     strcmp(drivers[i]->name,"hardhat") &&
+                     strcmp(drivers[i]->name,"fax") &&
+                     strcmp(drivers[i]->name,"circus") &&
+                     strcmp(drivers[i]->name,"robotbwl") &&
+                     strcmp(drivers[i]->name,"crash") &&
+                     strcmp(drivers[i]->name,"ripcord") &&
+                     strcmp(drivers[i]->name,"starfire") &&
+                     strcmp(drivers[i]->name,"fireone") &&
+                     strcmp(drivers[i]->name,"renegade") &&
+                     strcmp(drivers[i]->name,"battlane") &&
+                     strcmp(drivers[i]->name,"megatack") &&
+                     strcmp(drivers[i]->name,"killcom") &&
+                     strcmp(drivers[i]->name,"challeng") &&
+                     strcmp(drivers[i]->name,"kaos") &&
+                     strcmp(drivers[i]->name,"formatz") &&
+                     strcmp(drivers[i]->name,"bankp") &&
+                     strcmp(drivers[i]->name,"liberatr") &&
+                     strcmp(drivers[i]->name,"toki") &&
+                     strcmp(drivers[i]->name,"stactics") &&
+                     strcmp(drivers[i]->name,"sprint1") &&
+                     strcmp(drivers[i]->name,"sprint2") &&
+                     strcmp(drivers[i]->name,"nitedrvr") &&
+                     strcmp(drivers[i]->name,"punchout") &&
+                     strcmp(drivers[i]->name,"spnchout") &&
+                     strcmp(drivers[i]->name,"armwrest") &&
+                     strcmp(drivers[i]->name,"route16") &&
+                     strcmp(drivers[i]->name,"stratvox") &&
+                     strcmp(drivers[i]->name,"irobot") &&
+                     strcmp(drivers[i]->name,"leprechn") &&
+                     strcmp(drivers[i]->name,"starcrus") &&
+                     strcmp(drivers[i]->name,"astrof") &&
+                     strcmp(drivers[i]->name,"tomahawk") &&
+                     strcmp(drivers[i]->name,"astrocde") &&
+                     strcmp(drivers[i]->name,"vic20") &&
+                     strcmp(drivers[i]->name,"vc20") &&
+                     strcmp(drivers[i]->name,"p2000t") &&
+                     strcmp(drivers[i]->name,"kim1"))
+                  {
+                      fprintf(stdout_file, "%s %dx%d\n",drivers[i]->name,
+                         drivers[i]->drv->visible_area.max_x - drivers[i]->drv->visible_area.min_x + 1,
+                         drivers[i]->drv->visible_area.max_y - drivers[i]->drv->visible_area.min_y + 1);
+                      incorrect++;
+                  } else correct++;
+                  break;
+               case LIST_WRONGMERGE: /* list duplicate crc-32 with different ROM name in clone sets */
+                  {
+                     const struct RomModule *romp = drivers[i]->rom;
+                     int found = 0;
+
+                     if(!frontend_uses_roms(i))
+                     {
+                        skipped++;
+                        continue;
+                     }
+
+                     while (romp->name || romp->offset || romp->length)
+                     {
+                        if (romp->name && romp->name != (char *)-1 && romp->crc)
+                        {
+                           j = 0;
+                           while (drivers[j])
+                           {
+                              if(j != i &&
+                                 drivers[j]->clone_of &&
+                                 !(drivers[j]->clone_of->flags & NOT_A_DRIVER) &&
+                                 (drivers[j]->clone_of == drivers[i] ||
+                                    (i < j &&
+                                       drivers[j]->clone_of == drivers[i]->clone_of)))
+                              {
+                                 int match = 0;
+                                 const struct RomModule *romp1 = drivers[j]->rom;
+
+                                 while (romp1 && (romp1->name || romp1->offset || romp1->length))
+                                 {
+                                    if(romp1->name && romp1->name != (char *)-1 &&
+                                       !strcmp(romp->name,romp1->name))
+                                    {
+                                       match = 1;
+                                       break;
+                                    }
+                                    romp1++;
+                                 }
+                                 if (match == 0)
+                                 {
+                                    romp1 = drivers[j]->rom;
+
+                                    while (romp1->name || romp1->offset || romp1->length)
+                                    {
+                                       if(romp1->name && romp1->name != (char *)-1 &&
+                                          strcmp(romp->name,romp1->name) &&
+                                          romp1->crc == romp->crc)
+                                       {
+                                          fprintf(stdout_file,
+                                             "%08x  %-12s %-8s <-> %-12s %-8s\n",
+                                             romp->crc, romp->name,
+                                             drivers[i]->name,
+                                             romp1->name,
+                                             drivers[j]->name);
+                                          found = 1;
+                                       }
+                                       romp1++;
+                                    }
+                                 }
+                              }
+                              j++;
+                           }
+                        }
+                        romp++;
+                     }
+                     if (found)
+                        incorrect++;
+                     else
+                        correct++;
+                  }
+                  break;
+               case LIST_WRONGFPS: /* list drivers with too high frame rate */
+                  if ((drivers[i]->drv->video_attributes & VIDEO_TYPE_VECTOR) == 0 &&
+                     (drivers[i]->clone_of == 0 ||
+                        drivers[i]->clone_of->flags & NOT_A_DRIVER) &&
+                     drivers[i]->drv->frames_per_second > 57 &&
+                     drivers[i]->drv->visible_area.max_y - drivers[i]->drv->visible_area.min_y + 1 > 244 &&
+                     drivers[i]->drv->visible_area.max_y - drivers[i]->drv->visible_area.min_y + 1 <= 256)
+                  {
+                     fprintf(stdout_file, "%-8s  %-4dx%4d   %d\n",
+                        drivers[i]->name,
+                        drivers[i]->drv->visible_area.max_x -
+                           drivers[i]->drv->visible_area.min_x + 1,
+                        drivers[i]->drv->visible_area.max_y -
+                           drivers[i]->drv->visible_area.min_y + 1,
+                        (int)drivers[i]->drv->frames_per_second);
+                     incorrect++;
+                  }
+                  else
+                     correct++;
+                  break;
+            }
+         }
+   }
+
+   /* print footer for those -list options which need one */
+   switch(list)
+   {
+      case LIST_GAMELIST:
+         fprintf(stdout_file,
+            "+----------------------------------+-------+-------+-------+-------+----------+\n\n"
+            "(1) There are variants of the game (usually bootlegs) that work correctly\n"
+#if (HAS_SAMPLES)
+            "(2) Needs samples provided separately\n"
+#endif
+            );
+         break;
+   }
+
+   if (matching == 0)
+   {
+      fprintf(stderr_file, "Error: \"%s\" is not supported!\n", gamename);
+      return 1;
+   }
+
+   fprintf(stdout_file, "\n\n");
+   fprintf(stdout_file, "Total Supported: %d", i);
+   if (matching != i)
+   {
+      fprintf(stdout_file, ", Matching \"%s\": %d\n", gamename, matching);
+   }
+   else
+   {
+      fprintf(stdout_file, "\n");
+   }
+   if (skipped) fprintf(stdout_file, "Displayed: %d, Skipped: %d, because they don't use any roms/samples/devices\n", matching-skipped, skipped);
+   if (correct+incorrect) fprintf(stdout_file, "Found: %d, of which %d correct and %d incorrect\n", correct+incorrect, correct, incorrect);
+   if (not_found) fprintf(stdout_file, "Not found: %d\n", not_found);
+   fflush(stdout_file);
+
+   if (incorrect > 0)
+      return 2;
+   else
+      return 0;
+}
+
+static int frontend_list_clones(char *gamename)
+{
+   /* listclones is a special case since the strwildcmp */
+   /* also has to be done on clone_of. */
+   int i;
+
+   fprintf(stdout_file, "Name:    Clone of:\n");
+   for (i=0;drivers[i];i++)
+   {
+      if(drivers[i]->clone_of &&
+         !(drivers[i]->clone_of->flags & NOT_A_DRIVER) &&
+         ( !strwildcmp(gamename,drivers[i]->name) ||
+           !strwildcmp(gamename,drivers[i]->clone_of->name)))
+         fprintf(stdout_file, "%-8s %-8s\n",drivers[i]->name,drivers[i]->clone_of->name);
+   }
+   return 0;
+}
+
+static int frontend_list_cpu(void)
+{
+   int i,j;
+   int year;
+
+   for (j = 1;j < CPU_COUNT;j++)
+      fprintf(stdout_file, "\t%s", cputype_name(j));
+
+   fprintf(stdout_file, "\n");
+
+   for (year = 1980;year <= 1995;year++)
+   {
+      int count[CPU_COUNT];
+
+      for (j = 0;j < CPU_COUNT;j++)
+         count[j] = 0;
+
+      i = 0;
+
+      while (drivers[i])
+      {
+         if (drivers[i]->clone_of == 0 || (drivers[i]->clone_of->flags & NOT_A_DRIVER))
+         {
+            const struct MachineDriver *x_driver = drivers[i]->drv;
+            const struct MachineCPU *x_cpu = x_driver->cpu;
+
+            if (atoi(drivers[i]->year) == year)
+            {
+               for (j = 0;j < MAX_CPU;j++)
+                  count[x_cpu[j].cpu_type & ~CPU_FLAGS_MASK]++;
+            }
+         }
+         i++;
+      }
+
+      fprintf(stdout_file, "%d", year);
+      for (j = 1;j < CPU_COUNT;j++)
+         fprintf(stdout_file, "\t%d", count[j]);
+
+      fprintf(stdout_file, "\n");
+   }
+   return OSD_OK;
+}
+
+static int frontend_list_gamelistheader(void)
+{
+   fprintf(stdout_file,
+      "This is the complete list of games supported by %s %s\n",
+      NAME, build_version);
+   if (!showclones)
+      fprintf(stdout_file,
+         "Variants of the same game are not included, you can use the -listclones command\n"
+         "to get a list of the alternate versions of a given game.\n");
+   fprintf(stdout_file, "\n"
+      "The list is generated automatically and is not 100%% accurate, particularly in\n"
+      "the \"Screen Flip\" column. Please let us know of any errors you find so we can\n"
+      "correct them.\n"
+      "\n");
+   fprintf(stdout_file,
+      "The meanings of the columns are as follows:\n"
+      "Working - \"No\" means that the emulation has shortcomings that cause the game\n"
+      "  not to work correctly. This can be anywhere from just showing a black screen\n"
+      "  to being playable with major problems.\n");
+   fprintf(stdout_file,
+      "Correct Colors - \"Yes\" means that colors should be identical to the original,\n"
+      "  \"Close\" that they are very similar but wrong in places, \"No\" that they are\n"
+      "  completely wrong. In some cases, we were not able to find the color PROMs of\n");
+   fprintf(stdout_file,
+      "  the game. Those PROMs will be reported as \"NO GOOD DUMP KNOWN\" on startup,\n"
+      "  and the game will have wrong colors. The game is still reported as \"Yes\" in\n"
+      "  this column, because the code to handle the color PROMs is in the driver and\n"
+      "  if you provide them colors will be correct.\n");
+   fprintf(stdout_file,
+      "Sound - \"Partial\" means that sound support is either incomplete or not entirely\n"
+      "  accurate. Note that, due to analog circuitry which is difficult to emulate,\n"
+      "  sound may be significantly different from the real board. A common case is\n"
+      "  the presence of low pass filters that make the real board sound less harsh\n"
+      "  than the emulation.\n");
+   fprintf(stdout_file,
+      "Screen Flip - A large number of games have a dip switch setting for \"Cocktail\"\n"
+      "  cabinet, meaning that the players sit in front of each other, and the screen\n"
+      "  is flipped when player 2 is playing. Some games also have a \"Flip Screen\" dip\n"
+      "  switch. Those need special support in the driver, which is missing in many\n"
+      "  cases.\n");
+   fprintf(stdout_file,
+      "Internal Name - This is the unique name that should be specified on the command\n"
+      "  line to run the game. ROMs must be placed in the ROM path, either in a .zip\n"
+      "  file or in a subdirectory of the same name. The former is suggested, because\n"
+      "  the files will be identified by their CRC instead of requiring specific\n"
+      "  names.\n\n");
+
+   return OSD_OK;
+}
diff -Naur ../mmmmm/m36b16/src/unix/ident.c mame-0.36b16/src/unix/ident.c
--- ../mmmmm/m36b16/src/unix/ident.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/ident.c	2023-07-07 14:20:22.688001896 -0400
@@ -0,0 +1,325 @@
+#include "xmame.h"
+#include "audit.h"
+#include "unzip.h"
+#include "driver.h"
+#include <dirent.h>
+
+#ifdef BSD43 /* old style directory handling */
+#include <sys/types.h>
+#include <sys/dir.h>
+#define dirent direct
+#endif
+
+/* #define IDENT_DEBUG */
+
+unsigned int crc32 (unsigned int crc, const unsigned char *buf, unsigned int len);
+void romident(const char* name, int enter_dirs);
+
+enum { KNOWN_START, KNOWN_ALL, KNOWN_NONE, KNOWN_SOME };
+
+static int silentident = 0;
+static int knownstatus = KNOWN_START;
+static int ident = 0;
+
+enum { IDENT_IDENT = 1, IDENT_ISKNOWN };
+
+struct rc_option frontend_ident_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "Rom Identification Related", NULL,	rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "ident",		"id",			rc_set_int,	&ident,
+     NULL,		IDENT_IDENT,		0,		NULL,
+     "Identify unknown romdump, or unknown romdumps in dir/zip" },
+   { "isknown",		"ik",			rc_set_int,	&ident,
+     NULL,		IDENT_ISKNOWN,		0,		NULL,
+     "Check if romdump or romdumps in dir/zip are known"} ,
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+
+/* Identifies a rom from from this checksum */
+void identify_rom(const char* name, int checksum, int length)
+{
+/* Nicola output format */
+#if 1
+	int found = 0;
+	int i;
+#ifdef IDENT_DEBUG
+	fprintf(stderr_file, "identify_rom(%s, %x, %d) called\n", name,
+		checksum, length);
+#endif
+
+	/* remove directory name */
+	for (i = strlen(name)-1;i >= 0;i--)
+	{
+		if (name[i] == '/' || name[i] == '\\')
+		{
+			i++;
+			break;
+		}
+	}
+	if (!silentident)
+		fprintf(stdout_file, "%-12s ",&name[i]);
+
+	for (i = 0; drivers[i]; i++)
+	{
+		const struct RomModule *romp;
+
+		romp = drivers[i]->rom;
+		
+		/* for pong and others which don't have roms */
+		if (!romp)
+		   continue;
+
+#ifdef IDENT_DEBUG
+		fprintf(stderr_file, "in identify_rom, starting loop, driver = %d (%s), romp = %p, romp->name = %s, romp->offset = 0x%X, romp->lenght = 0x%X\n",
+			i, drivers[i]->name, romp, (romp->name==-1)? "-1":romp->name, romp->offset, romp->length);
+#endif
+		while (romp->name || romp->offset || romp->length)
+		{
+			if (romp->name && romp->name != (char *)-1 && checksum == romp->crc)
+			{
+				if (!silentident)
+				{
+					if (found != 0)
+						fprintf(stdout_file, "             ");
+					fprintf(stdout_file, "= %-12s  %s\n",romp->name,drivers[i]->description);
+				}
+				found++;
+			}
+			romp++;
+#ifdef IDENT_DEBUG
+			fprintf(stderr_file, "in identify_rom, in loop, romp = %p, romp->name = %s, romp->offset = 0x%X, romp->lenght = 0x%X\n",
+				romp, (romp->name==-1)? "-1":romp->name, romp->offset, romp->length);
+#endif
+		}
+	}
+	if (found == 0)
+	{
+		unsigned size = length;
+		while (size && (size & 1) == 0) size >>= 1;
+		if (size & ~1)
+		{
+			if (!silentident)
+				fprintf(stdout_file, "NOT A ROM\n");
+		}
+		else
+		{
+			if (!silentident)
+				fprintf(stdout_file, "NO MATCH\n");
+			if (knownstatus == KNOWN_START)
+				knownstatus = KNOWN_NONE;
+			else if (knownstatus == KNOWN_ALL)
+				knownstatus = KNOWN_SOME;
+		}
+	}
+	else
+	{
+		if (knownstatus == KNOWN_START)
+			knownstatus = KNOWN_ALL;
+		else if (knownstatus == KNOWN_NONE)
+			knownstatus = KNOWN_SOME;
+	}
+#else
+/* New output format */
+	int i;
+	fprintf(stdout_file, "%s\n",name);
+
+	for (i = 0; drivers[i]; i++) {
+		const struct RomModule *romp;
+
+		romp = drivers[i]->rom;
+
+		/* for pong and others which don't have roms */
+		if (!romp)
+		   continue;
+
+		while (romp->name || romp->offset || romp->length)
+		{
+			if (romp->name && romp->name != (char *)-1 && checksum == romp->crc)
+			{
+				fprintf(stdout_file, "\t%s/%s %s, %s, %s\n",drivers[i]->name,romp->name,
+					drivers[i]->description,
+					drivers[i]->manufacturer,
+					drivers[i]->year);
+			}
+			romp++;
+		}
+	}
+#endif
+}
+
+/* Identifies a file from from this checksum */
+void identify_file(const char* name)
+{
+	FILE *f;
+	int length;
+	char* data;
+#ifdef IDENT_DEBUG
+	fprintf(stderr_file, "identify_file(%s) called\n", name);
+#endif
+
+	f = fopen(name,"rb");
+	if (!f) {
+		return;
+	}
+
+	/* determine length of file */
+	if (fseek (f, 0L, SEEK_END)!=0)	{
+		fclose(f);
+		return;
+	}
+
+	length = ftell(f);
+	if (length == -1L) {
+		fclose(f);
+		return;
+	}
+
+	/* empty file */
+	if (!length) {
+		fclose(f);
+		return;
+	}
+
+	/* allocate space for entire file */
+	data = (char*)malloc(length);
+	if (!data) {
+		fclose(f);
+		return;
+	}
+
+	if (fseek (f, 0L, SEEK_SET)!=0) {
+		free(data);
+		fclose(f);
+		return;
+	}
+
+	if (fread(data, 1, length, f) != length) {
+		free(data);
+		fclose(f);
+		return;
+	}
+
+	fclose(f);
+
+	identify_rom(name, crc32(0L,(const unsigned char*)data,length), length);
+
+	free(data);
+}
+
+void identify_zip(const char* zipname)
+{
+	struct zipent* ent;
+	ZIP* zip = openzip( zipname );
+#ifdef IDENT_DEBUG
+	fprintf(stderr_file, "identify_zip(%s) called\n", zipname);
+#endif
+
+	if (!zip)
+		return;
+
+	while ((ent = readzip(zip))) {
+		/* Skip empty file and directory */
+		if (ent->uncompressed_size!=0) {
+			char* buf = (char*)malloc(strlen(zipname)+1+strlen(ent->name)+1);
+			sprintf(buf,"%s/%s",zipname,ent->name);
+			identify_rom(buf,ent->crc32,ent->uncompressed_size);
+			free(buf);
+		}
+	}
+
+	closezip(zip);
+}
+
+void identify_dir(const char* dirname)
+{
+	DIR *dir;
+	struct dirent *ent;
+#ifdef IDENT_DEBUG
+	fprintf(stderr_file, "identdir(%s) called\n", dirname);
+#endif
+
+	dir = opendir(dirname);
+	if (!dir) {
+		return;
+	}
+
+	ent = readdir(dir);
+	while (ent) {
+		/* Skip special files */
+		if (ent->d_name[0]!='.') {
+			char* buf = (char*)malloc(strlen(dirname)+1+strlen(ent->d_name)+1);
+			sprintf(buf,"%s/%s",dirname,ent->d_name);
+			romident(buf,0);
+			free(buf);
+		}
+
+		ent = readdir(dir);
+	}
+	closedir(dir);
+}
+
+void romident(const char* name,int enter_dirs) {
+	struct stat s;
+#ifdef IDENT_DEBUG
+	fprintf(stderr_file, "romident(%s, %d) called\n", name, enter_dirs);
+#endif
+
+	if (stat(name,&s) != 0)	{
+		fprintf(stdout_file, "%s: %s\n",name,strerror(errno));
+		return;
+	}
+
+#ifdef BSD43
+	if (S_IFDIR & s.st_mode) {
+#else
+	if (S_ISDIR(s.st_mode)) {
+#endif
+		if (enter_dirs)
+			identify_dir(name);
+	} else {
+		unsigned l = strlen(name);
+		if (l>=4 && stricmp(name+l-4,".zip")==0)
+			identify_zip(name);
+		else
+			identify_file(name);
+		return;
+	}
+}
+
+int frontend_ident(char *gamename)
+{
+#ifdef IDENT_DEBUG
+   fprintf(stderr_file, "frontend_ident(%d, %s) called\n", ident, gamename);
+#endif
+
+   if (!ident)
+      return 1234;
+   
+   if (!gamename)
+   {
+      fprintf(stderr_file, "-ident / -isknown requires a game- or filename as second argument\n");
+      return OSD_NOT_OK;
+   }
+   
+   if (ident == IDENT_ISKNOWN)
+         silentident = 1;
+         
+   romident(gamename, 1);
+   
+   if (ident == IDENT_ISKNOWN)
+   {
+      switch (knownstatus)
+      {
+         case KNOWN_START: fprintf(stdout_file, "ERROR     %s\n",gamename); break;
+         case KNOWN_ALL:   fprintf(stdout_file, "KNOWN     %s\n",gamename); break;
+         case KNOWN_NONE:  fprintf(stdout_file, "UNKNOWN   %s\n",gamename); break;
+         case KNOWN_SOME:  fprintf(stdout_file, "PARTKNOWN %s\n",gamename); break;
+      }
+   }
+   return OSD_OK;
+}
diff -Naur ../mmmmm/m36b16/src/unix/joystick-drivers/joy_i386.c mame-0.36b16/src/unix/joystick-drivers/joy_i386.c
--- ../mmmmm/m36b16/src/unix/joystick-drivers/joy_i386.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/joystick-drivers/joy_i386.c	2023-07-07 14:20:22.688001896 -0400
@@ -0,0 +1,196 @@
+#include "xmame.h"
+#include "devices.h"
+
+struct rc_option joy_i386_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+#ifdef I386_JOYSTICK
+
+#include <sys/ioctl.h>
+
+/* specific joystick for PC clones */
+#if defined(__ARCH_netbsd) || defined(__ARCH_freebsd)
+
+#include <machine/joystick.h>
+typedef struct joystick joy_struct;
+#define JOYSTICK_DEVICE_NAME "/dev/joy"
+
+#elif defined __ARCH_linux
+
+#include <linux/joystick.h>
+typedef struct JS_DATA_TYPE joy_struct;
+#define JOYSTICK_DEVICE_NAME "/dev/js"
+
+#ifdef JS_VERSION
+#define I386NEW_JOYSTICK 1
+#endif
+
+#else
+#error "i386 style joystick only supported under linux, netbsd & freebsd. "
+   "patches to support other arch's are welcome ;)"
+#endif
+
+/* #define JDEBUG */
+
+void joy_i386_poll(void);
+void joy_i386new_poll(void);
+static joy_struct my_joy_data;
+
+void joy_i386_init (void)
+{
+   int i,j;
+   char devname[20];
+#ifdef I386NEW_JOYSTICK
+   int version;
+#endif
+
+   fprintf (stderr_file, "I386 joystick interface initialization...\n");
+   for (i = 0; i < JOY; i++)
+   {
+      sprintf (devname, "%s%d", JOYSTICK_DEVICE_NAME, i);
+      if ((joy_data[i].fd = open (devname, O_RDONLY)) >= 0)
+      {
+         if (read(joy_data[i].fd, &my_joy_data, sizeof(joy_struct)) != sizeof(joy_struct))
+         {
+            close(joy_data[i].fd);
+            joy_data[i].fd = -1;
+            continue;
+         }
+         switch(joytype)
+         {
+            case JOY_I386NEW:
+#ifdef I386NEW_JOYSTICK
+               /* new joystick driver 1.x.x API 
+                  check the running version of driver, if 1.x.x is
+                  not detected fall back to 0.8 API */
+
+               if (ioctl (joy_data[i].fd, JSIOCGVERSION, &version)==0)
+               {
+                  char name[60];
+                  ioctl (joy_data[i].fd, JSIOCGAXES, &joy_data[i].num_axis);
+                  ioctl (joy_data[i].fd, JSIOCGBUTTONS, &joy_data[i].num_buttons);
+                  ioctl (joy_data[i].fd, JSIOCGNAME (sizeof (name)), name);
+                  if (joy_data[i].num_buttons > JOY_BUTTONS)
+                     joy_data[i].num_buttons = JOY_BUTTONS;
+                  if (joy_data[i].num_axis > JOY_AXIS)
+                     joy_data[i].num_axis = JOY_AXIS;
+                  fprintf (stderr_file, "Joystick: %s is %s\n", devname, name);
+                  fprintf (stderr_file, "Joystick: Built in driver version: %d.%d.%d\n", JS_VERSION >> 16, (JS_VERSION >> 8) & 0xff, JS_VERSION & 0xff);
+                  fprintf (stderr_file, "Joystick: Kernel driver version  : %d.%d.%d\n", version >> 16, (version >> 8) & 0xff, version & 0xff);
+                  for (j=0; j<joy_data[i].num_axis; j++)
+                  {
+                     joy_data[i].axis[j].min = -32768;
+                     joy_data[i].axis[j].max =  32768;
+                  }
+                  joy_poll_func = joy_i386new_poll;
+                  break;
+               }
+               /* else we're running on a kernel with 0.8 driver */
+               fprintf (stderr_file, "Joystick: %s unknown type\n", devname);
+               fprintf (stderr_file, "Joystick: Built in driver version: %d.%d.%d\n", JS_VERSION >> 16, (JS_VERSION >> 8) & 0xff, JS_VERSION & 0xff);
+               fprintf (stderr_file, "Joystick: Kernel driver version  : 0.8 ??\n");
+               fprintf (stderr_file, "Joystick: Please update your Joystick driver !\n");
+               fprintf (stderr_file, "Joystick: Using old interface method\n");
+#else
+               fprintf (stderr_file, "New joystick driver (1.x.x) support not compiled in.\n");
+               fprintf (stderr_file, "Falling back to 0.8 joystick driver api\n");
+#endif            
+               joytype = JOY_I386;
+            case JOY_I386:
+               joy_data[i].num_axis = 2;
+#if defined(__ARCH_netbsd) || defined(__ARCH_freebsd)
+               joy_data[i].num_buttons = 2;
+#else
+               joy_data[i].num_buttons = JOY_BUTTONS;
+#endif
+               joy_data[i].axis[0].center = my_joy_data.x;
+               joy_data[i].axis[1].center = my_joy_data.y;
+               joy_data[i].axis[0].min    = my_joy_data.x - 10;
+               joy_data[i].axis[1].min    = my_joy_data.y - 10;
+               joy_data[i].axis[0].max    = my_joy_data.x + 10;
+               joy_data[i].axis[1].max    = my_joy_data.y + 10;
+               
+               joy_poll_func = joy_i386_poll;
+               break;
+         }
+         fcntl (joy_data[i].fd, F_SETFL, O_NONBLOCK);
+      }
+   }
+}
+
+#ifdef I386NEW_JOYSTICK
+/* 
+ * Routine to manage PC clones joystick via new Linux driver 1.2.xxx
+ */
+void joy_i386new_poll (void)
+{
+   struct js_event js;
+   int i;
+
+   for (i=0; i<JOY; i++)
+   {
+      if (joy_data[i].fd < 0)
+         continue;
+      while ((read (joy_data[i].fd, &js, sizeof (struct js_event))) == sizeof (struct js_event))
+      {
+         switch (js.type & ~JS_EVENT_INIT)
+         {
+            case JS_EVENT_BUTTON:
+               if (js.number < JOY_BUTTONS)
+                  joy_data[i].buttons[js.number] = js.value;
+#ifdef JDEBUG
+               fprintf (stderr, "Button=%d,value=%d\n", js.number, js.value);
+#endif
+               break;
+
+            case JS_EVENT_AXIS:
+               if (js.number < JOY_AXIS)
+                  joy_data[i].axis[js.number].val = js.value;
+#ifdef JDEBUG
+               fprintf (stderr, "Axis=%d,value=%d\n", js.number, js.value);
+#endif
+               break;
+         }
+      }
+   }
+      
+   /* evaluate joystick movements */
+   joy_evaluate_moves ();
+}
+#endif
+
+/* 
+ * Routine to manage PC clones joystick via standard driver 
+ */
+void joy_i386_poll (void)
+{
+   int i, j, res;
+
+   for (i=0; i<JOY; i++)
+   {
+      if (joy_data[i].fd < 0)
+         continue;
+      if (read (joy_data[i].fd, &my_joy_data, sizeof (joy_struct)) != sizeof (joy_struct))
+         continue;
+      
+      /* get value of buttons */
+#if defined(__ARCH_netbsd) || defined(__ARCH_freebsd)
+      joy_data[i].buttons[0] = my_joy_data.b1;
+      joy_data[i].buttons[1] = my_joy_data.b2;
+#else
+      for (j = 0; j < JOY_BUTTONS; j++)
+         joy_data[i].buttons[j] = my_joy_data.buttons & (0x01 << j);
+#endif
+      joy_data[i].axis[0].val = my_joy_data.x;
+      joy_data[i].axis[1].val = my_joy_data.y;
+   }
+
+   /* evaluate joystick movements */
+   joy_evaluate_moves ();
+}
+
+#endif
diff -Naur ../mmmmm/m36b16/src/unix/joystick-drivers/joy_pad.c mame-0.36b16/src/unix/joystick-drivers/joy_pad.c
--- ../mmmmm/m36b16/src/unix/joystick-drivers/joy_pad.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/joystick-drivers/joy_pad.c	2023-07-07 14:20:22.688001896 -0400
@@ -0,0 +1,102 @@
+/*
+ ************************** FM TOWNS PAD specifics routines *************
+ */
+
+#include <fcntl.h>
+#include "xmame.h"
+#include "devices.h"
+#include "pad.h"
+
+/*
+ * Towns Pad control module for Xmame
+ *
+ * Author : Osamu KURATI
+ * Version : 29 apr 1997 0.000
+ */
+
+/*
+ * Joy Stick Code
+ * Up : 1
+ * Down       : 2
+ * Left       : 4
+ * Right      : 8
+ * A  : 10
+ * B  : 20
+ *
+ *
+ * PAD bit number
+ * up         : 0
+ * down               : 1
+ * left               : 2
+ * right      : 3
+ * A          : 4
+ * B          : 5
+ * RUN                : 6
+ * SELECT     : 7
+ */
+
+#ifdef LIN_FM_TOWNS
+static unsigned long lPadLastButton = 0;
+static char *towns_pad_dev = NULL; /* name of FM-TOWNS device */
+#endif
+
+struct rc_option joy_pad_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+#ifdef LIN_FM_TOWNS
+   { "paddevname",	NULL,			rc_string,	&towns_pad_dev,
+     "/dev/pad00",	0,			0,		NULL,
+     "Name of pad device (defaults to /dev/pad00)" },
+#endif
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+#ifdef LIN_FM_TOWNS
+void joy_pad_poll(void);
+
+void joy_pad_init(void)
+{
+  int i;
+  
+  joy_poll_func  = joy_pad_poll;
+  lPadLastButton = 0;
+ 
+  if ((joy_data[0].fd = open(towns_pad_dev, O_NONBLOCK | O_RDONLY)) >= 0)
+  {
+    joy_data[0].num_buttons=4;
+    joy_data[0].num_axis=2;
+  }
+}
+
+static int Pad()
+{
+  struct pad_event ev;
+  if (read(joy_data[0].fd, &ev, sizeof ev) == sizeof ev){
+    lPadLastButton = ev.buttons;
+  }
+  return((int) lPadLastButton & 0xff);
+}
+
+/*
+ * Linux FM-TOWNS game pad driver based joystick emulation routine
+ */
+void joy_pad_poll(void)
+{
+      int i;
+      int res = Pad();
+
+      /* get value of buttons */
+      for (i=0; i<4; i++)
+      {
+         joy_data[0].buttons[i] = (res>>4) & (0x01<<i);
+      }
+
+      joy_data[0].axis[0].dirs[0] = res & 0x01;
+      joy_data[0].axis[0].dirs[1] = res & 0x02;
+      joy_data[0].axis[1].dirs[0] = res & 0x04;
+      joy_data[0].axis[1].dirs[1] = res & 0x08;
+}
+
+/* TOWNS_PAD */
+#endif
diff -Naur ../mmmmm/m36b16/src/unix/joystick-drivers/joy_usb.c mame-0.36b16/src/unix/joystick-drivers/joy_usb.c
--- ../mmmmm/m36b16/src/unix/joystick-drivers/joy_usb.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/joystick-drivers/joy_usb.c	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,257 @@
+/*
+ * X-Mame USB HID joystick driver for NetBSD.
+ *
+ * Written by Krister Walfridsson <cato@df.lth.se>
+ */
+#include "xmame.h"
+#include "devices.h"
+
+struct rc_option joy_usb_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+#ifdef USB_JOYSTICK
+
+#if !defined(__ARCH_netbsd) && !defined(__ARCH_freebsd)
+#error "USB joysticks are only supported under NetBSD and FreeBSD. "
+   "Patches to support other archs are welcome ;)"
+#endif
+
+#if defined(__ARCH_netbsd)
+#include <usb.h>
+#elif defined(__ARCH_freebsd)
+#include <libusb.h>
+#endif
+#include <dev/usb/usb.h>
+#include <dev/usb/usbhid.h>
+
+struct priv_joydata_struct
+{
+  struct hid_item *hids;
+  int dlen;
+  int offset;
+  char *data_buf;
+} priv_joy_data[JOY];
+
+static int joy_initialize_hid(int i);
+static void joy_usb_poll(void);
+static int joy_read(int fd, int i);
+
+
+
+void joy_usb_init(void)
+{
+  int i;
+  char devname[20];
+
+  fprintf(stderr_file, "USB joystick interface initialization...\n");
+
+  for (i = 0; i < JOY; i++)
+    {
+      sprintf(devname, "/dev/uhid%d", i);
+      if ((joy_data[i].fd = open(devname, O_RDONLY | O_NONBLOCK)) != -1)
+	{
+	  if (!joy_initialize_hid(i))
+	    {
+	      close(joy_data[i].fd);
+	      joy_data[i].fd = -1;
+	    }
+	}
+    }
+
+  joy_poll_func = joy_usb_poll;
+}
+
+
+
+static int joy_initialize_hid(int i)
+{
+  int size, is_joystick, report_id;
+  struct hid_data *d;
+  struct hid_item h;
+  report_desc_t rd;
+
+  if ((rd = hid_get_report_desc(joy_data[i].fd)) == 0)
+    {
+      fprintf(stderr_file, "error: /dev/uhid%d: %s", i, strerror(errno));
+      return FALSE;
+    }
+
+  priv_joy_data[i].hids = NULL;
+
+  size = hid_report_size(rd, hid_input, &report_id);
+  if ((priv_joy_data[i].data_buf = malloc(size)) == NULL)
+    {
+      fprintf(stderr_file, "error: couldn't malloc %d bytes\n", size);
+      hid_dispose_report_desc(rd);
+      return FALSE;
+    }
+  priv_joy_data[i].dlen = size;
+  priv_joy_data[i].offset = (report_id != 0);
+
+  is_joystick = 0;
+  for (d = hid_start_parse(rd, 1 << hid_input); hid_get_item(d, &h); )
+    {
+      int axis, usage, page, interesting_hid;
+
+      page = HID_PAGE(h.usage);
+      usage = HID_USAGE(h.usage);
+
+      /* This test is somewhat too simplistic, but this is how MicroSoft
+       * does, so I guess it works for all joysticks/game pads. */
+      is_joystick = is_joystick ||
+	(h.kind == hid_collection &&
+	 page == HUP_GENERIC_DESKTOP &&
+	 (usage == HUG_JOYSTICK || usage == HUG_GAME_PAD));
+
+      if (h.kind != hid_input)
+	continue;
+
+      if (!is_joystick)
+	continue;
+
+      interesting_hid = TRUE;
+      if (page == HUP_GENERIC_DESKTOP)
+	{
+	  if (usage == HUG_X || usage == HUG_RX)
+	    axis = 0;
+	  else if (usage == HUG_Y || usage == HUG_RY)
+	    axis = 1;
+	  else if (usage == HUG_Z || usage == HUG_RZ)
+	    axis = 2;
+	  else
+	    interesting_hid = FALSE;
+
+	  if (interesting_hid)
+	    {
+	      joy_data[i].axis[axis].min = h.logical_minimum;
+	      joy_data[i].axis[axis].max = h.logical_maximum;
+
+	      /* Set the theoretical center. This will be used in case
+	       * the heuristic below fails. */
+	      joy_data[i].axis[axis].center =
+		(h.logical_minimum + h.logical_maximum) / 2;
+
+	      if (joy_data[i].num_axis < (axis + 1))
+		joy_data[i].num_axis = axis + 1;
+	    }
+	}
+      else if (page == HUP_BUTTON)
+	{
+	  interesting_hid = (usage > 0) && (usage <= JOY_BUTTONS);
+
+	  if (interesting_hid && usage > joy_data[i].num_buttons)
+	    joy_data[i].num_buttons = usage;
+	}
+
+      if (interesting_hid)
+	{
+	  h.next = priv_joy_data[i].hids;
+	  priv_joy_data[i].hids = malloc(sizeof *(priv_joy_data[i].hids));
+	  if (priv_joy_data[i].hids == NULL)
+	    {
+	      fprintf(stderr_file, "error: Not enough memory for joystick. "
+		      "Your joystick may fail to work correctly.\n");
+	      break;
+	    }
+	  *(priv_joy_data[i].hids) = h;
+	}
+    }
+  hid_end_parse(d);
+
+  if (priv_joy_data[i].hids != NULL)
+    {
+      /* We'll approximate the center with the current joystick value if
+       * that can be read (some HID devices returns no data if the state
+       * has not changed since the last time it was read.) */
+      if (joy_read(joy_data[i].fd, i))
+	{
+	  joy_data[i].axis[0].center = joy_data[i].axis[0].val;
+	  joy_data[i].axis[1].center = joy_data[i].axis[1].val;
+	  joy_data[i].axis[2].center = joy_data[i].axis[2].val;
+	}
+      else
+	{
+	  /* Assume that the joystick is positioned in the center.
+	   * This is needed, or else the system will think that the
+	   * joystick is in position left/up (or something) until it
+	   * is moved the first time. */
+	  joy_data[i].axis[0].val = joy_data[i].axis[0].center;
+	  joy_data[i].axis[1].val = joy_data[i].axis[1].center;
+	  joy_data[i].axis[2].val = joy_data[i].axis[2].center;
+	}
+
+      /* Approximate min/max values. Observe that we cannot use the
+       * max/min values that the HID reports, since that is theoretical
+       * values that may be wrong for analogs joystics (especially if
+       * you have a joystick -> USB adaptor.) We cannot use greater delta
+       * values than +/- 1, since it is OK for a gamepad (or my USB TAC 2)
+       * to reports directions as center +/- 1. */
+      joy_data[i].axis[0].min = joy_data[i].axis[0].center - 1;
+      joy_data[i].axis[1].min = joy_data[i].axis[1].center - 1;
+      joy_data[i].axis[2].min = joy_data[i].axis[2].center - 1;
+      joy_data[i].axis[0].max = joy_data[i].axis[0].center + 1;
+      joy_data[i].axis[1].max = joy_data[i].axis[1].center + 1;
+      joy_data[i].axis[2].max = joy_data[i].axis[2].center + 1;
+    }
+
+  return (priv_joy_data[i].hids != NULL);
+}
+
+
+
+static void joy_usb_poll(void)
+{
+  int i;
+
+  for (i = 0; i < JOY; i++)
+    {
+      if (joy_data[i].fd >= 0)
+	joy_read(joy_data[i].fd, i);
+    }
+
+   /* Evaluate joystick movements. */
+   joy_evaluate_moves ();
+}
+
+
+
+static int joy_read(int fd, int i)
+{
+  int len, axis, usage, page, d;
+  struct hid_item *h;
+
+  len = read(fd, priv_joy_data[i].data_buf, priv_joy_data[i].dlen);
+  if (len != priv_joy_data[i].dlen)
+    return FALSE;
+
+  for (h = priv_joy_data[i].hids; h; h = h->next)
+    {
+      d = hid_get_data(priv_joy_data[i].data_buf + priv_joy_data[i].offset, h);
+
+      page = HID_PAGE(h->usage);
+      usage = HID_USAGE(h->usage);
+
+      if (page == HUP_GENERIC_DESKTOP)
+	{
+	  if (usage == HUG_X || usage == HUG_RX)
+	    axis = 0;
+	  else if (usage == HUG_Y || usage == HUG_RY)
+	    axis = 1;
+	  else
+	    axis = 2;
+
+	  joy_data[i].axis[axis].val = d;
+	}
+      else if (page == HUP_BUTTON)
+	{
+	  joy_data[i].buttons[usage - 1] = (d == h->logical_maximum);
+	}
+    }
+
+  return TRUE;
+}
+#endif
diff -Naur ../mmmmm/m36b16/src/unix/joystick-drivers/joy_x11.c mame-0.36b16/src/unix/joystick-drivers/joy_x11.c
--- ../mmmmm/m36b16/src/unix/joystick-drivers/joy_x11.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/joystick-drivers/joy_x11.c	2023-07-07 14:20:22.688001896 -0400
@@ -0,0 +1,248 @@
+/*
+ * X-Mame x11 joystick code
+ *
+ */
+#include "xmame.h"
+#include "devices.h"
+
+#ifdef X11_JOYSTICK
+static char *x11joyname = NULL;
+#endif
+
+struct rc_option joy_x11_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+#ifdef X11_JOYSTICK
+   { "x11joyname",	NULL,			rc_string,	&x11joyname,
+     X11_JOYNAME,	0,			0,		NULL,
+     "Name of X-based joystick device (if compiled in)" },
+#endif
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+#ifdef X11_JOYSTICK
+#include "../video-drivers/x11.h"
+#if !defined x11 && !defined xgl && !defined xfx
+#error "x11 joystick support only works with an x11 display method, duh !"
+#endif
+
+/* standard X input extensions based joystick */
+#include <X11/extensions/XI.h>
+#include <X11/extensions/XInput.h>
+/* event types returned by XSelecExtensionEvent() */
+static XDevice *xdevice;
+void joy_x11_poll(void);
+
+/* FIXME shouldn't X support more then 1 joystick ? */
+
+void process_x11_joy_event(XEvent *event) {
+#ifdef USE_X11_JOYEVENTS
+/* does not run yet, don't know why :-( */
+    int i;
+    /* remember that event types are not harcoded: we evaluated it in XOpenDevice() */
+    /* hack: we'll suppose that:
+	 first_axis is allways equals 0. 
+	 device_id is joystic's id
+       in a real program, should be checked... 
+     */
+    if ( (event->type==devicebuttonpress) || (event->type==devicebuttonrelease) ) {
+	XDeviceButtonEvent *dbe=(XDeviceButtonEvent *) event;	
+	/* evaluate button state */
+	for (i=0; i<joy_data[0].num_buttons; i++)
+	   joy_data[0].buttons[i] = dbe->device_state & (0x01 << i);
+	for(i=0;i<joy_data[0].num_axis;i++)
+		joy_data[0].axis[i].val = joy_data[0].axis[i].center +
+		   dbe->axis_data[i];
+    }
+    if ( (event->type==devicemotionnotify) ) {
+	XDeviceMotionEvent *dme=(XDeviceMotionEvent *) event;	
+	/* evaluate button state */
+	for (i=0; i<joy_data[0].num_buttons; i++)
+	   joy_data[0].buttons[i] = dme->device_state & (0x01 << i);
+	for(i=0;i<joy_data[0].num_axis;i++)
+		joy_data[0].axis[i].val = joy_data[0].axis[i].center +
+		   dme->axis_data[i];
+    }
+#endif
+}
+
+void joy_x11_init(void)
+{
+	int 		i,j,k;
+	int 		result;
+	XDeviceInfoPtr 	list,slist;
+	XAnyClassPtr 	any;
+	XButtonInfoPtr 	binfo;
+	XValuatorInfoPtr vinfo;
+	XInputClassInfo *classptr;
+	XEventClass 	xeventlist[8];
+	int 		xeventcount;
+	
+	joy_poll_func = joy_x11_poll;
+	
+	/* query server for input extensions */
+	result =XQueryExtension(display,"XInputExtension",&i,&j,&k);
+	if(!result) {
+	    fprintf(stderr_file,"Your server doesn't support XInput Extensions\n");
+	    fprintf(stderr_file,"X11 Joystick disabled\n");
+	    joytype=JOY_NONE;
+	    return;
+	}
+	/* now get input device list and locate desired device */
+	list = XListInputDevices(display,&result);
+	if (!list ) {
+	    fprintf(stderr_file,"No extended input devices found !!\n");
+	    fprintf(stderr_file,"X11 Joystick disabled\n");
+	    joytype=JOY_NONE;
+	    return;
+	}
+	slist=list;
+	for(i=j=0;i<result;i++,list++) 
+		if ( ! strcmp(x11joyname,list->name)  ) { j=1; break; }
+	if (!j) {
+	    fprintf(stderr_file,"Cannot locate device \"%s\" in available devices\n",x11joyname);
+	    fprintf(stderr_file,"X11 Joystick disabled\n");
+	    joytype=JOY_NONE;
+	    XFreeDeviceList(slist);
+	    return;
+	}
+	/* test for correct device ( search at least two buttons and two axis */
+	any = (XAnyClassPtr)(list->inputclassinfo);
+	result=0;
+	for(j=0;j<list->num_classes;j++) {
+	    switch(any->class) {
+		case ButtonClass:
+			binfo=(XButtonInfoPtr) any;
+			if ((joy_data[0].num_buttons=binfo->num_buttons)>=2) result |= 0x01;
+			fprintf(stderr_file,"%s: %d buttons\n",x11joyname,joy_data[0].num_buttons);
+			if (joy_data[0].num_buttons > JOY_BUTTONS) joy_data[0].num_buttons = JOY_BUTTONS;
+			break;
+		case ValuatorClass:
+			vinfo=(XValuatorInfoPtr) any;
+			if ((joy_data[0].num_axis=vinfo->num_axes)>=2) result |= 0x02;
+			fprintf(stderr_file,"%s: %d axes\n",x11joyname,joy_data[0].num_axis);
+			if (joy_data[0].num_axis > JOY_AXIS) joy_data[0].num_axis = JOY_AXIS;
+			for (i=0; i<joy_data[0].num_axis; i++)
+			{
+			   joy_data[0].axis[i].val = joy_data[0].axis[i].center =
+			      (vinfo->axes[i].max_value - vinfo->axes[i].min_value) / 2;
+			   joy_data[0].axis[i].min = vinfo->axes[i].min_value;
+			   joy_data[0].axis[i].max = vinfo->axes[i].max_value;
+			}
+			break;
+		case KeyClass: /* no sense to use a extended key device */
+			fprintf(stderr_file,"%s: Ingnoring KeyClass info\n",x11joyname);
+		default: break;  /* unnknown class: ignore */
+	    }
+	    any = (XAnyClassPtr) ((char *) any+any->length);
+	}
+	if (result != 0x03 ) {
+	    fprintf(stderr_file,"Your selected X11 device \"%s\"doesn't match X-Mame/X-Mess requirements\n",x11joyname);
+	    fprintf(stderr_file,"X11 Joystick disabled\n");
+	    joytype=JOY_NONE;
+	    XFreeDeviceList(slist);
+	    return;
+	}
+	/* once located, try to open */	
+	if ( ! (xdevice=XOpenDevice(display,list->id) ) ) {
+	    fprintf(stderr_file,"XDeviceOpen error\n");
+	    joytype=JOY_NONE;
+	    XFreeDeviceList(slist);
+	    return;
+	} 
+	/* buscamos los eventos asociados que necesitamos */
+	/* realmente el bucle for y la sentencia switch no son necesarias, pues
+	   en XInput.h se buscan automaticamente los elementos de cada dato, pero
+	   lo pongo de ejemplo para si en el futuro se quieren chequear la existencia
+           de una determinada clase antes de pedir eventos. Nosotros sabemos a 
+	   priori que no deberia fallar....
+	*/
+	xeventcount=0;
+	for (i=0,classptr=xdevice->classes;i<xdevice->num_classes;i++,classptr++ ) {
+	    switch(classptr->input_class) {
+		case KeyClass: break;
+		case ButtonClass:
+	    		DeviceButtonPress(xdevice,devicebuttonpress,xeventlist[xeventcount]);
+			if (devicebuttonpress) xeventcount++;
+	    		DeviceButtonRelease(xdevice,devicebuttonrelease,xeventlist[xeventcount]);
+			if (devicebuttonrelease) xeventcount++;
+			break;
+		case ValuatorClass:
+	    		DeviceMotionNotify(xdevice,devicemotionnotify,xeventlist[xeventcount]);
+			if (devicemotionnotify) xeventcount++;
+	    		DeviceButtonMotion(xdevice,devicebuttonmotion,xeventlist[xeventcount]);
+			if (devicebuttonmotion) xeventcount++;
+			break;
+		case FocusClass: break;
+		case ProximityClass: break;
+		case OtherClass: break;
+		default: break;
+	    }
+	}
+#if 0
+	/* 
+	NOTE: don't know why but these two items don't work in my linux
+	XInputExtension Joystick module. still working on it ...
+	*/
+
+	/* force relative motion report */
+	XSetDeviceMode(display,xdevice,Relative);
+	/* set starting point of joystick (to force joy to be centered) */
+	for(i=0; i<joy_data[0].num_axis; i++)
+	   XSetDeviceValuators(display,xdevice,&(joy_data[0].axis[i]),i,1);
+	
+#endif
+#ifdef USE_X11_JOYEVENTS
+	/* not sure why don't recognize all events type. still working... */
+	XSelectExtensionEvent(display,window,xeventlist,xeventcount);
+	fprintf(stderr_file,"X11PointerDevice: Using X-Window Events\n");
+#else
+	fprintf(stderr_file,"X11PointerDevice: Using Demand QueryState\n");
+#endif
+	fprintf(stderr_file,"Found and installed X11 pointer device \"%s\"\n",x11joyname);
+	/* and finaly free requested device list */
+	XFreeDeviceList(slist);
+}
+
+/* 
+ * Routine to manage joystick via X-Windows Input Extensions
+ * should work in any X-Server that supports them
+ */
+void joy_x11_poll(void)
+{
+#ifndef USE_X11_JOYEVENTS
+	/* perform a roudtrip query to joy device to ask state */
+	XDeviceState    *xstate;
+	XInputClass     *any;
+	XValuatorState  *vinfo;
+	XButtonState    *binfo;
+	int i,j;
+	xstate = XQueryDeviceState(display,xdevice);
+	any = (XInputClass *)(xstate->data);
+	for(j=0;j<xstate->num_classes;j++) {
+	    switch(any->class) {
+		case ButtonClass:
+			binfo=(XButtonState *) any;
+			for (i=0; i<joy_data[0].num_buttons; i++)
+			{
+			   joy_data[0].buttons[i] = (int)binfo->buttons[0] & (0x01 << i);
+			}
+			break;
+		case ValuatorClass:
+			vinfo=(XValuatorState *) any;
+			for (i=0; i<joy_data[0].num_axis; i++)
+			   joy_data[0].axis[i].val =
+			      joy_data[0].axis[i].center + vinfo->valuators[i];
+			break;
+		case KeyClass: /* no sense to use a extended key device */
+		default: break;  /* unknown class: ignore */
+	    }
+	    any = (XInputClass *) ((char *) any+any->length);
+	}
+	XFreeDeviceState(xstate);
+#endif 
+	joy_evaluate_moves();
+}
+
+#endif /* ifdef X11_JOYSTICK */
diff -Naur ../mmmmm/m36b16/src/unix/joystick-drivers/pad.h mame-0.36b16/src/unix/joystick-drivers/pad.h
--- ../mmmmm/m36b16/src/unix/joystick-drivers/pad.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/joystick-drivers/pad.h	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,78 @@
+/*
+ * TOWNS PAD
+ *    By S.Nomura
+ */
+#ifndef TRUE
+# define TRUE (1)
+# define FALSE (0)
+#endif
+
+#define PAD_DEV_MASK    0x07
+#define PAD_MODE_MASK   0x38
+#define PAD_MODE_SHIFT  3
+
+  /* modes */
+#define PAD_NORMAL      0
+#define PAD_MARTY       1
+#define PAD_6BUTTON     2
+
+struct pad_event {
+  unsigned long buttons;
+  unsigned long stamp;
+};
+
+#define PAD_FWD    0x0001
+#define PAD_BACK   0x0002
+#define PAD_LEFT   0x0004
+#define PAD_RIGHT  0x0008
+#define PAD_RUN    0x0010
+#define PAD_SEL    0x0020
+#define PAD_ZOOM   0x0040
+#define PAD_A	   0x0100
+#define PAD_B	   0x0200
+#define PAD_C	   0x0400
+#define PAD_X	   0x0800
+#define PAD_Y	   0x1000
+#define PAD_Z	   0x2000
+
+#define PADIOCSETPARAM  0x5001
+
+#define PAD_QUE_SIZE 50
+
+struct pad_status {
+  int active;
+  int port;
+  int trig, com, mode;
+  unsigned long button, last_button;
+  struct inode *inode;
+
+  /* Queue */
+  struct wait_queue *proc;
+  struct pad_event ev[PAD_QUE_SIZE];
+  struct pad_event *put, *get, *limit;
+  int count, ovf;
+};
+
+/* I/O ports */
+#define PAD_CTRL_PORT  0x04d6
+#define PAD1_PORT      0x04d0
+#define PAD2_PORT      0x04d2
+
+ /* control */
+#define PAD1_TRIG      0x03
+#define PAD1_COM       0x10
+#define PAD2_TRIG      0x0c
+#define PAD2_COM       0x20
+
+ /* value */
+#define _PAD_FWD       0x01
+#define _PAD_BACK      0x02
+#define _PAD_LEFT      0x04
+#define _PAD_RIGHT     0x08
+#define _PAD_A         0x10
+#define _PAD_B         0x20
+#define _PAD_COM       0x40
+#define _PAD_C         0x08
+#define _PAD_X         0x04
+#define _PAD_Y         0x02
+#define _PAD_Z         0x01
diff -Naur ../mmmmm/m36b16/src/unix/keyboard.c mame-0.36b16/src/unix/keyboard.c
--- ../mmmmm/m36b16/src/unix/keyboard.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/keyboard.c	2023-07-07 14:20:22.688001896 -0400
@@ -0,0 +1,238 @@
+/*
+ * X-Mame keyboard specifics code
+ *
+ */
+#define __KEYBOARD_C_
+
+/*
+ * Include files.
+ */
+#include "xmame.h"
+#include "driver.h"
+#include "keyboard.h"
+#include "sysdep/fifo.h"
+ 
+#if defined svgalib || defined svgafx
+#include <vgakeyboard.h>
+#define sysdep_update_keyboard keyboard_update
+#endif
+
+/* we use standard pc scancodes these have a one-on-one mapping for
+   svgalib, for other targets we need a lookup table anyway */
+struct KeyboardInfo keylist[] =
+{
+	{ "A",		KEY_A,		KEYCODE_A },
+	{ "B",		KEY_B,		KEYCODE_B },
+	{ "C",		KEY_C,		KEYCODE_C },
+	{ "D",		KEY_D,		KEYCODE_D },
+	{ "E",		KEY_E,		KEYCODE_E },
+	{ "F",		KEY_F,		KEYCODE_F },
+	{ "G",		KEY_G,		KEYCODE_G },
+	{ "H",		KEY_H,		KEYCODE_H },
+	{ "I",		KEY_I,		KEYCODE_I },
+	{ "J",		KEY_J,		KEYCODE_J },
+	{ "K",		KEY_K,		KEYCODE_K },
+	{ "L",		KEY_L,		KEYCODE_L },
+	{ "M",		KEY_M,		KEYCODE_M },
+	{ "N",		KEY_N,		KEYCODE_N },
+	{ "O",		KEY_O,		KEYCODE_O },
+	{ "P",		KEY_P,		KEYCODE_P },
+	{ "Q",		KEY_Q,		KEYCODE_Q },
+	{ "R",		KEY_R,		KEYCODE_R },
+	{ "S",		KEY_S,		KEYCODE_S },
+	{ "T",		KEY_T,		KEYCODE_T },
+	{ "U",		KEY_U,		KEYCODE_U },
+	{ "V",		KEY_V,		KEYCODE_V },
+	{ "W",		KEY_W,		KEYCODE_W },
+	{ "X",		KEY_X,		KEYCODE_X },
+	{ "Y",		KEY_Y,		KEYCODE_Y },
+	{ "Z",		KEY_Z,		KEYCODE_Z },
+	{ "0",		KEY_0,		KEYCODE_0 },
+	{ "1",		KEY_1,		KEYCODE_1 },
+	{ "2",		KEY_2,		KEYCODE_2 },
+	{ "3",		KEY_3,		KEYCODE_3 },
+	{ "4",		KEY_4,		KEYCODE_4 },
+	{ "5",		KEY_5,		KEYCODE_5 },
+	{ "6",		KEY_6,		KEYCODE_6 },
+	{ "7",		KEY_7,		KEYCODE_7 },
+	{ "8",		KEY_8,		KEYCODE_8 },
+	{ "9",		KEY_9,		KEYCODE_9 },
+	{ "0 PAD",	KEY_0_PAD,	KEYCODE_0_PAD },
+	{ "1 PAD",	KEY_1_PAD,	KEYCODE_1_PAD },
+	{ "2 PAD",	KEY_2_PAD,	KEYCODE_2_PAD },
+	{ "3 PAD",	KEY_3_PAD,	KEYCODE_3_PAD },
+	{ "4 PAD",	KEY_4_PAD,	KEYCODE_4_PAD },
+	{ "5 PAD",	KEY_5_PAD,	KEYCODE_5_PAD },
+	{ "6 PAD",	KEY_6_PAD,	KEYCODE_6_PAD },
+	{ "7 PAD",	KEY_7_PAD,	KEYCODE_7_PAD },
+	{ "8 PAD",	KEY_8_PAD,	KEYCODE_8_PAD },
+	{ "9 PAD",	KEY_9_PAD,	KEYCODE_9_PAD },
+	{ "F1",		KEY_F1,		KEYCODE_F1 },
+	{ "F2",		KEY_F2,		KEYCODE_F2 },
+	{ "F3",		KEY_F3,		KEYCODE_F3 },
+	{ "F4",		KEY_F4,		KEYCODE_F4 },
+	{ "F5",		KEY_F5,		KEYCODE_F5 },
+	{ "F6",		KEY_F6,		KEYCODE_F6 },
+	{ "F7",		KEY_F7,		KEYCODE_F7 },
+	{ "F8",		KEY_F8,		KEYCODE_F8 },
+	{ "F9",		KEY_F9,		KEYCODE_F9 },
+	{ "F10",	KEY_F10,	KEYCODE_F10 },
+	{ "F11",	KEY_F11,	KEYCODE_F11 },
+	{ "F12",	KEY_F12,	KEYCODE_F12 },
+	{ "ESC",	KEY_ESC,	KEYCODE_ESC },
+	{ "~",		KEY_TILDE,	KEYCODE_TILDE },
+	{ "-",		KEY_MINUS,	KEYCODE_MINUS },
+	{ "=",		KEY_EQUALS,	KEYCODE_EQUALS },
+	{ "BKSPACE",	KEY_BACKSPACE,	KEYCODE_BACKSPACE },
+	{ "TAB",	KEY_TAB,	KEYCODE_TAB },
+	{ "[",		KEY_OPENBRACE,	KEYCODE_OPENBRACE },
+	{ "]",		KEY_CLOSEBRACE,	KEYCODE_CLOSEBRACE },
+	{ "ENTER",	KEY_ENTER,	KEYCODE_ENTER },
+	{ ":",		KEY_COLON,	KEYCODE_COLON },
+	{ "\"",		KEY_QUOTE,	KEYCODE_QUOTE },
+	{ "\\",		KEY_BACKSLASH,	KEYCODE_BACKSLASH },
+	{ "<",		KEY_BACKSLASH2,	KEYCODE_BACKSLASH2 },
+	{ ",",		KEY_COMMA,	KEYCODE_COMMA },
+	{ ".",		KEY_STOP,	KEYCODE_STOP },
+	{ "/",		KEY_SLASH,	KEYCODE_SLASH },
+	{ "SPACE",	KEY_SPACE,	KEYCODE_SPACE },
+	{ "INS",	KEY_INSERT,	KEYCODE_INSERT },
+	{ "DEL",	KEY_DEL,	KEYCODE_DEL },
+	{ "HOME",	KEY_HOME,	KEYCODE_HOME },
+	{ "END",	KEY_END,	KEYCODE_END },
+	{ "PGUP",	KEY_PGUP,	KEYCODE_PGUP },
+	{ "PGDN",	KEY_PGDN,	KEYCODE_PGDN },
+	{ "LEFT",	KEY_LEFT,	KEYCODE_LEFT },
+	{ "RIGHT",	KEY_RIGHT,	KEYCODE_RIGHT },
+	{ "UP",		KEY_UP,		KEYCODE_UP },
+	{ "DOWN",	KEY_DOWN,	KEYCODE_DOWN },
+	{ "/ PAD",	KEY_SLASH_PAD,	KEYCODE_SLASH_PAD },
+	{ "* PAD",	KEY_ASTERISK,	KEYCODE_ASTERISK },
+	{ "- PAD",	KEY_MINUS_PAD,	KEYCODE_MINUS_PAD },
+	{ "+ PAD",	KEY_PLUS_PAD,	KEYCODE_PLUS_PAD },
+	{ ". PAD",	KEY_DEL_PAD,	KEYCODE_DEL_PAD },
+	{ "ENTER PAD",	KEY_ENTER_PAD,	KEYCODE_ENTER_PAD },
+	{ "PRTSCR",	KEY_PRTSCR,	KEYCODE_PRTSCR },
+	{ "PAUSE",	KEY_PAUSE,	KEYCODE_PAUSE },
+	{ "PAUSE",	KEY_PAUSE_ALT,	KEYCODE_PAUSE },
+	{ "LSHIFT",	KEY_LSHIFT,	KEYCODE_LSHIFT },
+	{ "RSHIFT",	KEY_RSHIFT,	KEYCODE_RSHIFT },
+	{ "LCTRL",	KEY_LCONTROL,	KEYCODE_LCONTROL },
+	{ "RCTRL",	KEY_RCONTROL,	KEYCODE_RCONTROL },
+	{ "ALT",	KEY_ALT,	KEYCODE_LALT },
+	{ "ALTGR",	KEY_ALTGR,	KEYCODE_RALT },
+	{ "LWIN",	KEY_LWIN,	KEYCODE_OTHER },
+	{ "RWIN",	KEY_RWIN,	KEYCODE_OTHER },
+	{ "MENU",	KEY_MENU,	KEYCODE_OTHER },
+	{ "SCRLOCK",	KEY_SCRLOCK,	KEYCODE_SCRLOCK },
+	{ "NUMLOCK",	KEY_NUMLOCK,	KEYCODE_NUMLOCK },
+	{ "CAPSLOCK",	KEY_CAPSLOCK,	KEYCODE_CAPSLOCK },
+	{ 0, 0, 0 }	/* end of table */
+};
+
+struct kbd_fifo_struct;
+static struct kbd_fifo_struct *kbd_fifo = NULL;
+static char key[128];
+
+/* private methods */
+FIFO(INLINE, kbd, struct keyboard_event)
+
+/* public methods (in keyboard.h / osdepend.h) */
+int keyboard_init(void)
+{
+   memset(key, 0, 128);
+
+   kbd_fifo = kbd_fifo_create(256);
+   if(!kbd_fifo)
+      return -1;
+   
+   return 0;
+}
+
+void keyboard_exit()
+{
+   if(kbd_fifo)
+      kbd_fifo_destroy(kbd_fifo);
+}
+
+void keyboard_register_event(struct keyboard_event *event)
+{
+   /* register the event in our event fifo */
+   kbd_fifo_put(kbd_fifo, *event);
+   
+   /* and update the key array */
+   key[event->scancode] = event->press;
+}
+
+void keyboard_clear(void)
+{
+   kbd_fifo_empty(kbd_fifo);
+   memset(key, 0, 128);
+}
+
+/* return a list of all available keys */
+const struct KeyboardInfo *osd_get_key_list(void)
+{
+   return keylist;
+}
+
+void osd_customize_inputport_defaults(struct ipd *defaults)
+{
+}
+
+int osd_is_key_pressed(int keycode)
+{
+   /* blames to the dos-people who want to check key states before
+      the display (and under X thus the keyboard) is initialised */
+   if (!kbd_fifo)
+      return 0;
+   
+   if (keycode >= KEY_MAX)
+      return 0;
+
+   sysdep_update_keyboard();
+	
+   return key[keycode];
+}
+
+int osd_wait_keypress(void)
+{
+   struct keyboard_event event;
+   
+   /* blames to the dos-people who want to check key states before
+      the display (and under X thus the keyboard) is initialised */
+   if (!kbd_fifo)
+   {
+      getchar();
+      return KEY_ENTER;
+   }
+   
+   keyboard_clear();
+   
+   for (;;)
+   {
+      sysdep_update_keyboard();
+      if(!kbd_fifo_get(kbd_fifo, &event) && event.press)
+         return event.scancode;
+   }
+}
+
+int osd_readkey_unicode(int flush)
+{
+   struct keyboard_event event;
+   
+   /* blames to the dos-people who want to check key states before
+      the display (and under X thus the keyboard) is initialised */
+   if (!kbd_fifo)
+      return 0;
+   
+   if (flush)
+      keyboard_clear();
+   
+   sysdep_update_keyboard();
+   
+   if (!kbd_fifo_get(kbd_fifo, &event) && event.press)
+      return event.unicode;
+   else
+      return 0;
+}
diff -Naur ../mmmmm/m36b16/src/unix/keyboard.h mame-0.36b16/src/unix/keyboard.h
--- ../mmmmm/m36b16/src/unix/keyboard.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/keyboard.h	2023-07-07 14:20:22.688001896 -0400
@@ -0,0 +1,149 @@
+#ifndef __KEYBOARD_H
+#define __KEYBOARD_H
+
+struct keyboard_event {
+   unsigned char press;
+   unsigned char scancode;
+   unsigned short unicode;
+};
+
+int keyboard_init(void);
+void keyboard_exit(void);
+void keyboard_register_event(struct keyboard_event *event);
+void keyboard_clear(void);
+
+/* Defines for the standard pc-scancodes which xmame uses as keysyms.
+   The names of the defines have been kept the same as used in
+   src/msdos/input.c for easy cut and paste */
+
+#define KEY_NONE		0
+
+#define KEY_ESC			1
+
+#define KEY_1			2
+#define KEY_2			3
+#define KEY_3			4
+#define KEY_4			5
+#define KEY_5			6
+#define KEY_6			7
+#define KEY_7			8
+#define KEY_8			9
+#define KEY_9			10
+#define KEY_0			11
+
+#define KEY_MINUS		12
+#define KEY_EQUALS		13
+
+#define KEY_BACKSPACE		14
+#define KEY_TAB			15
+
+#define KEY_Q			16
+#define KEY_W			17
+#define KEY_E			18
+#define KEY_R			19
+#define KEY_T			20
+#define KEY_Y			21
+#define KEY_U			22
+#define KEY_I			23
+#define KEY_O			24
+#define KEY_P			25
+#define KEY_OPENBRACE		26
+#define KEY_CLOSEBRACE		27
+
+#define KEY_ENTER		28
+
+#define KEY_LCONTROL		29
+
+#define KEY_A			30
+#define KEY_S			31
+#define KEY_D			32
+#define KEY_F			33
+#define KEY_G			34
+#define KEY_H			35
+#define KEY_J			36
+#define KEY_K			37
+#define KEY_L			38
+#define KEY_COLON		39
+#define KEY_QUOTE		40
+#define KEY_TILDE		41
+
+#define KEY_LSHIFT		42
+#define KEY_BACKSLASH		43
+
+#define KEY_Z			44
+#define KEY_X			45
+#define KEY_C			46
+#define KEY_V			47
+#define KEY_B			48
+#define KEY_N			49
+#define KEY_M			50
+#define KEY_COMMA		51
+#define KEY_STOP		52
+#define KEY_SLASH		53
+
+#define KEY_RSHIFT		54
+#define KEY_ASTERISK		55
+
+#define KEY_ALT			56
+#define KEY_SPACE		57
+#define KEY_CAPSLOCK		58
+
+#define KEY_F1			59
+#define KEY_F2			60
+#define KEY_F3			61
+#define KEY_F4			62
+#define KEY_F5			63
+#define KEY_F6			64
+#define KEY_F7			65
+#define KEY_F8			66
+#define KEY_F9			67
+#define KEY_F10			68
+
+#define KEY_NUMLOCK		69
+#define KEY_SCRLOCK		70
+
+#define KEY_7_PAD		71
+#define KEY_8_PAD		72
+#define KEY_9_PAD		73
+#define KEY_MINUS_PAD		74
+#define KEY_4_PAD		75
+#define KEY_5_PAD		76
+#define KEY_6_PAD		77
+#define KEY_PLUS_PAD		78
+#define KEY_1_PAD		79
+#define KEY_2_PAD		80
+#define KEY_3_PAD		81
+#define KEY_0_PAD		82
+#define KEY_DEL_PAD		83
+
+#define KEY_BACKSLASH2		86
+
+#define KEY_F11			87
+#define KEY_F12			88
+
+#define KEY_ENTER_PAD		96
+#define KEY_RCONTROL		97
+#define KEY_SLASH_PAD		98
+#define KEY_PRTSCR		99
+#define KEY_ALTGR		100
+#define KEY_PAUSE		101	/* Beware: is 119     */
+#define KEY_PAUSE_ALT		119	/* on some keyboards! */
+
+#define KEY_HOME		102
+#define KEY_UP			103
+#define KEY_PGUP		104
+#define KEY_LEFT		105
+#define KEY_RIGHT		106
+#define KEY_END			107
+#define KEY_DOWN		108
+#define KEY_PGDN		109
+#define KEY_INSERT		110
+#define KEY_DEL			111
+
+#define KEY_LWIN		125
+#define KEY_RWIN		126
+#define KEY_MENU		127
+
+#define KEY_MAX			128
+
+#endif
diff -Naur ../mmmmm/m36b16/src/unix/main.c mame-0.36b16/src/unix/main.c
--- ../mmmmm/m36b16/src/unix/main.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/main.c	2023-07-07 14:20:22.688001896 -0400
@@ -0,0 +1,69 @@
+/*
+ * X-mame main-routine
+ */
+
+#define __MAIN_C_
+#include "xmame.h"
+
+/* put here anything you need to do when the program is started. Return 0 if */
+/* initialization was successful, nonzero otherwise. */
+int osd_init(void)
+{
+	/* now invoice system-dependent initialization */
+#ifdef MAME_NET
+	if (osd_net_init()      !=OSD_OK) return OSD_NOT_OK;
+#endif	
+	if (osd_input_initpre() !=OSD_OK) return OSD_NOT_OK;
+	
+	return OSD_OK;
+}
+
+/*
+ * Cleanup routines to be executed when the program is terminated.
+ */
+void osd_exit (void)
+{
+#ifdef MAME_NET
+	osd_net_close();
+#endif
+	osd_input_close();
+}
+
+
+int main (int argc, char **argv)
+{
+	int res;
+	
+	/* some display methods need to do some stuff with root rights */
+	if (sysdep_init()!= OSD_OK) exit(OSD_NOT_OK);
+	
+	/* to be absolutly safe force giving up root rights here in case
+	   a display method doesn't */
+	if(setuid(getuid()))
+	{
+		perror("setuid");
+		sysdep_close();
+		return OSD_NOT_OK;
+	}
+	
+        /* Set the title, now auto build from defines from the makefile */
+        sprintf(title,"%s (%s) version %s", NAME, DISPLAY_METHOD,
+           build_version);
+
+	/* parse configuration file and environment */
+	if ((res = config_init(argc, argv)) != 1234) goto leave;
+	
+        /* Check the colordepth we're requesting */
+        if (!options.color_depth && !sysdep_display_16bpp_capable())
+           options.color_depth = 8;
+	
+	/* go for it */
+	res = run_game (game_index);
+
+leave:
+	sysdep_close();
+	/* should be done last since this also closes stdout and stderr */
+	config_exit();
+
+	return res;
+}
diff -Naur ../mmmmm/m36b16/src/unix/Makefile mame-0.36b16/src/unix/Makefile
--- ../mmmmm/m36b16/src/unix/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/Makefile	2023-07-07 14:20:22.688001896 -0400
@@ -0,0 +1,118 @@
+OBJDIR = ../../$(OBJ)/unix.$(DISPLAY_METHOD)
+MY_TARGET = $(OBJDIR)/osdepend.a
+
+##############################################################################
+# *** object listings
+##############################################################################
+
+# common objs
+COMMON_OBJS  =  \
+	$(OBJDIR)/main.o $(OBJDIR)/sound.o \
+	$(OBJDIR)/keyboard.o $(OBJDIR)/devices.o \
+	$(OBJDIR)/video.o $(OBJDIR)/dirty.o $(OBJDIR)/mode.o \
+	$(OBJDIR)/fileio.o $(OBJDIR)/dirio.o $(OBJDIR)/config.o \
+	$(OBJDIR)/fronthlp.o $(OBJDIR)/ident.o $(OBJDIR)/network.o \
+	$(OBJDIR)/snprintf.o $(OBJDIR)/nec765_dummy.o
+
+# sysdep objs
+SYSDEP_DIR  = $(OBJDIR)/sysdep
+SYSDEP_OBJS = $(SYSDEP_DIR)/rc.o $(SYSDEP_DIR)/misc.o \
+   $(SYSDEP_DIR)/plugin_manager.o $(SYSDEP_DIR)/sound_stream.o \
+   $(SYSDEP_DIR)/sysdep_palette.o $(SYSDEP_DIR)/sysdep_dsp.o \
+   $(SYSDEP_DIR)/sysdep_mixer.o
+   
+# video driver objs per display method
+VID_DIR = $(OBJDIR)/video-drivers
+VID_OBJS.x11    = $(VID_DIR)/xinput.o $(VID_DIR)/xil.o \
+	$(VID_DIR)/x11_window.o $(VID_DIR)/xf86_dga.o 
+VID_OBJS.xgl    = $(VID_DIR)/glvec.o $(VID_DIR)/glgen.o $(VID_DIR)/gljpg.o \
+	$(VID_DIR)/glcab.o $(VID_DIR)/xinput.o $(VID_DIR)/vectorgen.o
+VID_OBJS.xfx    = $(VID_DIR)/fxgen.o $(VID_DIR)/fxvec.o $(VID_DIR)/xinput.o \
+	$(VID_DIR)/vectorgen.o
+VID_OBJS.svgalib = $(VID_DIR)/svgainput.o
+VID_OBJS.svgafx = $(VID_DIR)/svgainput.o $(VID_DIR)/fxgen.o \
+	$(VID_DIR)/fxvec.o $(VID_DIR)/vectorgen.o
+VID_OBJS.openstep = $(VID_DIR)/openstep_input.o
+VID_OBJS = $(VID_DIR)/$(DISPLAY_METHOD).o $(VID_OBJS.$(DISPLAY_METHOD))
+
+# sound driver objs per arch
+DSP_DIR = $(OBJDIR)/sysdep/dsp-drivers
+MIXER_DIR = $(OBJDIR)/sysdep/mixer-drivers
+SOUND_OBJS.linux   = $(DSP_DIR)/oss.o $(MIXER_DIR)/oss.o $(DSP_DIR)/alsa.o
+SOUND_OBJS.freebsd = $(DSP_DIR)/oss.o $(MIXER_DIR)/oss.o
+SOUND_OBJS.netbsd  = $(DSP_DIR)/netbsd.o
+SOUND_OBJS.solaris = $(DSP_DIR)/solaris.o $(MIXER_DIR)/solaris.o
+SOUND_OBJS.next    = $(DSP_DIR)/soundkit.o
+SOUND_OBJS.generic =
+#these need to be converted to plugins first
+#SOUND_OBJS.irix    = $(DSP_DIR)/irix.o
+#SOUND_OBJS.irix_al = $(DSP_DIR)/irix_al.o
+#SOUND_OBJS.aix     = $(DSP_DIR)/aix.o
+SOUND_OBJS = $(SOUND_OBJS.$(ARCH)) $(DSP_DIR)/esound.o
+
+# joystick objs
+JOY_DIR  = $(OBJDIR)/joystick-drivers
+JOY_OBJS = $(JOY_DIR)/joy_i386.o $(JOY_DIR)/joy_pad.o $(JOY_DIR)/joy_x11.o \
+    $(JOY_DIR)/joy_usb.o
+
+# framskip objs
+FRAMESKIP_DIR  = $(OBJDIR)/frameskip-drivers
+FRAMESKIP_OBJS = $(FRAMESKIP_DIR)/dos.o $(FRAMESKIP_DIR)/barath.o
+
+# all objs
+OBJS = $(COMMON_OBJS) $(SYSDEP_OBJS) $(VID_OBJS) $(SOUND_OBJS) $(JOY_OBJS) \
+   $(FRAMESKIP_OBJS)
+
+# obj dirs
+OBJDIRS = $(OBJDIR) $(SYSDEP_DIR) $(DSP_DIR) $(MIXER_DIR) $(VID_DIR) \
+   $(JOY_DIR) $(FRAMESKIP_DIR)
+
+
+##############################################################################
+# *** cflags
+##############################################################################
+
+# per arch
+CFLAGS.linux      = -DSYSDEP_DSP_OSS -DSYSDEP_MIXER_OSS -DHAVE_SNPRINTF -DHAVE_VSNPRINTF
+CFLAGS.freebsd    = -DSYSDEP_DSP_OSS -DSYSDEP_MIXER_OSS -DHAVE_SNPRINTF -DHAVE_VSNPRINTF
+CFLAGS.netbsd     = -DSYSDEP_DSP_NETBSD -DHAVE_SNPRINTF -DHAVE_VSNPRINTF
+CFLAGS.solaris    = -DSYSDEP_DSP_SOLARIS -DSYSDEP_MIXER_SOLARIS
+CFLAGS.next       = -DSYSDEP_DSP_SOUNDKIT -DBSD43
+CFLAGS.generic    =
+#these need to be converted to plugins first
+#CFLAGS.irix       = -DSYSDEP_DSP_IRIX
+#CFLAGS.irix_al    = -DSYSDEP_DSP_IRIX
+#CFLAGS.aix        = -DSYSDEP_DSP_AIX -I/usr/include/UMS -I/usr/lpp/som/include
+
+#all cflags
+MY_CFLAGS = $(CFLAGS) $(CFLAGS.$(ARCH)) -I. -I.. -I../../mess
+
+
+##############################################################################
+# *** begin of the real makefile
+##############################################################################
+all:	$(OBJDIRS) $(MY_TARGET)
+
+clean:
+	rm -f $(MY_TARGET) $(OBJS)
+
+$(MY_TARGET): $(OBJS)
+	$(CC_COMMENT) @echo 'Archiving $@ ...'
+	$(CC_COMPILE) ar $(AR_OPTS) $@ $(OBJS)
+	$(CC_COMPILE) $(RANLIB) $@
+
+$(OBJDIRS):
+	-mkdir $@
+
+$(OBJDIR)/%.o: %.c xmame.h
+	$(CC_COMMENT) @echo 'Compiling src/unix/$< ...'
+	$(CC_COMPILE) $(CC) $(MY_CFLAGS) -o $@ -c $<
+
+$(OBJDIR)/%.o: %.m xmame.h
+	$(CC_COMMENT) @echo 'Compiling src/unix/$< ...'
+	$(CC_COMPILE) $(CC) $(MY_CFLAGS) -o $@ -c $<
+
+$(VID_DIR)/x11_window.o: video-drivers/blit.h video-drivers/blit_core.h
+$(VID_DIR)/svgalib.o: video-drivers/blit.h video-drivers/blit_core.h video-drivers/twkmodes.h video-drivers/twkuser.c
+$(VID_DIR)/xf86_dga.o: video-drivers/blit.h video-drivers/blit_core.h
+$(VID_DIR)/xinput.o: video-drivers/xkeyboard.h
diff -Naur ../mmmmm/m36b16/src/unix/mode.c mame-0.36b16/src/unix/mode.c
--- ../mmmmm/m36b16/src/unix/mode.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/mode.c	2023-07-07 14:20:22.688001896 -0400
@@ -0,0 +1,161 @@
+#include "xmame.h"
+#include "driver.h"
+
+static int mode_disable(struct rc_option *option, const char *s, int priority);
+
+static int use_aspect_ratio = 1;
+
+struct rc_option mode_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "Video Mode Selection Related", NULL,	rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "keepaspect",	"nokeepaspect",		rc_bool,	&use_aspect_ratio,
+     "1",		0,			0,		NULL,
+     "Try / don't try to keep the aspect ratio of a game when selecting the best videomode" },
+   { "displayaspectratio", NULL,		rc_float,	&display_aspect_ratio,
+     "1.33",		0.75,			1.33,		NULL,
+     "Set the display aspect ratio of your monitor. This is used for -keepaspect The default = 1.33 (4/3). Use 0.75 (3/4) for a portrait monitor" },
+   { "disablemode",	NULL,			rc_use_function, NULL,
+     NULL,		0,			0,		mode_disable,
+     "Don't use mode XRESxYRESxDEPTH this can be used to disable specific video modes which don't work on your system. The xDEPTH part of the string is optional. This option may be used more then once" },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+#define MODE_DISABLED_MAX 32
+
+static int disabled_modes_count = 0;
+
+static struct 
+{
+   int width;
+   int height;
+   int depth;
+} disabled_modes[MODE_DISABLED_MAX];
+
+static int mode_disable(struct rc_option *option, const char *s, int priority)
+{
+   if (disabled_modes_count == MODE_DISABLED_MAX)
+   {
+      /* stderr_file doesn't have a valid value yet when we're called ! */
+      fprintf(stderr, "OSD: Warning: You can't disable more then %d modes. Mode %s not disabled\n",
+          MODE_DISABLED_MAX, s);
+      return OSD_OK;
+   }
+   if (sscanf(s, "%dx%dx%d",
+       &disabled_modes[disabled_modes_count].width,
+       &disabled_modes[disabled_modes_count].height,
+       &disabled_modes[disabled_modes_count].depth) < 2)
+      return OSD_NOT_OK;
+   switch (disabled_modes[disabled_modes_count].depth)
+   {
+      case 0:
+      case 256:
+      case 65536:
+         break;
+      default:
+         /* stderr_file doesn't have a valid value yet when we're called ! */
+         fprintf(stderr, "Svgalib: Warning: No such depth: %d. Mode not disabled\n",
+            disabled_modes[disabled_modes_count].depth);
+         return OSD_NOT_OK;
+   }
+   disabled_modes_count++;
+   return OSD_OK;
+}
+
+int mode_disabled(int width, int height)
+{
+   int i;
+   for(i=0; i<disabled_modes_count; i++)
+   {
+      if (disabled_modes[i].width  == width &&
+          disabled_modes[i].height == height)
+      {
+         switch (disabled_modes[disabled_modes_count].depth)
+         {
+            case 0:
+               return TRUE;
+            case 256:
+               if(bitmap->depth == 8)
+                  return TRUE;
+               break;
+            case 65536:
+               if(bitmap->depth == 16)
+                  return TRUE;
+               break;
+         }
+      }
+   }
+   return FALSE;
+}
+
+void mode_perfect(int *width, int *height)
+{
+   float game_aspect_ratio, pixel_aspect_ratio;
+   static int first_time = TRUE;
+   
+   if (use_aspect_ratio)
+   {
+      if (Machine->orientation & ORIENTATION_SWAP_XY)
+         game_aspect_ratio = 0.75; /* 3/4 */
+      else
+         game_aspect_ratio = 1.33; /* 4/3 */
+          
+      /* first of all calculate the pixel aspect_ratio the game has */
+      if (Machine->drv->video_attributes & VIDEO_TYPE_VECTOR)
+      {
+         pixel_aspect_ratio = 1.0;
+      }
+      else
+      {
+         pixel_aspect_ratio = (visual_width * widthscale) / 
+            (visual_height * heightscale * game_aspect_ratio);
+      }
+      
+       
+      /* should we maximize the used height, or the used width? */
+      if (display_aspect_ratio >= game_aspect_ratio)
+      {
+         *height = visual_height * heightscale;
+         *width  = *height * pixel_aspect_ratio * display_aspect_ratio;
+      }
+      else
+      {
+         *width  = visual_width  * widthscale;
+         *height = *width / (pixel_aspect_ratio * display_aspect_ratio);
+      }
+      if (first_time)
+      {
+         fprintf(stderr_file, "OSD: Info: Ideal mode for this game = %dx%d\n",
+            *width, *height);
+         first_time = FALSE;
+      }
+   }
+   else
+   {
+      *width  = visual_width;
+      *height = visual_height;
+   }
+}
+
+/* match a given mode to the needed width, height and aspect ratio to
+   prefectly display a game.
+   This function returns 0 for a not usable mode and 100 for the perfect mode.
+*/
+
+int mode_match(int width, int height)
+{
+   int wanted_width, wanted_height;
+   mode_perfect(&wanted_width, &wanted_height);
+       
+   /* does the game fit at all ? */
+   if(width  < (visual_width  * widthscale) ||
+      height < (visual_height * heightscale))
+      return 0;
+   
+   return ( 100 *
+      ((float)wanted_width  / (abs(width -wanted_width )+wanted_width )) *
+      ((float)wanted_height / (abs(height-wanted_height)+wanted_height)));
+}
diff -Naur ../mmmmm/m36b16/src/unix/nec765_dummy.c mame-0.36b16/src/unix/nec765_dummy.c
--- ../mmmmm/m36b16/src/unix/nec765_dummy.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/nec765_dummy.c	2023-07-07 14:20:22.688001896 -0400
@@ -0,0 +1,56 @@
+#include "xmame.h"
+#ifdef MESS
+
+int osd_fdc_init(void)
+{
+	/* this means init failed, since it isn't supported under unix */
+	return 0; 
+}
+
+void osd_fdc_exit(void)
+{
+}
+
+void osd_fdc_motors(unsigned char unit)
+{
+}
+
+void osd_fdc_density(unsigned char unit, unsigned char density, unsigned char tracks, unsigned char spt, unsigned char eot, unsigned char secl)
+{
+}
+
+void osd_fdc_interrupt(int param)
+{
+}
+
+unsigned char osd_fdc_recal(unsigned char * track)
+{
+	return 0;
+}
+
+unsigned char osd_fdc_seek(unsigned char t, unsigned char * track)
+{
+	return 0;
+}
+
+unsigned char osd_fdc_step(int dir, unsigned char * track)
+{
+	return 0;
+}
+
+unsigned char osd_fdc_format(unsigned char t, unsigned char h, unsigned char spt, unsigned char * fmt)
+{
+	return 0;
+}
+
+unsigned char osd_fdc_put_sector(unsigned char track, unsigned char side, unsigned char head, unsigned char sector, unsigned char *buff, unsigned char ddam)
+{
+	return 0;
+}
+
+unsigned char osd_fdc_get_sector(unsigned char track, unsigned char side, unsigned char head, unsigned char sector, unsigned char *buff)
+{
+	return 0;
+}
+
+#endif /* ifdef MESS */
diff -Naur ../mmmmm/m36b16/src/unix/network.c mame-0.36b16/src/unix/network.c
--- ../mmmmm/m36b16/src/unix/network.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/network.c	2023-07-07 14:20:22.688001896 -0400
@@ -0,0 +1,482 @@
+#include "xmame.h"
+
+#ifdef MAME_NET
+enum {MASTER=1,SLAVE};
+enum {IDENTIFY, SYNC};
+#define NAME_LENGTH 256
+#define PORT_DATA 9000
+
+static int netkeymap = 0;
+static int players = 0;
+static char *mastername = NULL;
+#endif
+
+struct rc_option network_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+#ifdef MAME_NET
+   { "Network Related", NULL,			rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "master",		NULL,			rc_int,		&players,
+     NULL,		1,			4,		NULL,
+     "Enable master mode. Set number of players" },
+   { "slave",		NULL,			rc_string,	&mastername,
+     NULL,		0,			0,		NULL,
+     "Enable slave mode. Set master hostname" },
+   { "netmapkey",	NULL,			rc_bool,	&netkeymap,
+     "0",		0,			0,		NULL,
+     "When enabled all players use the player 1 keys. For use with *real* multiplayer games" },
+#endif
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+#ifdef MAME_NET
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#ifdef svgalib
+#include <vgakeyboard.h>
+#endif
+#include "driver.h"
+
+static int socks[4];
+static struct sockaddr_in names[4];
+static int player;
+static unsigned char keymap[128]; /* table to map network keys to player 1 */
+static int timeout = 60;
+
+static int init_master_socket(void)
+{
+	struct hostent *hp;
+	char hname[NAME_LENGTH];
+
+        fprintf(stderr_file, "XMame in network Master Mode\nWaiting for %d players.\n", players-1);
+	gethostname(hname, 256);
+
+	/* socket creation */
+	if ((socks[0] = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
+	{
+		fprintf(stderr_file, "init master : Can't initialise socket\n");
+		return(OSD_NOT_OK);
+	}
+
+	/* Assign domain and port number */
+	memset(&names[0], 0, sizeof(names[0]));
+	names[0].sin_family = AF_INET;
+	names[0].sin_port = PORT_DATA;
+	
+	/* Assign IP address */
+	if ((hp = gethostbyname(hname)) == NULL)
+	{
+		fprintf(stderr_file, "init master : gethostbyname error\n");
+		return(OSD_NOT_OK);
+	}
+	memcpy(&(names[0].sin_addr.s_addr), hp->h_addr, hp->h_length);
+
+	/* bind socket */
+	if (bind(socks[0], (struct sockaddr *)&names[0], sizeof(names[0])) == -1)
+	{
+		fprintf(stderr_file, "init master : Bind failure.\n");
+		return(OSD_NOT_OK);
+	}
+
+	return(OSD_OK);
+}
+
+static int init_slave_sockets(void)
+{
+        struct hostent *hp;
+	char hname[NAME_LENGTH];
+
+        fprintf(stderr_file, "Slave Mode; Registering to Master %s\n", mastername);
+        
+        /* socket creation */
+        if ((socks[1] = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
+        {
+                fprintf(stderr_file, "init slave : Can't initialise socket\n");
+                return(OSD_NOT_OK);
+        }
+
+        /* Assign domain and port number */
+        memset(&names[1], 0, sizeof(names[1]));
+        names[1].sin_family = AF_INET;
+        names[1].sin_port = PORT_DATA;
+
+        /* Assign IP address */
+        if ((hp = gethostbyname(mastername)) == NULL)
+        {
+                fprintf(stderr_file, "init slave : gethostbyname error\n");
+                return(OSD_NOT_OK);
+        }
+        memcpy(&(names[1].sin_addr.s_addr), hp->h_addr, hp->h_length);
+
+        gethostname(hname, 256);
+
+        /* socket creation */
+        if ((socks[0] = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
+        {
+                fprintf(stderr_file, "init slave : Can't initialise socket\n");
+                return(OSD_NOT_OK);
+        }
+
+        /* Assign domain and port number */
+        memset(&names[0], 0, sizeof(names[0]));
+        names[0].sin_family = AF_INET;
+        names[0].sin_port = PORT_DATA+1;
+
+        /* Assign IP address */
+        if ((hp = gethostbyname(hname)) == NULL)
+        {
+                fprintf(stderr_file, "init slave : gethostbyname error\n");
+                return(OSD_NOT_OK);
+        }
+        memcpy(&(names[0].sin_addr.s_addr), hp->h_addr, hp->h_length);
+
+        /* bind socket */
+        if (bind(socks[0], (struct sockaddr *)&names[0], sizeof(names[0])) == -1)
+        {
+                fprintf(stderr_file, "init slave : Bind failure.\n");
+                return(OSD_NOT_OK);
+        }
+
+	return(OSD_OK);
+}
+
+static int receive_msg(void *msg, int size)
+{
+        unsigned int lg = 0;
+        fd_set rfds;
+        struct timeval tv;
+        
+        /* watch socks[0] to see if it has any input */
+        FD_ZERO(&rfds);
+        FD_SET(socks[0], &rfds);
+        
+        /* Wait up to timeout seconds. */
+        tv.tv_sec  = timeout;
+        tv.tv_usec = 0;
+
+        if (select(socks[0] + 1, &rfds, NULL, NULL, &tv)==0)
+        {
+        	fprintf(stderr_file, "Error: timeout (%d secs) while receiving message.\n", timeout);
+                return OSD_NOT_OK;
+        }
+        
+        if (recvfrom(socks[0], msg, size, 0, NULL, &lg) == -1)
+        {
+        	fprintf(stderr_file, "Error: socket error receiving message.\n");
+                return OSD_NOT_OK;
+        }
+        return OSD_OK;
+}
+
+static int send_msg(void *msg, int size)
+{
+	int i;
+
+	switch(netstate)
+	{
+	case MASTER:
+		for(i=1;i<players;i++)
+		{
+			if (sendto(socks[i], msg, size, 0, (struct sockaddr *)&names[i], sizeof(names[i])) == -1)
+			{
+				fprintf(stderr_file, "Error: socket error sending message.\n");
+				return OSD_NOT_OK;
+			}
+		}
+		break;
+	case SLAVE:
+		if (sendto(socks[1], msg, size, 0, (struct sockaddr *)&names[1], sizeof(names[1])) == -1)
+		{
+			fprintf(stderr_file, "Error: socket error sending message.\n");
+			return OSD_NOT_OK;
+		}
+		break;
+	}
+	return OSD_OK;
+}
+
+static int add_slave(char *host, int *sock, struct sockaddr_in *name)
+{
+        struct hostent *hp;
+
+        /* socket creation */
+        if ((*sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
+        {
+                fprintf(stderr_file, "Error: can't initialise socket\n");
+                return(OSD_NOT_OK);
+        }
+
+        /* Assign domain and port number */
+        memset(name, 0, sizeof(struct sockaddr_in));
+        name->sin_family = AF_INET;
+        name->sin_port   = PORT_DATA+1;
+
+        /* Assign IP address */
+        if ((hp = gethostbyname(host)) == NULL)
+        {
+                fprintf(stderr_file, "Error: gethostbyname error\n");
+                return(OSD_NOT_OK);
+        }
+        memcpy(&name->sin_addr.s_addr, hp->h_addr, hp->h_length);
+
+	return(OSD_OK);
+}
+
+static int register_to_master(void)
+{
+	char hname[NAME_LENGTH];
+
+	gethostname(hname, NAME_LENGTH);
+	if (sendto(socks[1], hname, NAME_LENGTH, 0, (struct sockaddr *)&names[1], sizeof(names[1])) == -1)
+	{
+		fprintf(stderr_file, "Error: socket error sending registration to master");
+		return OSD_NOT_OK;
+	}
+	if (receive_msg(&player, sizeof(player)) != OSD_OK) return OSD_NOT_OK;
+	fprintf(stderr_file, "Registered as player %d\n", player);
+	return OSD_OK;
+}
+
+static int wait_registration(void)
+{
+	char hname[NAME_LENGTH]; /* slave host name */
+	int i;
+
+	for(i=1;i<players;i++)
+	{
+		player=i+1;
+		if (receive_msg(hname, NAME_LENGTH) != OSD_OK)
+		{
+			fprintf(stderr_file, "Error: Can't receive registration from player %d\n", player);
+			return OSD_NOT_OK;
+		}
+		if (add_slave(hname, &socks[i], &names[i])!=OSD_OK) return OSD_NOT_OK;
+		if (sendto(socks[i], &player, sizeof(player), 0, (struct sockaddr *)&names[i], sizeof(names[i]))==-1)
+		{
+			fprintf(stderr_file, "Error: socket error sending registration to player %d\n", player);
+			return OSD_NOT_OK;
+		}
+		fprintf(stderr_file, "%s registered successfully as player %d.\n", hname, player);
+	}
+	player = 1;
+	return OSD_OK;
+}
+
+int default_key(const struct InputPort *in);
+
+static int net_map_key(int keycode, int playermask)
+{
+  struct InputPort *in = Machine->input_ports, *start = Machine->input_ports;
+  int port, found, event = 0;
+ 
+  if (in->type == IPT_END) return keycode;   /* nothing to do */
+ 
+    /* make sure the InputPort definition is correct */
+  if (in->type != IPT_PORT)
+    {
+      if (errorlog) fprintf(errorlog,"Error in InputPort definition: expecting PORT_START\n");
+      return keycode;
+    }
+  else start = ++in;
+ 
+  found = 0;
+  port = 0;
+  while ((found ==0) && (in->type != IPT_END) && (port < MAX_INPUT_PORTS))
+    {
+      while (in->type != IPT_END && in->type != IPT_PORT)
+        {
+          if (default_key(in)==keycode)
+            {
+              event = in->type;
+              found = 1;
+              break;
+            }
+          in++;
+        }
+      if (found == 0)
+      {
+        port++;
+        if (in->type == IPT_PORT) in++;
+      }
+    }
+ 
+  if (found == 0) return keycode;
+ 
+  in = start;
+  port = 0;
+  while (in->type != IPT_END && port < MAX_INPUT_PORTS)
+    {
+      while (in->type != IPT_END && in->type != IPT_PORT)
+        {
+          if ((in->type & IPF_PLAYERMASK)== playermask)
+            if ((in->type & (~IPF_MASK)) == (event & (~IPF_MASK)))
+              {
+                return default_key(in);
+              }
+          in++;
+        }
+ 
+      port++;
+      if (in->type == IPT_PORT) in++;
+    }
+ 
+  return keycode;
+}
+
+static void build_keymap(void)
+{
+  int i, keycode, playermask = 0;
+  
+  switch(player)
+  {
+    case 1:
+      playermask = IPF_PLAYER1;
+      break;
+    case 2:
+      playermask = IPF_PLAYER2;
+      break;
+    case 3:
+      playermask = IPF_PLAYER3;
+      break;
+    case 4:
+      playermask = IPF_PLAYER4;
+      break;
+  }
+  
+  memset(keymap,0,128*sizeof(unsigned char));
+  
+  for(i=0;i<128;i++)
+  {
+    keymap[net_map_key(i, playermask)] = i;
+  }
+}
+
+
+/*
+ * get key tables from slaves
+ */
+void osd_net_sync(void)
+{
+    int i,j;
+    static char net_key[128];
+    
+    if (!key) return;
+    
+    if (netkeymap)
+    {
+      for(i=0; i<128; i++)
+      {
+        global_key[i] = local_key[keymap[i]];
+      }
+    }
+    
+    switch(netstate)
+    {
+      case MASTER:
+        if(!netkeymap) memcpy(global_key, local_key, 128*sizeof(unsigned char));
+        for(i=1;i<players;i++)
+        {
+                if (receive_msg(net_key, 128*sizeof(unsigned char)) != OSD_OK)
+                	goto drop_to_single_player;
+                for(j=0;j<=OSD_MAX_KEY;j++)
+                	global_key[j] |= net_key[j];
+        }
+	if (send_msg(global_key, 128*sizeof(unsigned char)) != OSD_OK)
+                goto drop_to_single_player;
+	break;
+      case SLAVE:
+        if (netkeymap)
+        {
+		if (send_msg(global_key, 128*sizeof(unsigned char)) != OSD_OK)
+                	goto drop_to_single_player;
+	}
+        else
+        {
+		if (send_msg(local_key, 128*sizeof(unsigned char)) != OSD_OK)
+                	goto drop_to_single_player;
+	}
+	if (receive_msg(global_key, 128*sizeof(unsigned char))!=OSD_OK)
+                goto drop_to_single_player;
+	break;
+    }
+    /* after the first successfull sync it should be safe to lower the
+       timeout to 5 seconds */
+    timeout = 5;
+    return;
+    
+drop_to_single_player:    
+    fprintf(stderr_file, "Lost network connection, continuing in single player mode\n");
+    osd_net_close();
+    netstate=0;
+    key=local_key;
+}
+
+/*
+ * Close all opened sockets
+ */
+void osd_net_close(void)
+{
+	int i;
+
+	switch(netstate)
+	{
+	    case MASTER:
+		for(i=0;i<(players-1);i++) close(socks[i]);
+		break;
+	    case SLAVE:
+		close(socks[0]);
+		close(socks[1]);
+		break;
+	}
+}
+
+/*
+ * Initialise network
+ * - the master opens a socket and waits for slaves
+ * - the slaves register to the master
+ */
+int osd_net_init(void)
+{
+	netstate = 0;
+	
+	if (players) netstate = MASTER;
+	if (mastername)
+	{
+	   if(netstate==MASTER)
+	   {
+	      fprintf(stderr_file, "error: can't be Slave and Master\n");
+	      return OSD_NOT_OK;
+	   }
+	   netstate = SLAVE;
+	}
+	
+	switch(netstate)
+	{
+	    case 0:
+	        return OSD_OK;
+	    case MASTER:
+		if (init_master_socket() != OSD_OK)
+		    return OSD_NOT_OK;
+		if (wait_registration() != OSD_OK)
+		    return OSD_NOT_OK;
+		break;
+	    case SLAVE:
+		if (init_slave_sockets() != OSD_OK)
+		    return OSD_NOT_OK;
+		if (register_to_master() != OSD_OK)
+		    return OSD_NOT_OK;
+		break;
+	}
+	if (netkeymap) build_keymap();
+	/* mouse is not supported in network mode */
+	use_mouse = FALSE;
+	return OSD_OK;
+}
+
+#endif /* MAME_NET */
diff -Naur ../mmmmm/m36b16/src/unix/osd_cpu.h mame-0.36b16/src/unix/osd_cpu.h
--- ../mmmmm/m36b16/src/unix/osd_cpu.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/osd_cpu.h	2023-07-07 14:20:22.688001896 -0400
@@ -0,0 +1,101 @@
+/*******************************************************************************
+*																			   *
+*	Define size independent data types and operations.						   *
+*																			   *
+*   The following types must be supported by all platforms:					   *
+*																			   *
+*	UINT8  - Unsigned 8-bit Integer		INT8  - Signed 8-bit integer           *
+*	UINT16 - Unsigned 16-bit Integer	INT16 - Signed 16-bit integer          *
+*	UINT32 - Unsigned 32-bit Integer	INT32 - Signed 32-bit integer          *
+*	UINT64 - Unsigned 64-bit Integer	INT64 - Signed 64-bit integer          *
+*																			   *
+*																			   *
+*   The macro names for the artithmatic operations are composed as follows:    *
+*																			   *
+*   XXX_R_A_B, where XXX - 3 letter operation code (ADD, SUB, etc.)			   *
+*					 R   - The type	of the result							   *
+*					 A   - The type of operand 1							   *
+*			         B   - The type of operand 2 (if binary operation)		   *
+*																			   *
+*				     Each type is one of: U8,8,U16,16,U32,32,U64,64			   *
+*																			   *
+*******************************************************************************/
+#ifndef OSD_CPU_H 
+#define OSD_CPU_H
+
+/* fixup some clock() related issues */
+#include <time.h>
+/* this is cut and pasted from sysdep/misc.c ,check sysdep/misc.c for
+   changes if you suspect something is wrong with this */
+/* some platforms don't define CLOCKS_PER_SEC, according to posix it should
+   always be 1000000, so asume that's the case if it is not defined,
+   except for openstep which doesn't define it and has it at 64 */
+#ifndef CLOCKS_PER_SEC
+#ifdef openstep
+#define CLOCKS_PER_SEC 64     /* this is correct for OS4.2 intel */
+#else
+#define CLOCKS_PER_SEC 1000000
+#endif
+#endif
+
+/* grrr work around some stupid header conflicts */
+#if !defined __XF86_DGA_C && !defined __XOPENGL_C_
+typedef signed   char      INT8;
+typedef signed   short     INT16;
+typedef signed   int       INT32;
+typedef signed   long long INT64;
+#endif
+typedef unsigned char      UINT8;
+typedef unsigned short     UINT16;
+typedef unsigned int       UINT32;
+typedef unsigned long long UINT64;
+
+/* Combine to 32-bit integers into a 64-bit integer */
+#define COMBINE_64_32_32(A,B)     ((((UINT64)(A))<<32) | (UINT32)(B))
+#define COMBINE_U64_U32_U32(A,B)  COMBINE_64_32_32(A,B)
+
+/* Return upper 32 bits of a 64-bit integer */
+#define HI32_32_64(A)		  (((UINT64)(A)) >> 32)
+#define HI32_U32_U64(A)		  HI32_32_64(A)
+
+/* Return lower 32 bits of a 64-bit integer */
+#define LO32_32_64(A)		  ((A) & 0xffffffff)
+#define LO32_U32_U64(A)		  LO32_32_64(A)
+
+#define DIV_64_64_32(A,B)	  ((A)/(B))
+#define DIV_U64_U64_U32(A,B)  ((A)/(UINT32)(B))
+
+#define MOD_32_64_32(A,B)	  ((A)%(B))
+#define MOD_U32_U64_U32(A,B)  ((A)%(UINT32)(B))
+
+#define MUL_64_32_32(A,B)	  ((A)*(INT64)(B))
+#define MUL_U64_U32_U32(A,B)  ((A)*(UINT64)(UINT32)(B))
+
+/******************************************************************************
+ * Union of UINT8, UINT16 and UINT32 in native endianess of the target
+ * This is used to access bytes and words in a machine independent manner.
+ * The upper bytes h2 and h3 normally contain zero (16 bit CPU cores)
+ * thus PAIR.d can be used to pass arguments to the memory system
+ * which expects 'int' really.
+ ******************************************************************************/
+typedef union {
+#ifdef LSB_FIRST
+	struct { UINT8 l,h,h2,h3; } b;
+	struct { UINT16 l,h; } w;
+#else
+	struct { UINT8 h3,h2,h,l; } b;
+	struct { UINT16 h,l; } w;
+#endif
+	UINT32 d;
+}	PAIR;
+
+/* disable BIG_SWITCH optimalisation in z80.c and m6809.c on buggy gcc
+   versions */
+#if (defined __GNUC__) && \
+   ((__GNUC__ < 2) || ((__GNUC__ == 2) && (__GNUC_MINOR__ < 8)))
+#define BIG_SWITCH          0
+#else
+#define BIG_SWITCH          1
+#endif
+
+#endif	/* defined OSD_CPU_H */
diff -Naur ../mmmmm/m36b16/src/unix/osd_dbg.h mame-0.36b16/src/unix/osd_dbg.h
--- ../mmmmm/m36b16/src/unix/osd_dbg.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/osd_dbg.h	2023-07-07 14:20:22.688001896 -0400
@@ -0,0 +1,118 @@
+#ifndef _OSD_DBG_H
+#define _OSD_DBG_H
+
+#ifdef MAME_DEBUG
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <time.h>
+
+/*
+ * Specify the format of arguments to win_printf and win_set_title
+ * Can be empty if your compiler doesn't support argument checking.
+ * If you use GCC you can use the following macro.
+ */
+#ifdef __GCC__
+#define ARGFMT	__attribute__((format(printf,2,3)))
+#else
+#define ARGFMT
+#endif
+
+/*
+ * Additional declaration specifier for functions that use variable
+ * arguments (...) or C library functions like qsort (WIN32 needs this)
+ */
+#ifndef DECL_SPEC
+#define DECL_SPEC
+#endif
+
+#ifndef TRUE
+#define TRUE	1
+#endif
+
+#ifndef FALSE
+#define FALSE	0
+#endif
+
+#ifndef INVALID
+#define INVALID 0xffffffff
+#endif
+
+/* grrr rather useless as this sequence is hardcoded into src/mamedbg.h in
+   some places */
+enum {
+    BLACK, BLUE, GREEN, CYAN, RED, MAGENTA, BROWN, LIGHTGRAY,
+	DARKGRAY, LIGHTBLUE, LIGHTGREEN, LIGHTCYAN, LIGHTRED, LIGHTMAGENTA, YELLOW, WHITE
+};
+
+/*
+ * Characters used by the window engine to draw background, frames and caption
+ * You might want to put some ASCII characters here or the appropriate line
+ * characters for your machine.
+ */
+
+#ifndef WIN_EMPTY
+#define WIN_EMPTY	' '
+#endif
+#ifndef CAPTION_L
+#define CAPTION_L	'['
+#endif
+#ifndef CAPTION_R
+#define CAPTION_R	']'
+#endif
+#ifndef FRAME_TL
+#define FRAME_TL	'+'
+#endif
+#ifndef FRAME_BL
+#define FRAME_BL	'+'
+#endif
+#ifndef FRAME_TR
+#define FRAME_TR	'+'
+#endif
+#ifndef FRAME_BR
+#define FRAME_BR	'+'
+#endif
+#ifndef FRAME_V
+#define FRAME_V 	'|'
+#endif
+#ifndef FRAME_H
+#define FRAME_H 	'-'
+#endif
+
+/***************************************************************************
+ *
+ * These functions have to be provided by the OS specific code
+ *
+ ***************************************************************************/
+extern void osd_put_screen_char (int ch, int attr, int x, int y);
+extern void osd_set_screen_curpos (int x, int y);
+extern int /* key */ osd_debug_readkey (void);	/* JB 980103 */
+extern void osd_screen_update(void);
+
+/***************************************************************************
+ * Note: I renamed the set_gfx_mode function to avoid a name clash with
+ * DOS' allegro.h. The new function should set any mode that is available
+ * on the platform and the get_screen_size function should return the
+ * resolution that is actually available.
+ * The minimum required size is 80x25 characters, anything higher is ok.
+ ***************************************************************************/
+extern void osd_set_screen_size (unsigned width, unsigned height);
+extern void osd_get_screen_size (unsigned *width, unsigned *height);
+
+/***************************************************************************
+ * Convenience macro for the CPU cores, this is defined to empty
+ * if MAME_DEBUG is not specified, so a CPU core can simply add
+ * CALL_MAME_DEBUG; before executing an instruction
+ ***************************************************************************/
+#define CALL_MAME_DEBUG if( mame_debug ) MAME_Debug()
+
+#else	/* MAME_DEBUG */
+
+#define	CALL_MAME_DEBUG
+
+#endif	/* !MAME_DEBUG */
+
+#endif	/* _OSD_DBG_H */
+
diff -Naur ../mmmmm/m36b16/src/unix/osinline.h mame-0.36b16/src/unix/osinline.h
--- ../mmmmm/m36b16/src/unix/osinline.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/osinline.h	2023-07-07 14:20:22.688001896 -0400
@@ -0,0 +1,41 @@
+#ifndef __OSINLINE__
+#define __OSINLINE__
+
+/* for uclock() */
+#include "sysdep/misc.h"
+
+#define osd_cycles() uclock()
+
+#if defined svgalib || defined x11 || defined ggi || defined openstep
+extern unsigned char *dirty_lines;
+extern unsigned char **dirty_blocks;
+
+#define osd_mark_vector_dirty(x,y) \
+{ \
+   dirty_lines[(y)>>3] = 1; \
+   dirty_blocks[(y)>>3][(x)>>3] = 1; \
+}
+
+#else
+#define osd_mark_vector_dirty(x,y)
+#endif
+
+#ifdef X86_ASM
+#define vec_mult _vec_mult
+INLINE int _vec_mult(int x, int y)
+{
+	int result;
+	asm (
+			"movl  %1    , %0    ; "
+			"imull %2            ; "    /* do the multiply */
+			"movl  %%edx , %%eax ; "
+			:  "=&a" (result)           /* the result has to go in eax */
+			:  "mr" (x),                /* x and y can be regs or mem */
+			   "mr" (y)
+			:  "%edx", "%cc"            /* clobbers edx and flags */
+		);
+	return result;
+}
+#endif
+
+#endif /* __OSINLINE__ */
diff -Naur ../mmmmm/m36b16/src/unix/snprintf.c mame-0.36b16/src/unix/snprintf.c
--- ../mmmmm/m36b16/src/unix/snprintf.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/snprintf.c	2023-07-07 14:20:22.688001896 -0400
@@ -0,0 +1,813 @@
+/*
+ * Copyright Patrick Powell 1995
+ * This code is based on code written by Patrick Powell (papowell@astart.com)
+ * It may be used for any purpose as long as this notice remains intact
+ * on all source code distributions
+ */
+
+/**************************************************************
+ * Original:
+ * Patrick Powell Tue Apr 11 09:48:21 PDT 1995
+ * A bombproof version of doprnt (dopr) included.
+ * Sigh.  This sort of thing is always nasty do deal with.  Note that
+ * the version here does not include floating point...
+ *
+ * snprintf() is used instead of sprintf() as it does limit checks
+ * for string length.  This covers a nasty loophole.
+ *
+ * The other functions are there to prevent NULL pointers from
+ * causing nast effects.
+ *
+ * More Recently:
+ *  Brandon Long <blong@fiction.net> 9/15/96 for mutt 0.43
+ *  This was ugly.  It is still ugly.  I opted out of floating point
+ *  numbers, but the formatter understands just about everything
+ *  from the normal C string format, at least as far as I can tell from
+ *  the Solaris 2.5 printf(3S) man page.
+ *
+ *  Brandon Long <blong@fiction.net> 10/22/97 for mutt 0.87.1
+ *    Ok, added some minimal floating point support, which means this
+ *    probably requires libm on most operating systems.  Don't yet
+ *    support the exponent (e,E) and sigfig (g,G).  Also, fmtint()
+ *    was pretty badly broken, it just wasn't being exercised in ways
+ *    which showed it, so that's been fixed.  Also, formated the code
+ *    to mutt conventions, and removed dead code left over from the
+ *    original.  Also, there is now a builtin-test, just compile with:
+ *           gcc -DTEST_SNPRINTF -o snprintf snprintf.c -lm
+ *    and run snprintf for results.
+ * 
+ *  Thomas Roessler <roessler@guug.de> 01/27/98 for mutt 0.89i
+ *    The PGP code was using unsigned hexadecimal formats. 
+ *    Unfortunately, unsigned formats simply didn't work.
+ *
+ *  Michael Elkins <me@cs.hmc.edu> 03/05/98 for mutt 0.90.8
+ *    The original code assumed that both snprintf() and vsnprintf() were
+ *    missing.  Some systems only have snprintf() but not vsnprintf(), so
+ *    the code is now broken down under HAVE_SNPRINTF and HAVE_VSNPRINTF.
+ *
+ *  Andrew Tridgell (tridge@samba.org) Oct 1998
+ *    fixed handling of %.0f
+ *    added test for HAVE_LONG_DOUBLE
+ *
+ **************************************************************/
+
+/* #include "config.h" */
+#define HAVE_STDARG_H
+
+/* moved above the #ifdef to avoid warning about empty c-files */
+#include <string.h>
+#include <ctype.h>
+#include <sys/types.h>
+
+#if !defined(HAVE_SNPRINTF) || !defined(HAVE_VSNPRINTF)
+
+
+/* Define this as a fall through, HAVE_STDARG_H is probably already set */
+#define HAVE_VARARGS_H
+
+
+/* varargs declarations: */
+
+#if defined(HAVE_STDARG_H)
+# include <stdarg.h>
+# define HAVE_STDARGS    /* let's hope that works everywhere (mj) */
+# define VA_LOCAL_DECL   va_list ap
+# define VA_START(f)     va_start(ap, f)
+# define VA_SHIFT(v,t)  ;   /* no-op for ANSI */
+# define VA_END          va_end(ap)
+#else
+# if defined(HAVE_VARARGS_H)
+#  include <varargs.h>
+#  undef HAVE_STDARGS
+#  define VA_LOCAL_DECL   va_list ap
+#  define VA_START(f)     va_start(ap)      /* f is ignored! */
+#  define VA_SHIFT(v,t) v = va_arg(ap,t)
+#  define VA_END        va_end(ap)
+# else
+/*XX ** NO VARARGS ** XX*/
+# endif
+#endif
+
+#ifdef HAVE_LONG_DOUBLE
+#define LDOUBLE long double
+#else
+#define LDOUBLE double
+#endif
+
+int snprintf (char *str, size_t count, const char *fmt, ...);
+int vsnprintf (char *str, size_t count, const char *fmt, va_list arg);
+
+static void dopr (char *buffer, size_t maxlen, const char *format, 
+                  va_list args);
+static void fmtstr (char *buffer, size_t *currlen, size_t maxlen,
+		    char *value, int flags, int min, int max);
+static void fmtint (char *buffer, size_t *currlen, size_t maxlen,
+		    long value, int base, int min, int max, int flags);
+static void fmtfp (char *buffer, size_t *currlen, size_t maxlen,
+		   LDOUBLE fvalue, int min, int max, int flags);
+static void dopr_outch (char *buffer, size_t *currlen, size_t maxlen, char c );
+
+/*
+ * dopr(): poor man's version of doprintf
+ */
+
+/* format read states */
+#define DP_S_DEFAULT 0
+#define DP_S_FLAGS   1
+#define DP_S_MIN     2
+#define DP_S_DOT     3
+#define DP_S_MAX     4
+#define DP_S_MOD     5
+#define DP_S_CONV    6
+#define DP_S_DONE    7
+
+/* format flags - Bits */
+#define DP_F_MINUS 	(1 << 0)
+#define DP_F_PLUS  	(1 << 1)
+#define DP_F_SPACE 	(1 << 2)
+#define DP_F_NUM   	(1 << 3)
+#define DP_F_ZERO  	(1 << 4)
+#define DP_F_UP    	(1 << 5)
+#define DP_F_UNSIGNED 	(1 << 6)
+
+/* Conversion Flags */
+#define DP_C_SHORT   1
+#define DP_C_LONG    2
+#define DP_C_LDOUBLE 3
+
+#define char_to_int(p) (p - '0')
+#define MAX(p,q) ((p >= q) ? p : q)
+
+static void dopr (char *buffer, size_t maxlen, const char *format, va_list args)
+{
+  char ch;
+  long value;
+  LDOUBLE fvalue;
+  char *strvalue;
+  int min;
+  int max;
+  int state;
+  int flags;
+  int cflags;
+  size_t currlen;
+  
+  state = DP_S_DEFAULT;
+  currlen = flags = cflags = min = 0;
+  max = -1;
+  ch = *format++;
+
+  while (state != DP_S_DONE)
+  {
+    if ((ch == '\0') || (currlen >= maxlen)) 
+      state = DP_S_DONE;
+
+    switch(state) 
+    {
+    case DP_S_DEFAULT:
+      if (ch == '%') 
+	state = DP_S_FLAGS;
+      else 
+	dopr_outch (buffer, &currlen, maxlen, ch);
+      ch = *format++;
+      break;
+    case DP_S_FLAGS:
+      switch (ch) 
+      {
+      case '-':
+	flags |= DP_F_MINUS;
+        ch = *format++;
+	break;
+      case '+':
+	flags |= DP_F_PLUS;
+        ch = *format++;
+	break;
+      case ' ':
+	flags |= DP_F_SPACE;
+        ch = *format++;
+	break;
+      case '#':
+	flags |= DP_F_NUM;
+        ch = *format++;
+	break;
+      case '0':
+	flags |= DP_F_ZERO;
+        ch = *format++;
+	break;
+      default:
+	state = DP_S_MIN;
+	break;
+      }
+      break;
+    case DP_S_MIN:
+      if (isdigit(ch)) 
+      {
+	min = 10*min + char_to_int (ch);
+	ch = *format++;
+      } 
+      else if (ch == '*') 
+      {
+	min = va_arg (args, int);
+	ch = *format++;
+	state = DP_S_DOT;
+      } 
+      else 
+	state = DP_S_DOT;
+      break;
+    case DP_S_DOT:
+      if (ch == '.') 
+      {
+	state = DP_S_MAX;
+	ch = *format++;
+      } 
+      else 
+	state = DP_S_MOD;
+      break;
+    case DP_S_MAX:
+      if (isdigit(ch)) 
+      {
+	if (max < 0)
+	  max = 0;
+	max = 10*max + char_to_int (ch);
+	ch = *format++;
+      } 
+      else if (ch == '*') 
+      {
+	max = va_arg (args, int);
+	ch = *format++;
+	state = DP_S_MOD;
+      } 
+      else 
+	state = DP_S_MOD;
+      break;
+    case DP_S_MOD:
+      /* Currently, we don't support Long Long, bummer */
+      switch (ch) 
+      {
+      case 'h':
+	cflags = DP_C_SHORT;
+	ch = *format++;
+	break;
+      case 'l':
+	cflags = DP_C_LONG;
+	ch = *format++;
+	break;
+      case 'L':
+	cflags = DP_C_LDOUBLE;
+	ch = *format++;
+	break;
+      default:
+	break;
+      }
+      state = DP_S_CONV;
+      break;
+    case DP_S_CONV:
+      switch (ch) 
+      {
+      case 'd':
+      case 'i':
+	if (cflags == DP_C_SHORT) 
+	  value = va_arg (args, short int);
+	else if (cflags == DP_C_LONG)
+	  value = va_arg (args, long int);
+	else
+	  value = va_arg (args, int);
+	fmtint (buffer, &currlen, maxlen, value, 10, min, max, flags);
+	break;
+      case 'o':
+	flags |= DP_F_UNSIGNED;
+	if (cflags == DP_C_SHORT)
+	  value = va_arg (args, unsigned short int);
+	else if (cflags == DP_C_LONG)
+	  value = va_arg (args, unsigned long int);
+	else
+	  value = va_arg (args, unsigned int);
+	fmtint (buffer, &currlen, maxlen, value, 8, min, max, flags);
+	break;
+      case 'u':
+	flags |= DP_F_UNSIGNED;
+	if (cflags == DP_C_SHORT)
+	  value = va_arg (args, unsigned short int);
+	else if (cflags == DP_C_LONG)
+	  value = va_arg (args, unsigned long int);
+	else
+	  value = va_arg (args, unsigned int);
+	fmtint (buffer, &currlen, maxlen, value, 10, min, max, flags);
+	break;
+      case 'X':
+	flags |= DP_F_UP;
+      case 'x':
+	flags |= DP_F_UNSIGNED;
+	if (cflags == DP_C_SHORT)
+	  value = va_arg (args, unsigned short int);
+	else if (cflags == DP_C_LONG)
+	  value = va_arg (args, unsigned long int);
+	else
+	  value = va_arg (args, unsigned int);
+	fmtint (buffer, &currlen, maxlen, value, 16, min, max, flags);
+	break;
+      case 'f':
+	if (cflags == DP_C_LDOUBLE)
+	  fvalue = va_arg (args, LDOUBLE);
+	else
+	  fvalue = va_arg (args, double);
+	/* um, floating point? */
+	fmtfp (buffer, &currlen, maxlen, fvalue, min, max, flags);
+	break;
+      case 'E':
+	flags |= DP_F_UP;
+      case 'e':
+	if (cflags == DP_C_LDOUBLE)
+	  fvalue = va_arg (args, LDOUBLE);
+	else
+	  fvalue = va_arg (args, double);
+	break;
+      case 'G':
+	flags |= DP_F_UP;
+      case 'g':
+	if (cflags == DP_C_LDOUBLE)
+	  fvalue = va_arg (args, LDOUBLE);
+	else
+	  fvalue = va_arg (args, double);
+	break;
+      case 'c':
+	dopr_outch (buffer, &currlen, maxlen, va_arg (args, int));
+	break;
+      case 's':
+	strvalue = va_arg (args, char *);
+	if (max < 0) 
+	  max = maxlen; /* ie, no max */
+	fmtstr (buffer, &currlen, maxlen, strvalue, flags, min, max);
+	break;
+      case 'p':
+	strvalue = va_arg (args, void *);
+	fmtint (buffer, &currlen, maxlen, (long) strvalue, 16, min, max, flags);
+	break;
+      case 'n':
+	if (cflags == DP_C_SHORT) 
+	{
+	  short int *num;
+	  num = va_arg (args, short int *);
+	  *num = currlen;
+        } 
+	else if (cflags == DP_C_LONG) 
+	{
+	  long int *num;
+	  num = va_arg (args, long int *);
+	  *num = currlen;
+        } 
+	else 
+	{
+	  int *num;
+	  num = va_arg (args, int *);
+	  *num = currlen;
+        }
+	break;
+      case '%':
+	dopr_outch (buffer, &currlen, maxlen, ch);
+	break;
+      case 'w':
+	/* not supported yet, treat as next char */
+	ch = *format++;
+	break;
+      default:
+	/* Unknown, skip */
+	break;
+      }
+      ch = *format++;
+      state = DP_S_DEFAULT;
+      flags = cflags = min = 0;
+      max = -1;
+      break;
+    case DP_S_DONE:
+      break;
+    default:
+      /* hmm? */
+      break; /* some picky compilers need this */
+    }
+  }
+  if (currlen < maxlen - 1) 
+    buffer[currlen] = '\0';
+  else 
+    buffer[maxlen - 1] = '\0';
+}
+
+static void fmtstr (char *buffer, size_t *currlen, size_t maxlen,
+		    char *value, int flags, int min, int max)
+{
+  int padlen, strln;     /* amount to pad */
+  int cnt = 0;
+  
+  if (value == 0)
+  {
+    value = "<NULL>";
+  }
+
+  for (strln = 0; value[strln]; ++strln); /* strlen */
+  padlen = min - strln;
+  if (padlen < 0) 
+    padlen = 0;
+  if (flags & DP_F_MINUS) 
+    padlen = -padlen; /* Left Justify */
+
+  while ((padlen > 0) && (cnt < max)) 
+  {
+    dopr_outch (buffer, currlen, maxlen, ' ');
+    --padlen;
+    ++cnt;
+  }
+  while (*value && (cnt < max)) 
+  {
+    dopr_outch (buffer, currlen, maxlen, *value++);
+    ++cnt;
+  }
+  while ((padlen < 0) && (cnt < max)) 
+  {
+    dopr_outch (buffer, currlen, maxlen, ' ');
+    ++padlen;
+    ++cnt;
+  }
+}
+
+/* Have to handle DP_F_NUM (ie 0x and 0 alternates) */
+
+static void fmtint (char *buffer, size_t *currlen, size_t maxlen,
+		    long value, int base, int min, int max, int flags)
+{
+  int signvalue = 0;
+  unsigned long uvalue;
+  char convert[20];
+  int place = 0;
+  int spadlen = 0; /* amount to space pad */
+  int zpadlen = 0; /* amount to zero pad */
+  int caps = 0;
+  
+  if (max < 0)
+    max = 0;
+
+  uvalue = value;
+
+  if(!(flags & DP_F_UNSIGNED))
+  {
+    if( value < 0 ) {
+      signvalue = '-';
+      uvalue = -value;
+    }
+    else
+      if (flags & DP_F_PLUS)  /* Do a sign (+/i) */
+	signvalue = '+';
+    else
+      if (flags & DP_F_SPACE)
+	signvalue = ' ';
+  }
+  
+  if (flags & DP_F_UP) caps = 1; /* Should characters be upper case? */
+
+  do {
+    convert[place++] =
+      (caps? "0123456789ABCDEF":"0123456789abcdef")
+      [uvalue % (unsigned)base  ];
+    uvalue = (uvalue / (unsigned)base );
+  } while(uvalue && (place < 20));
+  if (place == 20) place--;
+  convert[place] = 0;
+
+  zpadlen = max - place;
+  spadlen = min - MAX (max, place) - (signvalue ? 1 : 0);
+  if (zpadlen < 0) zpadlen = 0;
+  if (spadlen < 0) spadlen = 0;
+  if (flags & DP_F_ZERO)
+  {
+    zpadlen = MAX(zpadlen, spadlen);
+    spadlen = 0;
+  }
+  if (flags & DP_F_MINUS) 
+    spadlen = -spadlen; /* Left Justifty */
+
+#ifdef DEBUG_SNPRINTF
+  dprint (1, (debugfile, "zpad: %d, spad: %d, min: %d, max: %d, place: %d\n",
+      zpadlen, spadlen, min, max, place));
+#endif
+
+  /* Spaces */
+  while (spadlen > 0) 
+  {
+    dopr_outch (buffer, currlen, maxlen, ' ');
+    --spadlen;
+  }
+
+  /* Sign */
+  if (signvalue) 
+    dopr_outch (buffer, currlen, maxlen, signvalue);
+
+  /* Zeros */
+  if (zpadlen > 0) 
+  {
+    while (zpadlen > 0)
+    {
+      dopr_outch (buffer, currlen, maxlen, '0');
+      --zpadlen;
+    }
+  }
+
+  /* Digits */
+  while (place > 0) 
+    dopr_outch (buffer, currlen, maxlen, convert[--place]);
+  
+  /* Left Justified spaces */
+  while (spadlen < 0) {
+    dopr_outch (buffer, currlen, maxlen, ' ');
+    ++spadlen;
+  }
+}
+
+static LDOUBLE abs_val (LDOUBLE value)
+{
+  LDOUBLE result = value;
+
+  if (value < 0)
+    result = -value;
+
+  return result;
+}
+
+static LDOUBLE pow10 (int exp)
+{
+  LDOUBLE result = 1;
+
+  while (exp)
+  {
+    result *= 10;
+    exp--;
+  }
+  
+  return result;
+}
+
+static long round (LDOUBLE value)
+{
+  long intpart;
+
+  intpart = value;
+  value = value - intpart;
+  if (value >= 0.5)
+    intpart++;
+
+  return intpart;
+}
+
+static void fmtfp (char *buffer, size_t *currlen, size_t maxlen,
+		   LDOUBLE fvalue, int min, int max, int flags)
+{
+  int signvalue = 0;
+  LDOUBLE ufvalue;
+  char iconvert[20];
+  char fconvert[20];
+  int iplace = 0;
+  int fplace = 0;
+  int padlen = 0; /* amount to pad */
+  int zpadlen = 0; 
+  int caps = 0;
+  long intpart;
+  long fracpart;
+  
+  /* 
+   * AIX manpage says the default is 0, but Solaris says the default
+   * is 6, and sprintf on AIX defaults to 6
+   */
+  if (max < 0)
+    max = 6;
+
+  ufvalue = abs_val (fvalue);
+
+  if (fvalue < 0)
+    signvalue = '-';
+  else
+    if (flags & DP_F_PLUS)  /* Do a sign (+/i) */
+      signvalue = '+';
+    else
+      if (flags & DP_F_SPACE)
+	signvalue = ' ';
+
+#if 0
+  if (flags & DP_F_UP) caps = 1; /* Should characters be upper case? */
+#endif
+
+  intpart = ufvalue;
+
+  /* 
+   * Sorry, we only support 9 digits past the decimal because of our 
+   * conversion method
+   */
+  if (max > 9)
+    max = 9;
+
+  /* We "cheat" by converting the fractional part to integer by
+   * multiplying by a factor of 10
+   */
+  fracpart = round ((pow10 (max)) * (ufvalue - intpart));
+
+  if (fracpart >= pow10 (max))
+  {
+    intpart++;
+    fracpart -= pow10 (max);
+  }
+
+#ifdef DEBUG_SNPRINTF
+  dprint (1, (debugfile, "fmtfp: %f =? %d.%d\n", fvalue, intpart, fracpart));
+#endif
+
+  /* Convert integer part */
+  do {
+    iconvert[iplace++] =
+      (caps? "0123456789ABCDEF":"0123456789abcdef")[intpart % 10];
+    intpart = (intpart / 10);
+  } while(intpart && (iplace < 20));
+  if (iplace == 20) iplace--;
+  iconvert[iplace] = 0;
+
+  /* Convert fractional part */
+  do {
+    fconvert[fplace++] =
+      (caps? "0123456789ABCDEF":"0123456789abcdef")[fracpart % 10];
+    fracpart = (fracpart / 10);
+  } while(fracpart && (fplace < 20));
+  if (fplace == 20) fplace--;
+  fconvert[fplace] = 0;
+
+  /* -1 for decimal point, another -1 if we are printing a sign */
+  padlen = min - iplace - max - 1 - ((signvalue) ? 1 : 0); 
+  zpadlen = max - fplace;
+  if (zpadlen < 0)
+    zpadlen = 0;
+  if (padlen < 0) 
+    padlen = 0;
+  if (flags & DP_F_MINUS) 
+    padlen = -padlen; /* Left Justifty */
+
+  if ((flags & DP_F_ZERO) && (padlen > 0)) 
+  {
+    if (signvalue) 
+    {
+      dopr_outch (buffer, currlen, maxlen, signvalue);
+      --padlen;
+      signvalue = 0;
+    }
+    while (padlen > 0)
+    {
+      dopr_outch (buffer, currlen, maxlen, '0');
+      --padlen;
+    }
+  }
+  while (padlen > 0)
+  {
+    dopr_outch (buffer, currlen, maxlen, ' ');
+    --padlen;
+  }
+  if (signvalue) 
+    dopr_outch (buffer, currlen, maxlen, signvalue);
+
+  while (iplace > 0) 
+    dopr_outch (buffer, currlen, maxlen, iconvert[--iplace]);
+
+  /*
+   * Decimal point.  This should probably use locale to find the correct
+   * char to print out.
+   */
+  if (max > 0)
+  {
+    dopr_outch (buffer, currlen, maxlen, '.');
+
+    while (fplace > 0) 
+      dopr_outch (buffer, currlen, maxlen, fconvert[--fplace]);
+  }
+
+  while (zpadlen > 0)
+  {
+    dopr_outch (buffer, currlen, maxlen, '0');
+    --zpadlen;
+  }
+
+  while (padlen < 0) 
+  {
+    dopr_outch (buffer, currlen, maxlen, ' ');
+    ++padlen;
+  }
+}
+
+static void dopr_outch (char *buffer, size_t *currlen, size_t maxlen, char c)
+{
+  if (*currlen < maxlen)
+    buffer[(*currlen)++] = c;
+}
+
+#ifndef HAVE_VSNPRINTF
+int vsnprintf (char *str, size_t count, const char *fmt, va_list args)
+{
+  str[0] = 0;
+  dopr(str, count, fmt, args);
+  return(strlen(str));
+}
+#endif /* !HAVE_VSNPRINTF */
+
+#ifndef HAVE_SNPRINTF
+/* VARARGS3 */
+#ifdef HAVE_STDARGS
+int snprintf (char *str,size_t count,const char *fmt,...)
+#else
+int snprintf (va_alist) va_dcl
+#endif
+{
+#ifndef HAVE_STDARGS
+  char *str;
+  size_t count;
+  char *fmt;
+#endif
+  VA_LOCAL_DECL;
+    
+  VA_START (fmt);
+  VA_SHIFT (str, char *);
+  VA_SHIFT (count, size_t );
+  VA_SHIFT (fmt, char *);
+  (void) vsnprintf(str, count, fmt, ap);
+  VA_END;
+  return(strlen(str));
+}
+#endif /* !HAVE_SNPRINTF */
+
+#ifdef TEST_SNPRINTF
+#ifndef LONG_STRING
+#define LONG_STRING 1024
+#endif
+int main (void)
+{
+  char buf1[LONG_STRING];
+  char buf2[LONG_STRING];
+  char *fp_fmt[] = {
+    "%-1.5f",
+    "%1.5f",
+    "%123.9f",
+    "%10.5f",
+    "% 10.5f",
+    "%+22.9f",
+    "%+4.9f",
+    "%01.3f",
+    "%4f",
+    "%3.1f",
+    "%3.2f",
+    "%.0f",
+    "%.1f",
+    NULL
+  };
+  double fp_nums[] = { -1.5, 134.21, 91340.2, 341.1234, 0203.9, 0.96, 0.996, 
+    0.9996, 1.996, 4.136, 0};
+  char *int_fmt[] = {
+    "%-1.5d",
+    "%1.5d",
+    "%123.9d",
+    "%5.5d",
+    "%10.5d",
+    "% 10.5d",
+    "%+22.33d",
+    "%01.3d",
+    "%4d",
+    NULL
+  };
+  long int_nums[] = { -1, 134, 91340, 341, 0203, 0};
+  int x, y;
+  int fail = 0;
+  int num = 0;
+
+  printf ("Testing snprintf format codes against system sprintf...\n");
+
+  for (x = 0; fp_fmt[x] != NULL ; x++)
+    for (y = 0; fp_nums[y] != 0 ; y++)
+    {
+      snprintf (buf1, sizeof (buf1), fp_fmt[x], fp_nums[y]);
+      sprintf (buf2, fp_fmt[x], fp_nums[y]);
+      if (strcmp (buf1, buf2))
+      {
+	printf("snprintf doesn't match Format: %s\n\tsnprintf = %s\n\tsprintf  = %s\n", 
+	    fp_fmt[x], buf1, buf2);
+	fail++;
+      }
+      num++;
+    }
+
+  for (x = 0; int_fmt[x] != NULL ; x++)
+    for (y = 0; int_nums[y] != 0 ; y++)
+    {
+      snprintf (buf1, sizeof (buf1), int_fmt[x], int_nums[y]);
+      sprintf (buf2, int_fmt[x], int_nums[y]);
+      if (strcmp (buf1, buf2))
+      {
+	printf("snprintf doesn't match Format: %s\n\tsnprintf = %s\n\tsprintf  = %s\n", 
+	    int_fmt[x], buf1, buf2);
+	fail++;
+      }
+      num++;
+    }
+  printf ("%d tests failed out of %d.\n", fail, num);
+}
+#endif /* SNPRINTF_TEST */
+
+#endif /* !HAVE_SNPRINTF */
diff -Naur ../mmmmm/m36b16/src/unix/sound.c mame-0.36b16/src/unix/sound.c
--- ../mmmmm/m36b16/src/unix/sound.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sound.c	2023-07-07 14:20:22.688001896 -0400
@@ -0,0 +1,223 @@
+/*
+ * X-Mame sound code
+ */
+
+#include "xmame.h"
+#include "sysdep/sysdep_dsp.h"
+#include "sysdep/sysdep_mixer.h"
+#include "sysdep/sound_stream.h"
+#include "driver.h"
+
+/* #define SOUND_DEBUG */
+
+static int sound_fake = 0;
+static int sound_samplerate = 22050;
+static float sound_bufsize = 3.0;
+static int sound_attenuation = -3;
+static char *sound_dsp_device = NULL;
+static char *sound_mixer_device = NULL;
+static struct sysdep_dsp_struct *sound_dsp = NULL;
+static struct sysdep_mixer_struct *sound_mixer = NULL;
+static int sound_samples_per_frame = 0;
+
+static int sound_set_options(struct rc_option *option, const char *arg,
+   int priority)
+{
+  if(sound_enabled)
+  {
+     options.samplerate = sound_samplerate;
+  }
+  else if(sound_fake)
+  {
+     options.samplerate = 8000;
+  }
+  else
+     options.samplerate = 0;
+  
+  option->priority = priority;
+  
+  return 0;
+}
+
+struct rc_option sound_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "Sound Related",	NULL,			rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "sound",		"snd",			rc_bool,	&sound_enabled,
+     "1",		0,			0,		sound_set_options,
+     "Enable/disable sound (if available)" },
+   { "samples",		"sam",			rc_bool,	&options.use_samples,
+     "1",		0,			0,		NULL,
+     "Use/don't use samples (if available)" },
+   { "fakesound",	"fsnd",			rc_set_int,	&sound_fake,
+     NULL,		1,			0,		sound_set_options,
+     "Generate sound even when sound is disabled, this is needed for some games which won't run without sound" },
+   { "samplefreq",	"sf",			rc_int,		&sound_samplerate,
+     "22050",		8000,			48000,		sound_set_options,
+     "Set the playback sample-frequency/rate" },
+   { "bufsize", 	"bs",			rc_float,	&sound_bufsize,
+     "3.0",		1.0,			30.0,		NULL,
+     "Number of frames of sound to buffer" },
+   { "volume",		"v",			rc_int,		&sound_attenuation,
+     "-3",		-32,			0,		NULL,
+     "Set volume to <int> db, (-32 (soft) - 0(loud) )" },
+   { "audiodevice",	"ad",			rc_string,	&sound_dsp_device,
+     NULL,		0,			0,		NULL,
+     "Use an alternative audiodevice" },
+   { "mixerdevice",	"md",			rc_string,	&sound_mixer_device,
+     NULL,		0,			0,		NULL,
+     "Use an alternative mixerdevice" },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+/* attenuation in dB */
+void osd_set_mastervolume (int attenuation)
+{
+   float f = attenuation;
+   
+   if(!sound_mixer)
+      return;
+      
+   f += 32.0;
+   f *= 100.0;
+   f /= 32.0;
+   f += 0.50; /* for rounding */
+#ifdef SOUND_DEBUG
+   fprintf(stderr, "sound.c: setting volume to %d (%d)\n",
+      attenuation, (int)f);
+#endif
+   
+   sysdep_mixer_set(sound_mixer, SYSDEP_MIXER_PCM1, f, f);
+}
+
+int osd_get_mastervolume (void)
+{
+   int left, right;
+   float f;
+   
+   if(!sound_mixer)
+      return -32;
+      
+   if(sysdep_mixer_get(sound_mixer, SYSDEP_MIXER_PCM1, &left, &right))
+      return -32;
+      
+   f = left;
+   f *= 32.0;
+   f /= 100.0;
+   f -= 32.5; /* 32 + 0.5 for rounding */
+#ifdef SOUND_DEBUG
+   fprintf(stderr, "sound.c: got volume %d (%d)\n", (int)f, left);
+#endif
+   return f;
+}
+
+void osd_sound_enable (int enable_it)
+{
+   if (sound_stream && enable_it)
+      sound_enabled = 1;
+   else
+      sound_enabled = 0;
+}
+
+/* handle ugly dos fm-stuff */
+void osd_opl_control (int chip, int reg)
+{
+}
+
+void osd_opl_write (int chip, int data)
+{
+}
+
+int osd_start_audio_stream(int stereo)
+{
+   int i;
+   int type = SYSDEP_DSP_16BIT | (stereo? SYSDEP_DSP_STEREO:SYSDEP_DSP_MONO);
+   
+   sound_stream = NULL;
+
+   /* create dsp */
+   if(sound_enabled)
+   {
+      if(!(sound_dsp = sysdep_dsp_create(NULL,
+         sound_dsp_device,
+         &options.samplerate,
+         &type,
+         sound_bufsize * (1 / Machine->drv->frames_per_second),
+         SYSDEP_DSP_EMULATE_TYPE | SYSDEP_DSP_O_NONBLOCK)))
+      {
+         osd_stop_audio_stream();
+         sound_enabled = 0;
+      }
+   }
+   
+   /* create sound_stream */
+   if(sound_enabled)
+   {
+      /* sysdep_dsp_open may have changed the samplerate */
+      Machine->sample_rate = options.samplerate;
+      
+      /* calculate samples_per_frame */
+      sound_samples_per_frame = Machine->sample_rate /
+         Machine->drv->frames_per_second;
+#ifdef SOUND_DEBUG
+      fprintf(stderr, "debug: sound: samples_per_frame = %d\n",
+         sound_samples_per_frame);
+#endif
+      if(!(sound_stream = sound_stream_create(sound_dsp, type,
+         sound_samples_per_frame, 3)))
+      {
+         osd_stop_audio_stream();
+         sound_enabled = 0;
+      }
+   }
+
+   /* if sound is not enabled, set the samplerate of the core to 0 */
+   if(!sound_enabled)
+   {
+      if(sound_fake)
+         Machine->sample_rate = options.samplerate = 8000;
+      else
+         Machine->sample_rate = options.samplerate = 0;
+      
+      /* calculate samples_per_frame */
+      sound_samples_per_frame = Machine->sample_rate /
+         Machine->drv->frames_per_second;
+      
+      return sound_samples_per_frame;
+   }
+   
+   /* create a mixer instance */
+   sound_mixer = sysdep_mixer_create(NULL, sound_mixer_device,
+      SYSDEP_MIXER_RESTORE_SETTINS_ON_EXIT);
+   
+   /* check if the user specified a volume, and ifso set it */
+   if(sound_mixer && rc_get_priority2(sound_opts, "volume"))
+      osd_set_mastervolume(sound_attenuation);
+   
+   return sound_samples_per_frame;
+}
+
+int osd_update_audio_stream(INT16 *buffer)
+{
+   /* sound enabled ? */
+   if (sound_enabled)
+      sound_stream_write(sound_stream, (unsigned char *)buffer,
+         sound_samples_per_frame);
+   
+   return sound_samples_per_frame;
+}
+
+void osd_stop_audio_stream(void)
+{
+   if(sound_stream)
+      sound_stream_destroy(sound_stream);
+   
+   if(sound_dsp)
+      sysdep_dsp_destroy(sound_dsp);
+   
+   if(sound_mixer)
+      sysdep_mixer_destroy(sound_mixer);
+}
diff -Naur ../mmmmm/m36b16/src/unix/sound-drivers.old/aix.c mame-0.36b16/src/unix/sound-drivers.old/aix.c
--- ../mmmmm/m36b16/src/unix/sound-drivers.old/aix.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sound-drivers.old/aix.c	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,136 @@
+/*
+* AIX dependent code
+*
+* Audio support by Chris Sharp <sharp@hursley.ibm.com>
+*
+*/
+
+#include "xmame.h"
+#include "sound.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/stropts.h>
+#include <UMS/UMSAudioDevice.h>
+#include <UMS/UMSBAUDDevice.h>
+
+static int channels;
+static UMSAudioDeviceMClass audio_device_class;
+static UMSAudioDevice_ReturnCode rc;
+static UMSBAUDDevice audio_device;
+
+static Environment *ev;
+static UMSAudioTypes_Buffer buffer;
+static long samples_per_sec, bytes_per_sample;
+static long read_cnt, transferred_cnt;
+static long samples_read;
+static long samples_written;
+static long out_rate;
+static long left_gain, right_gain;
+
+static long flags;
+static UMSAudioDeviceMClass_ErrorCode audio_device_class_error;
+static char* error_string;
+static char* audio_formats_alias;
+static char* audio_inputs_alias;
+static char* audio_outputs_alias;
+static char* obyte_order;
+
+int sysdep_audio_init(void)
+{
+	struct itimerval        timer_value;
+	int 			i;
+	sound_8bit   = TRUE;
+	sound_stereo = FALSE;
+	
+	if (play_sound)
+	{
+		int supported=FALSE;
+		channels = 1;
+                fprintf(stderr_file, "AIX sound device initialization...\n");
+                /* try to open audio device */
+        	ev = somGetGlobalEnvironment();
+        	audio_device = UMSBAUDDeviceNew();
+
+        	rc = UMSAudioDevice_open(audio_device,ev,"/dev/paud0","PLAY", UMSAudioDevice_BlockingIO);
+        	if (audio_device == NULL)
+        	{
+        	fprintf(stderr_file,"can't create audio device object\nError: %s\n",error_string);
+        	exit(1);
+        	}
+
+    		rc = UMSAudioDevice_set_sample_rate(audio_device, ev, options.samplerate, &out_rate);
+    		rc = UMSAudioDevice_set_bits_per_sample(audio_device, ev, AUDIO_SAMPLE_BITS);
+    		rc = UMSAudioDevice_set_number_of_channels(audio_device, ev, channels);
+    		rc = UMSAudioDevice_set_audio_format_type(audio_device, ev, "PCM");
+    		rc = UMSAudioDevice_set_number_format(audio_device, ev, "TWOS_COMPLEMENT");
+    		rc = UMSAudioDevice_set_volume(audio_device, ev, 100);
+    		rc = UMSAudioDevice_set_balance(audio_device, ev, 0);
+
+    		rc = UMSAudioDevice_set_time_format(audio_device,ev,UMSAudioTypes_Bytes);
+
+    		if (obyte_order) free(obyte_order);
+    		rc = UMSAudioDevice_set_byte_order(audio_device, ev, "LSB");
+    		left_gain = 100;
+    		right_gain = 100;
+
+    		rc = UMSAudioDevice_enable_output(audio_device, ev, "LINE_OUT", &left_gain, &right_gain);
+    		rc = UMSAudioDevice_initialize(audio_device, ev);
+#ifdef USE_TIMER
+    		buffer._maximum = AUDIO_BUFF_SIZE;
+#else
+		buffer._maximum = sysdep_get_audio_freespace();
+#endif
+    		buffer._buffer  = (char *) malloc(AUDIO_BUFF_SIZE);
+    		buffer._length = 0;
+
+		/*
+    		bytes_per_sample = (AUDIO_SAMPLE_BITS / 8) * channels;
+    		samples_per_sec  = bytes_per_sample * out_rate;
+    		buffer._buffer  = (char *) malloc(samples_per_sec);
+    		buffer._length = 0;
+    		buffer._maximum = samples_per_sec;
+    		bbuf_size = buffer._maximum;
+		*/
+    		rc = UMSAudioDevice_start(audio_device, ev);
+        }
+        return OSD_OK;
+}
+
+void sysdep_audio_close(void) {
+	if (play_sound)
+	{
+          rc = UMSAudioDevice_play_remaining_data(audio_device, ev, TRUE);
+          UMSAudioDevice_stop(audio_device, ev);
+          UMSAudioDevice_close(audio_device, ev);
+          _somFree(audio_device);
+          free(buffer._buffer);
+	}
+}	
+
+int sysdep_audio_play(unsigned char *buf, int bufsize)
+{
+/* 
+ * not sure about if audio buffers in aix are signed or unsigned char.
+ * please, tester needed...
+ */
+	int i;
+        buffer._length = bufsize;
+#if 1
+	memcpy(buffer._buffer,buf,bufsize); /* unsigned buffer */
+#else
+	for (i=0;i<bufsize;i++) buffer._buffer[i] = buf[i]^0x80; /* signed one */
+#endif
+        rc = UMSAudioDevice_write(audio_device, ev, &buffer, bufsize, &samples_written);
+        return rc;
+}
+
+long sysdep_audio_get_freespace() {
+	int i;
+	rc = UMSAudioDevice_write_buff_remain(audio_device,ev,&i);
+	i = i/96; /* ??? */
+	if (i<0) return (0);
+	/* fprintf(stderr_file,"Audio Buffer remains: %d\n blocks",i); */
+	return (long)(i);
+}
diff -Naur ../mmmmm/m36b16/src/unix/sound-drivers.old/irix.c mame-0.36b16/src/unix/sound-drivers.old/irix.c
--- ../mmmmm/m36b16/src/unix/sound-drivers.old/irix.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sound-drivers.old/irix.c	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,168 @@
+/*
+ * IRIX sound code
+ * 
+ * Addition of new al stuff by Tristram Scott 23/9/98
+ * 
+ */
+#include "xmame.h"
+#include "sound.h"
+#include <sys/stropts.h>
+#include <dmedia/audio.h>
+#include <errno.h>
+
+static ALport   devAudio;
+static ALconfig devAudioConfig;
+	
+int sysdep_audio_init(void) {
+#ifdef IRIX_HAVE_al
+	ALpv pvs[4];
+	int alIsBusy = 0;
+#else
+	long parambuf[4];
+#endif
+	sound_8bit	= TRUE;
+	sound_stereo	= FALSE;
+	
+	if (play_sound) {
+
+	    fprintf(stderr_file, "IRIX sound system initializing ...");
+
+#ifdef IRIX_HAVE_al
+	    /* first of all, look for anyone using driver */
+	    pvs[0].param = AL_MAX_PORTS;
+	    pvs[1].param = AL_UNUSED_PORTS;
+	    if( alGetParams( AL_SYSTEM,pvs,2) < 0) {
+		fprintf(stderr_file, "alGetParams failed: %s\n", alGetErrorString(oserror()));
+		exit(1);
+	    }
+	    fprintf(stderr_file, "Maximum audio port count is %d, current unused count is %d\n",
+	    	pvs[0].value.i,pvs[1].value.i);
+	    if( pvs[1].value.i < 1) {
+	        fprintf(stderr_file, "No unused audio ports, try using -nosound option\n");
+		exit(1); 
+	    }
+	    if( pvs[1].value.i < pvs[0].value.i) {
+	        fprintf(stderr_file, "Looks like someone else is using the audio device already.\n");
+		pvs[0].param = AL_RATE;
+		if( alGetParams( AL_DEFAULT_OUTPUT,pvs,1) < 0) {
+		    fprintf(stderr_file, "alGetParams failed: %s\n", alGetErrorString(oserror()));
+		    exit(1);
+		}
+		fprintf(stderr_file, "Current sample rate is %d, we will use that.\n", 
+		    pvs[0].value.i);
+		options.samplerate = pvs[0].value.i;
+		alIsBusy = 1;
+	    }
+
+	    /* try to get a configuration descriptor */
+	    if ( ( devAudioConfig=alNewConfig() ) == (ALconfig) NULL ){
+		fprintf(stderr_file, "Cannot get a config Descriptor.Exiting\n");
+		exit(1);
+	    }
+
+	    /* channel-specific parameters */	
+	    alSetChannels(devAudioConfig,AL_MONO); 		/* mono */
+	    alSetQueueSize(devAudioConfig,(int)AUDIO_BUFF_SIZE); /* buffer size */
+	    alSetSampFmt(devAudioConfig,AL_SAMPFMT_TWOSCOMP);	/* linear signed */
+	    alSetWidth(devAudioConfig,AL_SAMPLE_8);   	/* 8 bits */
+
+	    /* global audio-device parameters */
+
+	    pvs[0].param = AL_MASTER_CLOCK;
+	    pvs[0].value.i = AL_CRYSTAL_MCLK_TYPE;
+	    pvs[1].param = AL_RATE;
+	    pvs[1].value.i = options.samplerate; 
+ 
+	    if( !alIsBusy) {
+		if( alSetParams( AL_DEFAULT_OUTPUT,pvs,2) < 0) {
+		    fprintf(stderr_file, "Cannot Configure the sound system.Exiting...\n");
+		    exit(1);
+		}
+	    }
+
+	    /* try to get a Audio channel descriptor with pre-calculated params */
+	    if ( ( devAudio=alOpenPort("audio_fd","w",devAudioConfig) ) == (ALport) NULL ){
+		fprintf(stderr_file, "Cannot get an Audio Channel Descriptor.Exiting\n");
+		exit(1);
+	    }
+#else
+	    /* first of all, look for anyone using driver */
+	    parambuf[0] = AL_INPUT_COUNT;
+	    parambuf[2] = AL_OUTPUT_COUNT;
+	    ALgetparams( AL_DEFAULT_DEVICE,parambuf,4);
+	    if (parambuf[1] || parambuf[3]) {
+		fprintf(stderr_file, "Someone is already using the sound system.Exiting..\n");
+		exit(1);
+	    }
+
+	    /* try to get a configuration descriptor */
+	    if ( ( devAudioConfig=ALnewconfig() ) == (ALconfig) NULL ){
+		fprintf(stderr_file, "Cannot get a config Descriptor.Exiting\n");
+		exit(1);
+	    }
+
+	    /* channel-specific parameters */	
+	    ALsetchannels(devAudioConfig,AL_MONO); 		/* mono */
+	    ALsetqueuesize(devAudioConfig,(long)AUDIO_BUFF_SIZE); /* buffer size */
+	    ALsetsampfmt(devAudioConfig,AL_SAMPFMT_TWOSCOMP);	/* linear signed */
+	    ALsetwidth(devAudioConfig,AL_SAMPLE_8);   	/* 8 bits */
+
+	    /* global audio-device parameters */
+	    parambuf[0]	= AL_OUTPUT_RATE;	parambuf[1] =	options.samplerate;
+	    parambuf[2]	= AL_INPUT_RATE;	parambuf[3] =	options.samplerate;
+	    if( ALsetparams( AL_DEFAULT_DEVICE,parambuf,4) < 0) {
+		fprintf(stderr_file, "Cannot Configure the sound system.Exiting...\n");
+		exit(1);
+	    }
+
+	    /* try to get a Audio channel descriptor with pre-calculated params */
+	    if ( ( devAudio=ALopenport("audio_fd","w",devAudioConfig) ) == (ALport) NULL ){
+		fprintf(stderr_file, "Cannot get an Audio Channel Descriptor.Exiting\n");
+		exit(1);
+	    }
+
+#endif 
+	} /* if (play_sound) */
+	return OSD_OK;
+}
+
+void sysdep_audio_close(void) {
+#ifdef IRIX_HAVE_al
+	if(play_sound){
+		alClosePort(devAudio);
+		alFreeConfig(devAudioConfig);
+	}
+#else
+	if(play_sound){
+		ALcloseport(devAudio);
+		ALfreeconfig(devAudioConfig);
+	}
+#endif
+}	
+
+long sysdep_audio_get_freespace() {
+#ifdef IRIX_HAVE_al
+	return alGetFillable(devAudio);
+#else
+	return ALgetfillable(devAudio);
+#endif
+}
+
+/* routine to dump audio samples into audio device */
+int sysdep_audio_play(unsigned char *buff, int size) {
+#ifdef IRIX_HAVE_al
+	unsigned char *pt=buff;
+	/* try only to send samples that no cause blocking */
+        long maxsize=alGetFillable(devAudio);
+	/* new mixer code works in a unsigned char; driver is signed.... */
+	for (;pt<(buff+size);pt++) *pt ^=0x80;
+	return alWriteFrames(devAudio,(void *)buff,(size<=maxsize)?size:maxsize);	
+#else
+	unsigned char *pt=buff;
+	/* try only to send samples that no cause blocking */
+        long maxsize=ALgetfillable(devAudio);
+	/* new mixer code works in a unsigned char; driver is signed.... */
+	for (;pt<(buff+size);pt++) *pt ^=0x80;
+	return ALwritesamps(devAudio,(void *)buff,(size<=maxsize)?size:maxsize);	
+#endif
+}
diff -Naur ../mmmmm/m36b16/src/unix/sound-drivers.old/netbsd.c mame-0.36b16/src/unix/sound-drivers.old/netbsd.c
--- ../mmmmm/m36b16/src/unix/sound-drivers.old/netbsd.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sound-drivers.old/netbsd.c	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,235 @@
+/*
+ * NetBSD audio code by entropy@zippy.bernstein.com
+ * Audio code is based on the solaris driver, by jantonio@dit.upm.es
+ *
+ * fixed for 16bit & stereo sound by cpg@aladdin.de, 01-Aug-1999
+ * (tested on NetBSD/alpha and NetBSD/i386)
+ */
+
+#include "xmame.h"
+#include "sound.h"
+#include "devices.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/audioio.h>
+static int audio_fd;
+static char msg_buf[80];
+static audio_info_t a_info;
+static audio_device_t a_dev;
+static int card_stereo; /* card is a stereo card */
+static int setfragment(int,int *);
+static void setblocksize(int,struct audio_info *);
+
+int sysdep_audio_init(void)
+{
+  int log_2_frag, frag;
+  int corrected_frag_size;
+
+  if (play_sound)
+  {
+    fprintf(stderr_file, "NetBSD sound device initialization...\n");
+    /* try to open audio device */
+    if ((audio_fd = open("/dev/audio", O_WRONLY /* | O_NDELAY*/)) < 0)
+    {
+      perror("Cannot open audio device");
+      play_sound = FALSE;
+    }
+    else
+    {
+      /* empty buffers before change config */
+      ioctl(audio_fd, AUDIO_FLUSH, 0);        /* flush everything */
+      
+      /* identify audio device. */
+      if(ioctl(audio_fd, AUDIO_GETDEV, &a_dev) < 0)
+      {
+	perror("Cannot get sound device type");
+	close(audio_fd);
+	play_sound = FALSE;
+      }
+      else
+      {
+	fprintf(stderr_file, "Sound device is a %s %s version %s\n",
+	       a_dev.config, a_dev.name, a_dev.version);
+	    
+	/* initialize audio parameters. */ 
+	AUDIO_INITINFO(&a_info);
+        if (ioctl(audio_fd, AUDIO_GETINFO, &a_info) < 0) {
+          fprintf(stderr_file,"cannot query audio device parameters: %s\n",strerror(errno));
+        err_ret:
+          close(audio_fd);
+          play_sound = FALSE;
+          return OSD_OK;
+        }
+
+        if (a_info.play.channels == 1) {
+          a_info.play.channels = 2; /* try to set stereo */
+          if (ioctl(audio_fd, AUDIO_SETINFO, &a_info) < 0) {
+            a_info.play.channels = 1;
+          }
+        }
+
+        if (a_info.play.channels == 2) {
+          card_stereo = TRUE;
+        }
+        else {
+          card_stereo = FALSE;
+        }
+
+        if (!sound_8bit) { /* force from command line */
+          AUDIO_INITINFO(&a_info);
+          a_info.play.encoding = AUDIO_ENCODING_SLINEAR_LE;
+          a_info.play.precision = 16;
+          sound_8bit = FALSE;
+          if (ioctl(audio_fd, AUDIO_SETINFO, &a_info) < 0) {
+            sound_8bit = TRUE;
+          }
+        }
+        if (sound_8bit) {
+          a_info.play.encoding = (uint) AUDIO_ENCODING_ULINEAR;
+          a_info.play.precision = (uint) 8;
+        }
+
+	AUDIO_INITINFO(&a_info);
+        if (sound_8bit) {
+          a_info.play.encoding = (uint) AUDIO_ENCODING_ULINEAR;
+          a_info.play.precision = (uint) 8;
+        }
+        else {
+          a_info.play.encoding = (uint) AUDIO_ENCODING_SLINEAR_LE;
+          a_info.play.precision = (uint) 16;
+        }
+        if (sound_stereo && card_stereo) {
+          a_info.play.channels = 2;
+        }
+        else {
+          a_info.play.channels = 1;
+          sound_stereo = FALSE;
+        }
+	a_info.play.sample_rate = (uint) options.samplerate;
+	a_info.blocksize = options.samplerate / AUDIO_TIMER_FREQ;
+	a_info.mode = AUMODE_PLAY | AUMODE_PLAY_ALL;
+
+        if (ioctl(audio_fd, AUDIO_SETINFO, &a_info) < 0) {
+          fprintf(stderr_file,"cannot set audio device parameters: %s\n",strerror(errno));
+          goto err_ret;
+        }
+
+	corrected_frag_size = (options.samplerate * frag_size) / 22050;
+	if (!sound_8bit)  corrected_frag_size *= 2;
+	if (sound_stereo) corrected_frag_size *= 2;
+	for (log_2_frag=0; (1 << log_2_frag) < corrected_frag_size; log_2_frag++) {}
+	frag = log_2_frag + (num_frags << 16);
+
+        snprintf(msg_buf,sizeof(msg_buf)-1,"Setting fragsize to %d, numfrags to %d",
+                 1 << (frag&0x0000FFFF), frag >> 16);
+
+	if (setfragment(audio_fd,&frag) < 0) {
+          fprintf(stderr_file,"%s\nSNDCTL_DSP_SETFRAGMENT: %s\n",msg_buf,strerror(errno));
+          goto err_ret;
+	}
+
+#ifndef USE_TIMER
+        if (ioctl(audio_fd, AUDIO_GETINFO, &a_info) < 0) {
+          perror("AUDIO_GETINFO");
+          goto err_ret;
+        }
+        setblocksize(audio_fd, &a_info);
+        frag_size = a_info.blocksize;
+        num_frags = a_info.play.buffer_size / frag_size;
+
+        /* hmm, tests have shown that num_frags > 6 are no good,
+         * so we force them here into this limit...
+         */
+        if (num_frags > 6) {
+          fprintf(stderr_file,"Warning: frags reduced from %d to 6\n",num_frags);
+          num_frags = 6;
+
+          frag = log_2_frag + (num_frags << 16);
+          snprintf(msg_buf,sizeof(msg_buf)-1,"Setting fragsize to %d, numfrags to %d",
+                   1 << (frag&0x0000FFFF), frag >> 16);
+          setfragment(audio_fd,&frag);
+        }
+        /* fprintf(stderr_file,"Fragsize = %d, Numfrags = %d\n", frag_size, num_frags); */
+#endif
+        fprintf(stderr_file,"%s\n",msg_buf);
+	fprintf(stderr_file,"Audio device %s set to %dbit linear %s %dHz\n",
+                audiodevice,(sound_8bit)? 8:16,
+                (sound_stereo)? "stereo":"mono",
+                options.samplerate);
+      }
+    }
+  }
+  return OSD_OK;
+}
+
+static void setblocksize(int fd, struct audio_info *info) /* from netbsd's ossaudio lib */
+{
+  struct audio_info set;
+  int s;
+
+  if (info->blocksize & (info->blocksize-1)) {
+    for(s = 32; s < info->blocksize; s <<= 1)
+      ;
+    AUDIO_INITINFO(&set);
+    set.blocksize = s;
+    ioctl(fd, AUDIO_SETINFO, &set);
+    ioctl(fd, AUDIO_GETINFO, info);
+  }
+}
+
+
+static int setfragment(int fd,int *frag) /* from netbsd's ossaudio lib */
+{
+  audio_info_t tmpinfo;
+  unsigned int u;
+  int idat;
+  int retval;
+
+  AUDIO_INITINFO(&tmpinfo);
+  idat = *frag;
+  if ((idat & 0xffff) < 4 || (idat & 0xffff) > 17)
+    return (EINVAL);
+  tmpinfo.blocksize = 1 << (idat & 0xffff);
+  tmpinfo.hiwat = (idat >> 16) & 0x7fff;
+  if (tmpinfo.hiwat == 0) /* 0 means set to max */
+    tmpinfo.hiwat = 65536;
+  (void) ioctl(fd, AUDIO_SETINFO, &tmpinfo);
+  retval = ioctl(fd, AUDIO_GETINFO, &tmpinfo);
+  if (retval < 0)
+    return (retval);
+  u = tmpinfo.blocksize;
+  for(idat = 0; u > 1; idat++, u >>= 1)
+                        ;
+  idat |= (tmpinfo.hiwat & 0x7fff) << 16;
+  *frag = idat;
+  return(0);
+}
+
+void sysdep_audio_close(void)
+{
+  if (play_sound) close(audio_fd);
+}
+
+int sysdep_audio_play(unsigned char *buf, int bufsize)
+{
+  return write(audio_fd, buf, bufsize);
+}
+
+long sysdep_audio_get_freespace()
+{
+#ifndef USE_TIMER
+       audio_info_t info;
+       int i;
+       long l;
+        AUDIO_INITINFO(&info);
+        i = ioctl(audio_fd,AUDIO_GETINFO,&info);
+       if (i<0) { perror("AUDIO_GETINFO"); return -1; }
+       l = AUDIO_BUFF_SIZE - info.play.seek;
+       return (l < 0) ? 0 : l;
+#else 
+       return 0;
+#endif   
+}
diff -Naur ../mmmmm/m36b16/src/unix/sound-drivers.old/nosound.c mame-0.36b16/src/unix/sound-drivers.old/nosound.c
--- ../mmmmm/m36b16/src/unix/sound-drivers.old/nosound.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sound-drivers.old/nosound.c	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,22 @@
+#include "xmame.h"
+#include "sound.h"
+
+int sysdep_audio_init(void)
+{
+   play_sound = FALSE;
+   return OSD_OK;
+}
+
+void sysdep_audio_close(void)
+{
+}
+
+int sysdep_audio_play(unsigned char *buf, int bufsize)
+{
+   return 0;
+}
+
+long sysdep_audio_get_freespace(void)
+{
+   return 0;
+}
diff -Naur ../mmmmm/m36b16/src/unix/sound-drivers.old/solaris.c mame-0.36b16/src/unix/sound-drivers.old/solaris.c
--- ../mmmmm/m36b16/src/unix/sound-drivers.old/solaris.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sound-drivers.old/solaris.c	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,140 @@
+/*
+* Solaris dependent code
+*
+* Preliminary audio support by jantonio@dit.upm.es
+* no control on mono/stereo output channel and so  (yet)
+*
+*Major rewrite by Keith Hargrove condor@sun.com
+*       This is my first pass at this
+*       I use the EOF counter to keep track of how
+*       data has been played
+*
+*       The whole sound system needs to be rewiten as a thread
+*       This would give better performace and perfect sound
+*       This code is more of a band-aid
+*       I did not add support for the old ss1 and ss2 audio
+*       I don't think that a ss1 or ss2 can run MAME
+*       unless somone is using an ss2 with the turbo chip??
+*       if there is a need it can be added
+*
+* 990326 merged in Solaris x86 sound. Mathis Rosenhauer
+*
+*/
+
+#include <sys/stropts.h>
+#include <sys/audioio.h>
+#include "xmame.h"
+#include "sound.h"
+
+static int audioctl_fd;     /* audio control device for solaris     */
+static int audio_fd;        /* audio device for solaris             */
+static int written = 0;     /* number of bytes written              */
+static int sample_size;
+static int buffer_size;
+
+static audio_info_t	a_info;   /* info about audio settings            */
+static audio_device_t a_dev;  /* info about audio hardware            */
+
+int sysdep_audio_init(void)
+{
+	int error;
+
+	if (play_sound)
+	{
+		fprintf(stderr_file, "Solaris sound device initialization...\n");
+		/* try to open audio device */
+		if ( (audio_fd = open("/dev/audio", O_WRONLY | O_NDELAY)) < 0)
+		{
+			fprintf(stderr_file, "couldn't open audio device\n");
+			return OSD_NOT_OK;
+		}
+		/* try to open audioctl device */
+		if ( (audioctl_fd = open("/dev/audioctl", O_RDWR )) < 0)
+		{
+			fprintf(stderr_file, "couldn't open audioctl device\n");
+			close(audio_fd);
+			return OSD_NOT_OK;
+		}
+		sleep(2);
+		
+		/* empty buffers before change config */
+		ioctl(audio_fd, AUDIO_DRAIN, 0);    /* drain everything out */
+		ioctl(audio_fd, I_FLUSH, FLUSHRW);  /* flush everything     */
+		ioctl(audioctl_fd, I_FLUSH, FLUSHRW);   /* flush everything */
+		
+		/* identify audio device. if AMD chipset, bad, luck :-( */
+		if(ioctl(audio_fd, AUDIO_GETDEV, &a_dev) < 0)
+		{
+			fprintf(stderr_file, "Cannot get sound device type\n");
+			close(audio_fd);
+			close(audioctl_fd);
+			return OSD_NOT_OK;
+		}
+
+		fprintf(stderr_file, "Sound device is a %s %s version %s\n",a_dev.config,a_dev.name,a_dev.version);
+		
+		/* get audio parameters. */
+		if (ioctl(audioctl_fd, AUDIO_GETINFO, &a_info) < 0)
+		{
+			fprintf(stderr_file, "AUDIO_GETINFO failed!\nRun with -nosound\n");
+			close(audio_fd);
+			close(audioctl_fd);
+			return OSD_NOT_OK;
+		}
+
+		AUDIO_INITINFO(&a_info);
+		a_info.play.precision   = sound_8bit? 8: 16;
+		a_info.play.channels    = sound_stereo? 2: 1;
+		a_info.play.sample_rate = options.samplerate;
+		a_info.play.encoding    = AUDIO_ENCODING_LINEAR;
+		sample_size = a_info.play.precision / 8;
+		a_info.play.buffer_size = buffer_size = sample_size*frag_size*num_frags;
+
+		if ((error = ioctl(audio_fd,AUDIO_SETINFO,&a_info)) < 0 )
+		{
+			fprintf(stderr_file, "Error %d: audio device parameters not supported\n", error);
+			fprintf(stderr_file, "Enter 'man %s' to see parameters supported by your audio device.\n", (strchr(a_dev.name,','))+1);
+			sleep(2);
+			close(audio_fd);
+			close(audioctl_fd);
+			return OSD_NOT_OK;
+		}
+	}
+	return OSD_OK;
+}
+
+void sysdep_audio_close(void)
+{
+	if (play_sound)
+	{
+		close(audio_fd);
+		close(audioctl_fd);
+	}
+}
+
+int sysdep_audio_play(unsigned char *buf, int bufsize)
+{
+	static unsigned char tmp_buf[512];
+	static int  j = 0;
+    int i;
+
+	for (i = 0; i < bufsize; i++)
+	{
+		tmp_buf[j++] = buf[i];
+		if(j == 512 )
+		{
+			write(audio_fd, tmp_buf, j);
+			written += j;
+			/* write eof */
+			write(audio_fd, tmp_buf, 0);
+			j = 0;
+		}
+	}
+	return bufsize;
+}
+
+long sysdep_audio_get_freespace(void)
+{
+	ioctl (audioctl_fd, AUDIO_GETINFO, &a_info);
+	return ((buffer_size - (written - a_info.play.eof * 512))/sample_size);
+}
diff -Naur ../mmmmm/m36b16/src/unix/sound-drivers.old/soundkit.m mame-0.36b16/src/unix/sound-drivers.old/soundkit.m
--- ../mmmmm/m36b16/src/unix/sound-drivers.old/soundkit.m	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sound-drivers.old/soundkit.m	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,227 @@
+/*
+ * SoundKit support for xmame. This code is held here rather than in the
+ * OpenStep display file because it is not strictly OpenStep code and thus
+ * is only really applicable to NeXT/Apple operating systems. Not that I really
+ * expect anyone to try and run it elsewhere, but you should try and do these
+ * things right after all !
+ *
+ * -bat. 11/1/1999
+ */
+
+#import <SoundKit/SoundKit.h>
+#import <libc.h>
+#import "xmame.h"
+#import "sound.h"
+#import "osdepend.h"
+#import "driver.h"
+
+/*
+ * Variables used by the sound code.
+ */
+
+static NXSoundOut *sound = nil;
+static NXPlayStream *stream = nil;
+static NSLock *queue_lock = nil;
+static int queued = 0;
+
+/*
+ * This is the delegate object for the sound kit. It is used to keep
+ * track of the number of queued packets for the sound device by collecting
+ * the "complete" messages. Sometimes these get lost though for some reason.
+ */
+
+@interface Delegate : NSObject
+- soundStream:sender didCompleteBuffer:(int)tag;
+- soundStreamDidAbort:sender deviceReserved:(BOOL)flag;
+@end
+
+@implementation Delegate
+
+/*
+ * Decrement the number of queued buffers
+ */
+
+- soundStream:sender didCompleteBuffer:(int)tag
+{
+	[queue_lock lock];
+	queued--;
+	[queue_lock unlock];
+	return self;
+}
+
+/*
+ * Deal with an aborted sound stream
+ */
+
+- soundStreamDidAbort:sender deviceReserved:(BOOL)flag;
+{
+	fprintf(stderr,"Sound stream aborted: ");
+	if(flag!=YES) 
+		fprintf(stderr,"Device reserved\n");
+	else
+		fprintf(stderr,"%s\n",
+		[[NXSoundDevice textForError:[sender lastError]] cString]);
+	play_sound = FALSE;
+	return self;
+}
+
+@end
+
+/*
+ * Initialise the sound stream if we are playing sounds. We set up
+ * the soundkit objects and the delegate necessary to track what has
+ * been completed. A sound object may be placed on a remote host by the
+ * use of an environment variable.
+ */
+
+int
+sysdep_audio_init(void)
+{
+	NXSoundParameters *params = nil;
+	SNDSoundStruct *sptr = NULL;
+	char *host = getenv("SOUNDHOST");
+
+	if(!play_sound)
+		return OSD_OK;
+
+	/* make the queue lock */
+	queue_lock = [NSLock new];
+
+	/* create sound object (possibly remotely) */
+	if(host) {
+		sound = [[NXSoundOut alloc]
+			initOnHost:[NSString stringWithCString:host]];
+		if(sound==nil) {
+			fprintf(stderr,
+			   "could not initialise sound object on %s\n", host);
+	      		return OSD_NOT_OK;
+	    	} else
+	      		printf("Sending sound output to %s\n",host);
+	} else
+		sound=[[NXSoundOut alloc] init];
+
+	if(!sound) {
+		fprintf(stderr,"could not initialise sound object\n");
+		return OSD_NOT_OK;
+	}
+
+	/* create a parameters object */
+	printf("Sound is %d Hz %s %d bit samples\n", options.samplerate,
+		sound_stereo ? "stereo" : "mono", sound_8bit ? 8 : 16);
+	SNDAlloc(&sptr,0,SND_FORMAT_LINEAR_16,options.samplerate,
+		sound_stereo ? 2 : 1 ,0);
+	params = [[NXSoundParameters alloc] initFromSoundStruct:sptr];
+	if(!params) {
+		fprintf(stderr,"could not create sound parameters\n");
+		return OSD_NOT_OK;
+	}
+
+	/* create the stream object */
+	stream = [[NXPlayStream alloc]
+		initOnDevice:sound withParameters:params];
+	if(!stream) {
+		fprintf(stderr,"could not create play stream\n");
+		return OSD_NOT_OK;
+	}
+
+	/* set the delegate and activate the whole lot */
+	[stream setDelegate:[Delegate new]];
+	[stream activate];
+
+	return OSD_OK;
+}
+
+/*
+ * Wait for all sounds to finish and return.
+ */
+
+void
+sysdep_audio_close(void)
+{
+	int i;
+
+	/* return if we are not playing sounds at all */
+	if(!play_sound)
+		return;
+
+	/*
+	 * Wait for all the sounds to finish - but if
+	 * they aren't all done in 4 seconds then quit anyway.
+	 * (sometimes the delegate stops getting the messages!)
+	 */
+
+	for(i=0;i<4;i++) {
+		int left;
+		[queue_lock lock];
+		left = queued;
+		[queue_lock unlock];
+		if(left==0)
+			break;
+			sleep(1);
+	}
+	[stream release];
+	[sound release];
+	[queue_lock release];
+}
+
+/*
+ * o.k.- this is ugly, the idea of this function was to return the amount of
+ * freespace in the audio output buffer. however, all attempts on my part
+ * to do this "properly"  have either resulted in no sound of a horrible
+ * unlistenable mess. This is not great either, but it does work after
+ * a fashion. What I do is keep a count of the number of queued buffers.
+ * As more are queued I return less free space - thus MAME queues smaller
+ * buffers as the sound queue starts to fill up. Don't ask me for a rational
+ * behind this, and feel free to rip it out and try to do better...
+ */
+
+long
+sysdep_audio_get_freespace(void)
+{
+	int how_many;
+
+	if(!play_sound)	/* in case of abort */
+		return 0;
+
+	[queue_lock lock];
+	how_many = queued;
+	[queue_lock unlock];
+
+	if(how_many<8) return AUDIO_BUFF_SIZE;
+	if(how_many<18) return (AUDIO_BUFF_SIZE>>1);
+	if(how_many<30) return (AUDIO_BUFF_SIZE>>2);
+	return 0;
+}
+
+/*
+ * Here we play a block of audio.
+ */
+
+int
+sysdep_audio_play(unsigned char *buff, int size)
+{
+	short buf16[AUDIO_BUFF_SIZE];
+	short *pt16=buf16;
+	int samples = sound_8bit ? size : size / 2;
+	int bytes = sound_8bit ? size * 2 : size;
+
+	/* make sure we have native 16 bit block */
+	if(sound_8bit) {
+		int i;
+		unsigned char *pt8=buff;
+		for(i=0;i<size;i++)
+			*pt16++ = (*pt8++ - 0x80) * 256;
+		pt16=buf16;
+	} else
+		pt16 = (short*)buff;
+
+	/* Do the byte swapping and play the stream */
+	SNDSwapHostToSound(pt16, pt16, samples,
+		sound_stereo ? 2 : 1, SND_FORMAT_LINEAR_16);
+	[stream playBuffer:pt16 size:bytes tag:(int)1];
+
+	[queue_lock lock];
+	queued++;
+	[queue_lock unlock];
+	return size;
+}
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/begin_code.h mame-0.36b16/src/unix/sysdep/begin_code.h
--- ../mmmmm/m36b16/src/unix/sysdep/begin_code.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/begin_code.h	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,31 @@
+/* A few simple include macros
+
+   Copyright 1999,2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifndef BUF_SIZE
+#define BUF_SIZE 512
+#endif
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/blit_2.h mame-0.36b16/src/unix/sysdep/blit_2.h
--- ../mmmmm/m36b16/src/unix/sysdep/blit_2.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/blit_2.h	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,590 @@
+/* this routine is the generic blit routine used in many cases, trough a number
+   of defines it can be customised for specific cases.
+   Currently recognised defines:
+   DEST		ptr of type DEST_PIXEL to which should be blitted, if this is
+		not defined only PUT_IMAGE is called if defined.
+   DEST_PIXEL	type of the buffer to which is blitted, only needed if
+                DEST is defined.
+   DEST_WIDTH   Width of the destination buffer in pixels! Only needed if
+                DEST is defined.
+   SRC_PIXEL    type of the buffer from which is blitted, currently
+                8 bpp (unsigned char) and 16 bpp (unsigned short) are supported.
+   PUT_IMAGE    This function is called to update the parts of the screen
+		which need updating. This is only called if defined.
+   INDIRECT     This needs to be defined if DEST_PIXEL != unsigned char,
+                this is a ptr to a list of pixels/colormappings for the
+                colordepth conversion.
+   BLIT_16BPP_HACK This one speaks for itself, it's a speedup hack for 8bpp
+                to 16bpp blits.
+   PACK_BITS    Write to packed 24bit pixels, DEST_PIXEL must be 32bits and
+                INDIRECT must be on.
+   DOUBLEBUFFER First copy each line to a buffer called doublebuffer_buffer,
+                then do a memcpy to the real destination. This speeds up
+                scaling when writing directly to framebuffer since it
+                tremendously speeds up the reads done to copy one line to
+                the next.
+   
+   This routines use long copy's so everything should always be long aligned.
+*/
+
+#ifdef PACK_BITS
+/* scale destptr delta's by 3/4 since we're using 32 bits ptr's for a 24 bits
+   dest */
+#define DEST_SCALE(X) ((X * 3) / 4)
+#define DEST_PIXEL_SIZE 3
+#else
+#define DEST_SCALE(X) (X)
+#define DEST_PIXEL_SIZE sizeof(DEST_PIXEL)
+#endif
+
+switch (heightscale | (widthscale << 8) | (use_scanlines << 16))
+{
+/* 1x1 */
+
+#ifdef INDIRECT
+
+#ifdef BLIT_16BPP_HACK
+#define COPY_LINE2(SRC, END, DST) \
+   unsigned short *src = (unsigned short *)(SRC); \
+   unsigned short *end = (unsigned short *)(END); \
+   unsigned int   *dst = (unsigned int   *)(DST); \
+   for(;src<end;src+=4,dst+=4) \
+   { \
+      *(dst  ) = INDIRECT[*(src  )]; \
+      *(dst+1) = INDIRECT[*(src+1)]; \
+      *(dst+2) = INDIRECT[*(src+2)]; \
+      *(dst+3) = INDIRECT[*(src+3)]; \
+   }
+#elif defined PACK_BITS
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end;dst+=3,src+=4) \
+   { \
+      *(dst  ) = (INDIRECT[*(src  )]    ) | (INDIRECT[*(src+1)]<<24); \
+      *(dst+1) = (INDIRECT[*(src+1)]>> 8) | (INDIRECT[*(src+2)]<<16); \
+      *(dst+2) = (INDIRECT[*(src+2)]>>16) | (INDIRECT[*(src+3)]<< 8); \
+   }
+#else /* normal indirect */
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end;src+=8,dst+=8) \
+   { \
+      *(dst  ) = INDIRECT[*(src  )]; \
+      *(dst+1) = INDIRECT[*(src+1)]; \
+      *(dst+2) = INDIRECT[*(src+2)]; \
+      *(dst+3) = INDIRECT[*(src+3)]; \
+      *(dst+4) = INDIRECT[*(src+4)]; \
+      *(dst+5) = INDIRECT[*(src+5)]; \
+      *(dst+6) = INDIRECT[*(src+6)]; \
+      *(dst+7) = INDIRECT[*(src+7)]; \
+   }
+#endif /* dga_16bpp_hack / packed / normal indirect */
+
+#else  /* not indirect */
+#define COPY_LINE2(SRC, END, DST) \
+   memcpy(DST, SRC, ((END)-(SRC))*DEST_PIXEL_SIZE);
+#endif /* indirect */
+
+#define SCALE_X(X) (X)
+#define SCALE_Y(Y) (Y)
+
+/* 1x1 we don't do scanlines with 1x1 */
+case 0x00101:
+case 0x10101:
+#define COPY_LINE(SRC, END, DST) { COPY_LINE2(SRC, END, DST) }
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+#undef SCALE_Y
+
+/* 1x2 */
+
+#define SCALE_Y(Y)   ((Y) * 2)
+
+/* 1x2 no scanlines */
+case 0x00102:
+
+#ifdef DOUBLEBUFFER
+
+#ifdef INDIRECT
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                          doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE); \
+   memcpy((DST) + DEST_SCALE(DEST_WIDTH), doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DST)); \
+   COPY_LINE2(SRC, END, (DST) + DEST_SCALE(DEST_WIDTH)); \
+}
+#endif
+
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST) + DEST_SCALE(DEST_WIDTH), DST, ((END)-(SRC))*DEST_PIXEL_SIZE); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+/* 1x2 scanlines */
+case 0x10102:
+#define COPY_LINE(SRC, END, DST) { COPY_LINE2(SRC, END, DST) }
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+#undef COPY_LINE2
+#undef SCALE_X
+#undef SCALE_Y
+
+
+/* 2x2 */
+
+#ifdef INDIRECT
+
+#ifdef PACK_BITS
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=2, dst+=3) \
+   { \
+      *(dst  ) = (INDIRECT[*(src  )]    ) | (INDIRECT[*(src  )]<<24); \
+      *(dst+1) = (INDIRECT[*(src  )]>> 8) | (INDIRECT[*(src+1)]<<16); \
+      *(dst+2) = (INDIRECT[*(src+1)]>>16) | (INDIRECT[*(src+1)]<<8); \
+   }
+#else /* not pack bits */
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=16) \
+   { \
+      *(dst   ) = *(dst+ 1) = INDIRECT[*(src  )]; \
+      *(dst+ 2) = *(dst+ 3) = INDIRECT[*(src+1)]; \
+      *(dst+ 4) = *(dst+ 5) = INDIRECT[*(src+2)]; \
+      *(dst+ 6) = *(dst+ 7) = INDIRECT[*(src+3)]; \
+      *(dst+ 8) = *(dst+ 9) = INDIRECT[*(src+4)]; \
+      *(dst+10) = *(dst+11) = INDIRECT[*(src+5)]; \
+      *(dst+12) = *(dst+13) = INDIRECT[*(src+6)]; \
+      *(dst+14) = *(dst+15) = INDIRECT[*(src+7)]; \
+   }
+#endif /* pack bits */
+
+#else /* not indirect */
+
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=16) \
+   { \
+      *(dst   ) = *(dst+ 1) = *(src  ); \
+      *(dst+ 2) = *(dst+ 3) = *(src+1); \
+      *(dst+ 4) = *(dst+ 5) = *(src+2); \
+      *(dst+ 6) = *(dst+ 7) = *(src+3); \
+      *(dst+ 8) = *(dst+ 9) = *(src+4); \
+      *(dst+10) = *(dst+11) = *(src+5); \
+      *(dst+12) = *(dst+13) = *(src+6); \
+      *(dst+14) = *(dst+15) = *(src+7); \
+   }
+#endif
+
+#define SCALE_X(X)   ((X)<<1)
+#define SCALE_X_8(X) ((X)<<4)
+#define SCALE_Y(Y)   ((Y)<<1)
+#define SCALE_Y_8(Y) ((Y)<<4)
+
+/* 2x2 no scanlines */
+case 0x00202:
+
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                        doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*2); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH), doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*2); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH), DST, ((END)-(SRC))*DEST_PIXEL_SIZE*2); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+/* 2x2 scanlines */
+case 0x10202:
+
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                        doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*2); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) { COPY_LINE2(SRC, END, DST) }
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+#undef COPY_LINE2
+#undef SCALE_X
+#undef SCALE_X_8
+#undef SCALE_Y
+#undef SCALE_Y_8
+
+#ifndef PACK_BITS
+/* 3x3 */
+
+/* this macro is used to copy a line */
+#ifdef INDIRECT
+
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=24) \
+   { \
+      *(dst   ) = *(dst+ 1) = *(dst+ 2) = INDIRECT[*(src  )]; \
+      *(dst+ 3) = *(dst+ 4) = *(dst+ 5) = INDIRECT[*(src+1)]; \
+      *(dst+ 6) = *(dst+ 7) = *(dst+ 8) = INDIRECT[*(src+2)]; \
+      *(dst+ 9) = *(dst+10) = *(dst+11) = INDIRECT[*(src+3)]; \
+      *(dst+12) = *(dst+13) = *(dst+14) = INDIRECT[*(src+4)]; \
+      *(dst+15) = *(dst+16) = *(dst+17) = INDIRECT[*(src+5)]; \
+      *(dst+18) = *(dst+19) = *(dst+20) = INDIRECT[*(src+6)]; \
+      *(dst+21) = *(dst+22) = *(dst+23) = INDIRECT[*(src+7)]; \
+   }
+#else /* not indirect */
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=24) \
+   { \
+      *(dst   ) = *(dst+ 1) = *(dst+ 2) = *(src  ); \
+      *(dst+ 3) = *(dst+ 4) = *(dst+ 5) = *(src+1); \
+      *(dst+ 6) = *(dst+ 7) = *(dst+ 8) = *(src+2); \
+      *(dst+ 9) = *(dst+10) = *(dst+11) = *(src+3); \
+      *(dst+12) = *(dst+13) = *(dst+14) = *(src+4); \
+      *(dst+15) = *(dst+16) = *(dst+17) = *(src+5); \
+      *(dst+18) = *(dst+19) = *(dst+20) = *(src+6); \
+      *(dst+21) = *(dst+22) = *(dst+23) = *(src+7); \
+   }
+#endif
+
+#define SCALE_X(X)   ((X)*3)
+#define SCALE_X_8(X) ((X)*24)
+#define SCALE_Y(Y)   ((Y)*3)
+#define SCALE_Y_8(Y) ((Y)*24)
+
+/* 3x3 no scanlines */
+case 0x00303:
+
+/* should we use doublebuffering ? */
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                          doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   DST, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, DST, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+/* 3x3 scanlines */
+case 0x10303:
+
+/* should we use doublebuffering ? */
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                          doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   DST, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+#undef COPY_LINE2
+#undef SCALE_X
+#undef SCALE_X_8
+#undef SCALE_Y
+#undef SCALE_Y_8
+
+/* 4x4 */
+
+#ifdef INDIRECT
+
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=32) \
+   { \
+      *(dst   ) = *(dst+ 1) = *(dst+ 2) = *(dst+ 3) = INDIRECT[*(src  )]; \
+      *(dst+ 4) = *(dst+ 5) = *(dst+ 6) = *(dst+ 7) = INDIRECT[*(src+1)]; \
+      *(dst+ 8) = *(dst+ 9) = *(dst+10) = *(dst+11) = INDIRECT[*(src+2)]; \
+      *(dst+12) = *(dst+13) = *(dst+14) = *(dst+15) = INDIRECT[*(src+3)]; \
+      *(dst+16) = *(dst+17) = *(dst+18) = *(dst+19) = INDIRECT[*(src+4)]; \
+      *(dst+20) = *(dst+21) = *(dst+22) = *(dst+23) = INDIRECT[*(src+5)]; \
+      *(dst+24) = *(dst+25) = *(dst+26) = *(dst+27) = INDIRECT[*(src+6)]; \
+      *(dst+28) = *(dst+29) = *(dst+30) = *(dst+31) = INDIRECT[*(src+7)]; \
+   }
+#else /* not indirect */
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=32) \
+   { \
+      *(dst   ) = *(dst+ 1) = *(dst+ 2) = *(dst+ 3) = *(src  ); \
+      *(dst+ 4) = *(dst+ 5) = *(dst+ 6) = *(dst+ 7) = *(src+1); \
+      *(dst+ 8) = *(dst+ 9) = *(dst+10) = *(dst+11) = *(src+2); \
+      *(dst+12) = *(dst+13) = *(dst+14) = *(dst+15) = *(src+3); \
+      *(dst+16) = *(dst+17) = *(dst+18) = *(dst+19) = *(src+4); \
+      *(dst+20) = *(dst+21) = *(dst+22) = *(dst+23) = *(src+5); \
+      *(dst+24) = *(dst+25) = *(dst+26) = *(dst+27) = *(src+6); \
+      *(dst+28) = *(dst+29) = *(dst+30) = *(dst+31) = *(src+7); \
+   }
+#endif
+
+#define SCALE_X(X)   ((X)<<2)
+#define SCALE_X_8(X) ((X)<<5)
+#define SCALE_Y(Y)   ((Y)<<2)
+#define SCALE_Y_8(Y) ((Y)<<5)
+
+/* 4x4 no scanlines */
+case 0x00404:
+
+/* should we use doublebuffering ? */
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                          doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*3, doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   DST, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, DST, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*3, DST, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+/* 4x4 scanlines */
+case 0x10404:
+
+/* should we use doublebuffering ? */
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                          doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   DST, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, DST, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+#undef COPY_LINE2
+#undef SCALE_X
+#undef SCALE_X_8
+#undef SCALE_Y
+#undef SCALE_Y_8
+
+#endif /* #ifndef PACK_BITS */
+
+/* Generic scaling code here (arbitrary values) */
+
+/* This is what happens when you give an assembly-language programmer
+   a C compiler.  Thanks to td, of course.                             -JDL */
+
+default:
+
+#ifdef INDIRECT
+
+#ifdef PACK_BITS
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   DEST_PIXEL pixel; \
+   int i, step=0; \
+   for(;src<end;src++) \
+   { \
+      pixel = INDIRECT[*src]; \
+      for(i=0; i<widthscale; i++,step=(step+1)%4) \
+      { \
+         switch(step) \
+         { \
+            case 0: \
+               *(dst  )  = pixel; \
+               break; \
+            case 1: \
+               *(dst  ) |= pixel << 24; \
+               *(dst+1)  = pixel >> 8; \
+               break; \
+            case 2: \
+               *(dst+1) |= pixel << 16; \
+               *(dst+2)  = pixel >> 16; \
+               break; \
+            case 3: \
+               *(dst+2) |= pixel << 8; \
+               dst+=3; \
+               break; \
+         } \
+      } \
+   }
+#else
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   int i; \
+   for(;src<end;src++) \
+   { \
+      i=(widthscale+7)/8; \
+      dst+=widthscale%8; \
+      switch (widthscale%8) \
+      { \
+         case 0: do{  dst+=8; \
+                      *(dst-8) = INDIRECT[*(src)]; \
+         case 7:      *(dst-7) = INDIRECT[*(src)]; \
+         case 6:      *(dst-6) = INDIRECT[*(src)]; \
+         case 5:      *(dst-5) = INDIRECT[*(src)]; \
+         case 4:      *(dst-4) = INDIRECT[*(src)]; \
+         case 3:      *(dst-3) = INDIRECT[*(src)]; \
+         case 2:      *(dst-2) = INDIRECT[*(src)]; \
+         case 1:      *(dst-1) = INDIRECT[*(src)]; \
+                 } while(--i>0); \
+      } \
+   }
+#endif
+
+#else
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   int i; \
+   for(;src<end;src++) \
+   { \
+      i=(widthscale+7)/8; \
+      dst+=widthscale%8; \
+      switch (widthscale%8) \
+      { \
+         case 0: do{  dst+=8; \
+                      *(dst-8) = *(src); \
+         case 7:      *(dst-7) = *(src); \
+         case 6:      *(dst-6) = *(src); \
+         case 5:      *(dst-5) = *(src); \
+         case 4:      *(dst-4) = *(src); \
+         case 3:      *(dst-3) = *(src); \
+         case 2:      *(dst-2) = *(src); \
+         case 1:      *(dst-1) = *(src); \
+                 } while(--i>0); \
+      } \
+   }
+#endif
+
+#define SCALE_X(X)   ((X)*widthscale)
+#define SCALE_X_8(X) ((X)*widthscale*8)
+#define SCALE_Y(Y)   ((Y)*heightscale)
+#define SCALE_Y_8(Y) ((Y)*heightscale*8)
+
+/* should we use doublebuffering ? */
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   int max_i = heightscale-use_scanlines; \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   dst = (DST); \
+   if (max_i < 1) max_i = 1; \
+   for(i=0; i<max_i; i++, dst+=CORRECTED_DEST_WIDTH) \
+      memcpy(dst, doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*widthscale); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   dst = (DST) + (CORRECTED_DEST_WIDTH); \
+   for(i=1; i<(heightscale-use_scanlines); i++, dst+=CORRECTED_DEST_WIDTH) \
+      memcpy(dst, DST, ((END)-(SRC))*DEST_PIXEL_SIZE*widthscale); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+
+#undef COPY_LINE2
+#undef SCALE_X
+#undef SCALE_X_8
+#undef SCALE_Y
+#undef SCALE_Y_8
+
+break;      
+}
+
+#ifdef DEST_SCALE
+#undef DEST_SCALE
+#endif
+#undef DEST_PIXEL_SIZE
+#undef CORRECTED_DEST_WIDTH
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/blit_3.h mame-0.36b16/src/unix/sysdep/blit_3.h
--- ../mmmmm/m36b16/src/unix/sysdep/blit_3.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/blit_3.h	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,89 @@
+/* this file is used by blit.h don't use it directly ! */
+
+#define DEST_SCALE_X(X)   DEST_SCALE(SCALE_X(X))
+#define DEST_SCALE_X_8(X) DEST_SCALE(SCALE_X(X) * 8)
+#define DEST_SCALE_Y(Y)   DEST_SCALE(SCALE_Y(Y))
+#define DEST_SCALE_Y_8(Y) DEST_SCALE(SCALE_Y(Y) * 8)
+
+switch(use_dirty)
+{
+   case 0: /* non dirty */
+   {
+#ifdef DEST
+      int src_width = (((SRC_PIXEL *)bitmap->line[1]) -
+         ((SRC_PIXEL *)bitmap->line[0]));
+      SRC_PIXEL *line_src = (SRC_PIXEL *)bitmap->line[src_y] + src_x;
+      SRC_PIXEL *line_end = (SRC_PIXEL *)bitmap->line[src_y + src_height] +
+         src_x + src_width;
+      DEST_PIXEL *line_dest = (DEST_PIXEL *)(DEST);
+      
+      for (;line_src < line_end; line_dest+=DEST_SCALE_Y(DEST_WIDTH),
+         line_src+=src_width)
+         COPY_LINE(line_src, line_src+src_width, line_dest)
+#endif
+#ifdef PUT_IMAGE
+      PUT_IMAGE(src_x, src_y, dest_x, dest_y,
+         SCALE_X(src_width), SCALE_Y(src_height))
+#endif      
+      break;
+   }
+   case 1: /* normal dirty */
+      osd_dirty_merge();
+   case 2: /* vector */
+   {
+      int y, max_y = (src_y + src_width) >> 3;
+#ifdef DEST
+      DEST_PIXEL *line_dest = (DEST_PIXEL *)(DEST);
+      for (y = src_y>>3; y < max_y; y++, line_dest += DEST_SCALE_Y_8(DEST_WIDTH))
+#else
+      for (y = src_y>>3; y < max_y; y++)
+#endif      
+      {
+         if (bitmap->dirty_lines[y])
+         {
+            int x, max_x;
+            max_x = (src_x + src_width) >> 3;
+            for(x = src_x>>3; x < max_x; x++)
+            {
+               if (bitmap->dirty_blocks[y][x])
+               {
+                  int min_x;
+#ifdef DEST
+                  int max_x, h, max_h;
+                  DEST_PIXEL *block_dest = line_dest + DEST_SCALE_X_8(x);
+#endif
+                  min_x = x << 3;
+                  do {
+                     bitmap->dirty_blocks[y][x]=0;
+                     x++;
+                  } while (bitmap->dirty_blocks[y][x]);
+#ifdef DEST                  
+                  max_x = x << 3;
+                  h     = y << 3;
+                  max_h = h + 8;
+                  for (; h<max_h; h++, block_dest += DEST_SCALE_Y(DEST_WIDTH))
+                     COPY_LINE((SRC_PIXEL *)bitmap->line[h]+min_x,
+                        (SRC_PIXEL *)bitmap->line[h]+max_x, block_dest)
+#endif
+#ifdef PUT_IMAGE
+                  PUT_IMAGE(
+                     min_x,
+                     y << 3,
+                     dest_x + SCALE_X(min_x - src_x),
+                     dest_y + SCALE_Y((y << 3) - src_y),
+                     SCALE_X((x<<3) - min_x),
+                     SCALE_Y(8))
+#endif
+               }
+            }
+            bitmap->dirty_lines[y] = 0;
+         }
+      }
+      break;
+   }
+}
+
+#undef DEST_SCALE_X
+#undef DEST_SCALE_X_8
+#undef DEST_SCALE_Y
+#undef DEST_SCALE_Y_8
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/COPYING.LIB mame-0.36b16/src/unix/sysdep/COPYING.LIB
--- ../mmmmm/m36b16/src/unix/sysdep/COPYING.LIB	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/COPYING.LIB	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,482 @@
+		  GNU LIBRARY GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1991 Free Software Foundation, Inc.
+ 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the library GPL.  It is
+ numbered 2 because it goes with version 2 of the ordinary GPL.]
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Library General Public License, applies to some
+specially designated Free Software Foundation software, and to any
+other libraries whose authors decide to use it.  You can use it for
+your libraries, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if
+you distribute copies of the library, or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link a program with the library, you must provide
+complete object files to the recipients so that they can relink them
+with the library, after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  Our method of protecting your rights has two steps: (1) copyright
+the library, and (2) offer you this license which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  Also, for each distributor's protection, we want to make certain
+that everyone understands that there is no warranty for this free
+library.  If the library is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original
+version, so that any problems introduced by others will not reflect on
+the original authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that companies distributing free
+software will individually obtain patent licenses, thus in effect
+transforming the program into proprietary software.  To prevent this,
+we have made it clear that any patent must be licensed for everyone's
+free use or not licensed at all.
+
+  Most GNU software, including some libraries, is covered by the ordinary
+GNU General Public License, which was designed for utility programs.  This
+license, the GNU Library General Public License, applies to certain
+designated libraries.  This license is quite different from the ordinary
+one; be sure to read it in full, and don't assume that anything in it is
+the same as in the ordinary license.
+
+  The reason we have a separate public license for some libraries is that
+they blur the distinction we usually make between modifying or adding to a
+program and simply using it.  Linking a program with a library, without
+changing the library, is in some sense simply using the library, and is
+analogous to running a utility program or application program.  However, in
+a textual and legal sense, the linked executable is a combined work, a
+derivative of the original library, and the ordinary General Public License
+treats it as such.
+
+  Because of this blurred distinction, using the ordinary General
+Public License for libraries did not effectively promote software
+sharing, because most developers did not use the libraries.  We
+concluded that weaker conditions might promote sharing better.
+
+  However, unrestricted linking of non-free programs would deprive the
+users of those programs of all benefit from the free status of the
+libraries themselves.  This Library General Public License is intended to
+permit developers of non-free programs to use free libraries, while
+preserving your freedom as a user of such programs to change the free
+libraries that are incorporated in them.  (We have not seen how to achieve
+this as regards changes in header files, but we have achieved it as regards
+changes in the actual functions of the Library.)  The hope is that this
+will lead to faster development of free libraries.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, while the latter only
+works together with the library.
+
+  Note that it is possible for a library to be covered by the ordinary
+General Public License rather than by this special one.
+
+		  GNU LIBRARY GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library which
+contains a notice placed by the copyright holder or other authorized
+party saying it may be distributed under the terms of this Library
+General Public License (also called "this License").  Each licensee is
+addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+  
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also compile or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    c) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    d) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the source code distributed need not include anything that is normally
+distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Library General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+			    NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+     Appendix: How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms of the
+ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.  It is
+safest to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least the
+"copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+    MA 02111-1307, USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the library, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/dsp-drivers/alsa.c mame-0.36b16/src/unix/sysdep/dsp-drivers/alsa.c
--- ../mmmmm/m36b16/src/unix/sysdep/dsp-drivers/alsa.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/dsp-drivers/alsa.c	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,613 @@
+/*
+ * ALSA Sound Driver for xMAME
+ *
+ *  Copyright 2000 Luc Saillard <luc.saillard@alcove.fr>
+ *  Copyright 2001, 2002, 2003 Shyouzou Sugitani <shy@debian.or.jp>
+ *
+ *  This file and the acompanying files in this directory are free software;
+ *  you can redistribute them and/or modify them under the terms of the GNU
+ *  Library General Public License as published by the Free Software Foundation;
+ *  either version 2 of the License, or (at your option) any later version.
+ *
+ *  These files are distributed in the hope that they will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with these files; see the file COPYING.LIB.  If not,
+ *  write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ *  Boston, MA 02111-1307, USA.
+ *
+ * Changelog:
+ *   v 0.1 Thu, 10 Aug 2000 08:29:00 +0200
+ *     - initial release
+ *     - TODO: find the best sound card to play sound.
+ *   v 0.2 Wed, 13 Sep 2000    Shyouzou Sugitani <shy@debian.or.jp>
+ *     - change from block to stream mode.
+ *   v 0.3 Sat, 16 Sep 2000    Shyouzou Sugitani <shy@debian.or.jp>
+ *     - one important bug fix, performance improvements and code cleanup.
+ *   v 0.4 Sun, 15 Apr 2001    Shyouzou Sugitani <shy@debian.or.jp>
+ *     - minor cosmetic changes.
+ *     - suppression of bogus warnings about underruns.
+ *     - TODO: add support for ALSA 0.9 API.
+ *   v 0.5 Thu, 17 May 2001    Shyouzou Sugitani <shy@debian.or.jp>
+ *     - added preliminary support for ALSA 0.9 API.
+ *     - split of the 0.5 and 0.9 API stuff into separate files.
+ *   v 0.6 Sat, 19 May 2001    Shyouzou Sugitani <shy@debian.or.jp>
+ *     - update of the 0.9 API stuff.
+ *       added -list-alsa-pcm option.
+ *       improved write error handling.
+ *   v 0.7 Sat, 08 Sep 2001    Shyouzou Sugitani <shy@debian.or.jp>
+ *     - update of the 0.9 API stuff.
+ *       added -alsa-buffer option.
+ *       use SND_PCM_FORMAT_S16 instead of SND_PCM_FORMAT_S16_{LE,BE}.
+ *   v 0.8 Thu, 13 Sep 2001    Shyouzou Sugitani <shy@debian.or.jp>
+ *     - update of the 0.9 API stuff.
+ *       changed the -alsapcm(-pcm) to -alsa-pcm(-apcm).
+ *       changed the default value of the -alsa-pcm.
+ *   V 0.8a                    Stephen Anthony
+ *     - Fixed a problem in the ALSA 0.9 driver with setting the sample rate
+ *       on SB128 soundcards.
+ *   V 0.9 Mon, 13 Jan 2003    Shyouzou Sugitani <shy@debian.or.jp>
+ *     - removed the 0.5 API support.
+ *   V 1.0 Wed, 21 Jan 2004    Shyouzou Sugitani <shy@debian.or.jp>
+ *     - Update to the ALSA 1.0 API.
+ *
+ */
+
+#include "xmame.h"           /* xMAME common header */
+#include "devices.h"         /* xMAME device header */
+
+#ifdef SYSDEP_DSP_ALSA
+
+#define ALSA_PCM_NEW_HW_PARAMS_API 1
+
+#include <sys/ioctl.h>       /* System and I/O control */
+#include <alsa/asoundlib.h>  /* ALSA sound library header */
+//#include <sys/asoundlib.h>   /* ALSA sound library header */
+//#include "sysdep/sysdep_dsp.h"
+#include "sysdep/sysdep_dsp_priv.h"
+#include "sysdep/plugin_manager.h"
+
+/* our per instance private data struct */
+struct alsa_dsp_priv_data
+{
+  snd_pcm_t *pcm_handle;
+//  char *audiobuf;
+//  int frags;
+//  int frag;
+//  int buffer_size;
+};
+
+/* public methods prototypes (static but exported through the sysdep_dsp or
+   plugin struct) */
+static int alsa_dsp_init(void);
+static void *alsa_dsp_create(const void *flags);
+static void alsa_dsp_destroy(struct sysdep_dsp_struct *dsp);
+static int alsa_dsp_get_freespace(struct sysdep_dsp_struct *dsp);
+static int alsa_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+    int count);
+static int alsa_device_list(struct rc_option *option, const char *arg,
+    int priority);
+static int alsa_dsp_set_format(struct alsa_dsp_priv_data *priv, snd_pcm_format_t *format);
+static int alsa_pcm_list(struct rc_option *option, const char *arg,
+    int priority);
+static int alsa_dsp_set_params(struct alsa_dsp_priv_data *priv);
+
+/* public variables */
+
+static struct {
+        snd_pcm_format_t format;
+        unsigned int channels;
+        unsigned int rate;
+} pcm_params;
+
+static char *pcm_name = NULL;
+static snd_pcm_stream_t stream = SND_PCM_STREAM_PLAYBACK;
+static size_t bits_per_sample, bits_per_frame;
+static unsigned int buffer_time;
+static snd_pcm_uframes_t period_frames = 1;
+
+struct rc_option alsa_dsp_opts[] = {
+	/* name, shortname, type, dest, deflt, min, max, func, help */
+	{ "Alsa Sound System", NULL,     rc_seperator, NULL,
+	  NULL,    0,      0,    NULL,
+	  NULL },
+	{ "list-alsa-cards", NULL,	rc_use_function_no_arg, NULL,
+	  NULL,    0,      0,    alsa_device_list,
+	  "List available sound cards" },
+	{ "list-alsa-pcm", NULL,	rc_use_function_no_arg, NULL,
+	  NULL,    0,      0,    alsa_pcm_list,
+	  "List available pcm devices" },
+	{ "alsa-pcm",    "apcm",  rc_string,    &pcm_name,
+	  "default",     0,    0,    NULL,
+	  "Specify the PCM by name" },
+	{ "alsa-buffer", "abuf",  rc_int,       &buffer_time,
+	  "250000",      0,    0,    NULL,
+	  "Set the buffer size [micro sec] (default: 250000)" },
+	{ NULL,    NULL,     rc_end,   NULL,
+	  NULL,    0,      0,    NULL,
+	  NULL }
+};
+
+const struct plugin_struct sysdep_dsp_alsa = {
+   "alsa",
+   "sysdep_dsp",
+   "Alsa Sound System DSP plugin",
+   alsa_dsp_opts,
+   alsa_dsp_init,
+   NULL, /* no exit */
+   alsa_dsp_create,
+   4     /* high priority */
+};
+
+/* private variables */
+static int alsa_dsp_bytes_per_sample[4] = SYSDEP_DSP_BYTES_PER_SAMPLE;
+
+
+/* public methods (static but exported through the sysdep_dsp or plugin
+   struct) */
+
+/*
+ * Function name : alsa_dsp_init
+ *
+ * Description : Detect if a card is present on the machine
+ * Output :
+ *   a boolean
+ */
+static int alsa_dsp_init(void)
+{
+    int card = -1;
+
+	if (snd_card_next(&card) < 0 || card < 0) {
+		fprintf(stderr, "No cards detected.\n"
+			"ALSA sound disabled.\n");
+		return 1;
+	}
+	return 0;
+}
+
+/*
+ * Function name : alsa_dsp_create
+ *
+ * Description : Create an instance of dsp plugins
+ * Input :
+ *   flags: a ptr to struct sysdep_dsp_create_params
+ * Output :
+ *   a ptr to a struct sysdep_dsp_struct
+ */
+static void *alsa_dsp_create(const void *flags)
+{
+	int err;
+	struct alsa_dsp_priv_data *priv = NULL;
+	struct sysdep_dsp_struct *dsp = NULL;
+	const struct sysdep_dsp_create_params *params = flags;
+	snd_pcm_info_t *info;
+	int open_mode = 0;
+
+	/* allocate the dsp struct */
+	dsp = calloc(1, sizeof(struct sysdep_dsp_struct));
+	if (!dsp) {
+		fprintf(stderr,
+			"error malloc failed for struct sysdep_dsp_struct\n");
+		return NULL;
+	}
+
+	/* alloc private data */
+	priv = calloc(1, sizeof(struct alsa_dsp_priv_data));
+	if(!priv) {
+		fprintf(stderr,
+			"error malloc failed for struct alsa_dsp_priv_data\n");
+		alsa_dsp_destroy(dsp);
+		return NULL;
+	}
+
+	/* fill in the functions and some data */
+	memset(priv,0,sizeof(struct alsa_dsp_priv_data));
+	dsp->_priv = priv;
+	dsp->get_freespace = alsa_dsp_get_freespace;
+	dsp->write = alsa_dsp_write;
+	dsp->destroy = alsa_dsp_destroy;
+	dsp->hw_info.type = params->type;
+	dsp->hw_info.samplerate = params->samplerate;
+	dsp->hw_info.bufsize = 0;
+
+	open_mode |= SND_PCM_NONBLOCK;
+
+	pcm_params.format = (dsp->hw_info.type & SYSDEP_DSP_16BIT) ?
+		SND_PCM_FORMAT_S16 /* Signed 16 bit CPU endian */ :
+		SND_PCM_FORMAT_U8;
+
+	/* rate >= 2000 && rate <= 128000 */
+	pcm_params.rate = dsp->hw_info.samplerate;
+	pcm_params.channels = (dsp->hw_info.type & SYSDEP_DSP_STEREO) ? 2 : 1;
+
+	err = snd_pcm_open(&priv->pcm_handle, pcm_name, stream, open_mode);
+	if (err < 0) {
+		fprintf(stderr_file, "Alsa error: audio open error: %s\n",
+			snd_strerror(err));
+		return NULL;
+	}
+
+	snd_pcm_info_alloca(&info);
+	err = snd_pcm_info(priv->pcm_handle, info);
+	if (err < 0) {
+		fprintf(stderr_file, "Alsa error: info error: %s\n",
+			snd_strerror(err));
+		return NULL;
+	}
+	/* set non-blocking mode if selected */
+	if (params->flags & SYSDEP_DSP_O_NONBLOCK) {
+		err = snd_pcm_nonblock(priv->pcm_handle, 1);
+		if (err < 0) {
+			fprintf(stderr_file,
+				"Alsa error: nonblock setting error: %s\n",
+				snd_strerror(err));
+			return NULL;
+		}
+	}
+
+	fprintf(stderr_file, "info: set to %dbit linear %s %dHz\n",
+		(dsp->hw_info.type & SYSDEP_DSP_16BIT) ? 16 : 8,
+		(dsp->hw_info.type & SYSDEP_DSP_STEREO) ? "stereo" : "mono",
+		dsp->hw_info.samplerate);
+
+	if (alsa_dsp_set_params(priv) == 0)
+		return NULL;
+
+	return dsp;
+}
+
+/*
+ * Function name : alsa_dsp_destroy
+ *
+ * Description :
+ * Input :
+ * Output :
+ */
+static void alsa_dsp_destroy(struct sysdep_dsp_struct *dsp)
+{
+	struct alsa_dsp_priv_data *priv = dsp->_priv;
+
+	if (priv) {
+		if (priv->pcm_handle) {
+			snd_pcm_close(priv->pcm_handle);
+		}
+		free(priv);
+	}
+	free(dsp);
+}
+
+/*
+ * Function name : alsa_dsp_get_freespace
+ *
+ * Description :
+ * Input :
+ * Output :
+ */
+static int alsa_dsp_get_freespace(struct sysdep_dsp_struct *dsp)
+{
+	int err;
+	struct alsa_dsp_priv_data *priv = dsp->_priv;
+	snd_pcm_status_t *status;
+	snd_pcm_uframes_t frames;
+
+	snd_pcm_status_alloca(&status);
+	err = snd_pcm_status(priv->pcm_handle, status);
+	if (err < 0) {
+		fprintf(stderr_file, "Alsa error: status error: %s\n",
+			snd_strerror(err));
+		return -1;
+	}
+	frames = snd_pcm_status_get_avail(status);
+	if (frames < 0)
+		return -1;
+	else
+		return frames * bits_per_frame / 8
+			/ alsa_dsp_bytes_per_sample[dsp->hw_info.type];
+}
+
+/*
+ * Function name : alsa_dsp_write
+ *
+ * Description :
+ * Input :
+ * Output :
+ */
+static int alsa_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+    int count)
+{
+	int data_size, result;
+	struct alsa_dsp_priv_data *priv = dsp->_priv;
+
+	data_size = count * alsa_dsp_bytes_per_sample[dsp->hw_info.type]
+		* 8 / bits_per_frame;
+
+	result = snd_pcm_writei(priv->pcm_handle, data, data_size);
+	if (result == -EAGAIN) {
+		return 0;
+	} else if (result == -EPIPE) {
+		int err;
+		snd_pcm_status_t *status;
+
+		snd_pcm_status_alloca(&status);
+		err = snd_pcm_status(priv->pcm_handle, status);
+		if (err < 0) {
+			fprintf(stderr_file,
+				"Alsa error: status error: %s\n",
+				snd_strerror(err));
+			return -1;
+		}
+		if (snd_pcm_status_get_state(status) == SND_PCM_STATE_XRUN) {
+			err = snd_pcm_prepare(priv->pcm_handle);
+			if (err < 0) {
+				fprintf(stderr_file,
+					"Alsa error: prepare error: %s\n",
+					snd_strerror(err));
+				return -1;
+			}
+			/* ok, data should be accepted again */
+			return 0;
+		}
+		fprintf(stderr_file, "Alsa error: write error: %s\n",
+			snd_strerror(result));
+		return -1;
+	} else if (result < 0) {
+		fprintf(stderr_file, "Alsa error: write error: %s\n",
+			snd_strerror(result));
+		return -1;
+	}
+
+	return result * bits_per_frame / 8
+		/ alsa_dsp_bytes_per_sample[dsp->hw_info.type];
+}
+
+/*
+ * Function name : alsa_device_list
+ *
+ * Description :
+ * Input :
+ * Output :
+ */
+static int alsa_device_list(struct rc_option *option, const char *arg,
+    int priority)
+{
+	snd_ctl_t *handle;
+	int card, err, dev;
+	snd_ctl_card_info_t *info;
+	snd_pcm_info_t *pcminfo;
+	snd_ctl_card_info_alloca(&info);
+	snd_pcm_info_alloca(&pcminfo);
+
+	card = -1;
+	if (snd_card_next(&card) < 0 || card < 0) {
+		printf("Alsa: no soundcards found...\n");
+		return -1;
+	}
+	fprintf(stdout, "Alsa cards:\n");
+	while (card >= 0) {
+		char name[32];
+		sprintf(name, "hw:%d", card);
+		err = snd_ctl_open(&handle, name, 0);
+		if (err < 0) {
+			fprintf(stderr, "Alsa error: control open (%i): %s\n",
+				card, snd_strerror(err));
+			continue;
+		}
+		err = snd_ctl_card_info(handle, info);
+		if (err < 0) {
+			fprintf(stderr,
+				"Alsa error: control hardware info (%i): %s\n",
+				card, snd_strerror(err));
+			snd_ctl_close(handle);
+			continue;
+		}
+		dev = -1;
+		while (1) {
+			int idx;
+			unsigned int count;
+
+			if (snd_ctl_pcm_next_device(handle, &dev) < 0)
+				;
+			if (dev < 0)
+				break;
+			snd_pcm_info_set_device(pcminfo, dev);
+			snd_pcm_info_set_subdevice(pcminfo, 0);
+			snd_pcm_info_set_stream(pcminfo, stream);
+			err = snd_ctl_pcm_info(handle, pcminfo);
+			if (err < 0) {
+				if (err != -ENOENT)
+					fprintf(stderr,
+						"Alsa error: control digital audio info (%i): %s\n",
+						card, snd_strerror(err));
+				continue;
+			}
+			fprintf(stderr,
+				"card %i: %s [%s], device %i: %s [%s]\n",
+				card,
+				snd_ctl_card_info_get_id(info),
+				snd_ctl_card_info_get_name(info),
+				dev,
+				snd_pcm_info_get_id(pcminfo),
+				snd_pcm_info_get_name(pcminfo));
+			count = snd_pcm_info_get_subdevices_count(pcminfo);
+			fprintf(stderr, "  Subdevices: %i/%i\n",
+				snd_pcm_info_get_subdevices_avail(pcminfo),
+				count);
+			for (idx = 0; idx < count; idx++) {
+				snd_pcm_info_set_subdevice(pcminfo, idx);
+				err = snd_ctl_pcm_info(handle, pcminfo);
+				if (err < 0) {
+					fprintf(stderr,
+						"Alsa error: control digital audio playback info (%i): %s",
+						card, snd_strerror(err));
+				} else {
+					fprintf(stderr,
+						"  Subdevice #%i: %s\n",
+						idx, snd_pcm_info_get_subdevice_name(pcminfo));
+				}
+			}
+		}
+		snd_ctl_close(handle);
+		if (snd_card_next(&card) < 0) {
+			break;
+		}
+	}
+	return -1;
+}
+
+/*
+ * Function name : alsa_pcm_list
+ *
+ * Description :
+ * Input :
+ * Output :
+ */
+static int alsa_pcm_list(struct rc_option *option, const char *arg,
+			 int priority)
+{
+        snd_config_t *conf;
+        snd_output_t *out;
+
+        int err;
+
+	err = snd_config_update();
+        if (err < 0) {
+		fprintf(stderr, "Alsa error: snd_config_update: %s\n",
+			snd_strerror(err));
+                return -1;
+        }
+        snd_output_stdio_attach(&out, stderr, 0);
+        err = snd_config_search(snd_config, "pcm", &conf);
+        if (err < 0)
+                return -1;
+        fprintf(stderr, "ALSA PCM devices:\n");
+        snd_config_save(conf, out);
+        snd_output_close(out);
+
+	return -1;
+}
+
+/*
+ * Function name : alsa_dsp_set_params
+ *
+ * Description :
+ * Input :
+ *   priv: a ptr to struct alsa_dsp_priv_data
+ * Output :
+ *  priv is modified with the current parameters.
+ *  a boolean if the card accept the value.
+ *
+ */
+static int alsa_dsp_set_params(struct alsa_dsp_priv_data *priv)
+{
+	snd_pcm_hw_params_t *hw_params;
+	snd_pcm_sw_params_t *sw_params;
+
+	snd_pcm_uframes_t buffer_size;
+	snd_pcm_uframes_t chunk_size;
+	int err;
+	unsigned int rate;
+
+	snd_pcm_hw_params_alloca(&hw_params);
+	snd_pcm_sw_params_alloca(&sw_params);
+	err = snd_pcm_hw_params_any(priv->pcm_handle, hw_params);
+	if (err < 0) {
+		fprintf(stderr_file,
+			"Alsa error: no configurations available\n");
+		return 0;
+	}
+
+	if (snd_pcm_hw_params_set_access(priv->pcm_handle, hw_params,
+					 SND_PCM_ACCESS_RW_INTERLEAVED) < 0) {
+		fprintf(stderr_file,
+			"Alsa error: interleaved access mode non available\n");
+		return 0;
+	}
+
+	err = snd_pcm_hw_params_set_format(priv->pcm_handle, hw_params, pcm_params.format);
+	if (err < 0) {
+		fprintf(stderr_file,
+			"Alsa error: requested format %s isn't supported with hardware\n",
+			snd_pcm_format_name(pcm_params.format));
+		return 0;
+	}
+
+	err = snd_pcm_hw_params_set_channels(priv->pcm_handle, hw_params, pcm_params.channels);
+	if (err < 0) {
+		fprintf(stderr_file,
+			"Alsa error: channels count non available\n");
+		return 0;
+	}
+
+	rate = pcm_params.rate;
+	if (snd_pcm_hw_params_set_rate_near(priv->pcm_handle, hw_params, &pcm_params.rate, 0) < 0) {
+		unsigned int min, max;
+
+		snd_pcm_hw_params_get_rate_min(hw_params, &min, 0);
+		snd_pcm_hw_params_get_rate_max(hw_params, &max, 0);
+		fprintf(stderr_file,
+			"Alsa error: unsupported rate %uHz (valid range is %uHz-%iHz)\n",
+			rate, min, max);
+		return 0;
+	}
+
+	snd_pcm_hw_params_set_buffer_time_near(priv->pcm_handle, hw_params, &buffer_time, 0);
+	snd_pcm_hw_params_set_period_size_near(priv->pcm_handle, hw_params, &period_frames, 0);
+
+	err = snd_pcm_hw_params(priv->pcm_handle, hw_params);
+	if (err < 0) {
+		fprintf(stderr_file,
+			"Alsa error: Unable to install hw params\n");
+		return 0;
+	}
+
+	snd_pcm_hw_params_get_period_size(hw_params, &chunk_size, 0);
+	snd_pcm_hw_params_get_buffer_size(hw_params, &buffer_size);
+	if (chunk_size == buffer_size) {
+		fprintf(stderr_file,
+			"Alsa error: cannot use period equal to buffer size (%lu == %lu)\n",
+			chunk_size, buffer_size);
+		return 0;
+	}
+
+	snd_pcm_sw_params_current(priv->pcm_handle, sw_params);
+
+	snd_pcm_sw_params_set_sleep_min(priv->pcm_handle, sw_params, 0);
+	snd_pcm_sw_params_set_xfer_align(priv->pcm_handle, sw_params, 1);
+	snd_pcm_sw_params_set_avail_min(priv->pcm_handle, sw_params, 1);
+
+	snd_pcm_sw_params_set_start_threshold(priv->pcm_handle, sw_params, 1);
+
+	snd_pcm_sw_params_set_stop_threshold(priv->pcm_handle, sw_params, buffer_size);
+
+	if (snd_pcm_sw_params(priv->pcm_handle, sw_params) < 0) {
+		fprintf(stderr_file, "Alsa error: unable to install sw params\n");
+		return 0;
+	}
+
+#if 0 /* DEBUG */
+	{
+		snd_output_t *log;
+		snd_output_stdio_attach(&log, stderr_file, 0);
+		snd_pcm_dump(priv->pcm_handle, log);
+		snd_output_close(log);
+	}
+#endif
+
+	bits_per_sample = snd_pcm_format_physical_width(pcm_params.format);
+	bits_per_frame = bits_per_sample * pcm_params.channels;
+
+	err = snd_pcm_prepare(priv->pcm_handle);
+	if (err < 0) {
+		fprintf(stderr_file,
+			"Alsa error: unable to prepare audio: %s\n",
+			snd_strerror(err));
+		return 0;
+	}
+
+	return 1;
+}
+
+#endif /* SYSDEP_DSP_ALSA */
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/dsp-drivers/esound.c mame-0.36b16/src/unix/sysdep/dsp-drivers/esound.c
--- ../mmmmm/m36b16/src/unix/sysdep/dsp-drivers/esound.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/dsp-drivers/esound.c	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,185 @@
+/* Sysdep esound sound dsp driver
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, January 2000
+-initial release, based on the driver submitted by riq <riq@ciudad.com.ar>,
+ amongst others (Hans de Goede)
+*/
+#ifdef SYSDEP_DSP_ESOUND
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <esd.h>
+#include "sysdep/sysdep_dsp.h"
+#include "sysdep/sysdep_dsp_priv.h"
+#include "sysdep/plugin_manager.h"
+
+/* #define ESOUND_DEBUG */
+
+/* our per instance private data struct */
+struct esound_dsp_priv_data {
+   int fd;
+};
+
+/* public methods prototypes (static but exported through the sysdep_dsp or
+   plugin struct) */
+static void *esound_dsp_create(const void *flags);
+static void esound_dsp_destroy(struct sysdep_dsp_struct *dsp);
+static int esound_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+   int count);
+
+/* public variables */
+const struct plugin_struct sysdep_dsp_esound = {
+   "esound",
+   "sysdep_dsp",
+   "Esound DSP plugin",
+   NULL, /* no options */
+   NULL, /* no init */
+   NULL, /* no exit */
+   esound_dsp_create,
+   2     /* lower priority as direct device access */
+};
+
+/* private variables */
+static int esound_dsp_bytes_per_sample[4] = SYSDEP_DSP_BYTES_PER_SAMPLE;
+
+/* public methods (static but exported through the sysdep_dsp or plugin
+   struct) */
+static void *esound_dsp_create(const void *flags)
+{
+#ifdef ESOUND_DEBUG
+   int server_fd;
+#endif
+   struct esound_dsp_priv_data *priv = NULL;
+   struct sysdep_dsp_struct *dsp = NULL;
+   const struct sysdep_dsp_create_params *params = flags;
+   esd_format_t esd_format;
+   esd_server_info_t *info =NULL;
+   
+   /* allocate the dsp struct */
+   if (!(dsp = calloc(1, sizeof(struct sysdep_dsp_struct))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct sysdep_dsp_struct\n");
+      return NULL;
+   }
+   
+   /* alloc private data */
+   if(!(priv = calloc(1, sizeof(struct esound_dsp_priv_data))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct esound_dsp_priv_data\n");
+      esound_dsp_destroy(dsp);
+      return NULL;
+   }
+   
+   /* fill in the functions and some data */
+   priv->fd = -1;
+   dsp->_priv = priv;
+   dsp->write = esound_dsp_write;
+   dsp->destroy = esound_dsp_destroy;
+   dsp->hw_info.type = params->type;
+   dsp->hw_info.samplerate = params->samplerate;
+   
+   /* open the sound device */
+   esd_format = ESD_STREAM | ESD_PLAY ;
+   esd_format |= (dsp->hw_info.type & SYSDEP_DSP_16BIT)?
+      ESD_BITS16 : ESD_BITS8;
+   esd_format |= (dsp->hw_info.type & SYSDEP_DSP_STEREO)?
+      ESD_STEREO : ESD_MONO;
+   
+#ifdef ESOUND_DEBUG
+   if((server_fd = esd_open_sound(params->device)) < 0)
+   {
+      fprintf(stderr, "error: esound server open failed\n");
+      esound_dsp_destroy(dsp);
+      return NULL;
+   }
+   
+   if(!(info = esd_get_server_info(server_fd)))
+   {
+      fprintf(stderr, "error: esound get server info failed\n");
+      esd_close(server_fd);
+      esound_dsp_destroy(dsp);
+      return NULL;
+   }
+   
+   esd_print_server_info(info);
+   esd_free_server_info(info);
+   esd_close(server_fd);
+#endif
+   
+   if((priv->fd = esd_play_stream(esd_format, dsp->hw_info.samplerate,
+      params->device, "mame esound")) < 0)
+   {
+      fprintf(stderr, "error: esound open stream failed\n");
+      esound_dsp_destroy(dsp);
+      return NULL;
+   }
+
+   /* set non-blocking mode if selected */
+   if(params->flags & SYSDEP_DSP_O_NONBLOCK)
+   {
+      long flags = fcntl(priv->fd, F_GETFL);
+      if((flags < 0) || (fcntl(priv->fd, F_SETFL, flags|O_NONBLOCK) < 0))
+      {
+         perror("Esound-driver, error: fnctl");
+         esound_dsp_destroy(dsp);
+         return NULL;
+      }
+   }
+   
+   return dsp;
+}
+
+static void esound_dsp_destroy(struct sysdep_dsp_struct *dsp)
+{
+   struct esound_dsp_priv_data *priv = dsp->_priv;
+   
+   if(priv)
+   {
+      if(priv->fd >= 0)
+         close(priv->fd);
+      
+      free(priv);
+   }
+   free(dsp);
+}
+   
+static int esound_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+   int count)
+{
+   int result;
+   struct esound_dsp_priv_data *priv = dsp->_priv;
+
+   result = write(priv->fd, data, count *
+      esound_dsp_bytes_per_sample[dsp->hw_info.type]);
+      
+   if (result < 0)
+   {
+      fprintf(stderr, "error: esound write to stream failed\n");
+      return -1;
+   }
+      
+   return result / esound_dsp_bytes_per_sample[dsp->hw_info.type];
+}
+
+#endif /* ifdef SYSDEP_DSP_ESOUND */
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/dsp-drivers/netbsd.c mame-0.36b16/src/unix/sysdep/dsp-drivers/netbsd.c
--- ../mmmmm/m36b16/src/unix/sysdep/dsp-drivers/netbsd.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/dsp-drivers/netbsd.c	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,284 @@
+/* Sysdep NetBSD sound dsp driver
+
+   Copyright 2000 Hans de Goede, Krister Walfridsson
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, February 2000
+-initial release, based on the xmame OSS dsp driver version 0.1, and using
+ some inspiration from the old xmame NetBSD driver. (Krister Walfridsson)
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/audioio.h>
+#include "sysdep/sysdep_dsp.h"
+#include "sysdep/sysdep_dsp_priv.h"
+#include "sysdep/plugin_manager.h"
+
+/* Our per instance private data struct. */
+struct netbsd_dsp_priv_data {
+  int fd;
+};
+
+/* Public methods prototypes (static but exported through the sysdep_dsp or
+   plugin struct.) */
+static void *netbsd_dsp_create(const void *flags);
+static void netbsd_dsp_destroy(struct sysdep_dsp_struct *dsp);
+static int netbsd_dsp_get_freespace(struct sysdep_dsp_struct *dsp);
+static int netbsd_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+			    int count);
+
+/* Public variables. */
+const struct plugin_struct sysdep_dsp_netbsd = {
+  "netbsd",
+  "sysdep_dsp",
+  "NetBSD DSP plugin",
+  NULL, /* no options */
+  NULL, /* no init */
+  NULL, /* no exit */
+  netbsd_dsp_create,
+  3     /* high priority */
+};
+
+/* Private variables.  */
+static int netbsd_dsp_bytes_per_sample[4] = SYSDEP_DSP_BYTES_PER_SAMPLE;
+
+/* Public methods (static but exported through the sysdep_dsp or plugin
+   struct.) */
+static void *netbsd_dsp_create(const void *flags)
+{
+  int block_size, blocks;
+  audio_info_t a_info;
+  int desired_encoding, desired_precision;
+  struct netbsd_dsp_priv_data *priv = NULL;
+  struct sysdep_dsp_struct *dsp = NULL;
+  const struct sysdep_dsp_create_params *params = flags;
+  const char *device = params->device;
+
+  /* Allocate the dsp struct. */
+  if (!(dsp = calloc(1, sizeof(struct sysdep_dsp_struct))))
+    {
+      fprintf(stderr,
+	      "error malloc failed for struct sysdep_dsp_struct\n");
+      return NULL;
+    }
+
+  /* Alloc private data. */
+  if (!(priv = calloc(1, sizeof(struct netbsd_dsp_priv_data))))
+    {
+      fprintf(stderr,
+	      "error malloc failed for struct netbsd_dsp_priv_data\n");
+      netbsd_dsp_destroy(dsp);
+      return NULL;
+    }
+
+  /* Fill in the functions and some data. */
+  priv->fd = -1;
+  dsp->_priv = priv;
+  dsp->get_freespace = netbsd_dsp_get_freespace;
+  dsp->write = netbsd_dsp_write;
+  dsp->destroy = netbsd_dsp_destroy;
+  dsp->hw_info.type = params->type;
+  dsp->hw_info.samplerate = params->samplerate;
+
+  /* Open the sound device. */
+  if (!device)
+    device = "/dev/audio";
+
+  if((priv->fd = open(device, O_WRONLY, 0)) < 0)
+    {
+      perror("error: /dev/audio");
+      netbsd_dsp_destroy(dsp);
+      return NULL;
+    }
+
+  /* Empty buffers before change config. */
+  ioctl(priv->fd, AUDIO_FLUSH, 0);
+
+  /* Set the number of bits. */
+  AUDIO_INITINFO(&a_info);
+  if (dsp->hw_info.type & SYSDEP_DSP_16BIT)
+    {
+      desired_encoding = AUDIO_ENCODING_SLINEAR;
+      desired_precision = 16;
+    }
+  else
+    {
+      desired_encoding = AUDIO_ENCODING_ULINEAR;
+      desired_precision = 8;
+    }
+  a_info.play.encoding = desired_encoding;
+  a_info.play.precision = desired_precision;
+  if (ioctl(priv->fd, AUDIO_SETINFO, &a_info) < 0)
+    {
+      perror("error: AUDIO_SETINFO");
+      netbsd_dsp_destroy(dsp);
+      return NULL;
+    }
+  if (a_info.play.encoding != desired_encoding
+      || a_info.play.precision != desired_precision)
+    {
+      if (desired_precision == 8)
+	{
+	  fprintf(stderr, "error: couldn't set sound to 8 bits,\n");
+	  netbsd_dsp_destroy(dsp);
+	  return NULL;
+	}
+
+      fprintf(stderr,
+	      "warning: couldn't set sound to 16 bits,\n"
+	      "   trying again with 8 bits: ");
+
+      AUDIO_INITINFO(&a_info);
+      a_info.play.encoding = AUDIO_ENCODING_ULINEAR;
+      a_info.play.precision = 8;
+      if (ioctl(priv->fd, AUDIO_SETINFO, &a_info) < 0)
+	{
+	  perror("error: AUDIO_SETINFO");
+	  netbsd_dsp_destroy(dsp);
+	  return NULL;
+	}
+
+      if (a_info.play.encoding != AUDIO_ENCODING_ULINEAR
+	  || a_info.play.precision != 8)
+	{
+	  fprintf(stderr, "failed\n");
+	  netbsd_dsp_destroy(dsp);
+	  return NULL;
+	}
+      fprintf(stderr, "success\n");
+
+      dsp->hw_info.type &= ~SYSDEP_DSP_16BIT;
+    }
+
+  /* Set the number of channels.  */
+  AUDIO_INITINFO(&a_info);
+  a_info.play.channels = (dsp->hw_info.type & SYSDEP_DSP_STEREO)? 2 : 1;
+  if (ioctl(priv->fd, AUDIO_SETINFO, &a_info) < 0)
+    {
+      perror("error: AUDIO_SETINFO");
+      netbsd_dsp_destroy(dsp);
+      return NULL;
+    }
+  if (a_info.play.channels == 1)
+    dsp->hw_info.type &= ~SYSDEP_DSP_STEREO;
+  else
+    dsp->hw_info.type |= SYSDEP_DSP_STEREO;
+
+  /* Set the sample rate.  */
+  AUDIO_INITINFO(&a_info);
+  a_info.play.sample_rate = dsp->hw_info.samplerate;
+  a_info.mode = AUMODE_PLAY | AUMODE_PLAY_ALL;
+  if (ioctl(priv->fd, AUDIO_SETINFO, &a_info) < 0)
+    {
+      perror("error: AUDIO_SETINFO");
+      netbsd_dsp_destroy(dsp);
+      return NULL;
+    }
+  dsp->hw_info.samplerate = a_info.play.sample_rate;
+   
+  /* Calculate and set the block size and number of blocks.
+     This is basically the same thing as frags in OSS, so the
+     calculations are taken from the OSS driver. The a_info.play.seek
+     used in the freespace calculation doesn't seem to be updated
+     as often as we should like, so the buffer need to consist of
+     at least 4 blocks. */
+  block_size = 1<<9;
+  if (dsp->hw_info.type & SYSDEP_DSP_16BIT) block_size<<=1;
+  if (dsp->hw_info.type & SYSDEP_DSP_STEREO) block_size<<=1;
+
+  blocks = ((dsp->hw_info.samplerate
+	     * netbsd_dsp_bytes_per_sample[dsp->hw_info.type] *
+	     params->bufsize) / block_size) + 1;
+  blocks = (blocks < 4) ? 4 : blocks;
+
+  AUDIO_INITINFO(&a_info);
+  a_info.blocksize = block_size;
+  a_info.play.buffer_size = block_size * blocks;
+  if (ioctl(priv->fd, AUDIO_SETINFO, &a_info) < 0)
+    {
+      perror("error: AUDIO_SETINFO");
+      netbsd_dsp_destroy(dsp);
+      return NULL;
+    }
+  fprintf(stderr, "info: setting blocksize to %d, buffer_size to %d\n",
+	  a_info.blocksize, a_info.play.buffer_size);
+
+  dsp->hw_info.bufsize =
+    block_size * blocks / netbsd_dsp_bytes_per_sample[dsp->hw_info.type];
+
+  fprintf(stderr,
+	  "info: audiodevice %s set to %dbit linear %s %dHz\n",
+	  device,
+	  (dsp->hw_info.type & SYSDEP_DSP_16BIT) ? 16 : 8,
+	  (dsp->hw_info.type & SYSDEP_DSP_STEREO) ? "stereo" : "mono",
+	  dsp->hw_info.samplerate);
+
+  return dsp;
+}
+
+static void netbsd_dsp_destroy(struct sysdep_dsp_struct *dsp)
+{
+  struct netbsd_dsp_priv_data *priv = dsp->_priv;
+
+  if (priv)
+    {
+      if (priv->fd >= 0)
+	close(priv->fd);
+
+      free(priv);
+    }
+  free(dsp);
+}
+
+static int netbsd_dsp_get_freespace(struct sysdep_dsp_struct *dsp)
+{
+  audio_info_t a_info;
+  struct netbsd_dsp_priv_data *priv = dsp->_priv;
+
+  AUDIO_INITINFO(&a_info);
+  if (ioctl(priv->fd, AUDIO_GETINFO, &a_info) < 0)
+    {
+      perror("error: AUDIO_GETINFO");
+      return -1;
+    }
+
+  return  dsp->hw_info.bufsize
+    - a_info.play.seek/netbsd_dsp_bytes_per_sample[dsp->hw_info.type];
+}
+
+static int netbsd_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+			    int count)
+{
+  int result;
+  int bytes_per_sample;
+  struct netbsd_dsp_priv_data *priv = dsp->_priv;
+
+  bytes_per_sample = netbsd_dsp_bytes_per_sample[dsp->hw_info.type];
+
+  result = write(priv->fd, data, count * bytes_per_sample);
+
+  if (result < 0)
+    return -1;
+      
+  return result / bytes_per_sample;
+}
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/dsp-drivers/oss.c mame-0.36b16/src/unix/sysdep/dsp-drivers/oss.c
--- ../mmmmm/m36b16/src/unix/sysdep/dsp-drivers/oss.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/dsp-drivers/oss.c	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,294 @@
+/* Sysdep Open Sound System sound dsp driver
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, January 2000
+-initial release, based on the xmame driver done by Mike Oliphant
+ (oliphant@ling.ed.ac.uk), amongst others (Hans de Goede)
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#ifdef __ARCH_freebsd
+#include <machine/soundcard.h>
+#else
+#include <sys/soundcard.h>
+#endif
+#include "sysdep/sysdep_dsp.h"
+#include "sysdep/sysdep_dsp_priv.h"
+#include "sysdep/plugin_manager.h"
+
+/* our per instance private data struct */
+struct oss_dsp_priv_data {
+   int fd;
+};
+
+/* public methods prototypes (static but exported through the sysdep_dsp or
+   plugin struct) */
+static void *oss_dsp_create(const void *flags);
+static void oss_dsp_destroy(struct sysdep_dsp_struct *dsp);
+static int oss_dsp_get_freespace(struct sysdep_dsp_struct *dsp);
+static int oss_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+   int count);
+
+/* public variables */
+const struct plugin_struct sysdep_dsp_oss = {
+   "oss",
+   "sysdep_dsp",
+   "Open Sound System DSP plugin",
+   NULL, /* no options */
+   NULL, /* no init */
+   NULL, /* no exit */
+   oss_dsp_create,
+   3     /* high priority */
+};
+
+/* private variables */
+static int oss_dsp_bytes_per_sample[4] = SYSDEP_DSP_BYTES_PER_SAMPLE;
+
+/* public methods (static but exported through the sysdep_dsp or plugin
+   struct) */
+static void *oss_dsp_create(const void *flags)
+{
+   int i, j;
+   audio_buf_info info;
+   struct oss_dsp_priv_data *priv = NULL;
+   struct sysdep_dsp_struct *dsp = NULL;
+   const struct sysdep_dsp_create_params *params = flags;
+   const char *device = params->device;
+   
+   /* allocate the dsp struct */
+   if (!(dsp = calloc(1, sizeof(struct sysdep_dsp_struct))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct sysdep_dsp_struct\n");
+      return NULL;
+   }
+   
+   /* alloc private data */
+   if(!(priv = calloc(1, sizeof(struct oss_dsp_priv_data))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct oss_dsp_priv_data\n");
+      oss_dsp_destroy(dsp);
+      return NULL;
+   }
+   
+   /* fill in the functions and some data */
+   priv->fd = -1;
+   dsp->_priv = priv;
+   dsp->get_freespace = oss_dsp_get_freespace;
+   dsp->write = oss_dsp_write;
+   dsp->destroy = oss_dsp_destroy;
+   dsp->hw_info.type = params->type;
+   dsp->hw_info.samplerate = params->samplerate;
+   
+   /* open the sound device */
+   if (!device)
+      device = "/dev/dsp";
+   
+   /* always open in non-blocking mode, otherwise the open itself may
+      block hanging the entire application */
+   if((priv->fd = open(device, O_WRONLY|O_NONBLOCK, 0)) < 0) {
+      perror("error: /dev/dsp");
+      oss_dsp_destroy(dsp);
+      return NULL;
+   }
+   
+   /* set back to blocking mode, unless non-blocking mode was selected */
+   if(!(params->flags & SYSDEP_DSP_O_NONBLOCK))
+   {
+      if(fcntl(priv->fd, F_SETFL, O_WRONLY) < 0)
+      {
+         perror("OSS-driver, error: fnctl");
+         oss_dsp_destroy(dsp);
+         return NULL;
+      }
+   }
+   
+   /* set the number of bits */
+#ifdef LSB_FIRST
+   i = j = (dsp->hw_info.type & SYSDEP_DSP_16BIT)? AFMT_S16_LE:AFMT_U8;
+#else
+   i = j = (dsp->hw_info.type & SYSDEP_DSP_16BIT)? AFMT_S16_BE:AFMT_U8;
+#endif
+   if (ioctl(priv->fd, SNDCTL_DSP_SETFMT, &i) < 0)
+   {
+      perror("error: SNDCTL_DSP_SETFMT");
+      oss_dsp_destroy(dsp);
+      return NULL;
+   }
+   if (i != j)
+   {
+      if(dsp->hw_info.type & SYSDEP_DSP_16BIT)
+      {
+         fprintf(stderr, "warning: couldn't set sound to 16 bits,\n"
+            "   trying again with 8 bits: ");
+      }
+      else
+      {
+         fprintf(stderr, "error: couldn't set sound to 8 bits,\n");
+         oss_dsp_destroy(dsp);
+         return NULL;
+      }
+      dsp->hw_info.type &= ~SYSDEP_DSP_16BIT;
+      i = AFMT_U8;
+      if (ioctl(priv->fd, SNDCTL_DSP_SETFMT, &i) < 0)
+      {
+         perror("error: SNDCTL_DSP_SETFMT");
+         oss_dsp_destroy(dsp);
+         return NULL;
+      }
+      if (i != AFMT_U8)
+      {
+         fprintf(stderr, "failed\n");
+         oss_dsp_destroy(dsp);
+         return NULL;
+      }
+      fprintf(stderr, "success\n");
+   }
+   
+   /* set the number of channels */
+   i = (dsp->hw_info.type & SYSDEP_DSP_STEREO)? 1:0;
+   if(ioctl(priv->fd, SNDCTL_DSP_STEREO, &i) < 0)
+   {
+      perror("error: SNDCTL_DSP_STEREO");
+      oss_dsp_destroy(dsp);
+      return NULL;
+   }
+   if(i)
+      dsp->hw_info.type |= SYSDEP_DSP_STEREO;
+   else
+      dsp->hw_info.type &= ~SYSDEP_DSP_STEREO;
+   
+   /* set the samplerate */
+   if(ioctl(priv->fd, SNDCTL_DSP_SPEED, &dsp->hw_info.samplerate) < 0)
+   {
+      perror("error: SNDCTL_DSP_SPEED");
+      oss_dsp_destroy(dsp);
+      return NULL;
+   }
+   
+   /* calculate and set the fragsize & number of frags */
+   /* fragsize (as power of 2) */
+   i = 7;
+   if (dsp->hw_info.type & SYSDEP_DSP_16BIT) i++;
+   if (dsp->hw_info.type & SYSDEP_DSP_STEREO) i++;
+   i += dsp->hw_info.samplerate / 22000;
+   
+   /* number of frags */
+   j = ((dsp->hw_info.samplerate * oss_dsp_bytes_per_sample[dsp->hw_info.type] *
+      params->bufsize) / (0x01 << i)) + 1;
+      
+   /* set the fraginfo */
+   i = j = i | (j << 16);
+   fprintf(stderr, "info: setting fragsize to %d, numfrags to %d\n",
+   	1 << (i&0x0000FFFF), i >> 16);
+   if (ioctl(priv->fd, SNDCTL_DSP_SETFRAGMENT, &i) < 0)
+   {
+      perror("error: SNDCTL_DSP_SETFRAGMENT");
+      oss_dsp_destroy(dsp);
+      return NULL;
+   }
+
+   if (ioctl(priv->fd, SNDCTL_DSP_GETOSPACE, &info) < 0)
+   {
+      perror("warning: SNDCTL_DSP_GETOSPACE");
+      fprintf(stderr, "   falling back to timer based audio\n");
+      dsp->get_freespace = NULL;
+   }
+   else
+   {
+      fprintf(stderr, "info: fragsize = %d, numfrags = %d\n", info.fragsize,
+         info.fragstotal);
+      /* i = requested fragsize, j = requested numfrags */
+      i = 1 << (j&0x0000FFFF);
+      j = j >> 16;
+      if((info.fragsize < (i/2)) || (info.fragsize > (i*2)) ||
+         (info.fragstotal < (j-2)) || (info.fragstotal > (j+2)))
+      {
+         fprintf(stderr, "warning: gotten fragsize/numfrags differs to much from requested\n"
+            "   assuming buggy OSS (sb64 / 128 pci?), falling back to timer based audio\n");
+         dsp->get_freespace = NULL;
+      }
+      else if(info.bytes > (info.fragsize * info.fragstotal))
+      {
+         fprintf(stderr, "warning: freespace > (fragsize * numfrags) assuming buggy FreeBSD PCM driver,\n"
+            "   falling back to timer based audio\n");
+         dsp->get_freespace = NULL;
+      }
+      else
+         /* info.fragstotal + 1 to work around yet more OSS bugs ;( */
+         dsp->hw_info.bufsize = (info.fragsize * (info.fragstotal + 1)) /
+            oss_dsp_bytes_per_sample[dsp->hw_info.type];
+   }
+
+   fprintf(stderr, "info: audiodevice %s set to %dbit linear %s %dHz\n",
+      device, (dsp->hw_info.type & SYSDEP_DSP_16BIT)? 16:8,
+      (dsp->hw_info.type & SYSDEP_DSP_STEREO)? "stereo":"mono",
+      dsp->hw_info.samplerate);
+      
+   return dsp;
+}
+
+static void oss_dsp_destroy(struct sysdep_dsp_struct *dsp)
+{
+   struct oss_dsp_priv_data *priv = dsp->_priv;
+   
+   if(priv)
+   {
+      if(priv->fd >= 0)
+         close(priv->fd);
+      
+      free(priv);
+   }
+   free(dsp);
+}
+   
+static int oss_dsp_get_freespace(struct sysdep_dsp_struct *dsp)
+{
+   audio_buf_info info;
+   struct oss_dsp_priv_data *priv = dsp->_priv;
+   
+   if (ioctl(priv->fd, SNDCTL_DSP_GETOSPACE, &info) < 0)
+   {
+      perror("error: SNDCTL_DSP_GETOSPACE");
+      return -1;
+   }
+   return info.bytes / oss_dsp_bytes_per_sample[dsp->hw_info.type];
+}
+
+static int oss_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+   int count)
+{
+   int result;
+   struct oss_dsp_priv_data *priv = dsp->_priv;
+
+   result = write(priv->fd, data, count *
+      oss_dsp_bytes_per_sample[dsp->hw_info.type]);
+      
+   if (result < 0)
+      return -1;
+      
+   return result / oss_dsp_bytes_per_sample[dsp->hw_info.type];
+}
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/dsp-drivers/solaris.c mame-0.36b16/src/unix/sysdep/dsp-drivers/solaris.c
--- ../mmmmm/m36b16/src/unix/sysdep/dsp-drivers/solaris.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/dsp-drivers/solaris.c	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,264 @@
+/* Sysdep Solaris sound dsp driver
+
+   Copyright 2000 Hans de Goede, Mathis Rosenhauer
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, February 2000
+-initial release, based on oss.c and on the old xmame sound driver done by 
+ Juan Antonio Martinez, Keith Hargrove, Mathis Rosenhauer and others.
+ (Mathis Rosenhauer)
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/conf.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/stropts.h>
+#include <sys/audioio.h>
+#include "sysdep/sysdep_dsp.h"
+#include "sysdep/sysdep_dsp_priv.h"
+#include "sysdep/plugin_manager.h"
+
+/* our per instance private data struct */
+struct sol_dsp_priv_data {
+	int fd;
+	unsigned int samples_written;
+	unsigned int buffer_samples;
+};
+
+/* public methods prototypes (static but exported through the sysdep_dsp or
+   plugin struct) */
+static void *sol_dsp_create(const void *flags);
+static void sol_dsp_destroy(struct sysdep_dsp_struct *dsp);
+static int sol_dsp_get_freespace(struct sysdep_dsp_struct *dsp);
+static int sol_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+						 int count);
+
+/* public variables */
+const struct plugin_struct sysdep_dsp_solaris = {
+	"solaris",
+	"sysdep_dsp",
+	"Solaris DSP plugin",
+	NULL, /* no options */
+	NULL, /* no init */
+	NULL, /* no exit */
+	sol_dsp_create,
+	3	  /* high priority */
+};
+
+/* private variables */
+static int sol_dsp_bytes_per_sample[4] = SYSDEP_DSP_BYTES_PER_SAMPLE;
+
+/* public methods (static but exported through the sysdep_dsp or plugin
+   struct) */
+static void *sol_dsp_create(const void *flags)
+{
+	int i,j;
+	audio_info_t info;   /* info about audio settings */
+	audio_device_t dev;  /* info about audio hardware */
+	struct sol_dsp_priv_data *priv = NULL;
+	struct sysdep_dsp_struct *dsp = NULL;
+	const struct sysdep_dsp_create_params *params = flags;
+	const char *device = params->device;
+	
+	/* allocate the dsp struct */
+	if (!(dsp = calloc(1, sizeof(struct sysdep_dsp_struct))))
+	{
+		perror("error malloc failed for struct sysdep_dsp_struct\n");
+		return NULL;
+	}
+   
+	/* alloc private data */
+	if(!(priv = calloc(1, sizeof(struct sol_dsp_priv_data))))
+	{
+		perror("error malloc failed for struct sol_dsp_priv_data\n");
+		sol_dsp_destroy(dsp);
+		return NULL;
+	}
+   
+	/* fill in the functions and some data */
+	priv->fd = -1;
+	priv->samples_written = 0;
+	dsp->_priv = priv;
+	dsp->get_freespace = sol_dsp_get_freespace;
+	dsp->write = sol_dsp_write;
+	dsp->destroy = sol_dsp_destroy;
+	dsp->hw_info.type = params->type;
+	dsp->hw_info.samplerate = params->samplerate;
+   
+	/* open the sound device */
+	if (!device)
+		device = getenv("AUDIODEV");
+	if (!device)
+		device = "/dev/audio";
+   
+	if((priv->fd = open(device, O_WRONLY)) < 0)
+	{
+		fprintf(stderr, "error: opening %s\n", device);
+		sol_dsp_destroy(dsp);
+		return NULL;
+	}
+   
+	/* empty buffers before change config */
+	ioctl(priv->fd, AUDIO_DRAIN, 0);	/* drain everything out */
+	ioctl(priv->fd, I_FLUSH, FLUSHRW);	/* flush everything		*/
+		
+	/* identify audio device. */
+	if(ioctl(priv->fd, AUDIO_GETDEV, &dev) < 0)
+	{
+		perror("error: cannot get sound device type\n");
+		sol_dsp_destroy(dsp);
+		return NULL;
+	}
+
+	fprintf(stderr, "info: sound device is a %s %s version %s\n",dev.config,dev.name,dev.version);
+		
+	/* get audio parameters. */
+	if (ioctl(priv->fd, AUDIO_GETINFO, &info) < 0)
+	{
+		perror("AUDIO_GETINFO failed!\nRun with -nosound\n");
+		sol_dsp_destroy(dsp);
+		return NULL;
+	}
+
+	/* set the number of bits */
+	AUDIO_INITINFO(&info);
+
+	if (dsp->hw_info.type & SYSDEP_DSP_16BIT)
+	{
+		info.play.encoding = i = AUDIO_ENCODING_LINEAR;
+		info.play.precision = j = 16;
+	}
+	else
+	{
+		info.play.encoding = i = AUDIO_ENCODING_LINEAR8;
+		info.play.precision = j = 8;
+	}
+
+	if (ioctl(priv->fd, AUDIO_SETINFO, &info) < 0)
+	{
+		perror("error: AUDIO_SETINFO\n");
+		sol_dsp_destroy(dsp);
+		return NULL;
+	}
+	if ((info.play.encoding != i) || (info.play.precision != j))
+	{
+		if(dsp->hw_info.type & SYSDEP_DSP_16BIT)
+		{
+			fprintf(stderr, "warning: couldn't set sound to 16 bits,\ntrying again with 8 bits: ");
+		}
+		else
+		{
+			fprintf(stderr, "error: couldn't set sound to 8 bits,\n");
+			sol_dsp_destroy(dsp);
+			return NULL;
+		}
+		dsp->hw_info.type &= ~SYSDEP_DSP_16BIT;
+		info.play.precision = 8;
+		info.play.encoding = AUDIO_ENCODING_LINEAR8;
+		if (ioctl(priv->fd, AUDIO_SETINFO, &info) < 0)
+		{
+			perror("error: AUDIO_SETINFO\n");
+			sol_dsp_destroy(dsp);
+			return NULL;
+		}
+		if (info.play.precision != 8 || info.play.encoding != AUDIO_ENCODING_LINEAR8)
+		{
+			fprintf(stderr, "failed\n");
+			sol_dsp_destroy(dsp);
+			return NULL;
+		}
+		fprintf(stderr, "success\n");
+	}
+   
+   /* set the number of channels */
+    info.play.channels = (dsp->hw_info.type & SYSDEP_DSP_STEREO)? 2:1;
+	if (ioctl(priv->fd, AUDIO_SETINFO, &info) < 0)
+	{
+		perror("error: AUDIO_SETINFO\n");
+		sol_dsp_destroy(dsp);
+		return NULL;
+	}
+	if(info.play.channels == 2)
+		dsp->hw_info.type |= SYSDEP_DSP_STEREO;
+	else
+		dsp->hw_info.type &= ~SYSDEP_DSP_STEREO;
+   
+	/* set the samplerate and buffer size*/
+	info.play.sample_rate = dsp->hw_info.samplerate;
+	priv->buffer_samples = dsp->hw_info.samplerate * params->bufsize;
+	info.play.buffer_size = dsp->hw_info.bufsize = priv->buffer_samples * sol_dsp_bytes_per_sample[dsp->hw_info.type]; /* this seems to have no effect */
+	if (ioctl(priv->fd, AUDIO_SETINFO, &info) < 0)
+	{
+		perror("error: AUDIO_SETINFO\n");
+		sol_dsp_destroy(dsp);
+		return NULL;
+	}
+
+	dsp->hw_info.samplerate = info.play.sample_rate;
+	fprintf(stderr, "info: audiodevice %s set to %dbit linear %s %dHz\n",
+			dev.name, info.play.precision,
+			(info.play.channels & 2)? "stereo":"mono",
+			info.play.sample_rate);
+	
+	return dsp;
+}
+
+static void sol_dsp_destroy(struct sysdep_dsp_struct *dsp)
+{
+	struct sol_dsp_priv_data *priv = dsp->_priv;
+   
+	if(priv)
+	{
+		if(priv->fd >= 0)
+			close(priv->fd);
+		free(priv);
+	}
+	free(dsp);
+}
+   
+static int sol_dsp_get_freespace(struct sysdep_dsp_struct *dsp)
+{
+	audio_info_t info;
+	struct sol_dsp_priv_data *priv = dsp->_priv;
+   
+	if (ioctl(priv->fd, AUDIO_GETINFO, &info) < 0)
+	{
+		perror("error: AUDIO_GETINFO\n");
+		return -1;
+	}
+	return priv->buffer_samples - (priv->samples_written - info.play.samples);
+}
+
+static int sol_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data, int count)
+{
+	int result;
+	struct sol_dsp_priv_data *priv = dsp->_priv;
+	result = write(priv->fd, data, count * sol_dsp_bytes_per_sample[dsp->hw_info.type]);
+
+	if (result < 0)
+		return -1;
+	
+	result /= sol_dsp_bytes_per_sample[dsp->hw_info.type];
+	priv->samples_written += result;
+	return result;
+}
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/dsp-drivers/soundkit.m mame-0.36b16/src/unix/sysdep/dsp-drivers/soundkit.m
--- ../mmmmm/m36b16/src/unix/sysdep/dsp-drivers/soundkit.m	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/dsp-drivers/soundkit.m	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,166 @@
+/*
+ * Driver for the NeXT / Apple soundkit objects for use on OpenStep
+ * systems. Based on the older sound drivers, converted into the new
+ * style framework by taking a long hard look at esound.c.
+ *
+ * -bat. 06/09/2000
+ */
+
+#import <SoundKit/SoundKit.h>
+#import <libc.h>
+#import "sysdep/sysdep_dsp.h"
+#import "sysdep/sysdep_dsp_priv.h"
+#import "sysdep/plugin_manager.h"
+
+/*
+ * Destroy function - we release the playStream and free up
+ * the dsp structure.
+ */
+
+static void
+soundkit_dsp_destroy(struct sysdep_dsp_struct *dsp)
+{
+	NXPlayStream *playStream = (NXPlayStream*)dsp->_priv;
+
+	[playStream release];
+
+	free(dsp);
+}
+
+/*
+ * Write a block of data to the sound object. We take pains to make sure it
+ * in the correct format by copying it around the place quite a lot - this
+ * makes 8 bit sound rather slow as we cannot write it to the device
+ * directly due to an intel bug.
+ */
+   
+static int
+soundkit_dsp_write(struct sysdep_dsp_struct *dsp,
+		unsigned char *data, int count)
+{
+	static int theTag = 1;
+	static long buff_size = 0;
+	static unsigned char *out_buff = NULL;
+
+	BOOL isStereo = (dsp->hw_info.type & SYSDEP_DSP_STEREO) ? YES : NO;
+	NXPlayStream *playStream = (NXPlayStream*)dsp->_priv;
+	long bytes = sizeof(short) * count * (isStereo ? 2 : 1);
+
+	/* do a malloc if necessary */
+	if(bytes > buff_size) {
+		if(out_buff)
+			free(out_buff);
+		out_buff = malloc(bytes);
+		if(!out_buff)
+			return 0;
+		buff_size = bytes;
+	}
+
+	/* do the byte swap and write the block */
+	SNDSwapHostToSound(out_buff, data, count,
+			isStereo ? 2: 1, SND_FORMAT_LINEAR_16);
+	[playStream playBuffer:out_buff size:bytes tag:theTag++];
+
+	return count;
+}
+
+/*
+ * Creation function.
+ */
+
+static void*
+soundkit_dsp_create(const void *flags)
+{
+	NXPlayStream *playStream = nil;
+	NXSoundOut *soundOut = nil;
+	NXSoundParameters *soundParams = nil;
+	SNDSoundStruct *soundStruct = NULL;
+	char *soundHost = getenv("SOUNDHOST");
+	id priv = nil;
+	struct sysdep_dsp_struct *dsp = NULL;
+	const struct sysdep_dsp_create_params *params = flags;
+
+	/* allocate the dsp struct */
+	if (!(dsp = calloc(1, sizeof(struct sysdep_dsp_struct))))
+	{
+		perror("error malloc failed for struct sysdep_dsp_struct\n");
+		return NULL;
+	}
+
+	/* create sound object (possibly remotely) */
+	if(soundHost) {
+		soundOut = [[NXSoundOut alloc]
+			initOnHost:[NSString stringWithCString:soundHost]];
+		if(!soundOut) {
+			fprintf(stderr,
+				"could not initialise sound object on %s\n",
+				soundHost);
+	      		return NULL;
+	    	} else
+			fprintf(stderr, "info: soundkit: send sound to %s\n",
+					soundHost);
+	} else
+		soundOut = [NXSoundOut new];
+
+	if(!soundOut) {
+		fprintf(stderr,"could not initialise sound object\n");
+		return NULL;
+	}
+
+	/* create a parameters object - always 16 bit please ! */
+	dsp->hw_info.type |= SYSDEP_DSP_16BIT;
+	if(params->type & SYSDEP_DSP_STEREO) {
+		SNDAlloc(&soundStruct, 0, SND_FORMAT_LINEAR_16,
+				params->samplerate, 2, 0);
+		dsp->hw_info.type |= SYSDEP_DSP_STEREO;
+	} else {
+		SNDAlloc(&soundStruct, 0, SND_FORMAT_LINEAR_16,
+				params->samplerate, 1, 0);
+	}
+	soundParams = [[NXSoundParameters alloc]
+			initFromSoundStruct:soundStruct];
+	if(!soundParams) {
+		fprintf(stderr,"could not create sound parameters\n");
+		return NULL;
+	}
+
+	/* print the info */
+	fprintf(stderr, "info: soundkit: %s sound at %d hz\n",
+			(dsp->hw_info.type & SYSDEP_DSP_STEREO) ?
+			"stereo" : "mono", params->samplerate);
+
+	/* create the stream object */
+	playStream = [[NXPlayStream alloc]
+		initOnDevice:soundOut withParameters:soundParams];
+	if(!playStream) {
+		fprintf(stderr,"could not create play stream\n");
+		return NULL;
+	}
+
+	/* fill in the functions and some data */
+	dsp->_priv = playStream;
+	dsp->write = soundkit_dsp_write;
+	dsp->destroy = soundkit_dsp_destroy;
+	dsp->hw_info.type = params->type;
+	dsp->hw_info.samplerate = params->samplerate;
+
+	/* activate and return */
+   
+	[playStream activate];
+	return dsp;
+}
+
+/*
+ * The public variables structure
+ */
+
+const struct plugin_struct sysdep_dsp_soundkit = {
+	"soundkit",
+	"sysdep_dsp",
+	"NeXT SoundKit plugin",
+	NULL, 				/* no options */
+	NULL,				/* no init */
+	NULL,				/* no exit */
+	soundkit_dsp_create,
+	3				/* high priority */
+};
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/end_code.h mame-0.36b16/src/unix/sysdep/end_code.h
--- ../mmmmm/m36b16/src/unix/sysdep/end_code.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/end_code.h	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,22 @@
+/* A few simple include macros
+
+   Copyright 1999,2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifdef __cplusplus
+}
+#endif
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/fifo.h mame-0.36b16/src/unix/sysdep/fifo.h
--- ../mmmmm/m36b16/src/unix/sysdep/fifo.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/fifo.h	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,160 @@
+/* Generic fifo implemented through defines
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, March 2000
+-initial release (Hans de Goede)
+*/
+#ifndef __FIFO_H
+#define __FIFO_H
+
+#define FIFO(PREFIX,NAME,TYPE)						\
+   FIFO_PROTOTYPES(PREFIX,NAME,TYPE)					\
+   FIFO_STRUCT(PREFIX,NAME,TYPE)					\
+   FIFO_CREATE(PREFIX,NAME,TYPE)					\
+   FIFO_DESTROY(PREFIX,NAME,TYPE)					\
+   FIFO_PUT(PREFIX,NAME,TYPE)						\
+   FIFO_GET(PREFIX,NAME,TYPE)						\
+   FIFO_PEEK(PREFIX,NAME,TYPE)						\
+   FIFO_EMPTY(PREFIX,NAME,TYPE)						\
+   FIFO_GET_FREESPACE(PREFIX,NAME,TYPE)					\
+   FIFO_IN_USE(PREFIX,NAME,TYPE)
+
+#define FIFO_PROTOTYPES(PREFIX,NAME,TYPE)				\
+   struct NAME ## _fifo_struct;						\
+   PREFIX struct NAME ## _fifo_struct * NAME ## _fifo_create(int size);	\
+   PREFIX void NAME ## _fifo_destroy(struct NAME ## _fifo_struct	\
+      *fifo);								\
+   PREFIX int NAME ## _fifo_put(struct NAME ## _fifo_struct *fifo,	\
+      TYPE data);							\
+   PREFIX int NAME ## _fifo_get(struct NAME ## _fifo_struct *fifo,	\
+      TYPE *data);							\
+   PREFIX int NAME ## _fifo_peek(struct NAME ## _fifo_struct *fifo,	\
+      TYPE *data);							\
+   PREFIX void NAME ## _fifo_empty(struct NAME ## _fifo_struct *fifo);	\
+   PREFIX int NAME ## _fifo_in_use(struct NAME ## _fifo_struct *fifo);	\
+   PREFIX int NAME ## _fifo_get_freespace(struct NAME ## _fifo_struct 	\
+      *fifo);
+
+#define FIFO_STRUCT(PREFIX,NAME,TYPE)					\
+   struct NAME ## _fifo_struct {					\
+      int size;								\
+      int head;								\
+      int in_use;							\
+      TYPE *buffer;							\
+   };
+
+#define FIFO_CREATE(PREFIX,NAME,TYPE)					\
+   PREFIX struct NAME ## _fifo_struct * NAME ## _fifo_create(int size)	\
+   {									\
+      struct NAME ## _fifo_struct *fifo = NULL;				\
+      									\
+      /* allocate the fifo struct */					\
+      if(!(fifo = calloc(1, sizeof(struct NAME ## _fifo_struct))))	\
+      {									\
+         fprintf(stderr,						\
+            "error malloc failed for struct xxx_fifo_struct\n");	\
+         return NULL;							\
+      }									\
+      									\
+      /* allocate the buffer */						\
+      if(!(fifo->buffer = calloc(size, sizeof(TYPE))))			\
+      {									\
+         fprintf(stderr,						\
+            "error malloc failed for xxx_fifo buffer\n");		\
+         NAME ## _fifo_destroy(fifo);					\
+         return NULL;							\
+      }									\
+     									\
+      fifo->size = size;						\
+     									\
+      return fifo;							\
+   }
+
+#define FIFO_DESTROY(PREFIX,NAME,TYPE)					\
+   PREFIX void NAME ## _fifo_destroy(struct NAME ## _fifo_struct *fifo)	\
+   {									\
+      if(fifo->buffer)							\
+         free(fifo->buffer);						\
+      									\
+      free(fifo);							\
+   }
+   
+#define FIFO_PUT(PREFIX,NAME,TYPE)					\
+   PREFIX int NAME ## _fifo_put(struct NAME ## _fifo_struct *fifo,	\
+      TYPE data)							\
+   {									\
+      int tail;								\
+      									\
+      if(fifo->in_use == fifo->size)					\
+         return -1;							\
+      									\
+      tail = (fifo->head + fifo->in_use) % fifo->size;			\
+      fifo->buffer[tail] = data;					\
+      fifo->in_use++;							\
+      									\
+      return 0;								\
+   }
+
+#define FIFO_GET(PREFIX,NAME,TYPE)					\
+   PREFIX int NAME ## _fifo_get(struct NAME ## _fifo_struct *fifo,	\
+      TYPE *data)							\
+   {									\
+      if(!fifo->in_use)							\
+         return -1;							\
+      									\
+      *data = fifo->buffer[fifo->head];					\
+      fifo->head = (fifo->head + 1) % fifo->size;			\
+      fifo->in_use--;							\
+      									\
+      return 0;								\
+   }
+
+#define FIFO_PEEK(PREFIX,NAME,TYPE)					\
+   PREFIX int NAME ## _fifo_peek(struct NAME ## _fifo_struct *fifo,	\
+      TYPE *data)							\
+   {									\
+      if(!fifo->in_use)							\
+         return -1;							\
+      									\
+      *data = fifo->buffer[fifo->head];					\
+      									\
+      return 0;								\
+   }
+
+#define FIFO_EMPTY(PREFIX,NAME,TYPE)					\
+   PREFIX void NAME ## _fifo_empty(struct NAME ## _fifo_struct *fifo)	\
+   {									\
+      fifo->head = fifo->in_use = 0;					\
+   }
+
+#define FIFO_IN_USE(PREFIX,NAME,TYPE)					\
+   PREFIX int NAME ## _fifo_in_use(struct NAME ## _fifo_struct *fifo)	\
+   {									\
+      return fifo->in_use;						\
+   }
+
+#define FIFO_GET_FREESPACE(PREFIX,NAME,TYPE)				\
+   PREFIX int NAME ## _fifo_get_freespace(struct NAME ## _fifo_struct	\
+      *fifo)								\
+   {									\
+      return fifo->size - fifo->in_use;					\
+   }
+
+#endif /* ifndef __FIFO_H */
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/misc.c mame-0.36b16/src/unix/sysdep/misc.c
--- ../mmmmm/m36b16/src/unix/sysdep/misc.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/misc.c	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,143 @@
+/* Miscelancelous utility functions
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, February 2000
+-initial release (Hans de Goede)
+Version 0.2, May 2000
+-moved time system headers from .h to .c to avoid header conflicts (Hans de Goede)
+-made uclock a funtion on systems without gettimeofday too (Hans de Goede) 
+-UCLOCKS_PER_SECOND is now always 1000000, instead of making it depent on
+ the system headers. (Hans de Goede)
+*/
+/* Todo ?
+-rename uclock to sysdep_clock (Hans de Goede)
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <sys/time.h>
+#include "misc.h"
+
+
+#ifdef HAVE_GETTIMEOFDAY
+/* Standard UNIX clock() is based on CPU time, not real time.
+   Here is a real-time drop in replacement for UNIX systems that have the
+   gettimeofday() routine.  This results in much more accurate timing.
+*/
+uclock_t uclock(void)
+{
+  static uclock_t init_sec = 0;
+  struct timeval tv;
+  
+  gettimeofday(&tv, 0);
+  if (init_sec == 0) init_sec = tv.tv_sec;
+  
+  return (tv.tv_sec - init_sec) * 1000000 + tv.tv_usec;
+}
+#else
+
+/* some platforms don't define CLOCKS_PER_SEC, according to posix it should
+   always be 1000000, so asume that's the case if it is not defined,
+   except for openstep which doesn't define it and has it at 64 */
+#ifndef CLOCKS_PER_SEC
+#ifdef openstep
+#define CLOCKS_PER_SEC 64     /* this is correct for OS4.2 intel */
+#else
+#define CLOCKS_PER_SEC 1000000
+#endif
+#endif
+
+uclock_t uclock(void)
+{
+   return (clock() * (1000000 / CLOCKS_PER_SEC));
+}
+
+#endif
+
+void print_colums(const char *text1, const char *text2)
+{
+   fprint_colums(stdout, text1, text2);
+}
+
+void fprint_colums(FILE *f, const char *text1, const char *text2)
+{
+   const char *text[2];
+   int i, j, cols, width[2], done = 0;
+   char *e_cols = getenv("COLUMNS");
+
+   cols = e_cols? atoi(e_cols):80;
+   if ( cols < 6 ) cols = 6;  /* minimum must be 6 */
+   cols--;
+
+   /* initialize our arrays */
+   text[0] = text1;
+   text[1] = text2;
+   width[0] = cols * 0.4;
+   width[1] = cols - width[0];
+   
+   while(!done)
+   {
+      done = 1;
+      for(i = 0; i < 2; i++)
+      {
+         int to_print = width[i]-1; /* always leave one space open */
+         
+         /* we don't want to print more then we have */
+         j = strlen(text[i]);
+         if (to_print > j)
+           to_print = j;
+            
+         /* if they have preffered breaks, try to give them to them */
+         for(j=0; j<to_print; j++)
+            if(text[i][j] == '\n')
+            {
+               to_print = j;
+               break;
+            }
+         
+         /* if we don't have enough space, break at the first ' ' or '\n' */
+         if(to_print < strlen(text[i]))
+         {
+           while(to_print && (text[i][to_print] != ' ') &&
+              (text[i][to_print] != '\n'))
+              to_print--;
+           
+           /* if it didn't work, just print the columnwidth */
+           if(!to_print)
+              to_print = width[i]-1;
+         }
+         fprintf(f, "%-*.*s", width[i], to_print, text[i]);
+         
+         /* adjust ptr */
+         text[i] += to_print;
+         
+         /* skip ' ' and '\n' */
+         while((text[i][0] == ' ') || (text[i][0] == '\n'))
+            text[i]++;
+         
+         /* do we still have text to print */
+         if(text[i][0])
+            done = 0;
+      }
+      fprintf(f, "\n");
+   }
+}
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/misc.h mame-0.36b16/src/unix/sysdep/misc.h
--- ../mmmmm/m36b16/src/unix/sysdep/misc.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/misc.h	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,37 @@
+/* Miscelancelous utility functions
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __MISC_H
+#define __MISC_H
+#include <stdio.h>
+#include "begin_code.h"
+
+/* clock stuff */
+typedef long uclock_t;
+uclock_t uclock(void);
+#define UCLOCKS_PER_SEC 1000000
+
+//#define uclock() clock() /* RB */
+
+/* print colum stuff */
+void print_colums(const char *text1, const char *text2);
+void fprint_colums(FILE *f, const char *text1, const char *text2);
+
+#include "end_code.h"
+#endif /* ifndef __MISC_H */
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/mixer-drivers/oss.c mame-0.36b16/src/unix/sysdep/mixer-drivers/oss.c
--- ../mmmmm/m36b16/src/unix/sysdep/mixer-drivers/oss.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/mixer-drivers/oss.c	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,183 @@
+/* Sysdep Open Sound System sound mixer driver
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, January 2000
+-initial release (Hans de Goede)
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#ifdef __ARCH_freebsd
+#include <machine/soundcard.h>
+#else
+#include <sys/soundcard.h>
+#endif
+#include "sysdep/sysdep_mixer.h"
+#include "sysdep/sysdep_mixer_priv.h"
+#include "sysdep/plugin_manager.h"
+
+/* our per instance private data struct */
+struct oss_mixer_priv_data {
+   int fd;
+};
+
+/* public methods prototypes (static but exported through the sysdep_mixer or
+   plugin struct) */
+static void *oss_mixer_create(const void *flags);
+static void oss_mixer_destroy(struct sysdep_mixer_struct *mixer);
+static int oss_mixer_set(struct sysdep_mixer_struct *mixer,
+   int channel, int left, int right);
+static int oss_mixer_get(struct sysdep_mixer_struct *mixer,
+   int channel, int *left, int *right);
+   
+/* private variables */
+const int oss_mixer_sysdep_to_oss[] = {
+   SOUND_MIXER_VOLUME, /* SYSDEP_MIXER_VOLUME */
+   SOUND_MIXER_PCM,    /* SYSDEP_MIXER_PCM1 */
+   SOUND_MIXER_ALTPCM, /* SYSDEP_MIXER_PCM2 */
+   SOUND_MIXER_SYNTH,  /* SYSDEP_MIXER_SYNTH */
+   SOUND_MIXER_CD,     /* SYSDEP_MIXER_CD */
+   SOUND_MIXER_LINE,   /* SYSDEP_MIXER_LINE1 */
+   SOUND_MIXER_LINE1,  /* SYSDEP_MIXER_LINE2 */
+   SOUND_MIXER_LINE2,  /* SYSDEP_MIXER_LINE3 */
+   SOUND_MIXER_BASS,   /* SYSDEP_MIXER_BASS */
+   SOUND_MIXER_TREBLE, /* SYSDEP_MIXER_TREBLE */
+};
+
+/* public variables */
+const struct plugin_struct sysdep_mixer_oss = {
+   "oss",
+   "sysdep_mixer",
+   "Open Sound System mixer plugin",
+   NULL, /* no options */
+   NULL, /* no init */
+   NULL, /* no exit */
+   oss_mixer_create,
+   3     /* high priority */
+};
+
+/* public methods (static but exported through the sysdep_mixer or plugin
+   struct) */
+static void *oss_mixer_create(const void *flags)
+{
+   int i, j;
+   struct oss_mixer_priv_data *priv = NULL;
+   struct sysdep_mixer_struct *mixer = NULL;
+   const struct sysdep_mixer_create_params *params = flags;
+   const char *device = params->device;
+   
+   /* allocate the mixer struct */
+   if (!(mixer = calloc(1, sizeof(struct sysdep_mixer_struct))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct sysdep_mixer_struct\n");
+      return NULL;
+   }
+   
+   /* alloc private data */
+   if(!(priv = calloc(1, sizeof(struct oss_mixer_priv_data))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct oss_mixer_priv_data\n");
+      oss_mixer_destroy(mixer);
+      return NULL;
+   }
+   
+   /* fill in the functions and some data */
+   priv->fd = -1;
+   mixer->_priv = priv;
+   mixer->set = oss_mixer_set;
+   mixer->get = oss_mixer_get;
+   mixer->destroy = oss_mixer_destroy;
+   
+   /* open the mixer device */
+   if (!device)
+      device = "/dev/mixer";
+   
+   if((priv->fd = open(device, O_WRONLY, 0)) < 0) {
+      perror("error: /dev/mixer");
+      oss_mixer_destroy(mixer);
+      return NULL;
+   }
+   
+   /* and check which channels are available */
+   if (ioctl(priv->fd, SOUND_MIXER_READ_DEVMASK, &i))
+   {
+      perror("error: SOUND_MIXER_READ_DEVMASK");
+      oss_mixer_destroy(mixer);
+      return NULL;
+   }
+   for(j=0; j < SYSDEP_MIXER_CHANNELS; j++)
+      if(i & (0x01 << oss_mixer_sysdep_to_oss[j]))
+         mixer->channel_available[j] = 1;
+   
+   return mixer;
+}
+
+static void oss_mixer_destroy(struct sysdep_mixer_struct *mixer)
+{
+   struct oss_mixer_priv_data *priv = mixer->_priv;
+   
+   if(priv)
+   {
+      if(priv->fd >= 0)
+         close(priv->fd);
+      
+      free(priv);
+   }
+   free(mixer);
+}
+   
+static int oss_mixer_set(struct sysdep_mixer_struct *mixer,
+   int channel, int left, int right)
+{
+   int i = left | right << 8;
+   struct oss_mixer_priv_data *priv = mixer->_priv;
+   
+   if(ioctl(priv->fd, MIXER_WRITE(oss_mixer_sysdep_to_oss[channel]), &i))
+   {
+      perror("error: SOUND_MIXER_WRITE");
+      return -1;
+   }
+   return 0;
+}
+
+static int oss_mixer_get(struct sysdep_mixer_struct *mixer,
+   int channel, int *left, int *right)
+{
+   int value;
+   struct oss_mixer_priv_data *priv = mixer->_priv;
+   
+   if(ioctl(priv->fd, MIXER_READ(oss_mixer_sysdep_to_oss[channel]),
+      &value))
+   {
+      perror("error: SOUND_MIXER_READ");
+      return -1;
+   }
+      
+   *left = value & 0xFF;
+   *right = (value >> 8) & 0xFF;
+
+   return 0;
+}
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/mixer-drivers/solaris.c mame-0.36b16/src/unix/sysdep/mixer-drivers/solaris.c
--- ../mmmmm/m36b16/src/unix/sysdep/mixer-drivers/solaris.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/mixer-drivers/solaris.c	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,172 @@
+/* Sysdep Open Sound System sound mixer driver
+
+   Copyright 2000 Hans de Goede, Mathis Rosenhauer
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, February 2000
+-initial release based on oss.c by Hans de Goede (Mathis Rosenhauer)
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/stropts.h>
+#include <sys/audioio.h>
+#include "sysdep/sysdep_mixer.h"
+#include "sysdep/sysdep_mixer_priv.h"
+#include "sysdep/plugin_manager.h"
+
+/* our per instance private data struct */
+struct sol_mixer_priv_data {
+	int fd;
+};
+
+/* public methods prototypes (static but exported through the sysdep_mixer or
+   plugin struct) */
+static void *sol_mixer_create(const void *flags);
+static void sol_mixer_destroy(struct sysdep_mixer_struct *mixer);
+static int sol_mixer_set(struct sysdep_mixer_struct *mixer,
+						 int channel, int left, int right);
+static int sol_mixer_get(struct sysdep_mixer_struct *mixer,
+						 int channel, int *left, int *right);
+   
+/* public variables */
+const struct plugin_struct sysdep_mixer_solaris = {
+	"solaris",
+	"sysdep_mixer",
+	"Solaris mixer plugin",
+	NULL, /* no options */
+	NULL, /* no init */
+	NULL, /* no exit */
+	sol_mixer_create,
+	3	  /* high priority */
+};
+
+/* public methods (static but exported through the sysdep_mixer or plugin
+   struct) */
+static void *sol_mixer_create(const void *flags)
+{
+	struct sol_mixer_priv_data *priv = NULL;
+	struct sysdep_mixer_struct *mixer = NULL;
+	const struct sysdep_mixer_create_params *params = flags;
+	const char *device = params->device;
+   
+	/* allocate the mixer struct */
+	if (!(mixer = calloc(1, sizeof(struct sysdep_mixer_struct))))
+	{
+		perror("error malloc failed for struct sysdep_mixer_struct\n");
+		return NULL;
+	}
+   
+	/* alloc private data */
+	if(!(priv = calloc(1, sizeof(struct sol_mixer_priv_data))))
+	{
+		perror("error malloc failed for struct sol_mixer_priv_data\n");
+		sol_mixer_destroy(mixer);
+		return NULL;
+	}
+   
+	/* fill in the functions and some data */
+	priv->fd = -1;
+	mixer->_priv = priv;
+	mixer->set = sol_mixer_set;
+	mixer->get = sol_mixer_get;
+	mixer->destroy = sol_mixer_destroy;
+   
+	/* open the mixer device */
+	if (!device)
+		device = getenv("AUDIODEV");
+	if (!device)
+		device = "/dev/audioctl";
+   
+	if((priv->fd = open(device, O_RDWR)) < 0) {
+		fprintf(stderr, "error: opening %s\n", device);
+		sol_mixer_destroy(mixer);
+		return NULL;
+	}
+   
+	/* are there more channels on other hardware as dbri? */
+	mixer->channel_available[SYSDEP_MIXER_PCM1] = 1;
+	return mixer;
+}
+
+static void sol_mixer_destroy(struct sysdep_mixer_struct *mixer)
+{
+	struct sol_mixer_priv_data *priv = mixer->_priv;
+   
+	if(priv)
+	{
+		if(priv->fd >= 0)
+			close(priv->fd);
+	  
+		free(priv);
+	}
+	free(mixer);
+}
+   
+static int sol_mixer_set(struct sysdep_mixer_struct *mixer, int channel, int left, int right)
+{
+	audio_info_t info;
+	struct sol_mixer_priv_data *priv = mixer->_priv;
+	int maxvol = (left > right)? left: right;
+
+	AUDIO_INITINFO(&info);
+
+	info.play.gain = (maxvol * (AUDIO_MAX_GAIN - AUDIO_MIN_GAIN)) / 100 + AUDIO_MIN_GAIN;
+	if (maxvol)
+	{
+		info.play.balance = (right - left) * (AUDIO_RIGHT_BALANCE - AUDIO_LEFT_BALANCE);
+		info.play.balance /= 2 * maxvol;
+		info.play.balance += AUDIO_MID_BALANCE;
+	}
+
+	if (ioctl(priv->fd, AUDIO_SETINFO, &info) < 0)
+	{
+		perror("error: AUDIO_SETINFO\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int sol_mixer_get(struct sysdep_mixer_struct *mixer, int channel, int *left, int *right)
+{
+	audio_info_t info;
+	struct sol_mixer_priv_data *priv = mixer->_priv;
+
+	if (ioctl(priv->fd, AUDIO_GETINFO, &info) < 0)
+	{
+		perror("error: AUDIO_GETINFO\n");
+		return -1;
+	}
+	
+	if (info.play.balance > AUDIO_MID_BALANCE)
+	{
+		*right = ((info.play.gain - AUDIO_MIN_GAIN) * 100) / (AUDIO_MAX_GAIN - AUDIO_MIN_GAIN);
+		*left = *right * ((AUDIO_RIGHT_BALANCE - (float)info.play.balance) / AUDIO_MID_BALANCE);
+	}
+	else
+	{
+		*left = ((info.play.gain - AUDIO_MIN_GAIN) * 100) / (AUDIO_MAX_GAIN - AUDIO_MIN_GAIN);
+		*right = *left * ((float)info.play.balance / AUDIO_MID_BALANCE);
+	}
+	return 0;
+}
+
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/plugin_manager.c mame-0.36b16/src/unix/sysdep/plugin_manager.c
--- ../mmmmm/m36b16/src/unix/sysdep/plugin_manager.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/plugin_manager.c	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,247 @@
+/* A simple plugin manager
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, January 2000
+-initial release (Hans de Goede)
+*/
+#include <stdlib.h>
+#include <string.h>
+#include "plugin_manager.h"
+#include "plugin_manager_priv.h"
+#include "misc.h"
+
+/* private methods */
+static int plugin_manager_add(struct plugin_manager_struct *manager,
+   struct plugin_manager_data *data)
+{
+   int i;
+   
+   /* does the plugin have the correct type? */
+   if(strcmp(data->plugin->type, manager->type))
+   {
+      fprintf(stderr,
+         "error: trying to add \"%s\" type plugin, to \"%s\" type plugin manager\n",
+         data->plugin->type, manager->type);
+      return -1;
+   }
+   
+   for(i=0; i < manager->data_size; i++)
+      if(!manager->data[i].plugin)
+         break;
+         
+   if(i == manager->data_size)
+   {
+      struct plugin_manager_data *tmp;
+      
+      if(!(tmp=realloc(manager->data, (manager->data_size+BUF_SIZE) *
+         sizeof(struct plugin_manager_data))))
+      {
+         fprintf(stderr, "error reallocating plugin data\n");
+         return -1;
+      }
+      manager->data = tmp;
+      memset(manager->data + manager->data_size, 0,
+         sizeof(struct plugin_manager_data) * BUF_SIZE);
+      manager->data_size += BUF_SIZE;
+   }
+   
+   if (manager->rc && data->plugin->opts &&
+      rc_register(manager->rc, data->plugin->opts))
+      return -1;
+   
+   if (data->plugin->priority > manager->highest_priority)
+      manager->highest_priority = data->plugin->priority;
+   
+   manager->data[i] = *data;
+
+   return 0;
+}
+
+static void plugin_manager_remove(struct plugin_manager_struct *manager,
+   int id)
+{
+   if(manager->rc && manager->data[id].plugin->opts)
+      rc_unregister(manager->rc, manager->data[id].plugin->opts);
+      
+   if(manager->data[id].initialised && manager->data[id].plugin->exit)
+      manager->data[id].plugin->exit();
+   
+   if(manager->data[id].plugin_handle)
+   {
+      /* TODO implement dlclose */
+   }
+   memset(manager->data + id, 0, sizeof(struct plugin_manager_data));
+}
+
+/* public methods (in plugin_manager.h) */
+struct plugin_manager_struct *plugin_manager_create(const char *type,
+   struct rc_struct *rc)
+{
+   struct plugin_manager_struct *manager = NULL;
+   
+   /* allocate the plugin_manager struct */
+   if (!(manager = calloc(1, sizeof(struct plugin_manager_struct))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct plugin_manager_struct\n");
+      return NULL;
+   }
+   manager->type = type;
+   manager->rc   = rc;
+   return manager;
+}
+
+void plugin_manager_destroy(struct plugin_manager_struct *manager)
+{
+   plugin_manager_unload(manager, NULL);
+   free(manager);
+}
+
+int plugin_manager_register(struct plugin_manager_struct *manager,
+   const struct plugin_struct *plugin[])
+{
+   int i;
+   struct plugin_manager_data data = { NULL, NULL, 0 };
+   
+   for(i=0; plugin[i]; i++)
+   {
+      data.plugin = plugin[i];
+      if(plugin_manager_add(manager, &data))
+         return -1;
+   }
+   return 0;
+}
+
+void plugin_manager_unregister(struct plugin_manager_struct *manager,
+   const struct plugin_struct *plugin[])
+{
+   int i, j;
+   
+   /* remove all */
+   if (!plugin)
+   {
+      plugin_manager_unload(manager, NULL);
+      return;
+   }
+      
+   for(i=0; plugin[i]; i++)
+   {
+      for(j=0; j < manager->data_size; j++)
+      {
+         if(manager->data[j].plugin == plugin[i])
+         {
+            plugin_manager_remove(manager, j);
+            break;
+         }
+      }
+   }
+}
+
+int plugin_manager_load(struct plugin_manager_struct *manager,
+   const char *path, const char *name)
+{
+   /* TODO: implement me */
+   return 0;
+}
+
+void plugin_manager_unload(struct plugin_manager_struct *manager,
+   const char *name)
+{
+   int i;
+   
+   for(i=0; i < manager->data_size; i++)
+   {
+      if(manager->data[i].plugin &&
+         (!name || !strcmp(name, manager->data[i].plugin->name)))
+      {
+         plugin_manager_remove(manager, i);
+      }
+   }
+}
+
+static void *plugin_manager_init_and_or_create(
+   struct plugin_manager_struct *manager, const char *name, int load,
+   void *flags)
+{
+   int i, priority;
+   void *result = NULL;
+
+   for(priority=manager->highest_priority; priority>=0; priority--)
+   {
+      for(i=0; i<manager->data_size; i++)
+      {
+         if(manager->data[i].plugin &&
+            (manager->data[i].plugin->priority == priority) &&
+            (!name || !strcmp(name, manager->data[i].plugin->name)) )
+         {
+            if(!manager->data[i].initialised &&
+               manager->data[i].plugin->init &&
+               manager->data[i].plugin->init())
+            {  /* init failed */
+               plugin_manager_remove(manager, i);
+               continue;
+            }
+            /* no init needed, or init successfull */
+            manager->data[i].initialised = 1;
+            if (load)
+            {
+               if((result = manager->data[i].plugin->create(flags)))
+               {
+                  /* if no name was given tell them which plugin we're
+                     using */
+                  if(!name)
+                     fprintf(stderr, "info: %s: using %s plugin\n",
+                        manager->type, manager->data[i].plugin->name);
+                  return result;
+               }
+            }
+            else
+               result = (void *)-1;
+         }
+      }
+   }
+   return result;
+}
+
+int plugin_manager_init_plugin(struct plugin_manager_struct *manager,
+   const char *name)
+{
+   if(!plugin_manager_init_and_or_create(manager, name, 0, NULL))
+      return -1;
+
+   return 0;
+}
+
+void *plugin_manager_create_instance(struct plugin_manager_struct *manager,
+   const char *name, void *flags)
+{
+   return plugin_manager_init_and_or_create(manager, name, 1, flags);
+}
+
+void plugin_manager_list_plugins(struct plugin_manager_struct *manager,
+   FILE *f)
+{
+   int i;
+   
+   for(i=0; i < manager->data_size; i++)
+      if(manager->data[i].plugin)
+         fprint_colums(f, manager->data[i].plugin->name,
+            manager->data[i].plugin->description);
+}
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/plugin_manager.h mame-0.36b16/src/unix/sysdep/plugin_manager.h
--- ../mmmmm/m36b16/src/unix/sysdep/plugin_manager.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/plugin_manager.h	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,103 @@
+/* A simple plugin manager
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __PLUGIN_MANAGER_H
+#define __PLUGIN_MANAGER_H
+#include <stdio.h>
+#include "rc.h"
+#include "begin_code.h"
+
+struct plugin_struct
+{
+   const char *name;             /* name of plugin */
+   const char *type;             /* type of plugin */
+   const char *description;      /* description of plugin */
+   struct rc_option *opts;       /* options for this plugin */
+   int (*init)(void);            /* f-ptr which inits the plugin if nescesarry
+                                    */
+   void (*exit)(void);           /* cleans up before unloading */
+   void *(*create)(const void *flags);
+                                 /* creates an instance of the object
+                                    associated with the type of pluging we're
+                                    managing.
+                                    The plugin system has no knowledge of this
+                                    object, but the object which uses the
+                                    plugin system should have knowledge about
+                                    it. */
+   int priority;                 /* higher priority plugins are checked first
+                                    when checking multiple plugins. (for
+                                    auto plugin selection for example) */
+};
+
+struct plugin_manager_struct;
+
+/* Creates a plugin manager struct, doesn't do much else */
+struct plugin_manager_struct *plugin_manager_create(const char *type,
+   struct rc_struct *rc);
+
+/* Free all data, unload all plugins etc */
+void plugin_manager_destroy(struct plugin_manager_struct *manager);
+
+/* Register the NULL ptr terminated list of plugins, mainly usefull,
+   to register static plugins. */
+int plugin_manager_register(struct plugin_manager_struct *manager,
+   const struct plugin_struct *plugin[]);
+
+/* Unregister (and if not static unloads) the NULL ptr terminated list of
+   plugins, if plugin == NULL, all plugins are unregistered */
+void plugin_manager_unregister(struct plugin_manager_struct *manager,
+   const struct plugin_struct *plugin[]);
+
+/* Loads plugin(s) from:
+   <path>/<name>.so
+   If name == NULL all plugins in <path> are loaded.
+   
+   Returns:
+   0 if one or more plugins we're successfully loaded -1 otherwise */
+int plugin_manager_load(struct plugin_manager_struct *manager,
+   const char *path, const char *name);
+   
+/* Unloads (if not static) and unregisters plugins matching name, if
+   name == NULL, all plugins are unloaded.
+   If one or more plugins where unloaded successfully 0 is returned,
+   otherwise -1 is returned */
+void plugin_manager_unload(struct plugin_manager_struct *manager,
+   const char *name);
+
+/* Initialises the plugin(s) matching name. If name == NULL all plugins are
+   initialised starting with the ones with the highest priority.
+   If one or more plugins where initialised successfully 0 is returned,
+   otherwise -1 is returned */
+int plugin_manager_init_plugin(struct plugin_manager_struct *manager,
+   const char *name);
+
+/* Creates an instance of the object associated with the type of plugin which
+   is being managed. The instance is created using the plugin matching name,
+   which will first be initialised if nescesarry. If name == NULL all plugins
+   are tried untill the instance has been created, starting with the ones with
+   the highest priority.
+   On success 0 is returned, on failure -1 is returned */
+void *plugin_manager_create_instance(struct plugin_manager_struct *manager,
+   const char *name, void *flags);
+   
+void plugin_manager_list_plugins(struct plugin_manager_struct *manager,
+   FILE *f);
+
+#include "end_code.h"
+#endif /* #ifndef __PLUGIN_MANAGER_H */
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/plugin_manager_priv.h mame-0.36b16/src/unix/sysdep/plugin_manager_priv.h
--- ../mmmmm/m36b16/src/unix/sysdep/plugin_manager_priv.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/plugin_manager_priv.h	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,52 @@
+/* A simple plugin manager
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __PLUGIN_MANAGER_PRIV_H
+#define __PLUGIN_MANAGER_PRIV_H
+
+#include "begin_code.h"
+
+struct plugin_manager_data {
+   const struct plugin_struct *plugin; 
+                                 /* the plugin_plugin struct describing
+                                    the plugin, or NULL for a removed plugin */
+   void *plugin_handle;          /* void * for the dynamic linker handles,
+                                    or NULL for static / unloaded plugins */
+   int initialised;              /* is the plugin checked? (plugins
+                                    which fail there check are removed from
+                                    the list */
+};
+
+struct plugin_manager_struct
+{
+   const char *type;             /* type of the plugins which are
+                                    managed by this instance of the plugin
+                                    manager */
+   struct rc_struct *rc;         /* rc object where the options for
+                                    added plugins should be registered */
+   struct plugin_manager_data *data;
+                                 /* array of data for the loaded plugins */
+   int data_size;                /* size of this array, to know when it
+                                    should be reallocated */
+   int highest_priority;         /* keeps count of the highest priority plugin
+                                    added */
+};
+
+#include "end_code.h"
+#endif /* #ifndef __PLUGIN_MANAGER_PRIV_H */
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/rc.c mame-0.36b16/src/unix/sysdep/rc.c
--- ../mmmmm/m36b16/src/unix/sysdep/rc.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/rc.c	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,749 @@
+/* A simple rcfile and commandline parsing mechanism
+
+   Copyright 1999,2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, December 1999
+-Initial release (Hans de Goede)
+Version 0.2, January 2000
+-Fixed priority parsing for booleans (Hans de Goede)
+-Fixed error messages for: "error optionx requires an argument". (Hans de
+ Goede)
+-Fixed --boolean option parsing. (Hans de Goede)
+Version 0.3, Februari 2000
+-Reworked and cleaned up the interface, broke backward compatibility (Hans
+ de Goede)
+*/
+#include <stdlib.h>
+#include <string.h>
+#include <pwd.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include "rc.h"
+#include "rc_priv.h"
+#include "misc.h"
+
+/* private variables */
+static int rc_requires_arg[] = {0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0 };
+
+/* private methods */
+static int rc_verify(struct rc_option *option, float value)
+{
+   if(option->min == option->max)
+      return 0;
+      
+   if( (value < option->min) || (value > option->max) )
+      return -1;
+
+   return 0;
+}
+
+static int rc_set_defaults(struct rc_option *option)
+{
+   int i;
+
+   /* set the defaults */
+   for(i=0; option[i].type; i++)
+   {
+      if (option[i].type == rc_link)
+      {
+         if(rc_set_defaults(option[i].dest))
+            return -1;
+      }
+      else if (option[i].deflt && rc_set_option3(option+i, option[i].deflt,
+         option[i].priority))
+         return -1;
+   }
+   
+   return 0;
+}
+
+static void rc_free_stuff(struct rc_option *option)
+{
+   int i;
+   
+   for(i=0; option[i].type; i++)
+   {
+      switch (option[i].type)
+      {
+         case rc_link:
+            rc_free_stuff(option[i].dest);
+            break;
+         case rc_string:
+            if(*(char **)option[i].dest)
+               free(*(char **)option[i].dest);
+            break;
+         case rc_file:
+            if(*(FILE **)option[i].dest)
+               fclose(*(FILE **)option[i].dest);
+            break;
+      }
+   }
+}
+
+/* public methods (in rc.h) */
+struct rc_struct *rc_create(void)
+{
+   struct rc_struct *rc = NULL;
+   
+   if(!(rc = calloc(1, sizeof(struct rc_struct))))
+   {
+      fprintf(stderr, "error: malloc failed for: struct rc_struct\n");
+      return NULL;
+   }
+   
+   return rc;
+}
+
+void rc_destroy(struct rc_struct *rc)
+{
+   if(rc->option)
+   {
+      rc_free_stuff(rc->option);
+      free (rc->option);
+   }
+   if(rc->arg)
+      free(rc->arg);
+   free(rc);
+}
+
+int rc_register(struct rc_struct *rc, struct rc_option *option)
+{
+   int i;
+   
+   /* try to find a free entry in our option list */
+   for(i = 0; i < rc->option_size; i++)
+      if(rc->option[i].type <= 0)
+         break;
+
+   /* do we have space to register this option list ? */
+   if(i >= (rc->option_size-1))
+   {
+      struct rc_option *tmp = realloc(rc->option,
+         (rc->option_size + BUF_SIZE) * sizeof(struct rc_option));
+      if (!tmp)
+      {
+         fprintf(stderr, "error: malloc failed in rc_register_option\n");
+         return -1;
+      }
+      rc->option = tmp;
+      memset(rc->option + rc->option_size, 0, BUF_SIZE * 
+         sizeof(struct rc_option));
+      rc->option_size += BUF_SIZE;
+   }
+   
+   /* set the defaults */
+   if(rc_set_defaults(option))
+      return -1;
+   
+   /* register the option */
+   rc->option[i].type = rc_link;
+   rc->option[i].dest = option;
+   
+   return 0;
+}
+
+int rc_unregister(struct rc_struct *rc, struct rc_option *option)
+{
+   int i;
+   
+   /* try to find the entry in our option list, unregister later registered
+      duplicates first */
+   for(i = rc->option_size - 1; i >= 0; i--)
+   {
+      if(rc->option[i].dest == option)
+      {
+         memset(rc->option + i, 0, sizeof(struct rc_option));
+         rc->option[i].type = rc_ignore;
+         return 0;
+      }
+   }
+   
+   return -1;
+}
+
+int rc_load(struct rc_struct *rc, const char *name,
+   int priority, int continue_on_errors)
+{
+   FILE *f;
+   
+   fprintf(stderr, "info: trying to parse: %s\n", name);
+   
+   if (!(f = fopen(name, "r")))
+      return 0;
+      
+   return rc_read(rc, f, name, priority, continue_on_errors);
+}
+   
+int rc_save(struct rc_struct *rc, const char *name, int append)
+{
+   FILE *f;
+   
+   if (!(f = fopen(name, append? "a":"w")))
+      return -1;
+      
+   return rc_write(rc, f, name);
+}
+
+int rc_read(struct rc_struct *rc, FILE *f, const char *description,
+   int priority, int continue_on_errors)
+{
+   char buf[BUF_SIZE];
+   int line = 0;
+   
+   while(fgets(buf, BUF_SIZE, f))
+   {
+      struct rc_option *option;
+      char *name, *tmp, *arg = NULL;
+      
+      line ++;
+      
+      if(!(name = strtok(buf, " \t\r\n")))
+         continue;
+      if(name[0] == '#')
+         continue;
+         
+      if(!(option = rc_get_option2(rc->option, name)))
+      {
+         fprintf(stderr, "error: unknown option %s, on line %d of file: %s\n",
+            name, line, description);
+      }
+      else if (rc_requires_arg[option->type] &&
+         !(arg = strtok(NULL, " \t\r\n")))
+      {
+         fprintf(stderr,
+            "error: %s requires an argument, on line %d of file: %s\n",
+            name, line, description);
+      }
+      else if ( (tmp = strtok(NULL, " \t\r\n")) && (tmp[0] != '#') )
+      {
+         fprintf(stderr,
+            "error: trailing garbage: \"%s\" on line: %d of file: %s\n",
+            tmp, line, description);
+      }
+      else if (!rc_set_option3(option, arg, priority))
+         continue;
+      
+      if (continue_on_errors)
+         fprintf(stderr, "   ignoring line\n");
+      else
+         return -1;
+   }
+   return 0;
+}
+
+/* needed to walk the tree */
+static int rc_real_write(struct rc_option *option, FILE *f,
+   const char *description)
+{
+   int i;
+   
+   if (description)
+      fprintf(f, "### %s ###\n", description);   
+   
+   for(i=0; option[i].type; i++)
+   {
+      switch (option[i].type)
+      {
+         case rc_seperator:
+            fprintf(f, "\n### %s ###\n", option[i].name);
+            break;
+         case rc_link:
+            if(rc_real_write(option[i].dest, f, NULL))
+               return -1;
+            break;
+         case rc_string:
+            if(!*(char **)option[i].dest)
+            {
+               fprintf(f, "# %-19s   <NULL> (not set)\n", option[i].name);
+               break;
+            }
+         case rc_bool:
+         case rc_int:
+         case rc_float:
+            fprintf(f, "%-21s   ", option[i].name);
+            switch(option[i].type)
+            {
+               case rc_bool:
+               case rc_int:
+                  fprintf(f, "%d\n", *(int *)option[i].dest);
+                  break;
+               case rc_float:
+                  fprintf(f, "%f\n", *(float *)option[i].dest);
+                  break;
+               case rc_string:
+                  fprintf(f, "%s\n", *(char **)option[i].dest);
+                  break;
+            }
+            break;
+      }
+   }
+   if (description)
+      fprintf(f, "\n");   
+   return 0;
+}
+
+int rc_write(struct rc_struct *rc, FILE *f, const char *description)
+{
+   return rc_real_write(rc->option, f, description);
+}
+
+int rc_parse_commandline(struct rc_struct *rc, int argc, char *argv[],
+   int priority, int (*arg_callback)(char *arg))
+{
+   int i;
+   
+   for(i=1; i<argc; i++)
+   {
+      if(argv[i][0] == '-')
+      {
+         int start = 1;
+         struct rc_option *option;
+         char *arg = NULL;
+         
+         if(argv[i][1] == '-')
+            start = 2;
+         
+         if((option = rc_get_option2(rc->option, argv[i] + start)))
+         {
+            if (option->type == rc_bool)
+            {
+               /* handle special bool set case */
+               arg = "1";
+            }
+            else
+            {
+               /* normal option */
+               if (rc_requires_arg[option->type])
+               {
+                  i++;
+                  if (i >= argc)
+                  {
+                     fprintf(stderr, "error: %s requires an argument\n", argv[i-1]);
+                     return -1;
+                  }
+                  arg = argv[i];
+               }
+            }
+         }
+         else if(!strncmp(argv[i] + start, "no", 2) &&
+            (option = rc_get_option2(rc->option, argv[i] + start + 2)) &&
+            (option->type == rc_bool))
+         {
+            /* handle special bool clear case */
+            arg = "0";
+         }
+         else
+         {
+            fprintf(stderr, "error: unknown option %s\n", argv[i]);
+            return -1;
+         }
+         
+         if(rc_set_option3(option, arg, priority))
+            return -1;
+      }
+      else
+      {
+         /* do we have space to register the non-option arg */
+         if(rc->args_registered >= (rc->arg_size))
+         {
+            char **tmp = realloc(rc->arg, (rc->arg_size + BUF_SIZE) *
+               sizeof(char *));
+            if (!tmp)
+            {
+               fprintf(stderr,
+                  "error: malloc failed in rc_parse_commadline\n");
+               return -1;
+            }
+            rc->arg = tmp;
+            memset(rc->arg + rc->arg_size, 0, BUF_SIZE * sizeof(char *));
+            rc->arg_size += BUF_SIZE;
+         }
+         
+         /* register the non-option arg */
+         rc->arg[rc->args_registered] = argv[i];
+         rc->args_registered++;
+         
+         /* call the callback if defined */
+         if(arg_callback && (*arg_callback)(argv[i]))
+            return -1;
+      }
+   }
+   return 0;
+}
+
+int rc_get_non_option_args(struct rc_struct *rc, int *argc, char **argv[])
+{
+   *argv = rc->arg;
+   *argc = rc->args_registered;
+   return 0;
+}
+
+/* needed to walk the tree */
+static void rc_real_print_help(struct rc_option *option, FILE *f)
+{
+   int i;
+   char buf[BUF_SIZE];
+   static const char *type_name[] = {"", "", " <string>", " <int>", " <float>",
+      "", "", " <filename>", " <arg>", "", "" };
+   
+   for(i=0; option[i].type; i++)
+   {
+      switch (option[i].type)
+      {
+         case rc_ignore:
+            break;
+         case rc_seperator:
+            fprintf(f, "\n*** %s ***\n", option[i].name);
+            break;
+         case rc_link:
+            rc_real_print_help(option[i].dest, f);
+            break;
+         default:
+            snprintf(buf, BUF_SIZE, "-%s%s%s%s%s%s",
+               (option[i].type == rc_bool)? "[no]":"",
+               option[i].name,
+               (option[i].shortname)? " / -":"",
+               (option[i].shortname && (option[i].type == rc_bool))? "[no]":"",
+               (option[i].shortname)? option[i].shortname:"",
+               type_name[option[i].type]);
+            fprint_colums(f, buf,
+               (option[i].help)? option[i].help:"no help available");
+      }
+   }
+}
+
+void rc_print_help(struct rc_struct *rc, FILE *f)
+{
+   rc_real_print_help(rc->option, f);
+}
+
+/* needed to walk the tree */
+static void rc_real_print_man_options(struct rc_option *option, FILE *f)
+{
+   int i;
+   static const char *type_name[] = {"", "", " Ar string", " Ar int",
+      " Ar float", "", "", " Ar filename", " Ar arg", "", "" };
+   
+   for(i=0; option[i].type; i++)
+   {
+      switch (option[i].type)
+      {
+         case rc_ignore:
+            break;
+         case rc_seperator:
+            fprintf(f, ".It \\fB*** %s ***\\fR\n", option[i].name);
+            break;
+         case rc_link:
+            rc_real_print_man_options(option[i].dest, f);
+            break;
+         default:
+            fprintf(f, ".It Fl %s%s%s%s%s%s\n%s\n",
+               (option[i].type == rc_bool)? "[no]":"",
+               option[i].name,
+               (option[i].shortname)? " , ":"",
+               (option[i].shortname && (option[i].type == rc_bool))? "[no]":"",
+               (option[i].shortname)? option[i].shortname:"",
+               type_name[option[i].type],
+               (option[i].help)? option[i].help:"no help available");
+      }
+   }
+}
+
+void rc_print_man_options(struct rc_struct *rc, FILE *f)
+{
+   rc_real_print_man_options(rc->option, f);
+}
+
+int rc_verify_power_of_2(struct rc_option *option, const char *arg,
+   int priority)
+{
+   int i, value;
+   
+   value = *(int *)option->dest;
+   
+   for(i=0; i<(sizeof(int)*8); i++)
+      if(((int)0x01 << i) == value)
+         break;
+   if(i == (sizeof(int)*8))
+   {
+      fprintf(stderr, "error invalid value for %s: %s\n", option->name, arg);
+      return -1;
+   }
+   
+   option->priority = priority;
+   
+   return 0;
+}
+
+int rc_option_requires_arg(struct rc_struct *rc, const char *name)
+{
+   return rc_option_requires_arg2(rc->option, name);
+}
+
+int rc_option_requires_arg2(struct rc_option *option, const char *name)
+{
+   struct rc_option *my_option;
+   
+   if(!(my_option = rc_get_option2(option, name)))
+   {
+      fprintf(stderr, "error: unknown option %s\n", name);
+      return -1;
+   }
+   return rc_requires_arg[my_option->type];
+}
+
+int rc_option_requires_arg3(struct rc_option *option)
+{
+   return rc_requires_arg[option->type];
+}
+
+int rc_get_priority(struct rc_struct *rc, const char *name)
+{
+   return rc_get_priority2(rc->option, name);
+}
+
+int rc_get_priority2(struct rc_option *option, const char *name)
+{
+   struct rc_option *my_option;
+   
+   if(!(my_option = rc_get_option2(option, name)))
+   {
+      fprintf(stderr, "error: unknown option %s\n", name);
+      return -1;
+   }
+   return my_option->priority;
+}
+
+int rc_get_priority3(struct rc_option *option)
+{
+   return option->priority;
+}
+
+int rc_set_option(struct rc_struct *rc, const char *name, const char *arg,
+   int priority)
+{
+   return rc_set_option2(rc->option, name, arg, priority);
+}
+
+int rc_set_option2(struct rc_option *option, const char *name,
+   const char *arg, int priority)
+{
+   struct rc_option *my_option;
+   
+   if(!(my_option = rc_get_option2(option, name)))
+   {
+      fprintf(stderr, "error: unknown option %s\n", name);
+      return -1;
+   }
+   return rc_set_option3(my_option, arg, priority);
+}
+
+int rc_set_option3(struct rc_option *option, const char *arg, int priority)
+{
+   char *end;
+   
+   /* check priority */
+   if(priority < option->priority)
+      return 0;
+   
+   switch(option->type)
+   {
+      case rc_string:
+         {
+            char *str;
+            if ( !( str = malloc(strlen(arg)+1) ) )
+            {
+               fprintf(stderr, "error: malloc failed for %s\n", option->name);
+               return -1;
+            }
+            strcpy(str, arg);
+            if(*(char **)option->dest)
+               free(*(char **)option->dest);
+            *(char **)option->dest = str;
+         }
+         break;
+      case rc_int:
+      case rc_bool:
+         {
+            int x;
+            x = strtol(arg, &end, 0);
+            if (*end || rc_verify(option, x))
+            {
+               fprintf(stderr, "error invalid value for %s: %s\n", option->name, arg);
+               return -1;
+            }
+            *(int *)option->dest = x;
+         }
+         break;
+      case rc_float:
+         {
+            float x;
+            x = strtod(arg, &end);
+            if (*end || rc_verify(option, x))
+            {
+               fprintf(stderr, "error invalid value for %s: %s\n", option->name, arg);
+               return -1;
+            }
+            *(float *)option->dest = x;
+         }
+         break;
+      case rc_set_int:
+         *(int*)option->dest = option->min;
+         break;
+      case rc_file:
+         {
+            FILE *f = fopen(arg, (option->min)? "w":"r");
+            if(!f)
+            {
+               fprintf(stderr, "error: couldn't open file: %s\n", arg);
+               return -1;
+            }
+            if (*(FILE **)option->dest)
+               fclose(*(FILE **)option->dest);
+            *(FILE **)option->dest = f;
+         }
+         break;
+      case rc_use_function:
+      case rc_use_function_no_arg:
+         break;
+      default:
+         fprintf(stderr,
+            "error: unknown option type: %d, this should not happen!\n",
+            option->type);
+         return -1;
+   }
+   /* functions should do there own priority handling, so that they can
+      ignore priority handling if they wish */
+   if(option->func)
+      return (*option->func)(option, arg, priority);
+   
+   option->priority = priority;
+   
+   return 0;
+}
+
+struct rc_option *rc_get_option(struct rc_struct *rc, const char *name)
+{
+   return rc_get_option2(rc->option, name);
+}
+
+struct rc_option *rc_get_option2(struct rc_option *option, const char *name)
+{
+   int i;
+   struct rc_option *result;
+   
+   for(i=0; option[i].type; i++)
+   {
+      switch(option[i].type)
+      {
+         case rc_ignore:
+         case rc_seperator:
+            break;
+         case rc_link:
+            if((result = rc_get_option2(option[i].dest, name)))
+               return result;
+            break;
+         default:
+            if(!strcmp(name, option[i].name) ||
+               (option[i].shortname &&
+                  !strcmp(name, option[i].shortname)))
+               return &option[i];
+      }
+   }
+   return NULL;
+}
+
+/* gimmi the entire tree, I want todo all the parsing myself */
+struct rc_option *rc_get_options(struct rc_struct *rc)
+{
+   return rc->option;
+}
+
+/* various utility methods which don't really belong to the rc object,
+   but seem to fit here well */
+
+/* locate user's home directory */
+char *rc_get_home_dir(void)
+{
+   struct passwd *pw;
+   char *s;
+   
+   if (!(pw=getpwuid(getuid())))
+   { 
+      fprintf(stderr, "Who are you? Not found in passwd database!!\n");
+      return NULL;
+   }
+   if (!(s=malloc(strlen(pw->pw_dir)+1)))
+   {
+      fprintf(stderr, "error: malloc faild for homedir string\n");
+      return NULL;
+   }
+   strcpy(s, pw->pw_dir);
+   return s;
+}
+
+/* 
+ * check and if nescesarry create dir
+ */
+int rc_check_and_create_dir(const char *name)
+{
+   struct stat stat_buffer;
+
+   if (stat(name, &stat_buffer))
+   {
+      /* error check if it doesn't exist or something else is wrong */
+      if (errno == ENOENT)
+      {
+         /* doesn't exist letts create it ;) */
+#ifdef BSD43
+	 if (mkdir(name, 0775))
+#else
+         if (mkdir(name, S_IRWXU|S_IRWXG|S_IROTH|S_IXOTH))
+#endif
+         {
+            fprintf(stderr, "Error creating dir %s", name);
+            perror(" ");
+            return -1;
+         }
+      }
+      else
+      {
+         /* something else went wrong yell about it */
+         fprintf(stderr, "Error opening %s", name);
+         perror(" ");
+         return -1;
+      }
+   }
+   else
+   {
+      /* file exists check it's a dir otherwise yell about it */
+#ifdef BSD43
+      if(!(S_IFDIR & stat_buffer.st_mode))
+#else
+      if(!S_ISDIR(stat_buffer.st_mode))
+#endif
+      {
+         fprintf(stderr,"Error %s exists but isn't a dir\n", name);
+         return -1;
+      }
+   }
+   return 0;
+}
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/rc.h mame-0.36b16/src/unix/sysdep/rc.h
--- ../mmmmm/m36b16/src/unix/sysdep/rc.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/rc.h	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,125 @@
+/* A simple rcfile and commandline parsing mechanism
+
+   Copyright 1999,2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __RC_H
+#define __RC_H
+
+#include <stdio.h>
+#include "begin_code.h"
+
+struct rc_struct;
+struct rc_option;
+
+enum { rc_ignore = -1, rc_end, rc_bool, rc_string, rc_int, rc_float,
+   rc_set_int, rc_seperator, rc_file, rc_use_function,
+   rc_use_function_no_arg, rc_link };
+
+typedef int(*rc_func)(struct rc_option *option, const char *arg,
+   int priority);
+
+struct rc_option
+{
+   const char *name;  /* name of the option */
+   const char *shortname;  /* shortcut name of the option, or clear for bool */
+   int type;          /* type of the option */
+   void *dest;        /* ptr to where the value of the option should be stored */
+   const char *deflt; /* default value of the option in a c-string */
+   float min;         /* used to verify rc_int or rc_float, this check is not */
+   float max;         /* done if min == max. min is also used as value for
+                         set_int, and as write flag for rc_file. */
+   rc_func func;      /* function which is called for additional verification
+                         of the value, or which is called to parse the value if
+                         type == use_function, or NULL. Should return 0 on
+                         success, -1 on failure */
+   const char *help;  /* help text for this option */
+   int priority;      /* priority of the current value, the current value
+                         is only changed when the priority of the source
+                         is higher as this, and then the priority is set to
+                         the priority of the source */
+};
+
+/* open / close */
+struct rc_struct *rc_create(void);
+void rc_destroy(struct rc_struct *rc);
+
+/* register / unregister */
+int rc_register(struct rc_struct *rc, struct rc_option *option);
+int rc_unregister(struct rc_struct *rc, struct rc_option *option);
+
+/* load/save (read/write) a configfile */
+int rc_load(struct rc_struct *rc, const char *name, int priority,
+   int continue_on_errors);
+int rc_save(struct rc_struct *rc, const char *name, int append);
+int rc_read(struct rc_struct *rc, FILE *f, const char *description,
+   int priority, int continue_on_errors);
+int rc_write(struct rc_struct *rc, FILE *f, const char *description);
+
+/* commandline handling */
+int rc_parse_commandline(struct rc_struct *rc, int argc, char *argv[],
+   int priority, int(*arg_callback)(char *arg));
+int rc_get_non_option_args(struct rc_struct *rc, int *argc, char **argv[]);
+
+/* print help */
+void rc_print_help(struct rc_struct *rc, FILE *f);
+
+/* print commandline options in manpage style */
+void rc_print_man_options(struct rc_struct *rc, FILE *f);
+
+/* some default verify functions */
+int rc_verify_power_of_2(struct rc_option *option, const char *arg,
+   int priority);
+
+/* functions which can be used in option functions or to build your own
+   parser. */
+/* 3 ways to query if an option needs arguments, to query it's priority and
+   to set it:
+   -by name, searching the options in a rc instance
+   -by name, searching an array of options, as given to rc_register
+   -using the option given (which could for example have been returned
+    by rc_get_option) */
+int rc_option_requires_arg(struct rc_struct *rc, const char *name);
+int rc_option_requires_arg2(struct rc_option *option, const char *name);
+int rc_option_requires_arg3(struct rc_option *option);
+
+int rc_get_priority(struct rc_struct *rc, const char *name);
+int rc_get_priority2(struct rc_option *option, const char *name);
+int rc_get_priority3(struct rc_option *option);
+
+int rc_set_option(struct rc_struct *rc, const char *name, const char *arg,
+   int priority);
+int rc_set_option2(struct rc_option *option, const char *name,
+   const char *arg, int priority);
+int rc_set_option3(struct rc_option *option, const char *arg, int priority);
+   
+/* 2 ways to get the option_struct belonging to a certain option:
+   -by name, searching the options in a rc instance
+   -by name, searching an array of options, as given to rc_register */
+struct rc_option *rc_get_option(struct rc_struct *rc, const char *name);
+struct rc_option *rc_get_option2(struct rc_option *option, const char *name);
+
+/* gimmi the entire tree, I want todo all the parsing myself */
+struct rc_option *rc_get_options(struct rc_struct *rc);
+
+/* various utility functions which don't really belong to the rc object,
+   but seem to fit here well */
+int rc_check_and_create_dir(const char *name);
+char *rc_get_home_dir(void);
+
+#include "end_code.h"
+#endif /* ifndef __RC_H */
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/rc_priv.h mame-0.36b16/src/unix/sysdep/rc_priv.h
--- ../mmmmm/m36b16/src/unix/sysdep/rc_priv.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/rc_priv.h	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,36 @@
+/* A simple rcfile and commandline parsing mechanism
+
+   Copyright 1999,2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __RC_PRIV_H
+#define __RC_PRIV_H
+
+#include "rc.h"
+#include "begin_code.h"
+
+struct rc_struct
+{
+   struct rc_option *option;
+   int option_size;
+   char **arg;
+   int arg_size;
+   int args_registered;
+};
+
+#include "end_code.h"
+#endif /* ifndef __RC_PRIV_H */
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/sound_stream.c mame-0.36b16/src/unix/sysdep/sound_stream.c
--- ../mmmmm/m36b16/src/unix/sysdep/sound_stream.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/sound_stream.c	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,248 @@
+/* Sound stream object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, March 2000
+-initial release (Hans de Goede)
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "sound_stream.h"
+#include "sound_stream_priv.h"
+#include "fifo.h"
+
+/* #define SOUND_STREAM_DEBUG */
+/* #define SOUND_STREAM_WARNING */
+
+/* private methods */
+FIFO(INLINE, sample_buf, struct sound_stream_sample_buf *)
+
+/* public methods (in sound_stream.h) */
+struct sound_stream_struct *sound_stream_create(struct sysdep_dsp_struct* dsp,
+   int type, int buf_size, int buf_count)
+{
+   int i, bytes_per_sample[] = SYSDEP_DSP_BYTES_PER_SAMPLE;
+   struct sound_stream_struct *stream = NULL;
+   
+   /* allocate the sound_stream struct */
+   if(!(stream = calloc(1, sizeof(struct sound_stream_struct))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct sound_stream_struct\n");
+      return NULL;
+   }
+   
+   /* fill in some value's */
+   stream->dsp = dsp;
+   stream->bytes_per_sample = bytes_per_sample[type];
+   stream->sample_buf_size = buf_size;
+   stream->sample_buf_count = buf_count;
+   
+   /* allocate the output buffer */
+   stream->output_buf_size = sysdep_dsp_get_max_freespace(stream->dsp);
+   if(!(stream->output_buf = calloc(stream->output_buf_size,
+      stream->bytes_per_sample)))
+   {
+      fprintf(stderr,
+         "error malloc failed for sound_stream output buffer\n");
+      sound_stream_destroy(stream);
+      return NULL;
+   }
+   
+   /* create the fifo's */
+   if(!(stream->sample_buf_fifo = sample_buf_fifo_create(
+      stream->sample_buf_count)))
+   {
+      sound_stream_destroy(stream);
+      return NULL;
+   }
+   if(!(stream->empty_sample_buf_fifo = sample_buf_fifo_create(
+      stream->sample_buf_count)))
+   {
+      sound_stream_destroy(stream);
+      return NULL;
+   }
+   
+   /* create sample_buf_count sample_buf structs */
+   if(!(stream->sample_buf = calloc(stream->sample_buf_count,
+      sizeof(struct sound_stream_sample_buf))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct sound_stream_sample_buf\n");
+      sound_stream_destroy(stream);
+      return NULL;
+   }
+   
+   /* allocate the sample_buf-buffers and fill the empty_sample_buf_fifo */
+   for(i = 0; i < stream->sample_buf_count; i++)
+   {
+      if(!(stream->sample_buf[i].data =
+         calloc(stream->sample_buf_size, stream->bytes_per_sample)))
+      {
+         fprintf(stderr,
+            "error malloc failed for sample_buf data\n");
+         sound_stream_destroy(stream);
+         return NULL;
+      }
+      sample_buf_fifo_put(stream->empty_sample_buf_fifo,
+         &stream->sample_buf[i]);
+   }
+   
+   return stream;
+}
+
+void sound_stream_destroy(struct sound_stream_struct *stream)
+{
+   int i;
+   
+   if(stream->output_buf)
+      free(stream->output_buf);
+      
+   if(stream->sample_buf_fifo)
+      sample_buf_fifo_destroy(stream->sample_buf_fifo);
+   
+   if(stream->empty_sample_buf_fifo)
+      sample_buf_fifo_destroy(stream->empty_sample_buf_fifo);
+      
+   if(stream->sample_buf)
+   {
+      for(i = 0; i < stream->sample_buf_count; i++)
+         if(stream->sample_buf[i].data)
+            free(stream->sample_buf[i].data);
+      
+      free(stream->sample_buf);
+   }
+   
+   free(stream);
+}
+
+void sound_stream_write(struct sound_stream_struct *stream,
+   unsigned char *data, int samples)
+{
+   struct sound_stream_sample_buf *sample_buf;
+   
+   /* add the samples to our sample_buf_fifo */
+   while(samples)
+   {
+      if(sample_buf_fifo_get(stream->empty_sample_buf_fifo, &sample_buf) == 0)
+      {
+         int samples_this_loop = samples;
+         
+         if(samples_this_loop > stream->sample_buf_size)
+            samples_this_loop = stream->sample_buf_size;
+         
+         sample_buf->length = samples_this_loop;
+         sample_buf->pos = 0;
+         memcpy(sample_buf->data, data, samples_this_loop *
+            stream->bytes_per_sample);
+         sample_buf_fifo_put(stream->sample_buf_fifo, sample_buf);
+         
+         samples -= samples_this_loop;
+         data += samples_this_loop * stream->bytes_per_sample;
+      }
+      else
+      {
+#ifdef SOUND_STREAM_WARNING
+         fprintf(stderr, "warning: sound_stream: fifo full, dropping sample\n");
+#endif
+         samples = 0;
+      }
+   }
+}
+
+void sound_stream_update(struct sound_stream_struct *stream)
+{
+   int freespace;
+   struct sound_stream_sample_buf *sample_buf;
+
+   /* get freespace */   
+   freespace = sysdep_dsp_get_freespace(stream->dsp);
+#ifdef SOUND_STREAM_DEBUG
+   fprintf(stderr, "debug: sound_stream: freespace = %d\n", freespace);
+#endif
+
+   while(freespace > 0)
+   {
+      int result, samples_this_loop;
+      
+      /* we peek a sample_buf since we might not completly use it, once we're
+         done we get it to disgard it. If there haven't been any writes to the
+         fifo yet it can be empty, in this case there is nothing we can do. */
+      if(sample_buf_fifo_peek(stream->sample_buf_fifo, &sample_buf))
+         return;
+      
+#ifdef SOUND_STREAM_DEBUG      
+      fprintf(stderr, "sample_buf->length = %d, sample_buf->pos = %d\n",
+         sample_buf->length, sample_buf->pos);
+#endif
+      
+      samples_this_loop = sample_buf->length - sample_buf->pos;
+      if (samples_this_loop > freespace)
+         samples_this_loop = freespace;
+      
+      result = sysdep_dsp_write(stream->dsp,
+         sample_buf->data + (sample_buf->pos * stream->bytes_per_sample),
+         samples_this_loop);
+      
+      /* woops something went wrong (EAGAIN ?!), try again next update */
+      if (result < 0)
+      {
+#ifdef SOUND_STREAM_WARNING
+         fprintf(stderr, "warning: sound_stream: sysdep_dsp_write returned -1\n");
+#endif
+         return;
+      }
+      
+      sample_buf->pos += result;
+      
+      /* was there enough space in the sound device to write the entire sample?
+         otherwise try again next update */
+      if (result < samples_this_loop)
+      {
+#ifdef SOUND_STREAM_WARNING
+         fprintf(stderr,
+            "warning: sound_stream: sysdep_dsp_write returned %d, expected %d\n",
+            result, samples_this_loop);
+#endif
+         return;
+      }
+         
+      /* is this sample_buf finished ? */
+      if(sample_buf->pos == sample_buf->length)
+      {
+         /* if we have more then one sample_buf queued, queue the next,
+            otherwise loop this one */
+         if(sample_buf_fifo_in_use(stream->sample_buf_fifo) > 1)
+         {
+            sample_buf_fifo_get(stream->sample_buf_fifo, &sample_buf);
+            sample_buf_fifo_put(stream->empty_sample_buf_fifo, sample_buf);
+         }
+         else
+         {
+#ifdef SOUND_STREAM_WARNING
+            fprintf(stderr, "warning: sound_stream: fifo empty, looping sample\n");
+#endif
+            sample_buf->pos = 0;
+         }
+      }
+      
+      freespace -= result;
+   }
+}
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/sound_stream.h mame-0.36b16/src/unix/sysdep/sound_stream.h
--- ../mmmmm/m36b16/src/unix/sysdep/sound_stream.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/sound_stream.h	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,38 @@
+/* Sound stream object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __SOUND_STREAM_H
+#define __SOUND_STREAM_H
+
+#include "sysdep_dsp.h"
+#include "begin_code.h"
+
+struct sound_stream_struct;
+
+struct sound_stream_struct *sound_stream_create(struct sysdep_dsp_struct* dsp,
+   int type, int buf_size, int buf_count);
+void sound_stream_destroy(struct sound_stream_struct *stream);
+
+void sound_stream_write(struct sound_stream_struct *stream,
+   unsigned char *data, int samples);
+
+void sound_stream_update(struct sound_stream_struct *stream);
+
+#include "end_code.h"
+#endif /* ifndef __SOUND_STREAM_H */
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/sound_stream_priv.h mame-0.36b16/src/unix/sysdep/sound_stream_priv.h
--- ../mmmmm/m36b16/src/unix/sysdep/sound_stream_priv.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/sound_stream_priv.h	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,46 @@
+/* Sound stream object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __SOUND_STREAM_PRIV_H
+#define __SOUND_STREAM_PRIV_H
+#include "sysdep_dsp.h"
+#include "begin_code.h"
+
+struct sample_buf_fifo_struct;
+
+struct sound_stream_sample_buf {
+   int length;
+   int pos;
+   unsigned char *data;
+};
+
+struct sound_stream_struct {
+   struct sysdep_dsp_struct *dsp;
+   int bytes_per_sample;
+   int sample_buf_size;
+   int sample_buf_count;
+   int output_buf_size;
+   unsigned char *output_buf;
+   struct sound_stream_sample_buf *sample_buf;
+   struct sample_buf_fifo_struct *sample_buf_fifo;
+   struct sample_buf_fifo_struct *empty_sample_buf_fifo;
+};
+
+#include "end_code.h"
+#endif /* ifndef __SOUND_STREAM_PRIV_H */
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/sysdep_display.c mame-0.36b16/src/unix/sysdep/sysdep_display.c
--- ../mmmmm/m36b16/src/unix/sysdep/sysdep_display.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/sysdep_display.c	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,440 @@
+/* Sysdep display object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, March 2000
+-initial release (Hans de Goede)
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include "sysdep_display.h"
+#include "sysdep_display_priv.h"
+#include "sysdep_display_plugins.h"
+#include "plugin_manager.h"
+
+/* private func prototypes */
+static int sysdep_display_list_plugins(struct rc_option *option,
+   const char *arg, int priority);
+
+/* private variables */
+static int sysdep_display_widthscale = 1;
+static int sysdep_display_heightscale = 1;
+static int sysdep_display_scanlines = 0;
+static float sysdep_display_hw_aspect_ratio = 1.33;
+static int sysdep_display_keep_aspect = 1;
+static char *sysdep_display_plugin = NULL;
+static struct rc_struct *sysdep_display_rc = NULL;
+static struct plugin_manager_struct *sysdep_display_plugin_manager = NULL;
+static struct rc_option sysdep_display_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "Display related", NULL,			rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "display-plugin", 	"dp",			rc_string,	&sysdep_display_plugin,
+     NULL,		0,			0,		NULL,
+     "Select which plugin to use for the display" },
+   { "list-display-plugins",  "ldp",		rc_use_function_no_arg, NULL,
+     NULL,		0,			0,		sysdep_display_list_plugins,
+     "List available display plugins" },
+   { "widthscale",	"ws",			rc_int,		&sysdep_display_widthscale,
+     "1",		1,			10,		NULL,
+     "Select the X scale factor" },
+   { "heightscale",	"hs",			rc_int,		&sysdep_display_heightscale,
+     "1",		1,			10,		NULL,
+     "Select the Y scale factor" },
+   { "scanlines",       "sl",			rc_bool,	&sysdep_display_scanlines,
+     "0",		0,			0,		NULL,
+     "Emulate / don't emulates scanlines when scaling allong the Y axis" },
+   { "display-aspect-ratio", "dar",		rc_float,	&sysdep_display_hw_aspect_ratio,
+     "1.33",		0.5,			2.0,		NULL,
+     "Set the aspect ratio of your monitor, this is used for mode selection "
+     "calculations. Usually this is 4/3 (1.33) in some cases this is 3/4 "
+     "(0.75) or even 16/9 (1.77)" },
+   { "keep-aspect",     "ka",			rc_bool,	&sysdep_display_keep_aspect,
+     "1",		0,			0,		NULL,
+     "Try / don't try to keep the correct aspect ratio when selecting the best mode" },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+static const struct plugin_struct *sysdep_display_plugins[] = {
+#ifdef SYSDEP_DISPLAY_X11
+   &sysdep_display_x11,
+#endif
+#ifdef SYSDEP_DISPLAY_DGA
+   &sysdep_display_dga,
+#endif
+#ifdef SYSDEP_DISPLAY_SVGALIB
+   &sysdep_display_svgalib,
+#endif
+   NULL
+};
+
+/* private methods */
+static int sysdep_display_list_plugins(struct rc_option *option,
+   const char *arg, int priority)
+{
+   fprintf(stdout, "Display plugins:\n\n");
+   plugin_manager_list_plugins(sysdep_display_plugin_manager, stdout);
+   
+   return -1;
+}
+
+static int sysdep_display_match_mode(struct sysdep_display_struct
+         *display, int mode)
+{
+   int ideal_width  = display->emu_mode.width  * display->widthscale;
+   int ideal_height = display->emu_mode.height * display->heightscale;
+   
+   /* does it fit at all ? */
+   if((display->modes[mode].width  < ideal_width) ||
+      (display->modes[mode].height < ideal_height) ||
+      (display->modes[mode].depth  < display->emu_mode.depth))
+      return 0;
+   
+   if(sysdep_display_keep_aspect)
+   {
+      float aspect_ratio_ratio = (display->aspect_ratio *
+         display->modes[mode].aspect_ratio) / display->emu_mode.aspect_ratio;
+
+      /* keep height? */
+      if(aspect_ratio_ratio >= 1.0)
+         ideal_width  *= aspect_ratio_ratio;
+      else
+         ideal_height /= aspect_ratio_ratio;
+   }
+
+   return ( 100 *
+      ((float)ideal_width  /
+         (abs(display->modes[mode].width  - ideal_width ) + ideal_width )) *
+      ((float)ideal_height /
+         (abs(display->modes[mode].height - ideal_height) + ideal_height)) *
+      ((float)display->emu_mode.depth / display->modes[mode].depth));
+}
+
+/* public methods (in sysdep_display.h) */
+int sysdep_display_init(struct rc_struct *rc, const char *plugin_path)
+{
+   if(!sysdep_display_rc)
+   {
+      if(rc && rc_register(rc, sysdep_display_opts))
+         return -1;
+      sysdep_display_rc = rc;
+   }
+   
+   if(!sysdep_display_plugin_mananger)
+   {
+      if(!(sysdep_display_plugin_manager =
+         plugin_manager_create("sysdep_display", rc)))
+      {
+         sysdep_display_exit();
+         return -1;
+      }
+      /* no need to fail here, if we don't have any plugins,
+         sysdep_display_create will always fail, but that doesn't have to be
+         fatal, failing here usually is! */
+      plugin_manager_register(sysdep_display_plugin_manager,
+         sysdep_display_plugins);
+      plugin_manager_load(sysdep_display_plugin_manager, plugin_path, NULL);
+      if (plugin_manager_init_plugin(sysdep_display_plugin_manager, NULL))
+      {
+         fprintf(stderr, "warning: no display plugins available\n");
+      }
+   }
+
+   return 0;
+}
+
+void sysdep_display_exit(void)
+{
+   if(sysdep_display_plugin_manager)
+   {
+      plugin_manager_destroy(sysdep_display_plugin_manager);
+      sysdep_display_plugin_manager = NULL;
+   }
+   if(sysdep_display_rc)
+   {
+      rc_unregister(sysdep_display_rc, sysdep_display_opts);
+      sysdep_display_rc = NULL;
+   }
+}
+
+
+struct sysdep_display_struct *sysdep_display_create(const char *plugin)
+{
+   struct sysdep_display_struct *display = NULL;
+   
+   /* create the instance */
+   if (!(display = plugin_manager_create_instance(sysdep_display_plugin_manager,
+      plugin? plugin:sysdep_display_plugin, NULL)))
+   {
+      return NULL;
+   }
+   
+   /* if the plugin couldn't give us an aspect ratio then use the user
+      defined aspect ratio */
+   if(!display->aspect_ratio)
+      display->aspect_ratio = sysdep_display_aspect_ratio;
+      
+   /* set the mode to -1 */
+   display->mode = -1;
+   
+   return display;
+}
+
+void sysdep_display_destroy(struct sysdep_display_struct *display)
+{
+   if(display->opened)
+      display->close(display);
+   
+   display->destroy(display);
+}
+
+
+int sysdep_display_open(struct sysdep_display_struct *display, int width,
+   int height, int depth, struct sysdep_display_open_params *params,
+   int params_present)
+{
+   /* are we already open ? */
+   if(display->opened)
+      return -1;
+   
+   /* get all the params */
+   display->emu_mode.width = width;
+   display->emu_mode.height = height;
+   display->emu_mode.depth = depth;
+   
+   if(params_present & SYSDEP_DISPLAY_ASPECT_RATIO)
+      display->emu_mode.aspect_ratio = params->aspect_ratio;
+   else
+      display->emu_mode.aspect_ratio = display->aspect_ratio;
+      
+   if(params_present & SYSDEP_DISPLAY_WIDTHSCALE)
+      display->widthscale = params->widthscale;
+   else
+      display->widthscale = sysdep_display_widthscale;
+   
+   if(params_present & SYSDEP_DISPLAY_HEIGHTSCALE)
+      display->heightscale = params->heightscale;
+   else
+      display->heightscale = sysdep_display_heightscale;
+      
+   if(params_present & SYSDEP_DISPLAY_SCANLINES)
+      display->scanlines = params->scanlines;
+   else
+      display->scanlines = sysdep_display_scanlines;
+      
+   /* if this plugin uses modes, then select the best mode */
+   if(display->modes)
+   {
+      int best_score = 0;
+      
+      display->mode = 0;
+      best_score = sysdep_display_match_mode(display, 0);
+      
+      for(i = 1; modes[i].width; i++)
+      {
+         int score = sysdep_display_match_mode(display, i);
+         if(score >= best_score)
+         {
+            best_score = score;
+            display->mode = i;
+         }
+      }
+      display->hw_mode = display->modes[display->mode];
+      display->startx = ((display->emu_mode.width  * display->widthscale) -
+         display->hw_mode.width ) / 2;
+      display->starty = ((display->emu_mode.heigth * display->heightscale) -
+         display->hw_mode.height) / 2;
+   }
+   else
+      display->hw_mode = display->emu_mode;
+   
+   if(display->open(display))
+   {
+      sysdep_display_close(display);
+      return -1;
+   }
+      
+   display->opened = 1;
+   
+   return 0;
+}
+
+void sysdep_display_close(struct sysdep_display_struct *display)
+{
+  /* Save these 3 so that they can be restored after clearing the
+     display struct. */
+  struct sysdep_display_mode *modes = display->modes;
+  float aspect_ratio = display->aspect_ratio;
+  void *_priv = display->_priv;
+  
+  /* close the display */
+  if(display->opened)
+     display->close(display);
+  
+  /* clear the display struct */
+  memset(display, 0, sizeof(struct sysdep_display_struct));
+  
+  /* and restore the vital data */
+  display->modes = modes;
+  display->aspect_ratio = aspect_ratio;
+  display->_priv = _priv;
+  display->mode = -1;
+}
+
+
+/* map / unmap (set graphics mode / text mode) */
+int sysdep_display_map(struct sysdep_display_struct *display)
+{
+}
+
+int sysdep_display_unmap(struct sysdep_display_struct *display)
+{
+}
+
+
+/* mode handling */
+float sysdep_display_get_aspect_ratio(struct sysdep_display_struct *display)
+{
+   return display->aspect_ratio;
+}
+
+const struct sysdep_display_mode *sysdep_display_get_modes(
+   struct sysdep_display_struct *display)
+{
+   static const struct sysdep_display_mode no_modes[2] = {
+      { -1, -1, -1, 0, 0 },
+         0,  0,  0, 0, 0 }
+      };
+      
+   /* does this plugin use modes? */
+   if (display->modes)
+      return display->modes;
+   else
+      return no_modes;
+}
+
+
+/* palette handling */
+int sysdep_display_16bpp_capable(struct sysdep_display_struct *display)
+{
+   return display->is_16bpp_capable;
+}
+
+const struct sysdep_palette_info *sysdep_display_get_palette_info(
+   struct sysdep_display_struct *display)
+{
+   return &(display->palette_info);
+}
+
+int sysdep_display_alloc_palette(struct sysdep_display_struct *display,
+   int writable_colors)
+{
+   if(display->alloc_palette)
+      return display->alloc_palette(display, writable_colors);
+      
+   return 0;
+}
+
+int sysdep_display_set_pen(struct sysdep_display_struct *display, int pen,
+   unsigned char red, unsigned char green, unsigned char blue)
+{
+   if(display->set_pen)
+      return display->set_pen(display, pen, red, green, blue);
+   
+   return -1;
+}
+
+   
+int sysdep_display_blit(struct sysdep_display_struct *display,
+   struct sysdep_bitmap *bitmap, int src_x, int src_y, int dest_x, int dest_y,
+   int src_width, int src_height, int scale_x, int scale_y, int use_dirty)
+{
+   /* adjust scale_xx and dest_xx for display scaling and panning */
+   scale_x *= display->widthscale;
+   scale_y *= display->heightscale;
+   dest_x  *= display->widthscale;
+   dest_y  *= display->heightscale;
+   dest_x  += display->startx;
+   dest_y  += display->starty;
+   
+   /* 4 different scenarios:
+      -The display plugin has it's own blit function, and we use that.
+      -The display plugin has it's own blit function, but the display
+       types (the display palette_info structs) don't match, or scaling is
+       requested, so we first blit to a dummy framebuffer, and then call the
+       system's blit function to update the real framebuffer.
+      -the display plugin gives us direct access to its framebuffer, so
+       we use our own blit code to blit to this.
+      -the display plugin gives us direct access to its framebuffer, so
+       we blit to it, and wants us to call a function afterwards to notify it
+       about the updating of his framebuffer.
+   */
+   
+   questions:
+   -do we solve this by writing seperate code 4 the 4 blit scenarios, or do
+    we introduce's if statements for this in the blit code.
+   -how about special cases like doublebuffering no double buffering etc.
+}
+
+
+struct sysdep_input_struct *sysdep_display_open_input(
+   struct sysdep_display_struct *display)
+{
+}
+
+
+int sysdep_display_set_widthscale(struct sysdep_display_struct **display,
+   int widthscale)
+{
+}
+int sysdep_display_get_widthscale(struct sysdep_display_struct *display)
+{
+}
+
+int sysdep_display_set_heightscale(struct sysdep_display_struct **display,
+   int heightscale)
+{
+}
+int sysdep_display_get_widthscale(struct sysdep_display_struct *display)
+{
+}
+   
+int sysdep_display_set_scanlines(struct sysdep_display_struct *display,
+   int scanlines)
+{
+}
+int sysdep_display_get_widthscale(struct sysdep_display_struct *display)
+{
+}
+   
+int sysdep_display_set_plugin(struct sysdep_display_struct **display,
+   const char *plugin)
+{
+}
+const char *sysdep_display_get_plugin(struct sysdep_display_struct *display)
+{
+}
+
+int sysdep_display_handle_hotkeys(struct sysdep_display_struct **display,
+   struct sysdep_input_struct *input)
+{
+}
+
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/sysdep_display.h mame-0.36b16/src/unix/sysdep/sysdep_display.h
--- ../mmmmm/m36b16/src/unix/sysdep/sysdep_display.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/sysdep_display.h	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,114 @@
+/* Sysdep display object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __SYSDEP_DISPLAY_H
+#define __SYSDEP_DISPLAY_H
+
+#include "begin_code.h"
+
+/* sysdep_display_open params_present defines */
+#define SYSDEP_DISPLAY_WIDTHSCALE	0x01
+#define SYSDEP_DISPLAY_HEIGHTSCALE	0x02
+#define SYSDEP_DISPLAY_SCANLINES	0x04
+#define SYSDEP_DISPLAY_ASPECT_RATIO	0x08
+
+struct sysdep_display_struct;
+struct sysdep_palette_struct;
+struct sysdep_palette_info;
+struct sysdep_input_struct;
+
+struct sysdep_display_open_params {
+   int widthscale;
+   int heightscale;
+   int scanlines;
+   float aspect_ratio;
+};
+
+struct sysdep_display_mode {
+   int width;
+   int height;
+   int depth;
+   float aspect_ratio;
+   int _priv;
+};
+
+/* init / exit */
+int sysdep_display_init(struct rc_struct *rc, const char *plugin_path);
+void sysdep_display_exit(void);
+
+/* create / destroy */
+struct sysdep_display_struct *sysdep_display_create(const char *plugin);
+void sysdep_display_destroy(struct sysdep_display_struct *display);
+
+/* open / close */
+int sysdep_display_open(struct sysdep_display_struct *display, int width,
+   int height, int depth, struct sysdep_display_open_params *params,
+   int params_present);
+void sysdep_display_close(struct sysdep_display_struct *display);
+
+/* map / unmap (set graphics mode / text mode) */
+int sysdep_display_map(struct sysdep_display_struct *display);
+int sysdep_display_unmap(struct sysdep_display_struct *display);
+
+/* mode handling */
+float sysdep_display_get_aspect_ratio(struct sysdep_display_struct *display);
+struct sysdep_display_mode *sysdep_display_get_modes(
+   struct sysdep_display_struct *display);
+
+/* palette handling */
+int sysdep_display_16bpp_capable(struct sysdep_display_struct *display);
+const struct sysdep_palette_info *sysdep_display_get_palette_info(
+   struct sysdep_display_struct *display);
+int sysdep_display_alloc_palette(struct sysdep_display_struct *display,
+   int writable_colors);
+int sysdep_display_set_pen(struct sysdep_display_struct *display, int pen,
+   unsigned char red, unsigned char green, unsigned char blue);
+
+/* blit */   
+int sysdep_display_blit(struct sysdep_display_struct *display,
+   struct sysdep_palette_struct *palette,
+   struct sysdep_bitmap *bitmap, int src_x, int src_y, int dest_x, int dest_y,
+   int src_width, int src_height, int scale_x, int scale_y, int use_dirty);
+
+/* input */ 
+struct sysdep_input_struct *sysdep_display_open_input(
+   struct sysdep_display_struct *display);
+
+/* option handling / changing */
+int sysdep_display_set_widthscale(struct sysdep_display_struct *display,
+   int widthscale);
+int sysdep_display_get_widthscale(struct sysdep_display_struct *display);
+
+int sysdep_display_set_heightscale(struct sysdep_display_struct *display,
+   int heightscale);
+int sysdep_display_get_widthscale(struct sysdep_display_struct *display);
+   
+int sysdep_display_set_scanlines(struct sysdep_display_struct *display,
+   int scanlines);
+int sysdep_display_get_widthscale(struct sysdep_display_struct *display);
+   
+int sysdep_display_set_plugin(struct sysdep_display_struct **display,
+   const char *plugin);
+const char *sysdep_display_get_plugin(struct sysdep_display_struct *display);
+
+int sysdep_display_handle_hotkeys(struct sysdep_display_struct **display,
+   struct sysdep_input_struct *input);
+
+#include "end_code.h"
+#endif /* ifndef __SYSDEP_DISPLAY_H */
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/sysdep_display_priv.h mame-0.36b16/src/unix/sysdep/sysdep_display_priv.h
--- ../mmmmm/m36b16/src/unix/sysdep/sysdep_display_priv.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/sysdep_display_priv.h	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,48 @@
+/* Sysdep display object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __SYSDEP_DISPLAY_PRIV_H
+#define __SYSDEP_DISPLAY_PRIV_H
+
+#include "sysdep_display.h"
+#include "sysdep_palette.h"
+#include "begin_code.h"
+
+struct sysdep_display_struct {
+   struct sysdep_display_mode emu_mode;
+   struct sysdep_display_mode hw_mode;
+   struct sysdep_display_mode *modes;
+   struct sysdep_palette_info palette_info;
+   float aspect_ratio;
+   int is_16bpp_capable;
+   int widthscale;
+   int heightscale;
+   int scanlines;
+   int mode;
+   int opened;
+   int mapped;
+   int startx;
+   int starty;
+   int framebuffer_pitch;
+   unsigned char *framebuffer;
+   void *_priv;
+};
+
+#include "end_code.h"
+#endif /* ifndef __SYSDEP_DISPLAY_PRIV_H */
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/sysdep_dsp.c mame-0.36b16/src/unix/sysdep/sysdep_dsp.c
--- ../mmmmm/m36b16/src/unix/sysdep/sysdep_dsp.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/sysdep_dsp.c	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,349 @@
+/* Sysdep sound dsp object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, January 2000
+-initial release (Hans de Goede)
+Version 0.2, March 2000
+-added a plugin parameter to create, to override the global plugin
+ configuration (Hans de Goede)
+-made bufsize a parameter to create, removed the global bufsize configuration,
+ the code using us should have a much better idea of what bufsize should be
+ then we do. (Hans de Goede)
+-protected sysdep_dsp_init against being called twice (Hans de Goede)
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "sysdep_dsp.h"
+#include "sysdep_dsp_priv.h"
+#include "sysdep_dsp_plugins.h"
+#include "plugin_manager.h"
+
+/* private func prototypes */
+static int sysdep_dsp_list_plugins(struct rc_option *option, const char *arg,
+   int priority);
+
+/* private variables */
+static char *sysdep_dsp_plugin = NULL;
+static int sysdep_dsp_use_timer = 0;
+static int sysdep_dsp_bytes_per_sample[] = SYSDEP_DSP_BYTES_PER_SAMPLE;
+static struct rc_struct *sysdep_dsp_rc = NULL;
+static struct plugin_manager_struct *sysdep_dsp_plugin_manager = NULL;
+static struct rc_option sysdep_dsp_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "Digital sound related", NULL,		rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "dsp-plugin", 	"dp",			rc_string,	&sysdep_dsp_plugin,
+     NULL,		0,			0,		NULL,
+     "Select which plugin to use for digital sound" },
+   { "list-dsp-plugins", "ldp",			rc_use_function_no_arg, NULL,
+     NULL,		0,			0,		sysdep_dsp_list_plugins,
+     "List available sound-dsp plugins" },
+   { "timer",		"ti",			rc_bool,	&sysdep_dsp_use_timer,
+     "0",		0,			0,		NULL,
+     "Use / don't use timer based audio (normally it will be used automagicly when nescesarry)" },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+static const struct plugin_struct *sysdep_dsp_plugins[] = {
+#ifdef SYSDEP_DSP_OSS
+   &sysdep_dsp_oss,
+#endif
+#ifdef SYSDEP_DSP_NETBSD
+   &sysdep_dsp_netbsd,
+#endif
+#ifdef SYSDEP_DSP_SOLARIS
+   &sysdep_dsp_solaris,
+#endif
+#ifdef SYSDEP_DSP_SOUNDKIT
+   &sysdep_dsp_soundkit,
+#endif
+#ifdef SYSDEP_DSP_IRIX
+   &sysdep_dsp_irix,
+#endif
+#ifdef SYSDEP_DSP_AIX
+   &sysdep_dsp_aix,
+#endif
+#ifdef SYSDEP_DSP_ESOUND
+   &sysdep_dsp_esound,
+#endif
+#ifdef SYSDEP_DSP_ALSA
+   &sysdep_dsp_alsa,
+#endif
+   NULL
+};
+
+/* private methods */
+static int sysdep_dsp_list_plugins(struct rc_option *option, const char *arg,
+   int priority)
+{
+   fprintf(stdout, "Digital sound plugins:\n\n");
+   plugin_manager_list_plugins(sysdep_dsp_plugin_manager, stdout);
+   
+   return -1;
+}
+
+/* public methods (in sysdep_dsp.h) */
+int sysdep_dsp_init(struct rc_struct *rc, const char *plugin_path)
+{
+   if(!sysdep_dsp_rc)
+   {
+      if(rc && rc_register(rc, sysdep_dsp_opts))
+         return -1;
+      sysdep_dsp_rc = rc;
+   }
+   
+   if(!sysdep_dsp_plugin_manager)
+   {
+      if(!(sysdep_dsp_plugin_manager =
+         plugin_manager_create("sysdep_dsp", rc)))
+      {
+         sysdep_dsp_exit();
+         return -1;
+      }
+      /* no need to fail here, if we don't have any plugins, sysdep_dsp_create
+         will always fail, but that doesn't have to be fatal, failing here
+         usually is! */
+      plugin_manager_register(sysdep_dsp_plugin_manager, sysdep_dsp_plugins);
+      plugin_manager_load(sysdep_dsp_plugin_manager, plugin_path, NULL);
+      if(plugin_manager_init_plugin(sysdep_dsp_plugin_manager, NULL))
+      {
+         fprintf(stderr, "warning: no dsp plugins available\n");
+      }
+   }
+
+   return 0;
+}
+
+void sysdep_dsp_exit(void)
+{
+   if(sysdep_dsp_plugin_manager)
+   {
+      plugin_manager_destroy(sysdep_dsp_plugin_manager);
+      sysdep_dsp_plugin_manager = NULL;
+   }
+   if(sysdep_dsp_rc)
+   {
+      rc_unregister(sysdep_dsp_rc, sysdep_dsp_opts);
+      sysdep_dsp_rc = NULL;
+   }
+}
+
+struct sysdep_dsp_struct *sysdep_dsp_create(const char *plugin,
+   const char *device, int *samplerate, int *type, float bufsize,
+   int flags)
+{
+   struct sysdep_dsp_struct *dsp = NULL;
+   struct sysdep_dsp_create_params params;
+   
+   /* fill the params struct */
+   params.bufsize = bufsize;
+   params.device = device;
+   params.samplerate = *samplerate;
+   params.type = *type;
+   params.flags = flags;
+   
+   /* create the instance */
+   if (!(dsp = plugin_manager_create_instance(sysdep_dsp_plugin_manager,
+      plugin? plugin:sysdep_dsp_plugin, &params)))
+   {
+      return NULL;
+   }
+   
+   /* calculate buf_size if not done by the plugin */
+   if(!dsp->hw_info.bufsize)
+      dsp->hw_info.bufsize = bufsize * dsp->hw_info.samplerate;
+
+   /* fill in the emu info struct */
+   if(flags & SYSDEP_DSP_EMULATE_TYPE)
+      dsp->emu_info.type = *type;
+   else
+      dsp->emu_info.type = dsp->hw_info.type;
+   dsp->emu_info.samplerate = dsp->hw_info.samplerate;
+   dsp->emu_info.bufsize = dsp->hw_info.bufsize;
+   
+   /* allocate convert buffer if nescesarry */
+   if(memcmp(&dsp->emu_info, &dsp->hw_info, sizeof(struct sysdep_dsp_info)))
+   {
+      if(!(dsp->convert_buf =
+         malloc(dsp->hw_info.bufsize *
+            sysdep_dsp_bytes_per_sample[dsp->hw_info.type])))
+      {
+         fprintf(stderr,
+            "error malloc failed for dsp convert buffer\n");
+         sysdep_dsp_destroy(dsp);
+         return NULL;
+      }
+   }
+   
+   if(sysdep_dsp_use_timer || !dsp->get_freespace)
+      fprintf(stderr, "info: dsp: using timer based audio\n");
+   
+   /* return actual type and samplerate */
+   *type = dsp->emu_info.type;
+   *samplerate = dsp->emu_info.samplerate;
+   
+   return dsp;
+}
+
+void sysdep_dsp_destroy(struct sysdep_dsp_struct *dsp)
+{
+   if(dsp->convert_buf)
+      free(dsp->convert_buf);
+   dsp->destroy(dsp);
+}
+
+int sysdep_dsp_get_freespace(struct sysdep_dsp_struct *dsp)
+{
+   uclock_t t;
+   int result;
+   
+   if(!sysdep_dsp_use_timer && dsp->get_freespace)
+      return dsp->get_freespace(dsp);
+      
+   /* fall back using uclock (which uses gettimeofday where available) */
+   t = uclock();
+   
+   if (dsp->last_update == 0)
+      result = 0;
+   else
+      result = ((t - dsp->last_update) * dsp->emu_info.samplerate) /
+         UCLOCKS_PER_SEC;
+   
+   dsp->last_update = t;
+   
+   /* sanity check */
+   if ((result < 0) || (result > dsp->emu_info.bufsize))
+      result = 0;
+   
+   return result;
+}
+
+int sysdep_dsp_write(struct sysdep_dsp_struct *dsp,
+   unsigned char *data, int count)
+{
+   if(!count)
+      return 0;
+
+   /* do we need to emulate? */
+   if(memcmp(&dsp->emu_info, &dsp->hw_info, sizeof(struct sysdep_dsp_info)))
+   {
+      unsigned char *convert_buf = dsp->convert_buf;
+      short *convert_buf_large = (short *)dsp->convert_buf;
+      short *data_large = (short *)data;
+      int i;
+      
+      if (count > dsp->emu_info.bufsize)
+         count = dsp->emu_info.bufsize;
+      
+      switch((dsp->emu_info.type << 4) | dsp->hw_info.type)
+      {
+         /* 8bit mono -> */
+         case 0x01: /* 16bit mono */
+            for(i = 0; i < count; i++)
+               convert_buf_large[i] = ((int)data[i] << 8) - 32768;
+            break;
+         case 0x02: /* 8bit stereo */
+            for(i = 0; i < count; i++)
+            {
+               convert_buf[i * 2]     = data[i];
+               convert_buf[i * 2 + 1] = data[i];
+            }
+            break;
+         case 0x03: /* 16bit stereo */
+            for(i = 0; i < count; i++)
+            {
+               convert_buf_large[i * 2]     = ((int)data[i] << 8) - 32768;
+               convert_buf_large[i * 2 + 1] = convert_buf[i * 2];
+            }
+            break;
+            
+         /* 16bit mono -> */
+         case 0x10: /* 8 bit mono */
+            for(i = 0; i < count; i++)
+               convert_buf[i] = (data_large[i] >> 8) + 128;
+            break;
+         case 0x12: /* 8bit stereo */
+            for(i = 0; i < count; i++)
+            {
+               convert_buf[i * 2]     = (data_large[i] >> 8) + 128;
+               convert_buf[i * 2 + 1] = convert_buf[i * 2];
+            }
+            break;
+         case 0x13: /* 16bit stereo */
+            for(i = 0; i < count; i++)
+            {
+               convert_buf_large[i * 2]     = data_large[i];
+               convert_buf_large[i * 2 + 1] = data_large[i];
+            }
+            break;
+            
+         /* 8bit stereo -> */
+         case 0x20: /* 8 bit mono */
+            for(i = 0; i < count; i++)
+               convert_buf[i] = (((int)data[i * 2] + (int)data[i * 2 + 1])
+                  >> 1);
+            break;
+         case 0x21: /* 16bit mono */
+            for(i = 0; i < count; i++)
+               convert_buf_large[i] = (((int)data[i * 2] + 
+                  (int)data[i * 2 + 1]) << 7) - 32768;
+            break;
+         case 0x23: /* 16bit stereo */
+            for (i = 0; i < count; i++)
+            {
+               convert_buf_large[i * 2    ] = ((int)data[i * 2    ] << 8)
+                  - 32768;
+               convert_buf_large[i * 2 + 1] = ((int)data[i * 2 + 1] << 8)
+                  - 32768;
+            }
+            break;
+            
+         /* 16bit stereo -> */
+         case 0x30: /* 8 bit mono */
+            for(i = 0; i < count; i++)
+               convert_buf[i] = (((int)data_large[i * 2] +
+                  (int)data_large[i * 2 + 1]) >> 9) + 128;
+            break;
+         case 0x31: /* 16bit mono */
+            for(i = 0; i < count; i++)
+               convert_buf_large[i] = (((int)data_large[i * 2] +
+                  (int)data_large[i * 2 + 1]) >> 1);
+            break;
+         case 0x32: /* 8bit stereo */
+            for (i = 0; i < count; i++)
+            {
+               convert_buf[i * 2    ] = (data_large[i * 2    ] >> 8) + 128;
+               convert_buf[i * 2 + 1] = (data_large[i * 2 + 1] >> 8) + 128;
+            }
+            break;
+      }
+      data = dsp->convert_buf;
+   }
+
+   return dsp->write(dsp, data, count);
+}
+
+int sysdep_dsp_get_max_freespace(struct sysdep_dsp_struct *dsp)
+{
+   return dsp->emu_info.bufsize;
+}
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/sysdep_dsp.h mame-0.36b16/src/unix/sysdep/sysdep_dsp.h
--- ../mmmmm/m36b16/src/unix/sysdep/sysdep_dsp.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/sysdep_dsp.h	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,55 @@
+/* Sysdep sound dsp object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __SYSDEP_DSP_H
+#define __SYSDEP_DSP_H
+
+#include "rc.h"
+#include "begin_code.h"
+
+#define SYSDEP_DSP_BYTES_PER_SAMPLE { 1, 2, 2, 4 }
+
+/* valid flags for type */
+#define SYSDEP_DSP_8BIT   0x00
+#define SYSDEP_DSP_16BIT  0x01
+#define SYSDEP_DSP_MONO   0x00
+#define SYSDEP_DSP_STEREO 0x02
+
+/* valid flags for sysdep_dsp_create */
+#define SYSDEP_DSP_EMULATE_TYPE 0x01
+/* TODO: implement SYSDEP_DSP_EMULATE_SAMPLERATE */
+/* #define SYSDEP_DSP_EMULATE_SAMPLERATE 0x02 */
+#define SYSDEP_DSP_O_NONBLOCK 0x04
+
+struct sysdep_dsp_struct;
+
+int sysdep_dsp_init(struct rc_struct *rc, const char *plugin_path);
+void sysdep_dsp_exit(void);
+
+struct sysdep_dsp_struct *sysdep_dsp_create(const char *plugin,
+   const char *device, int *samplerate, int *type, float bufsize, int flags);
+void sysdep_dsp_destroy(struct sysdep_dsp_struct *dsp);
+
+int sysdep_dsp_get_freespace(struct sysdep_dsp_struct *dsp);
+int sysdep_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+   int count);
+int sysdep_dsp_get_max_freespace(struct sysdep_dsp_struct *dsp);
+
+#include "end_code.h"
+#endif /* ifndef __SYSDEP_DSP_H */
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/sysdep_dsp_plugins.h mame-0.36b16/src/unix/sysdep/sysdep_dsp_plugins.h
--- ../mmmmm/m36b16/src/unix/sysdep/sysdep_dsp_plugins.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/sysdep_dsp_plugins.h	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,50 @@
+/* Sysdep sound dsp plugins listing
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __SYSDEP_DSP_PLUGINS_H
+#define __SYSDEP_DSP_PLUGINS_H
+#include "plugin_manager.h"
+#include "begin_code.h"
+
+#ifdef SYSDEP_DSP_OSS
+extern struct plugin_struct sysdep_dsp_oss;
+#endif
+#ifdef SYSDEP_DSP_NETBSD
+extern struct plugin_struct sysdep_dsp_netbsd;
+#endif
+#ifdef SYSDEP_DSP_SOLARIS
+extern struct plugin_struct sysdep_dsp_solaris;
+#endif
+#ifdef SYSDEP_DSP_SOUNDKIT
+extern struct plugin_struct sysdep_dsp_soundkit;
+#endif
+#ifdef SYSDEP_DSP_IRIX
+extern struct plugin_struct sysdep_dsp_irix;
+#endif
+#ifdef SYSDEP_DSP_AIX
+extern struct plugin_struct sysdep_dsp_aix;
+#endif
+#ifdef SYSDEP_DSP_ESOUND
+extern struct plugin_struct sysdep_dsp_esound;
+#endif
+#ifdef SYSDEP_DSP_ALSA
+extern struct plugin_struct sysdep_dsp_alsa;
+#endif
+
+#include "end_code.h"
+#endif /* ifndef __SYSDEP_DSP_PLUGINS_H */
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/sysdep_dsp_priv.h mame-0.36b16/src/unix/sysdep/sysdep_dsp_priv.h
--- ../mmmmm/m36b16/src/unix/sysdep/sysdep_dsp_priv.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/sysdep_dsp_priv.h	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,53 @@
+/* Sysdep sound dsp object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __SYSDEP_DSP_PRIV_H
+#define __SYSDEP_DSP_PRIV_H
+
+#include "misc.h"
+#include "begin_code.h"
+
+struct sysdep_dsp_info {
+   int samplerate;
+   int type;
+   int bufsize;
+};
+
+struct sysdep_dsp_struct {
+   struct sysdep_dsp_info hw_info;
+   struct sysdep_dsp_info emu_info;
+   unsigned char *convert_buf;
+   uclock_t last_update;
+   void *_priv;
+   int (*get_freespace)(struct sysdep_dsp_struct *dsp);
+   int (*write)(struct sysdep_dsp_struct *dsp, unsigned char *data,
+      int count);
+   void (*destroy)(struct sysdep_dsp_struct *dsp);
+};
+
+struct sysdep_dsp_create_params {
+   float bufsize;
+   const char *device;
+   int samplerate;
+   int type;
+   int flags;
+};
+
+#include "end_code.h"
+#endif /* ifndef __SYSDEP_DSP_PRIV_H */
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/sysdep_mixer.c mame-0.36b16/src/unix/sysdep/sysdep_mixer.c
--- ../mmmmm/m36b16/src/unix/sysdep/sysdep_mixer.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/sysdep_mixer.c	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,263 @@
+/* Sysdep sound mixer object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, February 2000
+-initial release (Hans de Goede)
+Version 0.2, March 2000
+-added a plugin parameter to create, to override the global plugin
+ configuration (Hans de Goede)
+-protected sysdep_mixer_init against being called twice (Hans de Goede)
+*/
+#include "sysdep_mixer.h"
+#include "sysdep_mixer_priv.h"
+#include "sysdep_mixer_plugins.h"
+
+/* #define SYSDEP_MIXER_DEBUG */
+
+/* private func prototypes */
+static int sysdep_mixer_list_plugins(struct rc_option *option,
+   const char *arg, int priority);
+
+/* private variables */
+static char *sysdep_mixer_plugin = NULL;
+static struct rc_struct *sysdep_mixer_rc = NULL;
+static struct plugin_manager_struct *sysdep_mixer_plugin_manager = NULL;
+static struct rc_option sysdep_mixer_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "Sound mixer related", NULL,		rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "sound-mixer-plugin", "smp",		rc_string,	&sysdep_mixer_plugin,
+     NULL,		0,			0,		NULL,
+     "Select which plugin to use for the sound mixer" },
+   { "list-mixer-plugins", "lmp",		rc_use_function_no_arg, NULL,
+     NULL,		0,			0,		sysdep_mixer_list_plugins,
+     "List available sound-mixer plugins" },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+static const struct plugin_struct *sysdep_mixer_plugins[] = {
+#ifdef SYSDEP_MIXER_OSS
+   &sysdep_mixer_oss,
+#endif
+#ifdef SYSDEP_MIXER_NETBSD
+   &sysdep_mixer_netbsd,
+#endif
+#ifdef SYSDEP_MIXER_SOLARIS
+   &sysdep_mixer_solaris,
+#endif
+#ifdef SYSDEP_MIXER_NEXT
+   &sysdep_mixer_next,
+#endif
+#ifdef DSYSDEP_MIXER_IRIX
+   &sysdep_mixer_irix,
+#endif
+#ifdef DSYSDEP_MIXER_AIX
+   &sysdep_mixer_aix,
+#endif
+   NULL
+};
+#ifdef SYSDEP_MIXER_DEBUG
+const char *sysdep_mixer_names[] = SYSDEP_MIXER_NAMES;
+#endif
+
+/* private methods */
+static int sysdep_mixer_list_plugins(struct rc_option *option,
+   const char *arg, int priority)
+{
+   fprintf(stdout, "Sound mixer plugins:\n\n");
+   plugin_manager_list_plugins(sysdep_mixer_plugin_manager, stdout);
+   
+   return -1;
+}
+
+/* public methods */
+int sysdep_mixer_init(struct rc_struct *rc, const char *plugin_path)
+{
+   if(!sysdep_mixer_rc)
+   {
+      if(rc && rc_register(rc, sysdep_mixer_opts))
+         return -1;
+      sysdep_mixer_rc = rc;
+   }
+   
+   if(!sysdep_mixer_plugin_manager)
+   {
+      if(!(sysdep_mixer_plugin_manager = plugin_manager_create("sysdep_mixer",
+         rc)))
+      {
+         sysdep_mixer_exit();
+         return -1;
+      }
+      /* no need to fail here, if we don't have any plugins,
+         sysdep_mixer_create will always fail, but that doesn't have to be
+         fatal, failing here usually is! */
+      plugin_manager_register(sysdep_mixer_plugin_manager,
+         sysdep_mixer_plugins);
+      plugin_manager_load(sysdep_mixer_plugin_manager, plugin_path, NULL);
+      if(plugin_manager_init_plugin(sysdep_mixer_plugin_manager, NULL))
+      {
+         fprintf(stderr, "warning: no mixer plugins available\n");
+      }
+   }
+
+   return 0;
+}
+
+void sysdep_mixer_exit(void)
+{
+   if(sysdep_mixer_plugin_manager)
+   {
+      plugin_manager_destroy(sysdep_mixer_plugin_manager);
+      sysdep_mixer_plugin_manager = NULL;
+   }
+   if(sysdep_mixer_rc)
+   {
+      rc_unregister(sysdep_mixer_rc, sysdep_mixer_opts);
+      sysdep_mixer_rc = NULL;
+   }
+}
+
+struct sysdep_mixer_struct *sysdep_mixer_create(const char *plugin,
+   const char *device, int flags)
+{
+   int i;
+   struct sysdep_mixer_struct *mixer = NULL;
+   struct sysdep_mixer_create_params params;
+   
+   /* fill the params struct */
+   params.device = device;
+   
+   /* create the instance */
+   if(!(mixer = plugin_manager_create_instance(sysdep_mixer_plugin_manager,
+      plugin? plugin:sysdep_mixer_plugin, &params)))
+      return NULL;
+   
+   /* fill the mixer cache and save the original settings */
+   for(i = 0; i < SYSDEP_MIXER_CHANNELS; i++)
+   {
+      if(mixer->channel_available[i])
+      {
+#ifdef SYSDEP_MIXER_DEBUG
+	 fprintf(stderr, "debug: mixer got channel %s\n",
+	    sysdep_mixer_names[i]);
+#endif
+         if(mixer->get(mixer, i, &mixer->cache_left[i],
+            &mixer->cache_right[i]))
+         {
+            sysdep_mixer_destroy(mixer);
+            return NULL;
+         }
+         mixer->orig_left[i]  = mixer->cache_left[i];
+         mixer->orig_right[i] = mixer->cache_right[i];
+      }
+   }
+   
+   /* save our flags */
+   mixer->flags = flags;
+   
+   return mixer;
+}
+
+void sysdep_mixer_destroy(struct sysdep_mixer_struct *mixer)
+{
+   int i, left, right;
+   
+   /* restore orig settings if requested */
+   for(i = 0; i < SYSDEP_MIXER_CHANNELS; i++)
+   {
+      /* check that the channel wasn't modified under our ass */
+      sysdep_mixer_get(mixer, i, &left, &right);
+      if(mixer->restore_channel[i])
+      {
+#ifdef SYSDEP_MIXER_DEBUG
+         fprintf(stderr, "debug: sysdep_mixer: restoring channel %s\n",
+	    sysdep_mixer_names[i]);
+#endif
+         sysdep_mixer_set(mixer, i, mixer->orig_left[i],
+            mixer->orig_right[i]);
+      }
+   }
+   mixer->destroy(mixer);
+}
+
+int sysdep_mixer_channel_available(struct sysdep_mixer_struct *mixer,
+   int channel)
+{
+   return mixer->channel_available[channel];
+}
+
+int sysdep_mixer_set(struct sysdep_mixer_struct *mixer, int channel,
+   int left, int right)
+{
+   if(!mixer->channel_available[channel])
+      return -1;
+
+   if(mixer->set(mixer, channel, left, right))
+      return -1;
+   
+   mixer->cache_left[channel]  = left;
+   mixer->cache_right[channel] = right;
+   if(mixer->flags & SYSDEP_MIXER_RESTORE_SETTINS_ON_EXIT)
+      mixer->restore_channel[channel] = 1;
+   
+   return 0;
+}
+
+int sysdep_mixer_get(struct sysdep_mixer_struct *mixer, int channel,
+   int *left, int *right)
+{
+   if(!mixer->channel_available[channel])
+      return -1;
+
+   if(mixer->get(mixer, channel, left, right))
+      return -1;
+   
+   /* if we're close to the cached values use the cache, to avoid repeated
+      calls to get->set, causing the volume to slide */
+   if((*left >= (mixer->cache_left[channel] - 5)) &&
+      (*left <= (mixer->cache_left[channel] + 5)) &&
+      (*right >= (mixer->cache_right[channel] - 5)) &&
+      (*right <= (mixer->cache_right[channel] + 5)))
+   {
+#ifdef SYSDEP_MIXER_DEBUG
+      fprintf(stderr, "debug: sysdep_mixer: cached\n");
+#endif
+      *left = mixer->cache_left[channel];
+      *right = mixer->cache_right[channel];
+   }
+   else 
+   {
+#ifdef SYSDEP_MIXER_DEBUG
+      fprintf(stderr, "debug: sysdep_mixer: modified under our ass\n");
+#endif
+      /* The channel was modified under our ass, no need to restore it anymore.
+         Save the new values as original values, so that if we change it
+         later on we restore the new values */
+      mixer->restore_channel[channel] = 0;
+      mixer->cache_left[channel]  = *left;
+      mixer->cache_right[channel] = *right;
+      mixer->orig_left[channel]  = *left;
+      mixer->orig_right[channel] = *right;
+   }
+      
+   return 0;
+}
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/sysdep_mixer.h mame-0.36b16/src/unix/sysdep/sysdep_mixer.h
--- ../mmmmm/m36b16/src/unix/sysdep/sysdep_mixer.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/sysdep_mixer.h	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,62 @@
+/* Sysdep sound mixer object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __SYSDEP_MIXER_H
+#define __SYSDEP_MIXER_H
+
+#include "rc.h"
+#include "begin_code.h"
+
+/* channel defines */
+#define SYSDEP_MIXER_VOLUME	0
+#define SYSDEP_MIXER_PCM1	1
+#define SYSDEP_MIXER_PCM2	2
+#define SYSDEP_MIXER_SYNTH	3
+#define SYSDEP_MIXER_CD		4
+#define SYSDEP_MIXER_LINE1	5
+#define SYSDEP_MIXER_LINE2	6
+#define SYSDEP_MIXER_LINE3	7
+#define SYSDEP_MIXER_BASS	8
+#define SYSDEP_MIXER_TREBLE	9
+#define SYSDEP_MIXER_CHANNELS	10
+#define SYSDEP_MIXER_NAMES { "Volume", "PCM 1", "PCM 2", "Synth", \
+   "CD", "Line 1", "Line 2", "Line 3", "Bass", "Treble" }
+
+/* flags for sysdep_mixer_create */
+#define SYSDEP_MIXER_RESTORE_SETTINS_ON_EXIT 0x01
+
+struct sysdep_mixer_struct;
+
+int sysdep_mixer_init(struct rc_struct *rc, const char *plugin_path);
+void sysdep_mixer_exit(void);
+
+struct sysdep_mixer_struct *sysdep_mixer_create(const char *plugin,
+   const char *device, int flags);
+void sysdep_mixer_destroy(struct sysdep_mixer_struct *dsp);
+
+int sysdep_mixer_channel_available(struct sysdep_mixer_struct *mixer,
+   int channel);
+
+int sysdep_mixer_set(struct sysdep_mixer_struct *mixer, int channel,
+   int left, int right);
+int sysdep_mixer_get(struct sysdep_mixer_struct *mixer, int channel,
+   int *left, int *right);
+
+#include "end_code.h"
+#endif /* ifndef __SYSDEP_MIXER_H */
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/sysdep_mixer_plugins.h mame-0.36b16/src/unix/sysdep/sysdep_mixer_plugins.h
--- ../mmmmm/m36b16/src/unix/sysdep/sysdep_mixer_plugins.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/sysdep_mixer_plugins.h	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,44 @@
+/* Sysdep sound mixer plugins listing
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __SYSDEP_MIXER_PLUGINS_H
+#define __SYSDEP_MIXER_PLUGINS_H
+#include "plugin_manager.h"
+#include "begin_code.h"
+
+#ifdef SYSDEP_MIXER_OSS
+extern struct plugin_struct sysdep_mixer_oss;
+#endif
+#ifdef SYSDEP_MIXER_NETBSD
+extern struct plugin_struct sysdep_mixer_netbsd;
+#endif
+#ifdef SYSDEP_MIXER_SOLARIS
+extern struct plugin_struct sysdep_mixer_solaris;
+#endif
+#ifdef SYSDEP_MIXER_NEXT
+extern struct plugin_struct sysdep_mixer_next;
+#endif
+#ifdef SYSDEP_MIXER_IRIX
+extern struct plugin_struct sysdep_mixer_irix;
+#endif
+#ifdef SYSDEP_MIXER_AIX
+extern struct plugin_struct sysdep_mixer_aix;
+#endif
+
+#include "end_code.h"
+#endif /* ifndef __SYSDEP_MIXER_PLUGINS_H */
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/sysdep_mixer_priv.h mame-0.36b16/src/unix/sysdep/sysdep_mixer_priv.h
--- ../mmmmm/m36b16/src/unix/sysdep/sysdep_mixer_priv.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/sysdep_mixer_priv.h	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,46 @@
+/* Sysdep sound mixer object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __SYSDEP_MIXER_PRIV_H
+#define __SYSDEP_MIXER_PRIV_H
+#include "sysdep_mixer.h"
+#include "begin_code.h"
+
+struct sysdep_mixer_struct {
+   int flags;
+   char channel_available[SYSDEP_MIXER_CHANNELS];
+   char restore_channel[SYSDEP_MIXER_CHANNELS];
+   int cache_left[SYSDEP_MIXER_CHANNELS];
+   int cache_right[SYSDEP_MIXER_CHANNELS];
+   int orig_left[SYSDEP_MIXER_CHANNELS];
+   int orig_right[SYSDEP_MIXER_CHANNELS];
+   void *_priv;
+   int (*set)(struct sysdep_mixer_struct *mixer, int channel, int left,
+      int right);
+   int (*get)(struct sysdep_mixer_struct *mixer, int channel, int *left,
+      int *right);
+   void (*destroy)(struct sysdep_mixer_struct *mixer);
+};
+
+struct sysdep_mixer_create_params {
+   const char *device;
+};
+
+#include "end_code.h"
+#endif /* ifndef __SYSDEP_MIXER_PRIV_H */
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/sysdep_palette.c mame-0.36b16/src/unix/sysdep/sysdep_palette.c
--- ../mmmmm/m36b16/src/unix/sysdep/sysdep_palette.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/sysdep_palette.c	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,424 @@
+/* Sysdep palette abstraction and emulation object
+
+   Copyright 1999,2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, November 1999
+-initial release (Hans de Goede)
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include "sysdep_palette.h"
+
+/* from xmame.h, since in the future we want this to be entirely mame
+   independent */
+extern struct sysdep_palette_info display_palette_info;
+int  sysdep_display_alloc_palette(int writable_colors);
+int  sysdep_display_set_pen(int pen, unsigned char red, unsigned char green, unsigned char blue);
+extern int widthscale, heightscale;
+
+/* private methods */
+static int sysdep_palette_make_pen_from_info(struct sysdep_palette_info
+   *info, unsigned char red, unsigned char green, unsigned char blue)
+{
+   int pen = 0;
+   
+   /* are the shifts initialised ? */
+   if(!info->red_shift)
+   {
+      for(pen = 1 << (8 * sizeof(pen) - 1); pen && (!(pen & info->red_mask));
+         pen >>= 1, info->red_shift++);
+
+      for(pen = 1 << (8 * sizeof(pen) - 1); pen && (!(pen & info->green_mask));
+         pen >>= 1, info->green_shift++);
+
+      for(pen = 1 << (8 * sizeof(pen) - 1); pen && (!(pen & info->blue_mask));
+         pen >>= 1, info->blue_shift++);
+   }
+   
+   pen  = ((red   << 24) >> info->red_shift)   & info->red_mask;
+   pen |= ((green << 24) >> info->green_shift) & info->green_mask;
+   pen |= ((blue  << 24) >> info->blue_shift)  & info->blue_mask;
+   
+   return pen;
+}
+
+
+/* public methods */
+struct sysdep_palette_struct *sysdep_palette_create(int depth,
+   int writable_colors)
+{
+   struct sysdep_palette_struct *palette = NULL;
+   int lookup_size = 0;
+   
+   /* verify if the display can handle the requested depth */
+   if ( display_palette_info.depth < depth )
+   {
+      fprintf(stderr,
+         "error in sysdep_palette_create: %d bpp requested on a %d bpp display\n",
+         depth, display_palette_info.depth);
+      return NULL;
+   }
+   
+   /* if the display is 8 bpp allocate the nescesarry pens for displays
+      with a shared palette like X */
+   if (display_palette_info.depth == 8)
+      if (sysdep_display_alloc_palette(writable_colors))
+         return NULL;
+   
+   /* allocate the palette struct */
+   if (!(palette = calloc(1, sizeof(struct sysdep_palette_struct))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct sysdep_palette_struct\n");
+      return NULL;
+   }
+   
+   palette->brightness   = 100;
+   palette->gamma        = 1.0;
+   palette->bright_dirty = 1;
+   
+   /* allocate the color lookup cache for get_pen */
+   if (writable_colors)
+   {
+      palette->colors = calloc(writable_colors, 3);
+      palette->color_dirty = calloc(writable_colors, 1);
+      if(!palette->colors || !palette->color_dirty)
+      {
+         fprintf(stderr, "error malloc failed for color cache\n");
+         sysdep_palette_destroy(palette);
+         return NULL;
+      }
+   }
+   
+   /* can we do our 8 -> 16 bpp speedup hack? */
+   if((depth == 8) &&
+      (display_palette_info.depth == 16) &&
+      (widthscale == 1) &&
+      (heightscale <= 2))
+      lookup_size = 65536;
+   
+   /* do we need a lookup table? */
+   else if ( (display_palette_info.depth != depth) ||
+        ( (depth == 16) && writable_colors) )
+      lookup_size = writable_colors? writable_colors:32768;
+      
+   if (lookup_size && !(palette->lookup = calloc(lookup_size, sizeof(int))))
+   {
+      fprintf(stderr, "error malloc failed for color lookup table\n");
+      sysdep_palette_destroy(palette);
+      return NULL;
+   }
+      
+   /* do we need to fill the lookup table? */
+   if (palette->lookup && !writable_colors)
+   {
+      int r,g,b;
+      
+      for(r=0; r<32; r++)
+         for(g=0; g<32; g++)
+            for(b=0; b<32; b++)
+               palette->lookup[r*1024 + g*32 + b] =
+                  sysdep_palette_make_pen_from_info(&display_palette_info,
+                     r*8, g*8, b*8);
+     
+      palette->lookup_dirty = 1;
+   }
+   
+   /* build the emulated palette info */
+   palette->emulated.writable_colors = writable_colors;
+   palette->emulated.depth           = depth;
+   /* fill in the masks and shifts if nescesarry */
+   if(!writable_colors)
+   {
+      if(palette->lookup)
+      {
+         /* if we're emulating a truecolor palette and we use a lookup
+            table, we always emulate 555 rgb */
+         palette->emulated.red_mask    = 0x7C00;
+         palette->emulated.green_mask  = 0x03E0;
+         palette->emulated.blue_mask   = 0x001F;
+      }
+      else
+      {
+         /* otherwise we're doing direct copy so use the display's values */
+         palette->emulated = display_palette_info;
+      }
+   }
+   
+   /* and mark the palette dirty so that the lookup table (if needed)
+      get's initalised upon the first sysdep_palette_update() */
+   sysdep_palette_mark_dirty(palette);
+
+   return palette;
+}
+
+/* destructor */
+void sysdep_palette_destroy(struct sysdep_palette_struct *palette)
+{
+   if(palette->colors)
+      free(palette->colors);
+   if(palette->color_dirty)
+      free(palette->color_dirty);
+   if(palette->lookup)
+      free(palette->lookup);
+   free(palette);
+}
+
+/* for pseudo color modes */   
+int sysdep_palette_set_pen(struct sysdep_palette_struct *palette, int pen,
+   unsigned char red, unsigned char green, unsigned char blue)
+{
+   if(pen >= palette->emulated.writable_colors)
+   {
+      fprintf(stderr,
+         "error in sysdep_palette_set_pen: pen (%d) out of range for writable_colors (%d)\n",
+         pen, palette->emulated.writable_colors);
+      return -1;
+   }
+  
+   if ( (palette->colors[pen*3]   == red)   &&
+        (palette->colors[pen*3+1] == green) &&
+        (palette->colors[pen*3+2] == blue) )
+      return 0;
+     
+   palette->colors[pen*3]   = red;
+   palette->colors[pen*3+1] = green;
+   palette->colors[pen*3+2] = blue;
+   
+   palette->color_dirty[pen] = 1;
+   palette->dirty = 1;
+   return 0;
+}
+
+int sysdep_palette_get_pen(struct sysdep_palette_struct *palette, int pen,
+   unsigned char *red, unsigned char *green, unsigned char *blue)
+{
+   if (palette->emulated.writable_colors)
+   {
+      if(pen >= palette->emulated.writable_colors)
+      {
+         fprintf(stderr,
+            "error in sysdep_palette_get_pen: pen (%d) out of range for writable_colors (%d)\n",
+            pen, palette->emulated.writable_colors);
+         return -1;
+      }
+      *red   = palette->colors[pen*3];
+      *green = palette->colors[pen*3+1];
+      *blue  = palette->colors[pen*3+2];
+   }
+   else
+   {
+      *red   = ((pen & palette->emulated.red_mask) <<
+         palette->emulated.red_shift) >> 24;
+      *green = ((pen & palette->emulated.green_mask) <<
+         palette->emulated.green_shift) >> 24;
+      *blue  = ((pen & palette->emulated.blue_mask) <<
+         palette->emulated.blue_shift) >> 24;
+   }
+   
+   return 0;
+}
+
+
+/* for true color modes */   
+int sysdep_palette_make_pen(struct sysdep_palette_struct *palette,
+   unsigned char red, unsigned char green, unsigned char blue)
+{
+   if(palette->emulated.writable_colors)
+   {
+      fprintf(stderr,
+         "error sysdep_palette_make_pen called for writable palette\n");
+      return -1;
+   }
+   
+   return sysdep_palette_make_pen_from_info(&palette->emulated, red, green,
+      blue);
+}
+
+
+void sysdep_palette_update(struct sysdep_palette_struct *palette)
+{
+   int i=0;
+   
+   palette->lookup_dirty = 0;
+   
+   if (palette->bright_dirty)
+   {
+      for (i=0; i<256; i++)
+         palette->bright_lookup[i] = (float)palette->brightness *
+            pow(i / 255.0, 1 / palette->gamma) * 2.55 + 0.5;
+      sysdep_palette_mark_dirty(palette);
+      palette->bright_dirty = 0;
+   }
+   
+   if (palette->dirty)
+   {
+      for (i=0; i<palette->emulated.writable_colors; i++)
+      {
+         if(palette->color_dirty[i])
+         {
+            unsigned char red =
+               palette->bright_lookup[palette->colors[i*3]];
+            unsigned char green =
+               palette->bright_lookup[palette->colors[i*3+1]];
+            unsigned char blue =
+               palette->bright_lookup[palette->colors[i*3+2]];
+            
+            if(!palette->lookup)
+            {
+               sysdep_display_set_pen(i, red, green, blue);
+            }
+            else
+            {
+               int color = sysdep_palette_make_pen_from_info(
+                  &display_palette_info, red, green, blue);
+               
+               /* can we do our 8 -> 16 bpp speedup hack? */
+               if((palette->emulated.depth == 8) &&
+                  (display_palette_info.depth == 16) &&
+                  (widthscale == 1) &&
+                  (heightscale <= 2))
+               {
+                  int n;
+                  for(n=0;n<256;n++)
+                  {
+                     palette->lookup[(n<<8) | i] &= 0xffff0000;
+                     palette->lookup[(n<<8) | i] |= color;
+                     
+                     palette->lookup[(i<<8) | n] &= 0x0000ffff;
+                     palette->lookup[(i<<8) | n] |= color << 16;
+                  }
+               }
+               else
+                  palette->lookup[i] = color;
+               
+               palette->lookup_dirty = 1;
+            }
+            palette->color_dirty[i] = 0;
+         }
+      }
+      palette->dirty = 0;
+   }
+}
+
+int sysdep_palette_change_display(struct sysdep_palette_struct **palette)
+{
+   int i;
+   struct sysdep_palette_struct *new_palette = NULL;
+   
+   if(!(new_palette=sysdep_palette_create((*palette)->emulated.depth,
+      (*palette)->emulated.writable_colors)))
+      return -1;
+   
+   if ((*palette)->emulated.writable_colors)
+   {
+      /* copy all the old colors */
+      for(i=0; i<(*palette)->emulated.writable_colors; i++)
+         sysdep_palette_set_pen(new_palette, i, (*palette)->colors[i*3],
+            (*palette)->colors[i*3+1], (*palette)->colors[i*3+2]);
+   }
+   else
+   {
+      /* check that the color masks of the new palette are the same as the old
+         colormasks, otherwise barf for now, we could emulate them later on
+         as follows:
+         - close new_palette
+         - recreate new_palette writable
+         - set all the pens of new_palette so that they match
+           the old masks.
+         - modify new_palette->emulated so that it becomes non-wrtiable,
+           with the masks of the old palette.
+         However if we're going this way, we might just as well
+         add the possibility to sysdep_palette_create to force specific 
+         colormasks, which we might want in the future anyway
+      */
+      if ( ((*palette)->emulated.red_mask   != new_palette->emulated.red_mask) ||
+           ((*palette)->emulated.green_mask != new_palette->emulated.green_mask) ||
+           ((*palette)->emulated.blue_mask  != new_palette->emulated.blue_mask))
+      {
+         fprintf(stderr, "error recreating palette, colormasks don't match!\n");
+         sysdep_palette_destroy(new_palette);
+         return -1;
+      }
+   }
+   
+   sysdep_palette_destroy(*palette);
+   *palette = new_palette;
+   return 0;
+}
+
+void sysdep_palette_mark_dirty(struct sysdep_palette_struct *palette)
+{
+   int i;
+   
+   if(palette->emulated.writable_colors)
+   {
+      for (i=0; i<palette->emulated.writable_colors; i++)
+         palette->color_dirty[i] = 1;
+      
+      palette->dirty = 1;
+   }
+}
+
+/* brightness = percentage 0-100% */
+int sysdep_palette_set_brightness(struct sysdep_palette_struct *palette,
+   int brightness)
+{
+   if (palette->brightness != brightness)
+   {
+      palette->brightness = brightness;
+         
+      /* failing isn't such a disaster thus we do it quietly */
+      if(!palette->emulated.writable_colors)
+         return -1;
+      
+      palette->bright_dirty = 1;
+   }
+
+   return 0;
+}
+
+int sysdep_palette_get_brightness(struct sysdep_palette_struct *palette)
+{
+   return palette->brightness;
+}
+
+
+int sysdep_palette_set_gamma(struct sysdep_palette_struct *palette,
+   float gamma)
+{
+   if (palette->gamma != gamma)
+   {
+      palette->gamma = gamma;
+
+      /* failing isn't such a disaster thus we do it quietly */
+      if(!palette->emulated.writable_colors)
+         return -1;
+
+      palette->bright_dirty = 1;
+   }
+
+   return 0;
+}
+
+float sysdep_palette_get_gamma(struct sysdep_palette_struct *palette)
+{
+   return palette->gamma;
+}
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/sysdep_palette.h mame-0.36b16/src/unix/sysdep/sysdep_palette.h
--- ../mmmmm/m36b16/src/unix/sysdep/sysdep_palette.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/sysdep_palette.h	2023-07-07 14:20:22.692001899 -0400
@@ -0,0 +1,128 @@
+/* Sysdep palette abstraction and emulation object
+
+   Copyright 1999,2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __SYSDEP_PALETTE_H
+#define __SYSDEP_PALETTE_H
+
+#include "begin_code.h"
+
+/* This struct is used to describe both the emulated palette and the
+   display's palette.
+   
+   The following modes are concidered valid for the display's palette
+   (depth, writable_colors) :
+   8,  256
+   16, 0
+   24, 0
+   32, 0
+   
+   The following modes can be emulated:
+   8,  1-256
+   16, 0
+   16, 1-65536
+   
+   Using this code with a display with any other palette, or requesting
+   any other palette to be emulated is unsupported, and may result
+   in undefined behaviour.
+*/
+struct sysdep_palette_info
+{
+   int writable_colors; /* 0 for truecolor, the number of writable colors
+                           for psuedo color */
+   int depth;           /* pixel size (not colordepth!) in bpp (8,16,24,32) */
+   int red_shift;       /* shifts and masks to calculate true_color palette */
+   int green_shift;     /* entries */
+   int blue_shift;
+   int red_mask;
+   int green_mask;
+   int blue_mask;
+};
+
+struct sysdep_palette_struct
+{
+   struct sysdep_palette_info emulated;
+   int dirty;
+   unsigned char *colors; /* used to cache the color values of pseudo color
+                             pens for get_pen */
+   unsigned char *color_dirty;
+   int *lookup;           /* lookup table to be used for blitters to convert
+                             the emulated palette to the physical palette */
+   int lookup_dirty;      /* this is set when the lookup table is changed,
+                             to notify blitters that they should update the
+                             entire screen */
+   float gamma;
+   int brightness;        /* brightess = percentage 0-100% */
+   int bright_dirty;
+   unsigned char bright_lookup[256];
+};
+
+/* This function creates a sysdep palette object for the current
+   display, which can be used with the display update functios.
+
+   Parameters:
+   depth           Color depth of the palette to be emulated valid values:
+                   8 or 16.
+   writable_colors The number of writable colors you want or 0 if you want
+                   true color. Valid values for depth == 8: 1-256, for
+                   depth == 16: 0-65536.
+                   
+   Return value:
+   A pointer to the sysdep palette object, or NULL on failure.
+   Upon failure an error message wil be printed to stderr.
+*/
+struct sysdep_palette_struct *sysdep_palette_create(int depth,
+   int writable_colors);
+   
+/* destructor */
+void sysdep_palette_destroy(struct sysdep_palette_struct *palette);
+
+/* for pseudo color modes */   
+int sysdep_palette_set_pen(struct sysdep_palette_struct *palette, int pen,
+   unsigned char red, unsigned char green, unsigned char blue);
+   
+int sysdep_palette_get_pen(struct sysdep_palette_struct *palette, int pen,
+   unsigned char *red, unsigned char *green, unsigned char *blue);
+
+/* for true color modes */   
+int sysdep_palette_make_pen(struct sysdep_palette_struct *palette,
+   unsigned char red, unsigned char green, unsigned char blue);
+
+void sysdep_palette_update(struct sysdep_palette_struct *palette);
+
+/* This function has to be called if the display is changed, it recreates
+   the palette object with the settings from the new display */
+int sysdep_palette_change_display(struct sysdep_palette_struct **palette);
+
+/* This function will cause all pens to be reset, this is usefull for
+   pseudocolor displays, if for some reason the hw palette
+   was reset, for example after switching to textmode */
+void sysdep_palette_mark_dirty(struct sysdep_palette_struct *palette);
+
+int sysdep_palette_set_brightness(struct sysdep_palette_struct *palette,
+   int brightness);
+
+int sysdep_palette_get_brightness(struct sysdep_palette_struct *palette);
+
+int sysdep_palette_set_gamma(struct sysdep_palette_struct *palette,
+   float gamma);
+
+float sysdep_palette_get_gamma(struct sysdep_palette_struct *palette);
+
+#include "end_code.h"
+#endif /* ifndef __SYSDEP_PALETTE_H */
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/unused/parser.c mame-0.36b16/src/unix/sysdep/unused/parser.c
--- ../mmmmm/m36b16/src/unix/sysdep/unused/parser.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/unused/parser.c	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,159 @@
+/* A simple text parser
+
+   Copyright 1999,2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* TODO:
+- allow unlimited number of arguments
+- check for comments ('#'), to allow parsing files
+- check for to much arguments
+- allow registering / removing parser elements
+- make a copy of the string before parsing it, make string a const * ?
+- put parser_struct in parser_priv.h
+*/
+/* Changelog
+Version 0.1, November 1999
+-initial release (Hans de Goede)
+Version 0.2, December 1999
+-changed parser_parse_tokens to take the command as a seperate argument
+ instead of using token[0], this allows the caller to remove the - for
+ a commandline option for example. (Hans de Goede)
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "parser.h"
+
+struct parser_struct *parser_create(const struct parser_element *element[])
+{
+   int i,j;
+   struct parser_struct *parser = NULL;
+   
+   if (!element)
+      return NULL;
+      
+   for(i=0; element[i]; i++)
+   {
+      for(j=0; element[i][j].name; j++)
+      {
+         if(element[i][j].arg_count > BUF_SIZE)
+         {
+            fprintf(stderr,
+               "error parser doesn't support commands with more then %d arguments",
+               BUF_SIZE);
+            return NULL;
+         }
+      }
+   }
+   
+   if (!(parser = calloc(1, sizeof(struct parser_struct))))
+   {
+      fprintf(stderr, "error malloc failed for struct parser_struct");
+      return NULL;
+   }
+   parser->element = element;
+   return parser;
+}
+
+void parser_destroy(struct parser_struct *parser)
+{
+   if (parser)
+      free(parser);
+}
+
+static const struct parser_element *parser_find_element(
+   struct parser_struct *parser, const char *command)
+{
+   int i,j;
+   
+   for(i=0; parser->element[i]; i++)
+   {
+      for(j=0; parser->element[i][j].name; j++)
+      {
+         if(!strcmp(command, parser->element[i][j].name) ||
+            (parser->element[i][j].shortname &&
+               !strcmp(command, parser->element[i][j].shortname)))
+         {
+            return &parser->element[i][j];
+         }
+      }
+   }
+   fprintf(stderr, "error unknown command: %s", command);
+   return NULL;
+}
+
+int parser_parse_string(struct parser_struct *parser, char *string)
+{
+   int i;
+   const char *command;
+   const char *arg[BUF_SIZE];
+   const struct parser_element *element = NULL;
+  
+   if(!(command = strtok(string, " \t\r\n")))
+      return 0;
+ 
+   if(!(element = parser_find_element(parser, command)))
+      return -1;
+
+   for(i=0; i < element->arg_count; i++)
+   {
+      arg[i] = strtok(NULL, " \t\r\n");
+      if (!arg[i])
+      {
+         fprintf(stderr, "error %s requires %d arguments",
+            element->name, element->arg_count);
+         return -1;
+      }
+   }
+   
+   return (*element->function)(arg, element->flags);
+}
+
+int parser_parse_tokens(struct parser_struct *parser, const char *command,
+   int tokenc, const char *tokenv[], int *tokens_used)
+{
+   const struct parser_element *element = NULL;
+   
+   *tokens_used = 0;
+      
+   if(!(element = parser_find_element(parser, command)))
+      return -1;
+
+   if (tokenc < element->arg_count)
+   {
+      fprintf(stderr, "error %s requires %d arguments",
+         element->name, element->arg_count);
+      return -1;
+   }
+   *tokens_used = element->arg_count;
+   return (*element->function)(tokenv, element->flags);
+}
+
+int parser_get_arg_count(struct parser_struct *parser, const char *command,
+   int *arg_count)
+{
+   const struct parser_element *element = NULL;
+   
+   *arg_count = 0;
+      
+   if(!(element = parser_find_element(parser, command)))
+      return -1;
+   
+   *arg_count = element->arg_count;
+   return 0;
+}
+
diff -Naur ../mmmmm/m36b16/src/unix/sysdep/unused/parser.h mame-0.36b16/src/unix/sysdep/unused/parser.h
--- ../mmmmm/m36b16/src/unix/sysdep/unused/parser.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/sysdep/unused/parser.h	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,52 @@
+/* A simple text parser
+
+   Copyright 1999,2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __PARSER_H
+#define __PARSER_H
+
+#include "begin_code.h"
+
+struct parser_element
+{
+   const char *name;
+   const char *shortname;
+   int (*function)(const char *arg[], void *flags);
+   int arg_count;
+   void *flags;
+};
+
+struct parser_struct
+{
+   const struct parser_element **element;
+};
+
+struct parser_struct *parser_create(const struct parser_element *element[]);
+
+void parser_destroy(struct parser_struct *parser);
+
+int parser_parse_string(struct parser_struct *parser, char *string);
+
+int parser_parse_tokens(struct parser_struct *parser, const char *command,
+   int tokenc, const char *tokenv[], int *tokens_used);
+   
+int parser_get_arg_count(struct parser_struct *parser, const char *command,
+   int *arg_count);
+
+#include "end_code.h"
+#endif /* ifndef __PARSER_H */
diff -Naur ../mmmmm/m36b16/src/unix/unix.mak mame-0.36b16/src/unix/unix.mak
--- ../mmmmm/m36b16/src/unix/unix.mak	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/unix.mak	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,330 @@
+##############################################################################
+# None user configurable settings
+##############################################################################
+
+# *** Comment this line to get verbose make output, for debugging build
+# problems
+QUIET = 1
+
+
+##############################################################################
+# **** CPU dependent settings.
+##############################################################################
+#note : -D__CPU_$(MY_CPU) is added automaticly later on.
+CFLAGS.i386       = -DLSB_FIRST -DX86_ASM
+CFLAGS.i386_noasm = -DLSB_FIRST
+CFLAGS.amd64      = -DLSB_FIRST -DALIGN_INTS -DALIGN_SHORTS -D__LP64__
+CFLAGS.ia64       = -DLSB_FIRST -DALIGN_INTS -DALIGN_SHORTS -D__LP64__
+CFLAGS.alpha      = -DLSB_FIRST -DALIGN_INTS -DALIGN_SHORTS -D__LP64__
+CFLAGS.m68k       = 
+CFLAGS.risc       = -DALIGN_INTS -DALIGN_SHORTS 
+CFLAGS.risc_lsb   = -DALIGN_INTS -DALIGN_SHORTS -DLSB_FIRST
+CFLAGS.mips       = -DALIGN_INTS -DALIGN_SHORTS -DSGI_FIX_MWA_NOP
+
+##############################################################################
+# **** Architecture dependent settings.
+##############################################################################
+LIBS.solaris       = -lnsl -lsocket
+LIBS.irix          = -laudio
+LIBS.irix_al       = -laudio
+LIBS.aix           = -lUMSobj
+
+##############################################################################
+# **** Display dependent settings.
+##############################################################################
+#first calculate the X11 Joystick driver settings, this is done here since
+#they are only valid for X11 based display methods
+ifdef JOY_X11
+JOY_X11_CFLAGS = -DX11_JOYSTICK "-DX11_JOYNAME='$(X11_JOYNAME)'" -DUSE_X11_JOYEVENTS
+JOY_X11_LIBS   = -lXi
+endif
+
+# svga and ggi also use $(X11LIB) since that's where zlib often is
+LIBS.x11        = $(X11LIB) $(JOY_X11_LIBS) -lX11 -lXext 
+LIBS.svgalib    = $(X11LIB) -lvga -lvgagl
+LIBS.ggi        = $(X11LIB) -lggi
+LIBS.xgl        = $(X11LIB) $(JOY_X11_LIBS) -lX11 -lXext $(GLLIBS) -ljpeg
+LIBS.xfx        = $(X11LIB) $(JOY_X11_LIBS) -lX11 -lXext -lglide2x
+LIBS.svgafx     = $(X11LIB) -lvga -lvgagl -lglide2x
+LIBS.openstep	= -framework AppKit -framework SoundKit
+LIBS.SDL	= -ldl -lSDL -lpthread -D_REENTRANT
+
+CFLAGS.x11      = $(X11INC) $(JOY_X11_CFLAGS)
+CFLAGS.xgl      = $(X11INC) $(JOY_X11_CFLAGS) $(GLDRIVER)
+CFLAGS.xfx      = $(X11INC) $(JOY_X11_CFLAGS) -I/usr/include/glide
+CFLAGS.svgafx   = -I/usr/include/glide
+CFLAGS.SDL      = -D_REENTRANT
+
+INST.x11        = doinstall
+INST.ggi        = doinstall
+INST.svgalib    = doinstallsuid
+INST.xgl        = doinstallsuid copycab
+INST.xfx        = doinstallsuid
+INST.svgafx     = doinstallsuid
+INST.SDL	= doinstallsuid
+
+# handle X11 display method additonal settings
+ifdef X11_MITSHM
+CFLAGS.x11 += -DUSE_MITSHM
+endif
+ifdef X11_DGA
+CFLAGS.x11 += -DUSE_DGA
+LIBS.x11   += -lXxf86dga -lXxf86vm
+endif
+ifdef X11_XIL
+CFLAGS.x11 += -DUSE_XIL
+LIBS.x11   += -lxil -lpthread
+endif
+
+
+##############################################################################
+# Quiet the compiler output if requested
+##############################################################################
+
+ifdef QUIET
+CC_COMMENT = 
+CC_COMPILE = @
+AR_OPTS = rc
+else
+CC_COMMENT = \#
+CC_COMPILE = 
+AR_OPTS = rcv
+endif
+
+
+##############################################################################
+# these are the object subdirectories that need to be created.
+##############################################################################
+OBJ     = $(TARGET).obj
+
+CORE_OBJDIRS = $(OBJ) \
+	$(OBJ)/drivers $(OBJ)/machine $(OBJ)/vidhrdw $(OBJ)/sndhrdw \
+	$(OBJ)/cpu $(OBJ)/sound \
+	$(OBJ)/mess $(OBJ)/mess/formats $(OBJ)/mess/systems $(OBJ)/mess/machine \
+	$(OBJ)/mess/vidhrdw $(OBJ)/mess/sndhrdw $(OBJ)/mess/tools
+
+
+##############################################################################
+# "Calculate" the final CFLAGS, unix CONFIG, LIBS and OBJS
+##############################################################################
+ifdef ZLIB
+ZLIB    = contrib/cutzlib-1.1.3/libz.a
+endif
+
+all: $(ZLIB) objdirs osdepend x$(TARGET).$(DISPLAY_METHOD)
+
+# CPU core include paths
+VPATH=src $(wildcard src/cpu/*)
+
+#the dirio object for imagetool
+IMGTOOL_OBJS = $(OBJ)/unix.$(DISPLAY_METHOD)/dirio.o
+
+include src/core.mak
+include src/$(TARGET).mak
+include src/rules.mak
+
+# Perhaps one day original mame/mess sources will use POSIX strcasecmp and
+# M_PI instead MS-DOS counterparts... ( a long and sad history ...)
+MY_CFLAGS = $(CFLAGS) $(IL) $(CFLAGS.$(MY_CPU)) \
+	-D__ARCH_$(ARCH) -D__CPU_$(MY_CPU) -D$(DISPLAY_METHOD) \
+	-Dstricmp=strcasecmp -Dstrnicmp=strncasecmp \
+	-DPI=M_PI -DUNIX -DSIGNED_SAMPLES \
+	$(COREDEFS) $(SOUNDDEFS) $(CPUDEFS) $(ASMDEFS) \
+	$(INCLUDES) -Isrc -Imess -Isrc/unix \
+	-I$(OBJ)/cpu/m68000 -Isrc/cpu/m68000
+
+MY_LIBS = $(LIBS) $(LIBS.$(ARCH)) $(LIBS.$(DISPLAY_METHOD)) -lz -lm
+
+ifdef ZLIB
+MY_CFLAGS += -Icontrib/cutzlib-1.1.3 -I../../contrib/cutzlib-1.1.3
+LDFLAGS   = -Lcontrib/cutzlib-1.1.3
+endif
+
+ifdef MAME_DEBUG
+MY_CFLAGS += -DMAME_DEBUG
+MY_LIBS   += -lcurses
+endif
+   
+# CONFIG are the cflags used to build the unix tree, this is were most defines
+# go
+CONFIG = $(MY_CFLAGS) $(CFLAGS.$(DISPLAY_METHOD)) -DNAME='\"x$(TARGET)\"' \
+	-DDISPLAY_METHOD='\"$(DISPLAY_METHOD)\"' -DXMAMEROOT='\"$(XMAMEROOT)\"'
+
+ifdef HAVE_GETTIMEOFDAY
+CONFIG += -DHAVE_GETTIMEOFDAY
+endif
+
+# Sound drivers config
+ifdef SOUND_ESOUND
+CONFIG  += -DSYSDEP_DSP_ESOUND `esd-config --cflags`
+MY_LIBS += `esd-config --libs`
+endif
+
+ifdef SOUND_ALSA
+CONFIG  += -DSYSDEP_DSP_ALSA 
+MY_LIBS += -lasound
+endif
+
+# Joystick drivers config
+ifdef JOY_I386
+CONFIG += -DI386_JOYSTICK
+endif
+ifdef JOY_PAD
+CONFIG += -DLIN_FM_TOWNS
+endif
+ifdef JOY_USB
+CONFIG += -DUSB_JOYSTICK
+MY_LIBS += -lusb
+endif
+
+ifdef EFENCE
+MY_LIBS += -lefence
+endif
+
+#we remove $(OBJ)/vidhrdw/vector.o from $(COREOBJS) since we have our own
+#build rules for this object because it is display dependent.
+OBJS  += $(subst $(OBJ)/vidhrdw/vector.o, ,$(COREOBJS)) $(DRVLIBS) \
+ $(OBJ)/unix.$(DISPLAY_METHOD)/osdepend.a $(OBJ)/unix.$(DISPLAY_METHOD)/vector.o
+
+MY_OBJDIRS = $(CORE_OBJDIRS) $(sort $(OBJDIRS))
+
+
+##############################################################################
+# Begin of the real makefile.
+##############################################################################
+x$(TARGET).$(DISPLAY_METHOD): $(OBJS)
+	$(CC_COMMENT) @echo 'Linking $@ ...'
+	$(CC_COMPILE) $(LD) $(LDFLAGS) -o $@ $(OBJS) $(MY_LIBS)
+
+tools: $(ZLIB) $(OBJDIRS) $(TOOLS)
+
+objdirs: $(MY_OBJDIRS)
+
+$(MY_OBJDIRS):
+	-mkdir $@
+
+xlistdev: contrib/tools/xlistdev.c
+	$(CC_COMMENT) @echo 'Compiling $< ...'
+	$(CC_COMPILE) $(CC) $(X11INC) contrib/tools/xlistdev.c -o xlistdev $(JSLIB) $(LIBS.$(ARCH)) $(LIBS.$(DISPLAY_METHOD)) -lm
+
+romcmp: $(OBJ)/romcmp.o $(OBJ)/unzip.o
+	$(CC_COMMENT) @echo Linking $@...
+	$(CC_COMPILE) $(LD) $(LDFLAGS) -o $@ $^ -lz
+
+osdepend:
+	$(CC_COMMENT) @echo 'Compiling in the unix directory...'
+	$(CC_COMPILE) \
+	 ( \
+	 cd src/unix; \
+	  $(MAKE) CC="$(CC)" RANLIB="$(RANLIB)" ARCH="$(ARCH)" \
+	  DISPLAY_METHOD="$(DISPLAY_METHOD)" CFLAGS="$(CONFIG)" \
+	  CC_COMMENT="$(CC_COMMENT)" CC_COMPILE="$(CC_COMPILE)" \
+	  AR_OPTS="$(AR_OPTS)" OBJ="$(OBJ)" \
+	 )
+
+contrib/cutzlib-1.1.3/libz.a:
+	( \
+	cd contrib/cutzlib-1.1.3; \
+	./configure; \
+	$(MAKE) libz.a \
+	)
+
+ifdef MESS
+$(OBJ)/mess/%.o: mess/%.c
+	$(CC_COMMENT) @echo '[MESS] Compiling $< ...'
+	$(CC_COMPILE) $(CC) $(MY_CFLAGS) -o $@ -c $<
+endif
+
+$(OBJ)/%.o: src/%.c
+	$(CC_COMMENT) @echo 'Compiling $< ...'
+	$(CC_COMPILE) $(CC) $(MY_CFLAGS) -o $@ -c $<
+
+$(OBJ)/%.a:
+	$(CC_COMMENT) @echo 'Archiving $@ ...'
+	$(CC_COMPILE) ar $(AR_OPTS) $@ $^
+	$(CC_COMPILE) $(RANLIB) $@
+
+# special cases for the 68000 core
+#
+# this generates the C source files for the 68000 emulator
+$(OBJ)/cpu/m68000/m68kmake $(OBJ)/cpu/m68000/m68kops.h: src/cpu/m68000/m68kmake.c src/cpu/m68000/m68k_in.c
+	$(CC_COMMENT) @echo 'Compiling src/cpu/m68000/m68kmake.c ...'
+	$(CC_COMPILE) $(CC) $(MY_CFLAGS) -o $(OBJ)/cpu/m68000/m68kmake src/cpu/m68000/m68kmake.c
+	$(CC_COMMENT) @echo 'Compiling src/cpu/m68000/m68k_in.c ...'
+	$(CC_COMPILE) $(OBJ)/cpu/m68000/m68kmake $(OBJ)/cpu/m68000 src/cpu/m68000/m68k_in.c
+
+# to compile generated C-files
+$(M68000_GENERATED_OBJS): $(OBJ)/cpu/m68000/m68kmake
+	$(CC_COMMENT) @echo 'Compiling $*.c ...'
+	$(CC_COMPILE) $(CC) $(MY_CFLAGS) -o $@ -c $*.c
+
+# src/cpu/m68000/m68kcpu.c needs a generated .h file
+$(OBJ)/cpu/m68000/m68kcpu.o: $(OBJ)/cpu/m68000/m68kops.h
+
+# The m68000 asm core
+$(OBJ)/cpu/m68000/68kem.asm: src/cpu/m68000/make68k.c
+	$(CC_COMMENT) @echo 'Compiling $< ...'
+	$(CC_COMPILE) $(CC) $(MY_CFLAGS) -o $(OBJ)/cpu/m68000/make68k $<
+	$(CC_COMPILE) $(OBJ)/cpu/m68000/make68k $@ $(OBJ)/cpu/m68000/comptab.asm
+
+$(OBJ)/cpu/m68000/68kem.o: $(OBJ)/cpu/m68000/68kem.asm
+	$(CC_COMMENT) @echo 'Assembling $< ...'
+	$(CC_COMPILE) $(ASM_STRIP) $<
+	$(CC_COMPILE) nasm $(NASM_FMT) -o $@ $<
+
+
+#some tricks, since vector.o these days is display-method dependent:
+$(OBJ)/unix.$(DISPLAY_METHOD)/vector.o: src/vidhrdw/vector.c
+	$(CC_COMMENT) @echo 'Compiling $< ...'
+	$(CC_COMPILE) $(CC) $(MY_CFLAGS) -o $@ -c $<
+
+#make sure this isn't accidently in makefile.$(OBJ):
+$(OBJ)/vidhrdw/vector.o: bla
+
+doc: doc/xmame-doc.txt doc/x$(TARGET)rc.dist doc/gamelist.$(TARGET) doc/x$(TARGET).6
+
+doc/xmame-doc.txt: doc/xmame-doc.sgml
+	cd doc; \
+	sgml2txt   -l en -p a4 -f          xmame-doc.sgml; \
+	sgml2html  -l en -p a4             xmame-doc.sgml; \
+	sgml2latex -l en -p a4 --output=ps xmame-doc.sgml; \
+	rm -f xmame-doc.lyx~
+	
+doc/x$(TARGET)rc.dist: all src/unix/xmamerc-keybinding-notes.txt
+	./x$(TARGET).$(DISPLAY_METHOD) -noloadconfig -showconfig | \
+	 grep -v loadconfig > doc/x$(TARGET)rc.dist
+	cat src/unix/xmamerc-keybinding-notes.txt >> doc/x$(TARGET)rc.dist
+	
+doc/gamelist.$(TARGET): all
+	./x$(TARGET).$(DISPLAY_METHOD) -listgamelistheader > doc/gamelist.$(TARGET)
+	./x$(TARGET).$(DISPLAY_METHOD) -listgamelist >> doc/gamelist.$(TARGET)
+
+doc/x$(TARGET).6: all src/unix/xmame.6-1 src/unix/xmame.6-3
+	cat src/unix/xmame.6-1 > doc/x$(TARGET).6
+	./x$(TARGET).$(DISPLAY_METHOD) -manhelp >> doc/x$(TARGET).6
+	cat src/unix/xmame.6-3 >> doc/x$(TARGET).6
+
+install: $(INST.$(DISPLAY_METHOD)) install-man
+	@echo x$(TARGET) for $(ARCH)-$(MY_CPU) installation completed
+
+install-man:
+	@echo installing manual pages under $(MANDIR) ...
+	-mkdir $(MANDIR)
+	$(INSTALL) doc/xmame.man $(MANDIR)/xmame.6
+
+doinstall:
+	@echo installing binaries under $(DESTDIR)...
+	$(INSTALL) x$(TARGET).$(DISPLAY_METHOD) $(DESTDIR)
+
+doinstallsuid:
+	@echo installing binaries under $(DESTDIR)...
+	$(INSTALL) x$(TARGET).$(DISPLAY_METHOD) $(DESTDIR)
+	chmod 4755 $(DESTDIR)/$(NAME).$(DISPLAY_METHOD)
+
+copycab:
+	@echo installing cabinet files under $(XMAMEROOT)...
+	$(INSTALL) -R cab $(XMAMEROOT)
+
+clean: 
+	rm -fr $(OBJ) x$(TARGET).* xlistdev contrib/cutzlib-1.1.3/libz.a contrib/cutzlib-1.1.3/*.o $(TARGET).dep
+#	cd makedep; make clean
diff -Naur ../mmmmm/m36b16/src/unix/video.c mame-0.36b16/src/unix/video.c
--- ../mmmmm/m36b16/src/unix/video.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video.c	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,705 @@
+/*
+ * X-Mame generic video code
+ *
+ */
+#define __VIDEO_C_
+#include <math.h>
+#include "xmame.h"
+#include "driver.h"
+#include "profiler.h"
+#include "input.h"
+/* for uclock */
+#include "sysdep/misc.h"
+
+#define FRAMESKIP_DRIVER_COUNT 2
+
+extern int bitmap_dirty;
+static const int safety = 16;
+static float beam_f, flicker_f;
+static float widthscale_f, heightscale_f;
+static char *vector_res = NULL;
+static int use_auto_double = 1;
+static int frameskipper = 0;
+static float gamma_correction = 1.0;
+static int brightness = 100;
+static float brightness_paused_adjust = 1.0;
+
+/* some prototypes */
+static int video_handle_scale(struct rc_option *option, const char *arg,
+   int priority);
+static int video_verify_scale(struct rc_option *option, const char *arg,
+   int priority);
+static int video_verify_beam(struct rc_option *option, const char *arg,
+   int priority);
+static int video_verify_flicker(struct rc_option *option, const char *arg,
+   int priority);
+static int video_verify_bpp(struct rc_option *option, const char *arg,
+   int priority);
+
+struct rc_option video_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "Video Related",	NULL,			rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "bpp",		NULL,			rc_int,		&options.color_depth,
+     "0",		0,			0,		video_verify_bpp,
+     "Specify the colordepth the core should render, one of: auto(0), 8, 16" },
+   { "heightscale",	NULL,			rc_float,	&heightscale_f,
+     "1",		0.5,			5.0,		video_verify_scale,
+     "Set Y-Scale aspect ratio" },
+   { "widthscale",	NULL,			rc_float,	&widthscale_f,
+     "1",		0.5,			5.0,		video_verify_scale,
+     "Set X-Scale aspect ratio" },
+   { "scale",		NULL,			rc_use_function, NULL,
+     NULL,		0,			0,		video_handle_scale,
+     "Set X-Y Scale to the same aspect ratio. For vector games scale (and also width- and heightscale) may have value's like 1.5 and even 0.5. For scaling of regular games this will be rounded to an int" },
+   { "autodouble",	"noautodouble",		rc_bool,	&use_auto_double,
+     "1",		0,			0,		NULL,
+     "Enable/disable automatic scale doubling for 1:2 pixel aspect ratio games" },
+   { "dirty",		"nodirty",		rc_bool,	&use_dirty,
+     "1",		0,			0,		NULL,
+     "Enable/disable use of dirty rectangles" },
+   { "scanlines",	"noscanlines",		rc_bool,	&use_scanlines,
+     "0",		0,			0,		NULL,
+     "Enable/disable displaying simulated scanlines" },
+   { "artwork",		"noartwork",		rc_bool,	&options.use_artwork,
+     "1",		0,			0,		NULL,
+     "Use/don't use artwork if available" },
+   { "frameskipper",	NULL,			rc_int,		&frameskipper,
+     "0",		0,			FRAMESKIP_DRIVER_COUNT-1, NULL,
+     "Select which autoframeskip and throttle routines to use. Available choices are:\n0 Dos frameskip code\n1 Enhanced frameskip code by William A. Barath" },
+   { "throttle",	"nothrottle",		rc_bool,	&throttle,
+     "1",		0,			0,		NULL,
+     "Enable/disable throttle" },
+   { "sleepidle",	"nosleepidle",		rc_bool,	&sleep_idle,
+     "0",		0,			0,		NULL,
+     "Enable/disable sleep during idle" },
+   { "autoframeskip",	"noautoframeskip",	rc_bool,	&autoframeskip,
+     "1",		0,			0,		NULL,
+     "Enable/disable autoframeskip" },
+   { "maxautoframeskip", NULL,			rc_int,		&max_autoframeskip,
+     "8",		0,			FRAMESKIP_LEVELS-1, NULL,
+     "Set highest allowed frameskip for autoframeskip" },
+   { "frameskip",	NULL,			rc_int,		&frameskip,
+     "0",		0,			FRAMESKIP_LEVELS-1, NULL,
+     "Set frameskip when not using autoframeskip" },
+   { "brightness",	NULL,			rc_int,		&brightness,
+     "100",		0,			100,		NULL,
+     "Set the brightness (0-100%%)" },
+   { "gamma-correction", NULL,			rc_float,	&gamma_correction,
+     "1.0",		0.5,			2.0,		NULL,
+     "Set the gamma-correction (0.5-2.0)" },
+   { "norotate",	NULL,			rc_set_int,	&options.norotate,
+     NULL,		1,			0,		NULL,
+     "Disable rotation" },
+   { "ror",		NULL,			rc_set_int,	&options.ror,
+     NULL,		1,			0,		NULL,
+     "Rotate display 90 degrees rigth" },
+   { "rol",		NULL,			rc_set_int,	&options.rol,
+     NULL,		1,			0,		NULL,
+     "Rotate display 90 degrees left" },
+   { "flipx",		NULL,			rc_set_int,	&options.flipx,
+     NULL,		1,			0,		NULL,
+     "Flip X axis" },
+   { "flipy",		NULL,			rc_set_int,	&options.flipy,
+     NULL,		1,			0,		NULL,
+     "Flip Y axis" },
+   { "Vector Games Related", NULL,		rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "vectorres",	NULL,			rc_string,	&vector_res,
+     NULL,		0,			0,		NULL,
+     "Always scale vectorgames to XresxYres, keeping their aspect ratio. This overrides the scale options" },
+   { "beam",		NULL,			rc_float,	&beam_f,
+     "1.0",		1.0,			16.0,		video_verify_beam,
+     "Set the beam size for vector games" },
+   { "flicker",		NULL,			rc_float,	&flicker_f,
+     "0.0",		0.0,			100.0,		video_verify_flicker,
+     "Set the flicker for vector games" },
+   { "antialias",	"noantialias",		rc_bool,	&options.antialias,
+     "1",		0,			0,		NULL,
+     "Enable/disable antialiasing" },
+   { "translucency",	"notranslucency",	rc_bool,	&options.translucency,
+     "1",		0,			0,		NULL,
+     "Enable/disable tranlucency" },
+   { NULL,		NULL,			rc_link,	display_opts,
+     NULL,		0,			0,		NULL,
+     NULL },     
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+static int video_handle_scale(struct rc_option *option, const char *arg,
+   int priority)
+{
+   if (rc_set_option2(video_opts, "widthscale", arg, priority))
+      return -1;
+   if (rc_set_option2(video_opts, "heightscale", arg, priority))
+      return -1;
+      
+   option->priority = priority;
+   
+   return 0;
+}
+
+static int video_verify_scale(struct rc_option *option, const char *arg,
+   int priority)
+{
+   int scale = *(float *)option->dest;
+   
+   if (scale < 1)
+      scale = 1;
+   
+   /* widthscale or heightscale? */
+   if (!strcmp(option->name, "widthscale"))
+      widthscale = scale;
+   else
+      heightscale = scale;
+
+   option->priority = priority;
+
+   return 0;
+}
+
+static int video_verify_beam(struct rc_option *option, const char *arg,
+   int priority)
+{
+   options.beam = (int)(beam_f * 0x00010000);
+   if (options.beam < 0x00010000)
+      options.beam = 0x00010000;
+   else if (options.beam > 0x00100000)
+      options.beam = 0x00100000;
+
+   option->priority = priority;
+
+   return 0;
+}
+
+static int video_verify_flicker(struct rc_option *option, const char *arg,
+   int priority)
+{
+   options.flicker = (int)(flicker_f * 2.55);
+   if (options.flicker < 0)
+      options.flicker = 0;
+   else if (options.flicker > 255)
+      options.flicker = 255;
+
+   option->priority = priority;
+
+   return 0;
+}
+
+static int video_verify_bpp(struct rc_option *option, const char *arg,
+   int priority)
+{
+   if( (options.color_depth != 0) &&
+       (options.color_depth != 8) &&
+       (options.color_depth != 16) )
+   {
+      options.color_depth = 0;
+      fprintf(stderr, "error: invalid value %s, for bpp\n", arg);
+      return -1;
+   }
+
+   option->priority = priority;
+
+   return 0;
+}
+
+/* Create a bitmap. Also calls osd_clearbitmap() to appropriately initialize */
+/* it to the background color. */
+/* VERY IMPORTANT: the function must allocate also a "safety area" 16 pixels wide all */
+/* around the bitmap. This is required because, for performance reasons, some graphic */
+/* routines don't clip at boundaries of the bitmap. */
+struct osd_bitmap *osd_new_bitmap(int width,int height,int depth)       /* ASG 980209 */
+{
+	struct osd_bitmap *bitmap;
+
+	if (!width) width++;
+	if (!height) height++;
+
+	if (Machine->orientation & ORIENTATION_SWAP_XY)
+	{
+		int temp;
+
+		temp = width;
+		width = height;
+		height = temp;
+	}
+
+	if ((bitmap = malloc(sizeof(struct osd_bitmap))) != 0)
+	{
+		int i,rowlen,rdwidth;
+		unsigned char *bm;
+
+		if (depth != 8 && depth != 16) depth = 8;
+
+		bitmap->depth = depth;
+		bitmap->width = width;
+		bitmap->height = height;
+
+		rdwidth = (width + 7) & ~7;     /* round width to a quadword */
+		if (depth == 16)
+			rowlen = 2 * (rdwidth + 2 * safety) * sizeof(unsigned char);
+		else
+			rowlen =     (rdwidth + 2 * safety) * sizeof(unsigned char);
+
+		if ((bm = malloc((height + 2 * safety) * rowlen)) == 0)
+		{
+			free(bitmap);
+			return 0;
+		}
+
+		if ((bitmap->line = malloc((height + 2 * safety) * sizeof(unsigned char *))) == 0)
+		{
+			free(bm);
+			free(bitmap);
+			return 0;
+		}
+
+		for (i = 0;i < height + 2 * safety;i++)
+		{
+			if (depth == 16)
+				bitmap->line[i] = &bm[i * rowlen + 2*safety];
+			else
+				bitmap->line[i] = &bm[i * rowlen + safety];
+		}
+		bitmap->line += safety;
+
+		bitmap->_private = bm;
+
+		osd_clearbitmap(bitmap);
+	}
+
+	return bitmap;
+}
+
+void osd_free_bitmap(struct osd_bitmap *bitmap)
+{
+	if (bitmap)
+	{
+		bitmap->line -= safety;
+		free(bitmap->line);
+		free(bitmap->_private);
+		free(bitmap);
+		bitmap = NULL;
+	}
+}
+
+/* set the bitmap to black */
+void osd_clearbitmap(struct osd_bitmap *bitmap)
+{
+	int i;
+
+	memset (bitmap->_private, 0, (bitmap->line[1] - bitmap->line[0]) *
+	   (bitmap->height + 2 * safety));
+
+	if (bitmap == Machine->scrbitmap)
+	{
+		bitmap_dirty = 1;
+		osd_mark_dirty (0,0,bitmap->width-1,bitmap->height-1,1);
+	}
+}
+
+struct osd_bitmap *osd_create_display(int width, int height, int depth,
+   int attributes)
+{
+   int i;
+   
+   if (Machine->drv->video_attributes & VIDEO_TYPE_VECTOR)
+   {
+      int vector_width, vector_height;
+      if(vector_res &&
+         sscanf(vector_res, "%dx%d", &vector_width, &vector_height) == 2)
+      {
+         if( Machine->orientation & ORIENTATION_SWAP_XY)
+         {
+            widthscale_f  = (float)vector_width  / height;
+            heightscale_f = (float)vector_height / width;
+         }
+         else
+         {
+            widthscale_f  = (float)vector_width  / width;
+            heightscale_f = (float)vector_height / height;
+         }
+         if (widthscale_f > heightscale_f)
+            widthscale_f  = heightscale_f;
+         else
+            heightscale_f = widthscale_f;
+         fprintf(stderr_file, "Vectorres %dx%d, scale = %f\n",
+            vector_width, vector_height, heightscale_f);
+      }
+      width  *= widthscale_f;
+      height *= heightscale_f;
+      widthscale = heightscale = 1;
+      /* round with & heigth to a multiple of 8 */
+      width  &= ~7;
+      height &= ~7;
+      /* store info into a visual struct */
+      visual.min_x = 0;
+      visual.min_y = 0;
+      visual.max_x = width - 1;
+      visual.max_y = height - 1;
+   }
+   else
+      /* we use the same struct as the core, but under a different name,
+         to avoid header conflicts */
+      memcpy(&visual, &Machine->drv->visible_area, sizeof(struct my_rectangle));
+     
+   if (!(bitmap = osd_new_bitmap(width,height, depth)))
+      return NULL;
+   
+   if( Machine->orientation & ORIENTATION_SWAP_XY) {
+      i=visual.max_x; visual.max_x=visual.max_y; visual.max_y=i;
+      i=visual.min_x; visual.min_x=visual.min_y; visual.min_y=i;
+      i=width; width=height; height=i;
+   } 
+
+   if (Machine->orientation & ORIENTATION_FLIP_X)
+   {
+      i            = width - visual.min_x - 1;
+      visual.min_x = width - visual.max_x - 1;
+      visual.max_x = i;
+   }
+   
+   if (Machine->orientation & ORIENTATION_FLIP_Y)
+   {
+      i            = height - visual.min_y - 1;
+      visual.min_y = height - visual.max_y - 1;
+      visual.max_y = i;
+   }
+   
+   /* Can we do dirty? First check if its a vector game */
+   if (Machine->drv->video_attributes & VIDEO_TYPE_VECTOR)
+   {
+      if (use_dirty) use_dirty  = 2;
+   }
+   else if ( (Machine->drv->video_attributes & VIDEO_SUPPORTS_DIRTY) == 0 )
+   {
+      use_dirty = FALSE;
+   }
+   
+   if(use_auto_double &&
+      (Machine->drv->video_attributes & VIDEO_PIXEL_ASPECT_RATIO_MASK) ==
+      VIDEO_PIXEL_ASPECT_RATIO_1_2)
+   {
+      if (Machine->orientation & ORIENTATION_SWAP_XY)
+         widthscale  *= 2;
+      else
+         heightscale *= 2;
+   }
+  
+   /* round to 8, since the new dirty code works with 8x8 blocks,
+      and we need to round to sizeof(long) for the long copies anyway */
+   if (visual.min_x & 7)
+   {
+      if((visual.min_x - (visual.min_x & ~7)) < 4)
+         visual.min_x &= ~7;
+       else
+         visual.min_x = (visual.min_x + 7) & ~7;
+   }
+   if ((visual.max_x+1) & 7)
+   {
+      if(((visual.max_x+1) - ((visual.max_x+1) & ~7)) > 4)
+         visual.max_x = ((visual.max_x+1 + 7) & ~7) - 1;
+       else
+         visual.max_x = ((visual.max_x+1) & ~7) - 1;
+   }
+
+   /* rounding of the y-coordinates is only nescesarry when we are doing dirty */
+   if (use_dirty)
+   {
+      if (visual.min_y & 7)
+      {
+         if((visual.min_y - (visual.min_y & ~7)) < 4)
+            visual.min_y &= ~7;
+          else
+            visual.min_y = (visual.min_y + 7) & ~7;
+      }
+      if ((visual.max_y+1) & 7)
+      {
+         if(((visual.max_y+1) - ((visual.max_y+1) & ~7)) > 4)
+            visual.max_y = ((visual.max_y+1 + 7) & ~7) - 1;
+          else
+            visual.max_y = ((visual.max_y+1) & ~7) - 1;
+      }
+   }
+   
+   /* now calculate the visual width / height */
+   visual_width  = visual.max_x - visual.min_x + 1;
+   visual_height = visual.max_y - visual.min_y + 1;
+
+#if !defined xgl
+   if (osd_dirty_init()!=OSD_OK) return NULL;
+#endif
+   
+   if (sysdep_create_display() != OSD_OK)
+      return NULL;
+   
+   /* a lott of display_targets need to have the display initialised before
+      initialising any input devices */
+   if (osd_input_initpost()!=OSD_OK) return NULL;
+   
+   set_ui_visarea (visual.min_x, visual.min_y, visual.max_x, visual.max_y);
+   
+   if (use_dirty)   fprintf(stderr_file,"Using dirty_buffer strategy\n");
+   if (bitmap->depth==16) fprintf(stderr_file,"Using 16bpp video mode\n");
+   
+   /* for debugging only */
+   fprintf(stderr_file, "width= %d, height = %d, viswidth = %d, visheight = %d,"
+           "visstartx= %d, visstarty= %d\n",
+            width, height, visual_width, visual_height, visual.min_x,
+            visual.min_y);
+   
+   return bitmap;
+}   
+
+int osd_allocate_colors(unsigned int totalcolors, const unsigned char *palette,
+   unsigned short *pens, int modifiable)
+{
+   int i;
+   int color_start = 0;
+   int writable_colors = 0;
+   int max_colors = (bitmap->depth == 8)? 256:65536;
+   
+   if (totalcolors > max_colors)
+   {
+      fprintf(stderr_file,
+         "Warning: More than %d colors (%d) are needed for this emulation,\n"
+         "some parts of the screen may be corrupted\n", max_colors, 
+         totalcolors);
+      /* fill the remainder of the pens array with 0's to make sure */
+      /* nothing strange happens                                    */
+      for (i=max_colors; i<totalcolors; i++)
+         pens[i] = 0;
+      totalcolors = max_colors;
+   }
+   else
+      fprintf(stderr_file, "Game uses %d colors\n", totalcolors);
+
+   if ((bitmap->depth == 8) || modifiable)
+   {
+      writable_colors = totalcolors + 2;
+      if (writable_colors > max_colors)
+         writable_colors = max_colors;
+   }
+   
+   /* alloc the sysdep_palette */
+   if(!(sysdep_palette = sysdep_palette_create(bitmap->depth,
+      writable_colors)))
+      return 1;
+      
+   sysdep_palette_set_gamma(sysdep_palette, gamma_correction);
+   sysdep_palette_set_brightness(sysdep_palette, brightness * brightness_paused_adjust);
+   
+   /* init the palette */
+   if (writable_colors)
+   {
+      int color_start = (totalcolors < max_colors)? 1:0;
+
+      for (i=0; i<totalcolors; i++)
+      {
+         pens[i] = i+color_start;
+         sysdep_palette_set_pen(sysdep_palette, i+color_start, palette[i*3],
+            palette[i*3+1], palette[i*3+2]);
+      }
+      if(color_start)
+         sysdep_palette_set_pen(sysdep_palette, 0, 0, 0, 0);
+      if( writable_colors > (totalcolors+color_start) )
+         sysdep_palette_set_pen(sysdep_palette, writable_colors - 1, 0xFF, 0xFF,
+            0xFF);
+      Machine->uifont->colortable[0] = 0;
+      Machine->uifont->colortable[1] = writable_colors - 1;
+      Machine->uifont->colortable[2] = writable_colors - 1;
+      Machine->uifont->colortable[3] = 0;
+   }
+   else
+   {
+      for (i=0; i<totalcolors; i++)
+      {
+         pens[i] = sysdep_palette_make_pen(sysdep_palette, palette[i*3],
+            palette[i*3+1], palette[i*3+2]);
+      }
+      Machine->uifont->colortable[0] = sysdep_palette_make_pen(sysdep_palette,
+         0, 0, 0);
+      Machine->uifont->colortable[1] = sysdep_palette_make_pen(sysdep_palette,
+         0xFF, 0xFF, 0xFF);
+      Machine->uifont->colortable[2] = sysdep_palette_make_pen(sysdep_palette,
+         0xFF, 0xFF, 0xFF);
+      Machine->uifont->colortable[3] = sysdep_palette_make_pen(sysdep_palette,
+         0, 0, 0);
+   }
+   return 0;
+}
+
+void osd_get_pen(int pen,unsigned char *red, unsigned char *green, unsigned char *blue)
+{
+    sysdep_palette_get_pen(sysdep_palette, pen, red, green, blue);
+}
+
+void osd_modify_pen(int pen, unsigned char red,unsigned char green,unsigned char blue) 
+{
+   sysdep_palette_set_pen(sysdep_palette, pen, red, green, blue);
+}
+
+static int skip_next_frame = 0;
+
+typedef int (*skip_next_frame_func)(int show_fps_counter);
+
+static skip_next_frame_func skip_next_frame_functions[FRAMESKIP_DRIVER_COUNT] =
+{
+   dos_skip_next_frame,
+   barath_skip_next_frame
+};
+
+int osd_skip_this_frame(void)
+{
+   return skip_next_frame;
+}
+
+/* Update the display. */
+void osd_update_video_and_audio(void)
+{
+   int i;
+   static int showfps=0, showfpstemp=0; 
+   int skip_this_frame;
+   int need_to_clear_bitmap=0;
+   
+   if (input_ui_pressed(IPT_UI_FRAMESKIP_INC))
+   {
+      if (autoframeskip)
+      {
+	 autoframeskip = 0;
+	 frameskip = 0;
+      }
+      else
+      {
+	 if (frameskip == FRAMESKIP_LEVELS-1)
+	 {
+	    frameskip = 0;
+	    autoframeskip = 1;
+	 }
+	 else frameskip++;
+      }
+
+      if (showfps == 0) showfpstemp = 2 * Machine->drv->frames_per_second;
+   }
+
+   if (input_ui_pressed(IPT_UI_FRAMESKIP_DEC))
+   {
+      if (autoframeskip)
+      {
+	 autoframeskip = 0;
+	 frameskip = FRAMESKIP_LEVELS-1;
+      }
+      else
+      {
+	 if (frameskip == 0) autoframeskip = 1;
+	 else frameskip--;
+      }
+
+      if (showfps == 0)	showfpstemp = 2 * Machine->drv->frames_per_second;
+   }
+
+   if (!keyboard_pressed(KEYCODE_LSHIFT) && !keyboard_pressed(KEYCODE_RSHIFT)
+       && !keyboard_pressed(KEYCODE_LCONTROL) && !keyboard_pressed(KEYCODE_RCONTROL)
+       && input_ui_pressed(IPT_UI_THROTTLE))
+   {
+      throttle ^= 1;
+   }
+
+   if (input_ui_pressed(IPT_UI_THROTTLE) && (keyboard_pressed(KEYCODE_RSHIFT) || keyboard_pressed(KEYCODE_LSHIFT)))
+   {
+      sleep_idle ^= 1;
+   }
+
+   if (!keyboard_pressed(KEYCODE_LSHIFT) && !keyboard_pressed(KEYCODE_RSHIFT)
+       && !keyboard_pressed(KEYCODE_LCONTROL) && !keyboard_pressed(KEYCODE_RCONTROL)
+       && input_ui_pressed(IPT_UI_SHOW_FPS))
+   {
+      if (showfpstemp)
+      {
+	 showfpstemp = 0;
+	 need_to_clear_bitmap = 1;
+      }
+      else
+      {
+	 showfps ^= 1;
+	 if (showfps == 0)
+	 {
+	    need_to_clear_bitmap = 1;
+	 }
+      }
+   }
+
+   if (keyboard_pressed (KEYCODE_LCONTROL))
+   {
+      if (keyboard_pressed_memory (KEYCODE_INSERT))
+         frameskipper = 0;
+      if (keyboard_pressed_memory (KEYCODE_HOME))
+         frameskipper = 1;
+   }
+   
+   if (showfpstemp)         /* MAURY_BEGIN: nuove opzioni */
+   {
+      showfpstemp--;
+      if (showfpstemp == 0) need_to_clear_bitmap = 1;
+   }
+
+   skip_this_frame = skip_next_frame;
+   skip_next_frame =
+      (*skip_next_frame_functions[frameskipper])(showfps || showfpstemp);
+   
+   if (skip_this_frame == 0)
+   {
+      profiler_mark(PROFILER_BLIT);
+      sysdep_palette_update(sysdep_palette);
+      sysdep_update_display();
+      profiler_mark(PROFILER_END);
+   }
+   
+   if (sound_stream && sound_enabled)
+      sound_stream_update(sound_stream);
+
+   if (need_to_clear_bitmap) osd_clearbitmap(bitmap);
+}
+
+void osd_set_gamma(float gamma)
+{
+   sysdep_palette_set_gamma(sysdep_palette, gamma);
+}
+
+float osd_get_gamma(void)
+{
+   return sysdep_palette_get_gamma(sysdep_palette);
+}
+
+/* brightess = percentage 0-100% */
+void osd_set_brightness(int _brightness)
+{
+   brightness = _brightness;
+   sysdep_palette_set_brightness(sysdep_palette, brightness *
+      brightness_paused_adjust);
+}
+
+int osd_get_brightness(void)
+{
+   return brightness;
+}
+
+void osd_save_snapshot(void)
+{
+   save_screen_snapshot();
+}
+
+void osd_pause(int paused)
+{
+   if (paused)
+      brightness_paused_adjust = 0.65;
+   else
+      brightness_paused_adjust = 1.0;
+
+   sysdep_palette_set_brightness(sysdep_palette, brightness *
+      brightness_paused_adjust);
+}
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/blit_core.h mame-0.36b16/src/unix/video-drivers/blit_core.h
--- ../mmmmm/m36b16/src/unix/video-drivers/blit_core.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/blit_core.h	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,87 @@
+/* this file is used by blit.h don't use it directly ! */
+
+#ifdef DEST_SCALE
+#define DEST_SCALE_X(X)   (SCALE_X(X)  *DEST_SCALE)
+#define DEST_SCALE_X_8(X) (SCALE_X_8(X)*DEST_SCALE)
+#define DEST_SCALE_Y(Y)   (SCALE_Y(Y)  *DEST_SCALE)
+#define DEST_SCALE_Y_8(Y) (SCALE_Y_8(Y)*DEST_SCALE)
+#else
+#define DEST_SCALE_X(X)   SCALE_X(X)
+#define DEST_SCALE_X_8(X) SCALE_X_8(X)
+#define DEST_SCALE_Y(Y)   SCALE_Y(Y)
+#define DEST_SCALE_Y_8(Y) SCALE_Y_8(Y)
+#endif
+
+   if (!use_dirty)
+   {
+      /* non dirty */
+#ifdef DEST
+      int src_width = (((SRC_PIXEL *)bitmap->line[1]) -
+         ((SRC_PIXEL *)bitmap->line[0]));
+      SRC_PIXEL *line_src = (SRC_PIXEL *)bitmap->line[visual.min_y]   + visual.min_x;
+      SRC_PIXEL *line_end = (SRC_PIXEL *)bitmap->line[visual.max_y+1] + visual.min_x;
+      DEST_PIXEL *line_dest = (DEST_PIXEL *)(DEST);
+      
+      for (;line_src < line_end; line_dest+=DEST_SCALE_Y(DEST_WIDTH),
+         line_src+=src_width)
+         COPY_LINE(line_src, line_src+visual_width, line_dest)
+#endif
+#ifdef PUT_IMAGE
+      PUT_IMAGE(0, 0, SCALE_X(visual_width), SCALE_Y(visual_height))
+#endif      
+   }
+   else
+   {
+      /* normal dirty */
+      int y, max_y = (visual.max_y+1) >> 3;
+#ifdef DEST
+      DEST_PIXEL *line_dest = (DEST_PIXEL *)(DEST) - DEST_SCALE_X(visual.min_x);
+      for (y=visual.min_y>>3; y<max_y; y++, line_dest+=DEST_SCALE_Y_8(DEST_WIDTH))
+#else
+      for (y=visual.min_y>>3;y<max_y; y++)
+#endif      
+      {
+         if (dirty_lines[y])
+         {
+            int x, max_x;
+            max_x = (visual.max_x+1) >> 3;
+            for(x=visual.min_x>>3; x<max_x; x++)
+            {
+               if (dirty_blocks[y][x])
+               {
+                  int min_x;
+#ifdef DEST
+                  int max_x, h, max_h;
+                  DEST_PIXEL *block_dest = line_dest + DEST_SCALE_X_8(x);
+#endif
+                  min_x = x << 3;
+                  do {
+                     dirty_blocks[y][x]=0;
+                     x++;
+                  } while (dirty_blocks[y][x]);
+#ifdef DEST                  
+                  max_x = x << 3;
+                  h     = y << 3;
+                  max_h = h + 8;
+                  for (; h<max_h; h++, block_dest += DEST_SCALE_Y(DEST_WIDTH))
+                     COPY_LINE((SRC_PIXEL *)bitmap->line[h]+min_x,
+                        (SRC_PIXEL *)bitmap->line[h]+max_x, block_dest)
+#endif
+#ifdef PUT_IMAGE
+                  PUT_IMAGE(
+                     SCALE_X( min_x - visual.min_x),
+                     SCALE_Y((y<<3) - visual.min_y),
+                     SCALE_X((x<<3) - min_x),
+                     SCALE_Y(8))
+#endif
+               }
+            }
+            dirty_lines[y] = 0;
+         }
+      }
+   }
+
+#undef DEST_SCALE_X
+#undef DEST_SCALE_X_8
+#undef DEST_SCALE_Y
+#undef DEST_SCALE_Y_8
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/blit.h mame-0.36b16/src/unix/video-drivers/blit.h
--- ../mmmmm/m36b16/src/unix/video-drivers/blit.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/blit.h	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,597 @@
+/* this routine is the generic blit routine used in many cases, trough a number
+   of defines it can be customised for specific cases.
+   Currently recognised defines:
+   DEST		ptr of type DEST_PIXEL to which should be blitted, if this is
+		not defined only PUT_IMAGE is called if defined.
+   DEST_PIXEL	type of the buffer to which is blitted, only needed if
+                DEST is defined.
+   DEST_WIDTH   Width of the destination buffer in pixels! Only needed if
+                DEST is defined.
+   SRC_PIXEL    type of the buffer from which is blitted, currently
+                8 bpp (unsigned char) and 16 bpp (unsigned short) are supported.
+   PUT_IMAGE    This function is called to update the parts of the screen
+		which need updating. This is only called if defined.
+   INDIRECT     This needs to be defined if DEST_PIXEL != unsigned char,
+                this is a ptr to a list of pixels/colormappings for the
+                colordepth conversion.
+   BLIT_16BPP_HACK This one speaks for itself, it's a speedup hack for 8bpp
+                to 16bpp blits.
+   PACK_BITS    Write to packed 24bit pixels, DEST_PIXEL must be 32bits and
+                INDIRECT must be on.
+   DOUBLEBUFFER First copy each line to a buffer called doublebuffer_buffer,
+                then do a memcpy to the real destination. This speeds up
+                scaling when writing directly to framebuffer since it
+                tremendously speeds up the reads done to copy one line to
+                the next.
+   
+   This routines use long copy's so everything should always be long aligned.
+*/
+
+#ifdef PACK_BITS
+/* scale destptr delta's by 3/4 since we're using 32 bits ptr's for a 24 bits
+   dest */
+#define DEST_SCALE 3/4
+#define DEST_PIXEL_SIZE 3
+#define CORRECTED_DEST_WIDTH ((DEST_WIDTH*3)/4)
+#else
+#define DEST_PIXEL_SIZE sizeof(DEST_PIXEL)
+#define CORRECTED_DEST_WIDTH DEST_WIDTH
+#endif
+
+switch (heightscale | (widthscale << 8) | (use_scanlines << 16))
+{
+/* 1x1 */
+
+#ifdef INDIRECT
+
+#ifdef BLIT_16BPP_HACK
+#define COPY_LINE2(SRC, END, DST) \
+   unsigned short *src = (unsigned short *)(SRC); \
+   unsigned short *end = (unsigned short *)(END); \
+   unsigned int   *dst = (unsigned int   *)(DST); \
+   for(;src<end;src+=4,dst+=4) \
+   { \
+      *(dst  ) = INDIRECT[*(src  )]; \
+      *(dst+1) = INDIRECT[*(src+1)]; \
+      *(dst+2) = INDIRECT[*(src+2)]; \
+      *(dst+3) = INDIRECT[*(src+3)]; \
+   }
+#elif defined PACK_BITS
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end;dst+=3,src+=4) \
+   { \
+      *(dst  ) = (INDIRECT[*(src  )]    ) | (INDIRECT[*(src+1)]<<24); \
+      *(dst+1) = (INDIRECT[*(src+1)]>> 8) | (INDIRECT[*(src+2)]<<16); \
+      *(dst+2) = (INDIRECT[*(src+2)]>>16) | (INDIRECT[*(src+3)]<< 8); \
+   }
+#else /* normal indirect */
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end;src+=8,dst+=8) \
+   { \
+      *(dst  ) = INDIRECT[*(src  )]; \
+      *(dst+1) = INDIRECT[*(src+1)]; \
+      *(dst+2) = INDIRECT[*(src+2)]; \
+      *(dst+3) = INDIRECT[*(src+3)]; \
+      *(dst+4) = INDIRECT[*(src+4)]; \
+      *(dst+5) = INDIRECT[*(src+5)]; \
+      *(dst+6) = INDIRECT[*(src+6)]; \
+      *(dst+7) = INDIRECT[*(src+7)]; \
+   }
+#endif /* dga_16bpp_hack / packed / normal indirect */
+
+#else  /* not indirect */
+#define COPY_LINE2(SRC, END, DST) \
+   memcpy(DST, SRC, ((END)-(SRC))*DEST_PIXEL_SIZE);
+#endif /* indirect */
+
+#define SCALE_X(X) (X)
+#define SCALE_X_8(X) ((X)<<3)
+#define SCALE_Y(Y) (Y)
+#define SCALE_Y_8(Y) ((Y)<<3)
+
+/* 1x1 we don't do scanlines with 1x1 */
+case 0x00101:
+case 0x10101:
+#define COPY_LINE(SRC, END, DST) { COPY_LINE2(SRC, END, DST) }
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+#undef SCALE_Y
+#undef SCALE_Y_8
+
+/* 1x2 */
+
+#define SCALE_Y(Y)   ((Y)<<1)
+#define SCALE_Y_8(Y) ((Y)<<4)
+
+/* 1x2 no scanlines */
+case 0x00102:
+
+#ifdef DOUBLEBUFFER
+
+#ifdef INDIRECT
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                        doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH), doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DST)); \
+   COPY_LINE2(SRC, END, (DST)+(CORRECTED_DEST_WIDTH)); \
+}
+#endif
+
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH), DST, ((END)-(SRC))*DEST_PIXEL_SIZE); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+/* 1x2 scanlines */
+case 0x10102:
+#define COPY_LINE(SRC, END, DST) { COPY_LINE2(SRC, END, DST) }
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+#undef COPY_LINE2
+#undef SCALE_X
+#undef SCALE_X_8
+#undef SCALE_Y
+#undef SCALE_Y_8
+
+
+/* 2x2 */
+
+#ifdef INDIRECT
+
+#ifdef PACK_BITS
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=2, dst+=3) \
+   { \
+      *(dst  ) = (INDIRECT[*(src  )]    ) | (INDIRECT[*(src  )]<<24); \
+      *(dst+1) = (INDIRECT[*(src  )]>> 8) | (INDIRECT[*(src+1)]<<16); \
+      *(dst+2) = (INDIRECT[*(src+1)]>>16) | (INDIRECT[*(src+1)]<<8); \
+   }
+#else /* not pack bits */
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=16) \
+   { \
+      *(dst   ) = *(dst+ 1) = INDIRECT[*(src  )]; \
+      *(dst+ 2) = *(dst+ 3) = INDIRECT[*(src+1)]; \
+      *(dst+ 4) = *(dst+ 5) = INDIRECT[*(src+2)]; \
+      *(dst+ 6) = *(dst+ 7) = INDIRECT[*(src+3)]; \
+      *(dst+ 8) = *(dst+ 9) = INDIRECT[*(src+4)]; \
+      *(dst+10) = *(dst+11) = INDIRECT[*(src+5)]; \
+      *(dst+12) = *(dst+13) = INDIRECT[*(src+6)]; \
+      *(dst+14) = *(dst+15) = INDIRECT[*(src+7)]; \
+   }
+#endif /* pack bits */
+
+#else /* not indirect */
+
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=16) \
+   { \
+      *(dst   ) = *(dst+ 1) = *(src  ); \
+      *(dst+ 2) = *(dst+ 3) = *(src+1); \
+      *(dst+ 4) = *(dst+ 5) = *(src+2); \
+      *(dst+ 6) = *(dst+ 7) = *(src+3); \
+      *(dst+ 8) = *(dst+ 9) = *(src+4); \
+      *(dst+10) = *(dst+11) = *(src+5); \
+      *(dst+12) = *(dst+13) = *(src+6); \
+      *(dst+14) = *(dst+15) = *(src+7); \
+   }
+#endif
+
+#define SCALE_X(X)   ((X)<<1)
+#define SCALE_X_8(X) ((X)<<4)
+#define SCALE_Y(Y)   ((Y)<<1)
+#define SCALE_Y_8(Y) ((Y)<<4)
+
+/* 2x2 no scanlines */
+case 0x00202:
+
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                        doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*2); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH), doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*2); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH), DST, ((END)-(SRC))*DEST_PIXEL_SIZE*2); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+/* 2x2 scanlines */
+case 0x10202:
+
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                        doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*2); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) { COPY_LINE2(SRC, END, DST) }
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+#undef COPY_LINE2
+#undef SCALE_X
+#undef SCALE_X_8
+#undef SCALE_Y
+#undef SCALE_Y_8
+
+#ifndef PACK_BITS
+/* 3x3 */
+
+/* this macro is used to copy a line */
+#ifdef INDIRECT
+
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=24) \
+   { \
+      *(dst   ) = *(dst+ 1) = *(dst+ 2) = INDIRECT[*(src  )]; \
+      *(dst+ 3) = *(dst+ 4) = *(dst+ 5) = INDIRECT[*(src+1)]; \
+      *(dst+ 6) = *(dst+ 7) = *(dst+ 8) = INDIRECT[*(src+2)]; \
+      *(dst+ 9) = *(dst+10) = *(dst+11) = INDIRECT[*(src+3)]; \
+      *(dst+12) = *(dst+13) = *(dst+14) = INDIRECT[*(src+4)]; \
+      *(dst+15) = *(dst+16) = *(dst+17) = INDIRECT[*(src+5)]; \
+      *(dst+18) = *(dst+19) = *(dst+20) = INDIRECT[*(src+6)]; \
+      *(dst+21) = *(dst+22) = *(dst+23) = INDIRECT[*(src+7)]; \
+   }
+#else /* not indirect */
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=24) \
+   { \
+      *(dst   ) = *(dst+ 1) = *(dst+ 2) = *(src  ); \
+      *(dst+ 3) = *(dst+ 4) = *(dst+ 5) = *(src+1); \
+      *(dst+ 6) = *(dst+ 7) = *(dst+ 8) = *(src+2); \
+      *(dst+ 9) = *(dst+10) = *(dst+11) = *(src+3); \
+      *(dst+12) = *(dst+13) = *(dst+14) = *(src+4); \
+      *(dst+15) = *(dst+16) = *(dst+17) = *(src+5); \
+      *(dst+18) = *(dst+19) = *(dst+20) = *(src+6); \
+      *(dst+21) = *(dst+22) = *(dst+23) = *(src+7); \
+   }
+#endif
+
+#define SCALE_X(X)   ((X)*3)
+#define SCALE_X_8(X) ((X)*24)
+#define SCALE_Y(Y)   ((Y)*3)
+#define SCALE_Y_8(Y) ((Y)*24)
+
+/* 3x3 no scanlines */
+case 0x00303:
+
+/* should we use doublebuffering ? */
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                          doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   DST, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, DST, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+/* 3x3 scanlines */
+case 0x10303:
+
+/* should we use doublebuffering ? */
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                          doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   DST, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+#undef COPY_LINE2
+#undef SCALE_X
+#undef SCALE_X_8
+#undef SCALE_Y
+#undef SCALE_Y_8
+
+/* 4x4 */
+
+#ifdef INDIRECT
+
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=32) \
+   { \
+      *(dst   ) = *(dst+ 1) = *(dst+ 2) = *(dst+ 3) = INDIRECT[*(src  )]; \
+      *(dst+ 4) = *(dst+ 5) = *(dst+ 6) = *(dst+ 7) = INDIRECT[*(src+1)]; \
+      *(dst+ 8) = *(dst+ 9) = *(dst+10) = *(dst+11) = INDIRECT[*(src+2)]; \
+      *(dst+12) = *(dst+13) = *(dst+14) = *(dst+15) = INDIRECT[*(src+3)]; \
+      *(dst+16) = *(dst+17) = *(dst+18) = *(dst+19) = INDIRECT[*(src+4)]; \
+      *(dst+20) = *(dst+21) = *(dst+22) = *(dst+23) = INDIRECT[*(src+5)]; \
+      *(dst+24) = *(dst+25) = *(dst+26) = *(dst+27) = INDIRECT[*(src+6)]; \
+      *(dst+28) = *(dst+29) = *(dst+30) = *(dst+31) = INDIRECT[*(src+7)]; \
+   }
+#else /* not indirect */
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=32) \
+   { \
+      *(dst   ) = *(dst+ 1) = *(dst+ 2) = *(dst+ 3) = *(src  ); \
+      *(dst+ 4) = *(dst+ 5) = *(dst+ 6) = *(dst+ 7) = *(src+1); \
+      *(dst+ 8) = *(dst+ 9) = *(dst+10) = *(dst+11) = *(src+2); \
+      *(dst+12) = *(dst+13) = *(dst+14) = *(dst+15) = *(src+3); \
+      *(dst+16) = *(dst+17) = *(dst+18) = *(dst+19) = *(src+4); \
+      *(dst+20) = *(dst+21) = *(dst+22) = *(dst+23) = *(src+5); \
+      *(dst+24) = *(dst+25) = *(dst+26) = *(dst+27) = *(src+6); \
+      *(dst+28) = *(dst+29) = *(dst+30) = *(dst+31) = *(src+7); \
+   }
+#endif
+
+#define SCALE_X(X)   ((X)<<2)
+#define SCALE_X_8(X) ((X)<<5)
+#define SCALE_Y(Y)   ((Y)<<2)
+#define SCALE_Y_8(Y) ((Y)<<5)
+
+/* 4x4 no scanlines */
+case 0x00404:
+
+/* should we use doublebuffering ? */
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                          doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*3, doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   DST, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, DST, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*3, DST, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+/* 4x4 scanlines */
+case 0x10404:
+
+/* should we use doublebuffering ? */
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                          doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   DST, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, DST, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+#undef COPY_LINE2
+#undef SCALE_X
+#undef SCALE_X_8
+#undef SCALE_Y
+#undef SCALE_Y_8
+
+#endif /* #ifndef PACK_BITS */
+
+/* Generic scaling code here (arbitrary values) */
+
+/* This is what happens when you give an assembly-language programmer
+   a C compiler.  Thanks to td, of course.                             -JDL */
+
+default:
+
+#ifdef INDIRECT
+
+#ifdef PACK_BITS
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   DEST_PIXEL pixel; \
+   int i, step=0; \
+   for(;src<end;src++) \
+   { \
+      pixel = INDIRECT[*src]; \
+      for(i=0; i<widthscale; i++,step=(step+1)%4) \
+      { \
+         switch(step) \
+         { \
+            case 0: \
+               *(dst  )  = pixel; \
+               break; \
+            case 1: \
+               *(dst  ) |= pixel << 24; \
+               *(dst+1)  = pixel >> 8; \
+               break; \
+            case 2: \
+               *(dst+1) |= pixel << 16; \
+               *(dst+2)  = pixel >> 16; \
+               break; \
+            case 3: \
+               *(dst+2) |= pixel << 8; \
+               dst+=3; \
+               break; \
+         } \
+      } \
+   }
+#else
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   int i; \
+   for(;src<end;src++) \
+   { \
+      i=(widthscale+7)/8; \
+      dst+=widthscale%8; \
+      switch (widthscale%8) \
+      { \
+         case 0: do{  dst+=8; \
+                      *(dst-8) = INDIRECT[*(src)]; \
+         case 7:      *(dst-7) = INDIRECT[*(src)]; \
+         case 6:      *(dst-6) = INDIRECT[*(src)]; \
+         case 5:      *(dst-5) = INDIRECT[*(src)]; \
+         case 4:      *(dst-4) = INDIRECT[*(src)]; \
+         case 3:      *(dst-3) = INDIRECT[*(src)]; \
+         case 2:      *(dst-2) = INDIRECT[*(src)]; \
+         case 1:      *(dst-1) = INDIRECT[*(src)]; \
+                 } while(--i>0); \
+      } \
+   }
+#endif
+
+#else
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   int i; \
+   for(;src<end;src++) \
+   { \
+      i=(widthscale+7)/8; \
+      dst+=widthscale%8; \
+      switch (widthscale%8) \
+      { \
+         case 0: do{  dst+=8; \
+                      *(dst-8) = *(src); \
+         case 7:      *(dst-7) = *(src); \
+         case 6:      *(dst-6) = *(src); \
+         case 5:      *(dst-5) = *(src); \
+         case 4:      *(dst-4) = *(src); \
+         case 3:      *(dst-3) = *(src); \
+         case 2:      *(dst-2) = *(src); \
+         case 1:      *(dst-1) = *(src); \
+                 } while(--i>0); \
+      } \
+   }
+#endif
+
+#define SCALE_X(X)   ((X)*widthscale)
+#define SCALE_X_8(X) ((X)*widthscale*8)
+#define SCALE_Y(Y)   ((Y)*heightscale)
+#define SCALE_Y_8(Y) ((Y)*heightscale*8)
+
+/* should we use doublebuffering ? */
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   int max_i = heightscale-use_scanlines; \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   dst = (DST); \
+   if (max_i < 1) max_i = 1; \
+   for(i=0; i<max_i; i++, dst+=CORRECTED_DEST_WIDTH) \
+      memcpy(dst, doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*widthscale); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   dst = (DST) + (CORRECTED_DEST_WIDTH); \
+   for(i=1; i<(heightscale-use_scanlines); i++, dst+=CORRECTED_DEST_WIDTH) \
+      memcpy(dst, DST, ((END)-(SRC))*DEST_PIXEL_SIZE*widthscale); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+
+#undef COPY_LINE2
+#undef SCALE_X
+#undef SCALE_X_8
+#undef SCALE_Y
+#undef SCALE_Y_8
+
+break;      
+}
+
+#ifdef DEST_SCALE
+#undef DEST_SCALE
+#endif
+#undef DEST_PIXEL_SIZE
+#undef CORRECTED_DEST_WIDTH
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/fxgen.c mame-0.36b16/src/unix/video-drivers/fxgen.c
--- ../mmmmm/m36b16/src/unix/video-drivers/fxgen.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/fxgen.c	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,679 @@
+/*****************************************************************
+
+  Generic glide routines
+
+  Copyright 1998 by Mike Oliphant - oliphant@ling.ed.ac.uk
+
+    http://www.ling.ed.ac.uk/~oliphant/glmame
+
+  This code may be used and distributed under the terms of the
+  Mame license
+
+*****************************************************************/
+
+#if defined xfx || defined svgafx
+
+#include <math.h>
+#include <glide.h>
+#include "xmame.h"
+#include "driver.h"
+
+void CalcPoint(GrVertex *vert,int x,int y);
+void InitTextures(void);
+int  InitVScreen(void);
+void CloseVScreen(void);
+void UpdateTexture(struct osd_bitmap *bitmap);
+void DrawFlatBitmap(void);
+void UpdateFlatDisplay(void);
+void UpdateFXDisplay(struct osd_bitmap *bitmap);
+static int SetResolution(struct rc_option *option, const char *arg,
+   int priority);
+
+extern int antialias;
+extern int pointnum;
+extern GrVertex vec_vert[10000];
+
+int fxwidth = 640;
+int fxheight = 480;
+GuTexPalette texpal;
+
+static GrScreenResolution_t Gr_resolution = GR_RESOLUTION_640x480;
+static GrHwConfiguration hwconfig;
+static char version[80];
+static GrTexInfo texinfo;
+static int palette_changed=0;
+static int bilinear=1; /* Do binlinear filtering? */
+static int screendirty=1;  /* Has the bitmap been modified since the last frame? */
+static const int texsize=256;
+
+/* The squares that are tiled to make up the game screen polygon */
+
+struct TexSquare
+{
+  unsigned char *texture;
+  unsigned int texobj;
+  long texadd;
+  float x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4;
+  GrVertex vtxA, vtxB, vtxC, vtxD;
+  float xcov,ycov;
+};
+
+static struct TexSquare *texgrid=NULL;
+static int texnumx;
+static int texnumy;
+static float texpercx;
+static float texpercy;
+static float vscrntlx;
+static float vscrntly;
+static float vscrnwidth;
+static float vscrnheight;
+static float xinc,yinc;
+
+float cscrx1,cscry1,cscrz1,cscrx2,cscry2,cscrz2,
+  cscrx3,cscry3,cscrz3,cscrx4,cscry4,cscrz4;
+float cscrwdx,cscrwdy,cscrwdz;
+float cscrhdx,cscrhdy,cscrhdz;
+
+int vecgame=0;
+
+struct rc_option fx_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "FX (Glide) Related", NULL,		rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "resolution",	"res",			rc_use_function, NULL,
+     "640x480",		0,			0,		SetResolution,
+     "Specify the resolution/ windowsize to use in the form of XRESxYRES" },
+   { "keepaspect",	NULL,			rc_bool,	&normal_use_aspect_ratio,
+     "1",		0,			0,		NULL,
+     "Try / don't try to keep the aspect ratio of a game" },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+int sysdep_display_16bpp_capable(void)
+{
+   return 0;
+}
+
+/* Allocate a palette */
+int sysdep_display_alloc_palette(int writable_colors)
+{
+  InitTextures();
+  return 0;
+}
+
+/* Change the color of a pen */
+int sysdep_display_set_pen(int pen, unsigned char red,unsigned char green,
+					unsigned char blue) 
+{
+  palette_changed=1;
+
+  texpal.data[pen]=red<<16|green<<8|blue;
+  return 0;
+}
+
+void CalcPoint(GrVertex *vert,int x,int y)
+{
+  vert->x=vscrntlx+(float)x*texpercx*vscrnwidth;
+  if(vert->x>vscrntlx+vscrnwidth) vert->x=vscrntlx+vscrnwidth;
+
+  vert->y=vscrntly+vscrnheight-(float)y*texpercy*vscrnheight;
+  if(vert->y<vscrntly) vert->y=vscrntly;
+}
+
+int InitGlide(void)
+{
+  int fd = open("/dev/3dfx", O_RDWR);
+  if ((fd < 0) && geteuid())
+  {
+     fprintf(stderr, "Glide error: couldn't open /dev/3dfx and not running as root\n");
+     return OSD_NOT_OK;
+  }
+  if (fd >= 0)
+     close(fd);
+  putenv("FX_GLIDE_NO_SPLASH=");
+  grGlideInit();
+  if (!grSstQueryHardware(&hwconfig))
+  {
+     grGlideShutdown();
+     fprintf(stderr, "Glide error: no boards found\n");
+     return OSD_NOT_OK;
+  }
+  return OSD_OK;
+}
+
+void InitTextures(void)
+{
+  int x,y,point;
+  struct TexSquare *tsq;
+  long texmem,memaddr;
+
+  texinfo.smallLod=texinfo.largeLod=GR_LOD_256;
+  texinfo.aspectRatio=GR_ASPECT_1x1;
+  texinfo.format=GR_TEXFMT_P_8;
+
+  texmem=grTexTextureMemRequired(GR_MIPMAPLEVELMASK_BOTH,&texinfo);
+
+  if(vecgame) {
+	grColorCombine(GR_COMBINE_FUNCTION_LOCAL,
+				   GR_COMBINE_FACTOR_NONE,
+				   GR_COMBINE_LOCAL_ITERATED,
+				   GR_COMBINE_OTHER_NONE,
+				   FXFALSE);
+	
+	grAlphaCombine(GR_COMBINE_FUNCTION_SCALE_OTHER,
+				   GR_COMBINE_FACTOR_ONE,
+				   GR_COMBINE_LOCAL_NONE,
+				   GR_COMBINE_LOCAL_ITERATED,
+				   FXFALSE);
+	
+    grAlphaBlendFunction(GR_BLEND_ALPHA_SATURATE,GR_BLEND_ONE,
+						 GR_BLEND_ALPHA_SATURATE,GR_BLEND_ONE);
+	
+  }
+  else {
+	grColorCombine(GR_COMBINE_FUNCTION_SCALE_OTHER,
+				   GR_COMBINE_FACTOR_ONE,
+				   GR_COMBINE_LOCAL_NONE,
+				   GR_COMBINE_OTHER_TEXTURE,
+				   FXFALSE);
+  }
+
+  grTexCombine(GR_TMU0,
+			   GR_COMBINE_FUNCTION_LOCAL,GR_COMBINE_FACTOR_NONE,
+			   GR_COMBINE_FUNCTION_NONE,GR_COMBINE_FACTOR_NONE,
+			   FXFALSE, FXFALSE);
+
+  grTexMipMapMode(GR_TMU0,
+				  GR_MIPMAP_DISABLE,
+				  FXFALSE);
+
+  grTexClampMode(GR_TMU0,
+				 GR_TEXTURECLAMP_CLAMP,
+				 GR_TEXTURECLAMP_CLAMP);
+
+  if(bilinear)
+	grTexFilterMode(GR_TMU0,
+					GR_TEXTUREFILTER_BILINEAR,
+					GR_TEXTUREFILTER_BILINEAR);
+  else
+	grTexFilterMode(GR_TMU0,
+					GR_TEXTUREFILTER_POINT_SAMPLED,
+					GR_TEXTUREFILTER_POINT_SAMPLED);
+
+  /* Allocate the texture memory */
+  
+  texnumx=visual_width/texsize;
+  if(texnumx*texsize!=visual_width) texnumx++;
+  texnumy=visual_height/texsize;
+  if(texnumy*texsize!=visual_height) texnumy++;
+  
+  xinc=vscrnwidth*((float)texsize/(float)visual_width);
+  yinc=vscrnheight*((float)texsize/(float)visual_height);
+  
+  /* printf("%d %d %d %d\n",visual_width,visual_height,texnumx,texnumy); */
+  
+  texpercx=(float)texsize/(float)visual_width;
+  if(texpercx>1.0) texpercx=1.0;
+  
+  texpercy=(float)texsize/(float)visual_height;
+  if(texpercy>1.0) texpercy=1.0;
+  
+  /*	printf("-- %f %f\n",texpercx,texpercy); */
+  
+  texgrid=(struct TexSquare *)
+	malloc(texnumx*texnumy*sizeof(struct TexSquare));
+  memaddr=grTexMinAddress(GR_TMU0);
+  
+  for(y=0;y<texnumy;y++) {
+	for(x=0;x<texnumx;x++) {
+	  tsq=texgrid+y*texnumx+x;
+
+	  tsq->texadd=memaddr;
+	  memaddr+=texmem;
+
+	  if(x==(texnumx-1) && visual_width%texsize)
+		tsq->xcov=(float)((visual_width)%texsize)/(float)texsize;
+	  else tsq->xcov=1.0;
+	  
+	  if(y==(texnumy-1) && visual_height%texsize)
+		tsq->ycov=(float)((visual_height)%texsize)/(float)texsize;
+	  else tsq->ycov=1.0;
+
+	  tsq->vtxA.oow=1.0;
+	  tsq->vtxB=tsq->vtxC=tsq->vtxD=tsq->vtxA;
+	
+	  CalcPoint(&(tsq->vtxA),x,y);
+	  CalcPoint(&(tsq->vtxB),x+1,y);
+	  CalcPoint(&(tsq->vtxC),x+1,y+1);
+	  CalcPoint(&(tsq->vtxD),x,y+1);
+ 	
+	  tsq->vtxA.tmuvtx[0].sow=0.0;
+	  tsq->vtxA.tmuvtx[0].tow=0.0;
+
+	  tsq->vtxB.tmuvtx[0].sow=256.0*tsq->xcov;
+	  tsq->vtxB.tmuvtx[0].tow=0.0;
+
+	  tsq->vtxC.tmuvtx[0].sow=256.0*tsq->xcov;
+	  tsq->vtxC.tmuvtx[0].tow=256.0*tsq->ycov;
+
+	  tsq->vtxD.tmuvtx[0].sow=0.0;
+	  tsq->vtxD.tmuvtx[0].tow=256.0*tsq->ycov;
+	  
+	  tsq->texture=malloc(texsize*texsize);
+
+	  /* Initialize the texture memory */
+
+	  for(point=0;point<(texsize*texsize);point++)
+		tsq->texture[point]=0;
+	}
+  }
+}
+
+typedef struct {
+    int         res;
+    int       width;
+    int       height;
+} ResToRes;
+		
+static ResToRes resTable[] = {
+    { GR_RESOLUTION_320x200,   320,  200 },  /* 0x0 */
+    { GR_RESOLUTION_320x240,   320,  240 },  /* 0x1 */
+    { GR_RESOLUTION_400x256,   400,  256 },  /* 0x2 */
+    { GR_RESOLUTION_512x384,   512,  384 },  /* 0x3 */
+    { GR_RESOLUTION_640x200,   640,  200 },  /* 0x4 */
+    { GR_RESOLUTION_640x350,   640,  350 },  /* 0x5 */
+    { GR_RESOLUTION_640x400,   640,  400 },  /* 0x6 */
+    { GR_RESOLUTION_640x480,   640,  480 },  /* 0x7 */
+    { GR_RESOLUTION_800x600,   800,  600 },  /* 0x8 */
+    { GR_RESOLUTION_960x720,   960,  720 },  /* 0x9 */
+    { GR_RESOLUTION_856x480,   856,  480 },  /* 0xA */
+    { GR_RESOLUTION_512x256,   512,  256 },  /* 0xB */
+    { GR_RESOLUTION_1024x768,  1024, 768 },  /* 0xC */
+    { GR_RESOLUTION_1280x1024, 1280, 1024 }, /* 0xD */
+    { GR_RESOLUTION_1600x1200, 1600, 1200 }, /* 0xE */
+    { GR_RESOLUTION_400x300,   400,  300 }   /* 0xF */
+};
+			
+static long resTableSize = sizeof( resTable ) / sizeof( ResToRes );
+
+/* Get screen resolution */
+static int SetResolution(struct rc_option *option, const char *arg,
+   int priority)
+{
+  int width, height, match;
+  if (sscanf(arg, "%dx%d", &width, &height) == 2)
+  {
+     for( match = 0; match < resTableSize; match++ )
+        if( width==resTable[match].width && height==resTable[match].height)
+        {
+           Gr_resolution = resTable[match].res;
+           fxwidth = width;
+           fxheight = height;
+           option->priority = priority;
+           return 0;
+        }
+  }
+  fprintf(stderr,
+      "error: invalid resolution or unknown resolution: \"%s\".\n"
+      "   Valid resolutions are:\n", arg);
+  for( match = 0; match < resTableSize; match++ )
+  {
+     fprintf(stderr_file, "   \"%dx%d\"", resTable[match].width,
+        resTable[match].height);
+     if (match && (match % 5) == 0)
+        fprintf(stderr_file, "\n");
+  }
+  return -1;
+}
+
+
+/* Set up the virtual screen */
+
+int InitVScreen(void)
+{
+  int line;
+  float scrnaspect,vscrnaspect;
+
+  if(Machine->drv->video_attributes & VIDEO_TYPE_VECTOR)
+	vecgame=1;
+
+  grGlideGetVersion(version);
+
+  fprintf(stderr_file, "info: using Glide version %s\n", version);
+  
+  grSstSelect(0);
+
+  if(!grSstWinOpen(0,Gr_resolution,GR_REFRESH_60Hz,GR_COLORFORMAT_ABGR,
+     GR_ORIGIN_LOWER_LEFT,2,1))
+  {
+     fprintf(stderr_file, "error opening Glide window, do you have enough memory on your 3dfx for the selected mode?\n");
+     return OSD_NOT_OK;
+  }
+  fprintf(stderr_file,
+     "info: screen resolution set to %dx%d\n", fxwidth, fxheight);
+
+  /* clear the buffer */
+
+  grBufferClear(0,0,GR_ZDEPTHVALUE_FARTHEST);
+
+  if (use_aspect_ratio)
+  {
+     scrnaspect=(float)visual_width/(float)visual_height;
+     vscrnaspect=(float)fxwidth/(float)fxheight;
+
+     if(scrnaspect<vscrnaspect) {
+   	vscrnheight=(float)fxheight;
+   	vscrnwidth=vscrnheight*scrnaspect;
+   	vscrntlx=((float)fxwidth-vscrnwidth)/2.0;
+   	vscrntly=0.0;
+     }
+     else {
+   	vscrnwidth=(float)fxwidth;
+   	vscrnheight=vscrnwidth/scrnaspect;
+   	vscrntlx=0.0;
+   	vscrntly=((float)fxheight-vscrnheight)/2.0;
+     }
+  }
+  else
+  {
+     vscrnwidth=(float)fxwidth;
+     vscrnheight=(float)fxheight;
+     vscrntlx=0.0;
+     vscrntly=0.0;
+  }
+  
+  /* fill the display_palette_info struct */
+  memset(&display_palette_info, 0, sizeof(struct sysdep_palette_info));
+  display_palette_info.depth = 8;
+  display_palette_info.writable_colors = 256;
+
+  return OSD_OK;
+}
+
+/* Close down the virtual screen */
+
+void CloseVScreen(void)
+{
+  int x,y;
+
+  /* Free Texture stuff */
+
+  if(texgrid) {
+	for(y=0;y<texnumy;y++) {
+	  for(x=0;x<texnumx;x++) {
+		free(texgrid[y*texnumx+x].texture);
+	  }
+	}
+	
+	free(texgrid);
+	texgrid = NULL;
+  }
+
+  grGlideShutdown();
+}
+
+/* Not needed under GL */
+
+void sysdep_clear_screen(void)
+{
+}
+
+
+/* Update the texture with the contents of the game screen */
+
+void UpdateTexture(struct osd_bitmap *bitmap)
+{
+  int max_y,y,rline,texline,xsquare,ysquare,ofs,width;
+  int x, max_x;
+  struct TexSquare *square;
+  int min,max;
+  unsigned long *src,*dest,*end;
+  int blocky;
+
+  if(visual_width<=texsize) width=visual_width;
+  else width=texsize;
+
+  switch(use_dirty) {
+  case 0:
+	screendirty=1;
+
+	for(y=visual.min_y;y<=visual.max_y;y++) {
+	  rline=y-visual.min_y;
+	ysquare=rline/texsize;
+	texline=rline%texsize;
+	  
+	for(xsquare=0;xsquare<texnumx;xsquare++) {
+	  ofs=xsquare*texsize;
+		
+	  if(xsquare<(texnumx-1) || !(visual_width%texsize))
+		width=texsize;
+	  else width=visual_width%texsize;
+	  
+		square=texgrid+(ysquare*texnumx)+xsquare;
+		
+		src=(unsigned long *)(bitmap->line[y]+visual.min_x+ofs);
+		dest=(unsigned long *)(square->texture+texline*texsize);
+		end=(unsigned long *)((unsigned int)src+width);
+		
+		for(;src<end;src++,dest++)
+		  *dest=*src;
+	  }
+	}
+
+	break;
+
+  case 1:
+	osd_dirty_merge();
+
+  case 2:
+	max_y=(visual.max_y+1) >> 3;
+
+	for(y=visual.min_y>>3;y<max_y;y++) {
+	  if(dirty_lines[y]) {
+		screendirty=1;
+
+		rline=(y<<3)-visual.min_y;
+		ysquare=rline/texsize;
+
+		for(blocky=0;blocky<8;blocky++) {
+		  texline=(rline+blocky)%texsize;
+
+		  for(xsquare=0;xsquare<texnumx;xsquare++) {
+			ofs=xsquare*texsize;
+
+			square=texgrid+(ysquare*texnumx)+xsquare;
+
+			grTexDownloadMipMapLevelPartial(GR_TMU0,square->texadd,
+											GR_LOD_256,GR_LOD_256,
+											GR_ASPECT_1x1,
+											GR_TEXFMT_P_8,
+											GR_MIPMAPLEVELMASK_BOTH,
+											bitmap->line[(y<<3)+blocky]+
+											visual.min_x+ofs,
+											texline,texline);
+		  }
+		}
+
+		/*
+		max_x=(visual.max_x+1) >> 3;
+
+		for(x=visual.min_x>>3;x<max_x;x++) {
+		  if(dirty_blocks[y][x]) {
+			xsquare=((x<<3)-visual.min_x)/texsize;
+			ofs=((x<<3)-visual.min_x)%texsize;		  
+			square=texgrid+(ysquare*texnumx)+xsquare;
+
+			for(blocky=0;blocky<8;blocky++) {
+			  texline=(rline+blocky)%texsize;
+
+			  src=(unsigned long *)(bitmap->line[(y<<3)+blocky]+(x<<3));
+			  dest=(unsigned long *)(square->texture+(texline*texsize)+ofs);
+			  end=(unsigned long *)((unsigned int)src+8);
+		
+			  for(;src<end;src++,dest++)
+				*dest=*src;
+			}
+
+			dirty_blocks[y][x]=0;
+		  }
+		}
+		*/
+
+		dirty_lines[y] = 0;
+	}
+  }
+	
+	break;		
+  }
+}
+
+void DrawFlatBitmap(void)
+{
+  struct TexSquare *square;
+  int x,y;
+
+  /* If the palette was changed, update the color table */
+	  
+  if(palette_changed)
+	grTexDownloadTable(GR_TMU0,GR_TEXTABLE_PALETTE,&texpal);
+	  
+  for(y=0;y<texnumy;y++) {
+	for(x=0;x<texnumx;x++) {
+	  square=texgrid+y*texnumx+x;
+
+	  texinfo.data=(void *)square->texture;
+
+	  if(!use_dirty) {
+	  grTexDownloadMipMapLevel(GR_TMU0,square->texadd,
+							   GR_LOD_256,GR_LOD_256,GR_ASPECT_1x1,
+							   GR_TEXFMT_P_8,
+							   GR_MIPMAPLEVELMASK_BOTH,texinfo.data);
+	  }
+
+	  grTexSource(GR_TMU0,square->texadd,
+				  GR_MIPMAPLEVELMASK_BOTH,&texinfo);
+
+	  grDrawTriangle(&(square->vtxA),&(square->vtxD),&(square->vtxC));
+	  grDrawTriangle(&(square->vtxA),&(square->vtxB),&(square->vtxC));
+	}
+  }
+}
+
+void UpdateFlatDisplay(void)
+{
+  int point;
+  GrVertex *v1,*v2;
+  GrVertex tmpvert;
+
+  grBufferClear(0,0,GR_ZDEPTHVALUE_FARTHEST);
+
+  if(vecgame) {
+	for(point=1;point<pointnum;point++) {
+	  v1=vec_vert+(point-1);
+	  v2=vec_vert+point;
+
+	  if(v2->a>0.0) {
+		if(v1->x==v2->x&&v1->y==v2->y) {
+		  if(antialias)
+			grAADrawPoint(v2);
+		  else grDrawPoint(v2);
+		}
+		else {
+		  tmpvert.oow=1.0;
+		  tmpvert.r=v2->r; tmpvert.g=v2->g; tmpvert.b=v2->b; tmpvert.a=v2->a;
+		  tmpvert.x=v1->x; tmpvert.y=v1->y;
+
+		  if(antialias)
+			grAADrawLine(&tmpvert,v2);
+		  else
+			grDrawLine(&tmpvert,v2);
+		}
+	  }
+	}
+  }
+
+  if(!vecgame||screendirty) {
+	if(vecgame) {
+	  grColorCombine(GR_COMBINE_FUNCTION_SCALE_OTHER,
+					 GR_COMBINE_FACTOR_ONE,
+					 GR_COMBINE_LOCAL_NONE,
+					 GR_COMBINE_OTHER_TEXTURE,
+					 FXFALSE);
+
+	  grAlphaCombine(GR_COMBINE_FUNCTION_LOCAL,
+					 GR_COMBINE_FACTOR_LOCAL,
+					 GR_COMBINE_LOCAL_CONSTANT,
+					 GR_COMBINE_OTHER_NONE,
+					 FXFALSE);
+	}
+
+	DrawFlatBitmap();
+
+	if(vecgame) {
+	  grColorCombine(GR_COMBINE_FUNCTION_LOCAL,
+					 GR_COMBINE_FACTOR_NONE,
+					 GR_COMBINE_LOCAL_ITERATED,
+					 GR_COMBINE_OTHER_NONE,
+					 FXFALSE);
+
+	  grAlphaCombine(GR_COMBINE_FUNCTION_LOCAL,
+					 GR_COMBINE_FACTOR_LOCAL,
+					 GR_COMBINE_LOCAL_ITERATED,
+					 GR_COMBINE_OTHER_NONE,
+					 FXFALSE);
+	}
+  }
+
+  grBufferSwap(1);
+
+  palette_changed=0;
+}
+
+void UpdateFXDisplay(struct osd_bitmap *bitmap)
+{
+  if(bitmap && (!vecgame||screendirty)) UpdateTexture(bitmap);
+
+  UpdateFlatDisplay();
+
+  /* screendirty=0; */
+}
+
+/* used when expose events received */
+
+void osd_refresh_screen(void)
+{
+  /* Just re-draw the whole screen */
+
+  UpdateFXDisplay(NULL);
+}
+
+
+/* invoked by main tree code to update bitmap into screen */
+
+void sysdep_update_display(struct osd_bitmap *bitmap)
+{
+  if(keyboard_pressed(KEYCODE_RCONTROL)) {
+	if(keyboard_pressed_memory(KEYCODE_A))
+	  antialias=1-antialias;
+	if(keyboard_pressed_memory(KEYCODE_B)) {
+	  bilinear=1-bilinear;
+
+	  if(bilinear)
+		grTexFilterMode(GR_TMU0,
+						GR_TEXTUREFILTER_BILINEAR,
+						GR_TEXTUREFILTER_BILINEAR);
+	  else
+		grTexFilterMode(GR_TMU0,
+						GR_TEXTUREFILTER_POINT_SAMPLED,
+						GR_TEXTUREFILTER_POINT_SAMPLED);
+
+	}
+  }
+
+  UpdateFXDisplay(bitmap);
+}
+
+#endif /* if defined xfx || defined svgafx */
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/fxvec.c mame-0.36b16/src/unix/video-drivers/fxvec.c
--- ../mmmmm/m36b16/src/unix/video-drivers/fxvec.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/fxvec.c	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,153 @@
+/*****************************************************************
+
+  Glide vector routines
+
+  Copyright 1998 by Mike Oliphant - oliphant@ling.ed.ac.uk
+
+    http://www.ling.ed.ac.uk/~oliphant/glmame
+
+  This code may be used and distributed under the terms of the
+  Mame license
+
+*****************************************************************/
+
+#if defined xfx || defined svgafx
+
+#include <glide.h>
+#include "xmame.h"
+#include "driver.h"
+#include "artwork.h"
+
+extern int fxwidth,fxheight;
+extern GuTexPalette texpal;
+
+unsigned char *vectorram;
+int vectorram_size;
+
+int antialias;                            /* flag for anti-aliasing */
+int beam;                                 /* size of vector beam    */
+int flicker;                              /* beam flicker value     */
+int translucency;
+
+int pointnum;
+GrVertex vec_vert[10000];
+
+static int vecshift;
+static float vecwidth,vecheight;
+
+
+/*
+ * Initializes vector game video emulation
+ */
+
+int vector_vh_start (void)
+{
+  vecwidth=(float)(Machine->drv->default_visible_area.max_x-
+	Machine->drv->default_visible_area.min_x);
+
+  vecheight=(float)(Machine->drv->default_visible_area.max_y-
+	Machine->drv->default_visible_area.min_y);
+
+  pointnum=0;
+
+  return 0;
+}
+
+/*
+ * Stop the vector video hardware emulation. Free memory.
+ */
+
+void vector_vh_stop (void)
+{
+}
+
+/*
+ * Setup scaling. Currently the Sega games are stuck at VECSHIFT 15
+ * and the the AVG games at VECSHIFT 16
+ */
+
+void vector_set_shift (int shift)
+{
+  vecshift=shift;
+}
+
+/* Convert an xy point to xyz in the 3D scene */
+
+void PointConvert(int x,int y,float *sx,float *sy)
+{
+  float dx,dy,tmp;
+
+  dx=(float)(x>>vecshift)/vecwidth;
+  dy=(float)(y>>vecshift)/vecheight;
+
+  if(Machine->orientation&ORIENTATION_SWAP_XY) {
+    tmp=dx;
+    dx=dy;
+    dy=tmp;
+  }
+
+  if(Machine->orientation&ORIENTATION_FLIP_X)
+    dx=1.0-dx;
+
+  if(Machine->orientation&ORIENTATION_FLIP_Y)
+    dy=1.0-dy;
+
+  *sx=dx*(float)fxwidth;
+  *sy=(float)fxheight-dy*(float)fxheight;
+}
+
+/*
+ * Adds a line end point to the vertices list. The vector processor emulation
+ * needs to call this.
+ */
+
+void vector_add_point(int x, int y, int color, int intensity)
+{
+  GrVertex *vert;
+  FxU32 pen;
+
+  if(pointnum==10000)
+	printf("Vector buffer overflow\n");
+  else {
+	vert=vec_vert+pointnum;
+
+	vert->oow=1.0;
+
+	pen=texpal.data[Machine->pens[color]];
+
+	vert->r=(float)((pen>>16)&0x000000ff);
+	vert->g=(float)((pen>>8)&0x000000ff);
+	vert->b=(float)(pen&0x000000ff);
+
+	vert->a=(float)intensity; /* /1.7; */
+
+	PointConvert(x,y,&(vert->x),&(vert->y));
+  }
+
+  pointnum++;
+}
+
+/*
+ * Add new clipping info to the list
+ */
+
+void vector_add_clip (int x1, int yy1, int x2, int y2)
+{
+}
+
+/*
+ * The vector CPU creates a new display list.
+ */
+
+void vector_clear_list(void)
+{
+  pointnum=0;
+}
+
+/* Called when the frame is complete */
+
+void vector_vh_update(struct osd_bitmap *bitmap,int full_refresh)
+{
+}
+
+#endif /* if defined xfx || defined svgafx */
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/ggi.c mame-0.36b16/src/unix/video-drivers/ggi.c
--- ../mmmmm/m36b16/src/unix/video-drivers/ggi.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/ggi.c	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,1255 @@
+/***************************************************************************
+
+ Linux libGGI driver by Gabriele Boccone - clayton@dist.unige.it
+
+  Something is recycled (and/or tweaked) from svgalib.c. This is only
+  a "Quick and Dirty Hack"(TM) to make things interesting.
+
+  Please if you test GGI-mame send me a mail, saying: "It works on my system"
+  or "It does not work on my system", and what kind of computer you tested
+  GGI-mame on. If you also want to send me sugar, coffee, chocolate, etc,
+  feel free to send it by e-mail.
+
+  Adapted for xmame-0.31 by Christian Groessler - cpg@aladdin.de
+
+  * tested with GGI 2.0 Beta2 *
+***************************************************************************/
+#ifdef ggi
+#define __GGI_C
+
+#include <ggi/ggi.h>
+#include <signal.h>
+#include <math.h>
+
+/*#define KEY_DEBUG*/
+/*#define GGI_DEBUG*/
+/*#define CATCH_SIGNALS*/
+
+#include "xmame.h"
+#include "driver.h"
+#include "devices.h"
+#include "keyboard.h"
+
+static int video_width,video_height;
+static int scaled_visual_width,scaled_visual_height;
+static ggi_visual_t vis = NULL;
+static int screen_startx,screen_starty;
+static int lastmouse[MOUSE_AXIS]={0,0,0,0,0,0,0,0};
+static unsigned char *video_mem;
+static unsigned char *doublebuffer_buffer = NULL; /* also used for scaling */
+static ggi_mode mode;
+static int use_linear = 0;
+static int force_x,force_y;
+
+struct rc_option display_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "GGI Related",	NULL,			rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "linear",		NULL,			rc_bool,	&use_linear,
+     "0",		0,			0,		NULL,
+     "Enable/disable use of linear framebuffer (fast)" },
+   { "xres",            NULL,                   rc_int,         &force_x,
+     "0",               0,                      0,              NULL,
+     "Force the X resolution" },
+   { "yres",            NULL,                   rc_int,         &force_y,
+     "0",               0,                      0,              NULL,
+     "Force the Y resolution" },
+   { NULL,		NULL,			rc_link,	mode_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+struct mode_list {
+    int width;
+    int height;
+};
+
+/* table of modes to try */
+static struct mode_list ggimodes[] = {
+    {  320,  200 },
+    {  320,  240 },
+    {  360,  240 },
+    {  360,  400 },
+    {  360,  480 },
+    {  320,  400 },
+    {  320,  480 },
+    {  400,  300 },
+    {  600,  400 },
+    {  640,  200 },
+    {  640,  400 },
+    {  640,  480 },
+    {  800,  600 },
+    { 1024,  768 },
+    { 1280, 1024 },
+    { 2048, 1536 }
+};
+#define ML_ANZ (sizeof(ggimodes) / sizeof(struct mode_list))   /* # of entries in table */
+
+static int first_call=TRUE;
+/* do we need this? It makes debugging crashes sorta hard without a core file */
+#ifdef CATCH_SIGNALS
+static void (*oldsigsegvh)(int) = NULL;
+static void (*oldsigbush)(int) = NULL;
+static void (*oldsigquith)(int) = NULL;
+#endif
+
+static void ggi_cleanup(void);
+static void (*update_function)(struct osd_bitmap *bitmap);
+static void ggi_update_8_to_8bpp(struct osd_bitmap *bitmap);
+static void ggi_update_8_to_8bpp_scaled(struct osd_bitmap *bitmap);
+static void ggi_update_8_to_16bpp(struct osd_bitmap *bitmap);
+static void ggi_update_8_to_24bpp(struct osd_bitmap *bitmap);
+static void ggi_update_8_to_32bpp(struct osd_bitmap *bitmap);
+static void ggi_update_16_to_16bpp(struct osd_bitmap *bitmap);
+static void ggi_update_16_to_16bpp_scaled(struct osd_bitmap *bitmap);
+static void ggi_update_16_to_24bpp(struct osd_bitmap *bitmap);
+static void ggi_update_16_to_32bpp(struct osd_bitmap *bitmap);
+static void ggi_update_linear_8_to_8bpp(struct osd_bitmap *bitmap);
+static void ggi_update_linear_8_to_16bpp(struct osd_bitmap *bitmap);
+static void ggi_update_linear_8_to_24bpp(struct osd_bitmap *bitmap);
+static void ggi_update_linear_8_to_32bpp(struct osd_bitmap *bitmap);
+static void ggi_update_linear_16_to_16bpp(struct osd_bitmap *bitmap);
+static void ggi_update_linear_16_to_24bpp(struct osd_bitmap *bitmap);
+static void ggi_update_linear_16_to_32bpp(struct osd_bitmap *bitmap);
+
+
+/* do we need this? It makes debugging crashes sorta hard without a core file */
+#ifdef CATCH_SIGNALS
+/* emergency signal handler: try to restore things */
+
+static void myhandler(int signum)
+{
+    char *signam;
+    char tmpbuf[32];
+    void (*orgh)(int) = NULL;
+    switch(signum) {
+        case SIGSEGV:
+            signam="SIGSEGV";
+            orgh=oldsigsegvh;
+            break;
+        case SIGBUS:
+            signam="SIGBUS";
+            orgh=oldsigbush;
+            break;
+        case SIGQUIT:
+            signam="SIGQUIT";
+            orgh=oldsigquith;
+            break;
+        default:
+            sprintf(tmpbuf,"unknown(%d)",signum);
+            signam=tmpbuf;
+    }
+    fprintf(stderr_file,"%s: aborting...\n",signam);
+    if (first_call) {
+        first_call=FALSE;
+        ggi_cleanup(); /* try again once */
+    }
+    if (orgh) orgh(signum);
+    exit(255);
+}
+#endif
+
+int sysdep_init(void)
+{
+#ifdef GGI_DEBUG
+   if (stderr_file)
+      fprintf(stderr_file,"sysdep_init called\n");
+#endif
+
+   if (ggiInit())
+   {
+      fprintf(stderr, "Unable to initialize GGI subsystem!\n"); /* sounds good, doesn't it? */
+      return OSD_NOT_OK;
+   }
+
+   return OSD_OK;
+}
+
+void sysdep_close(void)
+{
+#ifdef GGI_DEBUG
+    fprintf(stderr_file,"sysdep_close called\n");
+#endif
+    ggiExit();
+}
+
+
+int sysdep_display_16bpp_capable(void)
+{
+   /* ehm ? */
+   return 1;
+}
+
+/*
+ * check whether a given mode exists
+ * try 8bit and >8bit color depths as needed
+ * 15-Oct-1999, chris
+ */
+static int ggi_check_mode(ggi_visual_t vis, int w, int h, int depth,
+   ggi_graphtype *type)
+{
+    ggi_mode mode;
+
+#ifdef GGI_DEBUG
+    fprintf(stderr_file,"ggi_check_mode called (%dx%d)\n",w,h);
+#endif
+    memset(&mode,0xff,sizeof(mode));
+    /* try 8bit color depth */
+    if ((depth == 8) &&
+        (! ggiCheckSimpleMode(vis, w, h, GGI_AUTO, GT_8BIT, &mode)))
+    {
+       *type = GT_8BIT;
+       return(TRUE);
+    }
+    /* try 16bit color depth */
+    if (! ggiCheckSimpleMode(vis, w, h, GGI_AUTO, GT_16BIT, &mode))
+    {
+       *type = GT_16BIT;
+       return(TRUE);
+    }
+    /* try 15bit color depth */
+    if (! ggiCheckSimpleMode(vis, w, h, GGI_AUTO, GT_15BIT, &mode))
+    {
+       *type = GT_15BIT;
+       return(TRUE);
+    }
+    /* try 24bit color depth */
+    if (! ggiCheckSimpleMode(vis, w, h, GGI_AUTO, GT_24BIT, &mode))
+    {
+       *type = GT_24BIT;
+       return(TRUE);
+    }
+    /* try 32bit color depth */
+    if (! ggiCheckSimpleMode(vis, w, h, GGI_AUTO, GT_32BIT, &mode))
+    {
+       *type = GT_32BIT;
+       return(TRUE);
+    }
+    return(FALSE);
+}
+
+/*
+ * determine video mode to set:
+ * must have >= colors as game (bitmap->depth == 16)
+ * must be >= resolution than game (visual_width/visual_height)
+ * 03-Nov-1999, chris
+ * 14-Mar-2000, chris, force_x + force_y
+ */
+static int set_video_mode(int depth)
+{
+    int i, best_score = 0;
+    ggi_graphtype type, best_type;
+    const ggi_directbuffer *direct_buf;
+    typedef void(*updater_t)(struct osd_bitmap *bitmap);
+    updater_t updaters[] = {
+        /* linear updaters */
+        ggi_update_linear_8_to_8bpp,
+        ggi_update_linear_8_to_16bpp,
+        ggi_update_linear_8_to_24bpp,
+        ggi_update_linear_8_to_32bpp,
+        NULL,
+        ggi_update_linear_16_to_16bpp,
+        ggi_update_linear_16_to_24bpp,
+        ggi_update_linear_16_to_32bpp,
+        /* non-linear updaters */
+        ggi_update_8_to_8bpp,
+        ggi_update_8_to_16bpp,
+        ggi_update_8_to_24bpp,
+        ggi_update_8_to_32bpp,
+        NULL,
+        ggi_update_16_to_16bpp,
+        ggi_update_16_to_24bpp,
+        ggi_update_16_to_32bpp,
+        /* scaled non-linear updaters */
+        ggi_update_8_to_8bpp_scaled,
+        ggi_update_8_to_16bpp,
+        ggi_update_8_to_24bpp,
+        ggi_update_8_to_32bpp,
+        NULL,
+        ggi_update_16_to_16bpp_scaled,
+        ggi_update_16_to_24bpp,
+        ggi_update_16_to_32bpp
+    };
+    int updater = 0;
+
+#ifdef GGI_DEBUG
+    fprintf(stderr_file,"set_video_mode called\n");
+#endif
+    scaled_visual_width = visual_width  * widthscale;
+    scaled_visual_height = visual_height * heightscale;
+
+    if (force_x == 0)
+        video_width = scaled_visual_width;
+    else
+        video_width = force_x;
+
+    if (force_y == 0)
+        video_height = scaled_visual_height;
+    else
+        video_height = force_y;
+
+    if (video_height < scaled_visual_height || video_width < scaled_visual_width) {
+        fprintf(stderr_file,"Forced resolution %dx%d < needed resolution %dx%d -- aborting...\n",
+                video_width,video_height,scaled_visual_width,scaled_visual_height);
+        return(FALSE);
+    }
+
+    if (force_x || force_y)
+        fprintf(stderr_file,"Command line override: setting mode %dx%d\n",video_width,video_height);
+
+    /* some GGI stuff */
+    vis = ggiOpen(NULL);
+    ggiSetFlags(vis, GGIFLAG_ASYNC);
+    ggiSetEventMask(vis, emKey | emPointer);
+
+    /* first try exact game resolution... */
+    if (! ggi_check_mode(vis, video_width, video_height, depth, &best_type) &&
+        (!force_x && !force_y))
+    {
+        int w, h, score;
+        /* now try from my [just hacked] list of modes */
+        /* (grrr -- isn't there a way to get all supported modes from GGI?) */
+        for (i=0; i<ML_ANZ; i++)
+        {
+            w = ggimodes[i].width;
+            h = ggimodes[i].height;
+            if (ggi_check_mode(vis, w, h, depth, &type)) {
+                score = mode_match(w,h);
+                if (score && score >= best_score) {
+                    best_score = score;
+                    best_type  = type;
+                    video_width = w; video_height = h;
+                }
+            }
+        }
+        if (! best_score) {
+            fprintf(stderr_file, "GGI: Couldn't find a suitable mode for a resolution of %dx%d\n"
+                    "Trying to get any mode....\n",
+                    scaled_visual_width,scaled_visual_height);
+            /* trying to get any mode from GGI */
+            if (ggiSetSimpleMode(vis,GGI_AUTO,GGI_AUTO,GGI_AUTO,GT_AUTO) != 0) {
+                fprintf(stderr_file, "GGI: Couldn't find a suitable mode for a resolution of %dx%d\n",
+                        scaled_visual_width,scaled_visual_height);
+                return(FALSE);
+            }
+            goto mode_set;
+        }
+    }
+
+    if (ggiCheckSimpleMode(vis, video_width, video_height, GGI_AUTO,
+                           best_type, &mode) != 0)
+       return(FALSE);
+
+    if (ggiSetMode(vis, &mode) != 0)
+       return(FALSE);
+
+ mode_set:
+
+    ggiGetMode(vis, &mode); /* Maybe we did not get what we asked for */
+    if ((mode.visible.x < scaled_visual_width)||
+	(mode.visible.y < scaled_visual_height)) {
+	fprintf(stderr_file,
+		"Fatal: cannot get big enough mode %dx%d\n",
+		scaled_visual_width,scaled_visual_height);
+        return(FALSE);
+    }
+    if ((mode.visible.x != scaled_visual_width)||
+	(mode.visible.y != scaled_visual_height)) {
+	fprintf(stderr_file,
+		"Notice: cannot get ideal mode %dx%d, setting to %dx%d\n",
+		scaled_visual_width,scaled_visual_height,mode.visible.x,mode.visible.y);
+    }
+    video_width   = mode.visible.x;
+    video_height  = mode.visible.y;
+    screen_startx = ((video_width - scaled_visual_width) / 2) & ~7;
+    screen_starty = (video_height - scaled_visual_height) / 2;
+    
+    /* choose the correct updater for this graphtype */
+    updater += (GT_SIZE(mode.graphtype) / 8) - 1;
+    
+    /* can we do linear ? */
+    if (use_linear && (direct_buf = ggiDBGetBuffer(vis,0)) &&
+        (direct_buf->type & GGI_DB_SIMPLE_PLB) )
+    {
+        if ((widthscale > 1 || heightscale > 2))
+        {
+           doublebuffer_buffer = malloc(scaled_visual_width * 
+              GT_SIZE(mode.graphtype) / 8);
+           if (!doublebuffer_buffer)
+           {
+              fprintf(stderr_file, "GGI: Error: Couldn't allocate doublebuffer buffer\n");
+              return FALSE;
+           }
+        }
+        video_mem = direct_buf->write;
+        video_mem += screen_startx * GT_SIZE(mode.graphtype) / 8;
+        video_mem += screen_starty * video_width *
+           GT_SIZE(mode.graphtype) / 8;
+#ifdef GGI_DEBUG
+        fprintf(stderr_file,
+           "ggi.c: set_video_mode: using %d bit linear update\n",
+           GT_SIZE(mode.graphtype));
+#endif
+    }
+    else
+    {
+        if((widthscale == 1) && (heightscale == 1))
+           updater += 8;
+        else
+           updater += 16;
+        /* we need the doublebuffer_buffer in the following scenarios:
+           -scale != 1x1
+           -16bpp modes, since it could be paletised
+           -if the depths don't match */
+        if( (widthscale > 1) || (heightscale > 1) || (depth == 16) ||
+            (depth != GT_SIZE(mode.graphtype)) )
+        {
+           doublebuffer_buffer = malloc(scaled_visual_width*scaled_visual_height*
+              GT_SIZE(mode.graphtype) / 8);
+           if (!doublebuffer_buffer)
+           {
+              fprintf(stderr_file, "GGI: Error: Couldn't allocate doublebuffer buffer\n");
+              return FALSE;
+           }
+        }
+    }
+    
+    if (depth == 16)
+       updater+=4;
+       
+    update_function = updaters[updater];
+    
+    /* fill the display_palette_info */
+    memset(&display_palette_info, 0, sizeof(struct sysdep_palette_info));
+    display_palette_info.depth = GT_SIZE(mode.graphtype);
+    switch (GT_SIZE(mode.graphtype))
+    {
+       case 8:
+          display_palette_info.writable_colors = 256;
+          break;
+       case 15:
+          display_palette_info.red_mask   = 0x001F;
+          display_palette_info.green_mask = 0x03E0;
+          display_palette_info.blue_mask  = 0xEC00;
+          break;
+       case 16:
+          display_palette_info.red_mask   = 0xF800;
+          display_palette_info.green_mask = 0x07E0;
+          display_palette_info.blue_mask  = 0x001F;
+          break;
+       case 24:
+       case 32:
+          display_palette_info.red_mask   = 0xFF0000;
+          display_palette_info.green_mask = 0x00FF00;
+          display_palette_info.blue_mask  = 0x0000FF;
+          break;
+    }
+    
+    return TRUE;
+}
+
+
+/*
+ * parts from svgalib.c version
+ */
+int sysdep_create_display(int depth)
+{
+#ifdef GGI_DEBUG
+    fprintf(stderr_file,"sysdep_create_display called\n");
+#endif
+/* do we need this? It makes debugging crashes sorta hard without a core file */
+#ifdef CATCH_SIGNALS
+    oldsigsegvh=signal(SIGSEGV,myhandler);
+    oldsigbush=signal(SIGBUS,myhandler);
+    oldsigquith=signal(SIGQUIT,myhandler);
+    if (oldsigsegvh == SIG_ERR || oldsigbush == SIG_ERR || oldsigquith == SIG_ERR) {
+	fprintf (stderr_file, "Cannot install signal handler. Exiting\n");
+	return OSD_NOT_OK;
+    }
+#endif
+    if (! set_video_mode(depth)) {
+        fprintf(stderr_file,"cannot find a mode to use :-(\n");
+        return OSD_NOT_OK;
+    }
+
+    fprintf(stderr_file,"GGI: using mode %dx%d\n",video_width,video_height);
+#ifdef GGI_DEBUG
+    fprintf(stderr_file,"16bit game: %s\n",(bitmap->depth == 16) ? "yes" : "no");
+#endif
+
+    return OSD_OK;
+}
+
+
+/*
+ * close down the display
+ */
+void sysdep_display_close(void)
+{
+#ifdef GGI_DEBUG
+    fprintf(stderr_file,"sysdep_display_close called\n");
+#endif
+/* do we need this? It makes debugging crashes sorta hard without a core file */
+#ifdef CATCH_SIGNALS
+    if (oldsigsegvh) signal(SIGSEGV,oldsigsegvh);
+    if (oldsigbush) signal(SIGBUS,oldsigbush);
+    if (oldsigquith) signal(SIGBUS,oldsigquith);
+#endif
+    ggi_cleanup();
+#ifdef GGI_DEBUG
+    fprintf(stderr_file,"sysdep_display_close finished\n");
+#endif
+}
+
+
+static void ggi_cleanup(void)
+{
+#ifdef GGI_DEBUG
+    fprintf(stderr_file,"ggi_cleanup called\n");
+#endif
+    if (vis) {
+      ggiClose(vis);
+      vis=NULL;
+    }
+    if (doublebuffer_buffer) free(doublebuffer_buffer);
+}
+
+
+int sysdep_display_alloc_palette(int writable_colors)
+{
+#ifdef GGI_DEBUG
+    fprintf(stderr_file,"sysdep_alloc_palette called\n");
+#endif
+
+    return 0;
+}
+
+
+int sysdep_display_set_pen(int pen,unsigned char red, unsigned char green,
+   unsigned char blue)
+{
+    ggi_color gpen;
+
+#if 0 && defined(GGI_DEBUG)
+    fprintf(stderr_file,"sysdep_modify_pen called\n");
+#endif
+    if (!vis) return -1; /* visual not initialized yet -- do nothing */
+
+    gpen.r = red << 8;
+    gpen.g = green << 8;
+    gpen.b = blue << 8;
+    ggiSetPalette(vis, pen, 1, &gpen);
+    
+    return 0;
+}
+
+
+/*
+ * low-level update routines
+ * for different color depths
+ * (04-Nov-99, they are working, but could
+ *  be improved: move calculations of
+ *  e.g. "X+screen_startx" out of the loops...)
+ */
+
+/* 8bpp to 8bpp, not scaled */
+static void ggi_update_8_to_8bpp(struct osd_bitmap *bitmap)
+{
+#define PUT_IMAGE(X, Y, WIDTH, HEIGHT) \
+    { \
+        int _i; \
+        for (_i=0; _i<HEIGHT; _i++) { \
+            ggiPutHLine(vis,screen_startx+(X),screen_starty+(Y)+_i, \
+                        WIDTH,bitmap->line[(Y)+visual.min_y+_i]+visual.min_x+(X)); \
+        } \
+    }
+#include "blit.h"
+#undef PUT_IMAGE
+}
+
+/*---------*/
+
+/* 8bpp to 8bpp, scaled */
+static void ggi_update_8_to_8bpp_scaled(struct osd_bitmap *bitmap)
+{
+#define SRC_PIXEL unsigned char
+#define DEST_PIXEL unsigned char
+#define DEST doublebuffer_buffer
+#define DEST_WIDTH scaled_visual_width
+#define PUT_IMAGE(X, Y, WIDTH, HEIGHT) \
+    { \
+        int _i; \
+        for (_i=0; _i<HEIGHT; _i++) { \
+            ggiPutHLine(vis,screen_startx+X,screen_starty+Y+_i, \
+                        WIDTH,DEST + (X) * sizeof(DEST_PIXEL) + DEST_WIDTH * sizeof(DEST_PIXEL) * (_i + Y) ); \
+        } \
+    }
+#include "blit.h"
+#undef PUT_IMAGE
+#undef DEST_WIDTH
+#undef DEST
+#undef DEST_PIXEL
+#undef SRC_PIXEL
+}
+
+/*---------*/
+
+static void ggi_update_8_to_16bpp(struct osd_bitmap *bitmap)
+{
+#define INDIRECT current_palette->lookup
+#define SRC_PIXEL unsigned char
+#define DEST_PIXEL unsigned short
+#define DEST doublebuffer_buffer
+#define DEST_WIDTH scaled_visual_width
+#define PUT_IMAGE(X, Y, WIDTH, HEIGHT) \
+    { \
+        int _i; \
+        for (_i=0; _i<HEIGHT; _i++) { \
+            ggiPutHLine(vis,screen_startx+X,screen_starty+Y+_i, \
+                        WIDTH,DEST + (X) * sizeof(DEST_PIXEL) + DEST_WIDTH * sizeof(DEST_PIXEL) * (_i + Y) ); \
+        } \
+    }
+#include "blit.h"
+#undef DEST_WIDTH
+#undef DEST
+#undef DEST_PIXEL
+#undef SRC_PIXEL
+#undef PUT_IMAGE
+#undef INDIRECT
+}
+
+/*---------*/
+
+static void ggi_update_8_to_24bpp(struct osd_bitmap *bitmap)
+{
+#define INDIRECT current_palette->lookup
+#define SRC_PIXEL unsigned char
+#define DEST_PIXEL unsigned int
+#define DEST doublebuffer_buffer
+#define DEST_WIDTH scaled_visual_width
+#define PACK_BITS
+#define PUT_IMAGE(X, Y, WIDTH, HEIGHT) \
+    { \
+        int _i; \
+        for (_i=0; _i<HEIGHT; _i++) { \
+            ggiPutHLine(vis,screen_startx+X,screen_starty+Y+_i, \
+                        WIDTH,DEST + (X) * 3 + DEST_WIDTH * 3 * (_i + Y) ); \
+        } \
+    }
+#include "blit.h"
+#undef DEST_WIDTH
+#undef DEST
+#undef DEST_PIXEL
+#undef SRC_PIXEL
+#undef PUT_IMAGE
+#undef PACK_BITS
+#undef INDIRECT
+}
+
+/*---------*/
+
+static void ggi_update_8_to_32bpp(struct osd_bitmap *bitmap)
+{
+#define INDIRECT current_palette->lookup
+#define SRC_PIXEL unsigned char
+#define DEST_PIXEL unsigned int
+#define DEST doublebuffer_buffer
+#define DEST_WIDTH scaled_visual_width
+#define PUT_IMAGE(X, Y, WIDTH, HEIGHT) \
+    { \
+        int _i; \
+        for (_i=0; _i<(HEIGHT); _i++) { \
+            ggiPutHLine(vis,screen_startx+(X),screen_starty+(Y)+_i, \
+                        WIDTH,DEST + (X) * sizeof(DEST_PIXEL) + DEST_WIDTH * sizeof(DEST_PIXEL) * (_i + (Y)) ); \
+        } \
+    }
+#include "blit.h"
+#undef DEST_WIDTH
+#undef DEST
+#undef DEST_PIXEL
+#undef SRC_PIXEL
+#undef PUT_IMAGE
+#undef INDIRECT
+}
+
+/*---------*/
+
+static void ggi_update_16_to_16bpp(struct osd_bitmap *bitmap)
+{
+   if (current_palette->lookup)
+   {
+      /* since we need todo the lookups we need to go through an extra buffer,
+         just like ggi_update_16_to_16bpp_scaled() does */
+      ggi_update_16_to_16bpp_scaled(bitmap);
+   }
+   else
+   {
+#define PUT_IMAGE(X, Y, WIDTH, HEIGHT) \
+    { \
+        int _i; \
+        for (_i=0; _i<HEIGHT; _i++) { \
+            ggiPutHLine(vis,screen_startx+(X),screen_starty+(Y)+_i, \
+                        WIDTH,bitmap->line[(Y)+visual.min_y+_i]+(visual.min_x+(X))*2); \
+        } \
+    }
+#include "blit.h"
+#undef PUT_IMAGE
+   }
+}
+
+/*---------*/
+
+void ggi_update_16_to_16bpp_scaled(struct osd_bitmap *bitmap)
+{
+#define SRC_PIXEL unsigned short
+#define DEST_PIXEL unsigned short
+#define DEST doublebuffer_buffer
+#define DEST_WIDTH scaled_visual_width
+#define PUT_IMAGE(X, Y, WIDTH, HEIGHT) \
+    { \
+        int _i; \
+        for (_i=0; _i<HEIGHT; _i++) { \
+            ggiPutHLine(vis,screen_startx+(X),screen_starty+(Y)+_i, \
+                        WIDTH,DEST + (X) * sizeof(DEST_PIXEL) + DEST_WIDTH * sizeof(DEST_PIXEL) * (_i + (Y)) ); \
+        } \
+    }
+    
+    if (current_palette->lookup)
+    {
+#define INDIRECT current_palette->lookup
+#include "blit.h"
+#undef INDIRECT
+    }
+    else
+    {
+#include "blit.h"
+    }
+#undef DEST_WIDTH
+#undef DEST
+#undef DEST_PIXEL
+#undef SRC_PIXEL
+#undef PUT_IMAGE
+}
+
+/*---------*/
+
+static void ggi_update_16_to_24bpp(struct osd_bitmap *bitmap)
+{
+#define INDIRECT current_palette->lookup
+#define SRC_PIXEL unsigned short
+#define DEST_PIXEL unsigned int
+#define DEST doublebuffer_buffer
+#define DEST_WIDTH scaled_visual_width
+#define PACK_BITS
+#define PUT_IMAGE(X, Y, WIDTH, HEIGHT) \
+    do { \
+        int _i; \
+        for (_i=0; _i<HEIGHT; _i++) { \
+            ggiPutHLine(vis,screen_startx+(X),screen_starty+(Y)+_i, \
+                        WIDTH,DEST + (X) * 3 + DEST_WIDTH * 3 * (_i + (Y)) ); \
+        } \
+    } while(0);
+#include "blit.h"
+#undef DEST_WIDTH
+#undef DEST
+#undef DEST_PIXEL
+#undef SRC_PIXEL
+#undef PUT_IMAGE
+#undef PACK_BITS
+#undef INDIRECT
+}
+
+/*---------*/
+
+static void ggi_update_16_to_32bpp(struct osd_bitmap *bitmap)
+{
+#define INDIRECT current_palette->lookup
+#define SRC_PIXEL unsigned short
+#define DEST_PIXEL unsigned int
+#define DEST doublebuffer_buffer
+#define DEST_WIDTH scaled_visual_width
+#define PUT_IMAGE(X, Y, WIDTH, HEIGHT) \
+    do { \
+        int _i; \
+        for (_i=0; _i<HEIGHT; _i++) { \
+            ggiPutHLine(vis,screen_startx+(X),screen_starty+(Y)+_i, \
+                        WIDTH,DEST + (X) * sizeof(DEST_PIXEL) + DEST_WIDTH * sizeof(DEST_PIXEL) * (_i + (Y)) ); \
+        } \
+    } while(0);
+#include "blit.h"
+#undef DEST_WIDTH
+#undef DEST
+#undef DEST_PIXEL
+#undef SRC_PIXEL
+#undef PUT_IMAGE
+#undef INDIRECT
+}
+
+/*---------*/
+
+static void ggi_update_linear_8_to_8bpp(struct osd_bitmap *bitmap)
+{
+#define DEST_PIXEL unsigned char
+#define SRC_PIXEL unsigned char
+#define DEST video_mem
+#define DEST_WIDTH mode.virt.x
+#define DOUBLEBUFFER
+#include "blit.h"
+#undef DEST
+#undef DEST_WIDTH
+#undef DOUBLEBUFFER
+#undef SRC_PIXEL
+#undef DEST_PIXEL
+}
+
+/*---------*/
+
+static void ggi_update_linear_8_to_16bpp(struct osd_bitmap *bitmap)
+{
+#define INDIRECT current_palette->lookup
+#define DEST_PIXEL unsigned short
+#define SRC_PIXEL unsigned char
+#define DEST video_mem
+#define DEST_WIDTH mode.virt.x
+#define DOUBLEBUFFER
+#define BLIT_16BPP_HACK
+#include "blit.h"
+#undef BLIT_16BPP_HACK
+#undef DEST
+#undef DEST_WIDTH
+#undef DOUBLEBUFFER
+#undef SRC_PIXEL
+#undef DEST_PIXEL
+#undef INDIRECT
+}
+
+/*---------*/
+
+static void ggi_update_linear_8_to_24bpp(struct osd_bitmap *bitmap)
+{
+#define INDIRECT current_palette->lookup
+#define DEST_PIXEL unsigned int
+#define SRC_PIXEL unsigned char
+#define PACK_BITS
+#define DEST video_mem
+#define DEST_WIDTH mode.virt.x
+#define DOUBLEBUFFER
+#include "blit.h"
+#undef PACK_BITS
+#undef DEST
+#undef DEST_WIDTH
+#undef DOUBLEBUFFER
+#undef SRC_PIXEL
+#undef DEST_PIXEL
+#undef INDIRECT
+}
+
+/*---------*/
+
+static void ggi_update_linear_8_to_32bpp(struct osd_bitmap *bitmap)
+{
+#define INDIRECT current_palette->lookup
+#define DEST_PIXEL unsigned int
+#define SRC_PIXEL unsigned char
+#define DEST video_mem
+#define DEST_WIDTH mode.virt.x
+#define DOUBLEBUFFER
+#include "blit.h"
+#undef PACK_BITS
+#undef DEST_WIDTH
+#undef DOUBLEBUFFER
+#undef SRC_PIXEL
+#undef DEST_PIXEL
+#undef INDIRECT
+}
+
+/*---------*/
+
+static void ggi_update_linear_16_to_16bpp(struct osd_bitmap *bitmap)
+{
+#define DEST_PIXEL unsigned short
+#define SRC_PIXEL unsigned short
+#define DEST video_mem
+#define DEST_WIDTH mode.virt.x
+#define DOUBLEBUFFER
+    if (current_palette->lookup)
+    {
+#define INDIRECT current_palette->lookup
+#include "blit.h"
+#undef INDIRECT
+    }
+    else
+    {
+#include "blit.h"
+    }
+#undef DEST
+#undef DEST_WIDTH
+#undef DOUBLEBUFFER
+#undef SRC_PIXEL
+#undef DEST_PIXEL
+}
+
+/*---------*/
+
+static void ggi_update_linear_16_to_24bpp(struct osd_bitmap *bitmap)
+{
+#define INDIRECT current_palette->lookup
+#define DEST_PIXEL unsigned int
+#define SRC_PIXEL unsigned short
+#define PACK_BITS
+#define DEST video_mem
+#define DEST_WIDTH mode.virt.x
+#define DOUBLEBUFFER
+#include "blit.h"
+#undef DEST
+#undef DEST_WIDTH
+#undef DOUBLEBUFFER
+#undef PACK_BITS
+#undef SRC_PIXEL
+#undef DEST_PIXEL
+#undef INDIRECT
+}
+
+/*---------*/
+
+static void ggi_update_linear_16_to_32bpp(struct osd_bitmap *bitmap)
+{
+#define INDIRECT current_palette->lookup
+#define DEST_PIXEL unsigned int
+#define SRC_PIXEL unsigned short
+#define DEST video_mem
+#define DEST_WIDTH mode.virt.x
+#define DOUBLEBUFFER
+#include "blit.h"
+#undef PACK_BITS
+#undef DEST_WIDTH
+#undef DOUBLEBUFFER
+#undef SRC_PIXEL
+#undef DEST_PIXEL
+#undef INDIRECT
+}
+
+
+/*
+ * Update the display.
+ */
+void sysdep_update_display(struct osd_bitmap *bitmap) {
+    int old_usedirty = use_dirty;
+
+    if (current_palette->lookup_dirty)
+        use_dirty = 0;
+
+    update_function(bitmap);
+    ggiFlush(vis);
+    
+    use_dirty = old_usedirty;
+}
+
+int ggi_key(ggi_event *ev)
+{
+    unsigned int keycode=KEY_NONE;
+    int label = ev->key.label;
+
+#ifdef KEY_DEBUG
+    fprintf(stderr_file,
+        "Keyevent detected: sym = 0x%02x, code = 0x%02x, label = 0x%02x\n",
+        ev->key.sym, ev->key.button, label);
+#endif
+
+    switch (label >> 8)
+    {
+       case GII_KT_LATIN1:
+          switch (label) { /* for now, the simple way */
+              case GIIUC_BackSpace:  keycode = KEY_BACKSPACE;  break;
+              case GIIUC_Tab:        keycode = KEY_TAB;        break;
+              case GIIUC_Linefeed:   keycode = KEY_ENTER;      break;
+              case GIIUC_Return:     keycode = KEY_ENTER;      break;
+              case GIIUC_Escape:     keycode = KEY_ESC;        break;
+              case GIIUC_Delete:     keycode = KEY_DEL;        break;
+              case GIIUC_Space:      keycode = KEY_SPACE;      break;
+              case GIIUC_Exclam:     keycode = KEY_1;          break;
+              case GIIUC_QuoteDbl:   keycode = KEY_QUOTE;      break;
+              case GIIUC_Hash:       keycode = KEY_3;          break;
+              case GIIUC_Dollar:     keycode = KEY_4;          break;
+              case GIIUC_Percent:    keycode = KEY_5;          break;
+              case GIIUC_Ampersand:  keycode = KEY_7;          break;
+              case GIIUC_Apostrophe: keycode = KEY_QUOTE;      break;
+              case GIIUC_ParenLeft:  keycode = KEY_9;          break;
+              case GIIUC_ParenRight: keycode = KEY_0;          break;
+              case GIIUC_Asterisk:   keycode = KEY_ASTERISK;   break;
+              case GIIUC_Plus:       keycode = KEY_EQUALS;     break;
+              case GIIUC_Comma:      keycode = KEY_COMMA;      break;
+              case GIIUC_Minus:      keycode = KEY_MINUS;      break;
+              case GIIUC_Period:     keycode = KEY_STOP;       break;
+              case GIIUC_Slash:      keycode = KEY_SLASH;      break;
+              case GIIUC_0:          keycode = KEY_0;          break;
+              case GIIUC_1:          keycode = KEY_1;          break;
+              case GIIUC_2:          keycode = KEY_2;          break;
+              case GIIUC_3:          keycode = KEY_3;          break;
+              case GIIUC_4:          keycode = KEY_4;          break;
+              case GIIUC_5:          keycode = KEY_5;          break;
+              case GIIUC_6:          keycode = KEY_6;          break;
+              case GIIUC_7:          keycode = KEY_7;          break;
+              case GIIUC_8:          keycode = KEY_8;          break;
+              case GIIUC_9:          keycode = KEY_9;          break;
+              case GIIUC_Colon:      keycode = KEY_COLON;      break;
+              case GIIUC_Semicolon:  keycode = KEY_COLON;      break;
+              case GIIUC_Less:       keycode = KEY_COMMA;      break;
+              case GIIUC_Equal:      keycode = KEY_EQUALS;     break;
+              case GIIUC_Greater:    keycode = KEY_STOP;       break;
+              case GIIUC_Question:   keycode = KEY_SLASH;      break;
+              case GIIUC_At:         keycode = KEY_2;          break;
+              case GIIUC_A:          keycode = KEY_A;          break;
+              case GIIUC_B:          keycode = KEY_B;          break;
+              case GIIUC_C:          keycode = KEY_C;          break;
+              case GIIUC_D:          keycode = KEY_D;          break;
+              case GIIUC_E:          keycode = KEY_E;          break;
+              case GIIUC_F:          keycode = KEY_F;          break;
+              case GIIUC_G:          keycode = KEY_G;          break;
+              case GIIUC_H:          keycode = KEY_H;          break;
+              case GIIUC_I:          keycode = KEY_I;          break;
+              case GIIUC_J:          keycode = KEY_J;          break;
+              case GIIUC_K:          keycode = KEY_K;          break;
+              case GIIUC_L:          keycode = KEY_L;          break;
+              case GIIUC_M:          keycode = KEY_M;          break;
+              case GIIUC_N:          keycode = KEY_N;          break;
+              case GIIUC_O:          keycode = KEY_O;          break;
+              case GIIUC_P:          keycode = KEY_P;          break;
+              case GIIUC_Q:          keycode = KEY_Q;          break;
+              case GIIUC_R:          keycode = KEY_R;          break;
+              case GIIUC_S:          keycode = KEY_S;          break;
+              case GIIUC_T:          keycode = KEY_T;          break;
+              case GIIUC_U:          keycode = KEY_U;          break;
+              case GIIUC_V:          keycode = KEY_V;          break;
+              case GIIUC_W:          keycode = KEY_W;          break;
+              case GIIUC_X:          keycode = KEY_X;          break;
+              case GIIUC_Y:          keycode = KEY_Y;          break;
+              case GIIUC_Z:          keycode = KEY_Z;          break;
+              case GIIUC_BracketLeft:  keycode = KEY_OPENBRACE;  break;
+              case GIIUC_BackSlash:    keycode = KEY_BACKSLASH;  break;
+              case GIIUC_BracketRight: keycode = KEY_CLOSEBRACE; break;
+              case GIIUC_Circumflex:   keycode = KEY_6;          break;
+              case GIIUC_Underscore:   keycode = KEY_MINUS;      break;
+              case GIIUC_Grave:        keycode = KEY_TILDE;      break;
+              case GIIUC_a:          keycode = KEY_A;          break;
+              case GIIUC_b:          keycode = KEY_B;          break;
+              case GIIUC_c:          keycode = KEY_C;          break;
+              case GIIUC_d:          keycode = KEY_D;          break;
+              case GIIUC_e:          keycode = KEY_E;          break;
+              case GIIUC_f:          keycode = KEY_F;          break;
+              case GIIUC_g:          keycode = KEY_G;          break;
+              case GIIUC_h:          keycode = KEY_H;          break;
+              case GIIUC_i:          keycode = KEY_I;          break;
+              case GIIUC_j:          keycode = KEY_J;          break;
+              case GIIUC_k:          keycode = KEY_K;          break;
+              case GIIUC_l:          keycode = KEY_L;          break;
+              case GIIUC_m:          keycode = KEY_M;          break;
+              case GIIUC_n:          keycode = KEY_N;          break;
+              case GIIUC_o:          keycode = KEY_O;          break;
+              case GIIUC_p:          keycode = KEY_P;          break;
+              case GIIUC_q:          keycode = KEY_Q;          break;
+              case GIIUC_r:          keycode = KEY_R;          break;
+              case GIIUC_s:          keycode = KEY_S;          break;
+              case GIIUC_t:          keycode = KEY_T;          break;
+              case GIIUC_u:          keycode = KEY_U;          break;
+              case GIIUC_v:          keycode = KEY_V;          break;
+              case GIIUC_w:          keycode = KEY_W;          break;
+              case GIIUC_x:          keycode = KEY_X;          break;
+              case GIIUC_y:          keycode = KEY_Y;          break;
+              case GIIUC_z:          keycode = KEY_Z;          break;
+              case GIIUC_BraceLeft:  keycode = KEY_OPENBRACE;  break;
+              case GIIUC_Pipe:       keycode = KEY_BACKSLASH;  break;
+              case GIIUC_BraceRight: keycode = KEY_CLOSEBRACE; break;
+              case GIIUC_Tilde:      keycode = KEY_TILDE;      break;
+          }
+          break;
+       case GII_KT_SPEC:
+          switch (label) { /* for now, the simple way */
+              case GIIK_Break:       keycode = KEY_PAUSE;      break;
+              case GIIK_ScrollForw:  keycode = KEY_PGUP;       break;
+              case GIIK_ScrollBack:  keycode = KEY_PGDN;       break;
+              case GIIK_Menu:        keycode = KEY_MENU;       break;
+              case GIIK_Cancel:      keycode = KEY_ESC;        break;
+              case GIIK_PrintScreen: keycode = KEY_PRTSCR;     break;
+              case GIIK_Execute:     keycode = KEY_ENTER;      break;
+              case GIIK_Begin:       keycode = KEY_HOME;       break;
+              case GIIK_Clear:       keycode = KEY_DEL;        break;
+              case GIIK_Insert:      keycode = KEY_INSERT;     break;
+              case GIIK_Select:      keycode = KEY_ENTER_PAD;  break;
+              case GIIK_Pause:       keycode = KEY_PAUSE;      break;
+              case GIIK_SysRq:       keycode = KEY_PRTSCR;     break;
+              case GIIK_ModeSwitch:  keycode = KEY_ALTGR;      break;
+              case GIIK_Up:          keycode = KEY_UP;         break;
+              case GIIK_Down:        keycode = KEY_DOWN;       break;
+              case GIIK_Left:        keycode = KEY_LEFT;       break;
+              case GIIK_Right:       keycode = KEY_RIGHT;      break;
+              case GIIK_PageUp:      keycode = KEY_PGUP;       break;
+              case GIIK_PageDown:    keycode = KEY_PGDN;       break;
+              case GIIK_Home:        keycode = KEY_HOME;       break;
+              case GIIK_End:         keycode = KEY_END;        break;
+          }
+          break;
+       case GII_KT_FN:
+          switch (label) { /* for now, the simple way */
+              case GIIK_F1:      keycode = KEY_F1;     break;
+              case GIIK_F2:      keycode = KEY_F2;     break;
+              case GIIK_F3:      keycode = KEY_F3;     break;
+              case GIIK_F4:      keycode = KEY_F4;     break;
+              case GIIK_F5:      keycode = KEY_F5;     break;
+              case GIIK_F6:      keycode = KEY_F6;     break;
+              case GIIK_F7:      keycode = KEY_F7;     break;
+              case GIIK_F8:      keycode = KEY_F8;     break;
+              case GIIK_F9:      keycode = KEY_F9;     break;
+              case GIIK_F10:     keycode = KEY_F10;    break;
+              case GIIK_F11:     keycode = KEY_F11;    break;
+              case GIIK_F12:     keycode = KEY_F12;    break;
+          }
+          break;
+       case GII_KT_PAD:
+          switch (label) { /* for now, the simple way */
+              case GIIK_P0:          keycode = KEY_0_PAD;      break;
+              case GIIK_P1:          keycode = KEY_1_PAD;      break;
+              case GIIK_P2:          keycode = KEY_2_PAD;      break;
+              case GIIK_P3:          keycode = KEY_3_PAD;      break;
+              case GIIK_P4:          keycode = KEY_4_PAD;      break;
+              case GIIK_P5:          keycode = KEY_5_PAD;      break;
+              case GIIK_P6:          keycode = KEY_6_PAD;      break;
+              case GIIK_P7:          keycode = KEY_7_PAD;      break;
+              case GIIK_P8:          keycode = KEY_8_PAD;      break;
+              case GIIK_P9:          keycode = KEY_9_PAD;      break;
+              case GIIK_PA:          keycode = KEY_A;          break;
+              case GIIK_PB:          keycode = KEY_B;          break;
+              case GIIK_PC:          keycode = KEY_C;          break;
+              case GIIK_PD:          keycode = KEY_D;          break;
+              case GIIK_PE:          keycode = KEY_E;          break;
+              case GIIK_PF:          keycode = KEY_F;          break;
+              case GIIK_PPlus:       keycode = KEY_PLUS_PAD;   break;
+              case GIIK_PMinus:      keycode = KEY_MINUS_PAD;  break;
+              case GIIK_PSlash:      keycode = KEY_SLASH_PAD;  break;
+              case GIIK_PAsterisk:   keycode = KEY_ASTERISK;   break;
+              case GIIK_PEqual:       keycode = KEY_ENTER_PAD;  break;
+              case GIIK_PSeparator:  keycode = KEY_DEL_PAD;    break;
+              case GIIK_PDecimal:    keycode = KEY_DEL_PAD;    break;
+              case GIIK_PParenLeft:  keycode = KEY_9_PAD;      break;
+              case GIIK_PParenRight: keycode = KEY_0_PAD;      break;
+              case GIIK_PSpace:      keycode = KEY_SPACE;      break;
+              case GIIK_PEnter:      keycode = KEY_ENTER_PAD;  break;
+              case GIIK_PTab:        keycode = KEY_TAB;        break;
+              case GIIK_PBegin:      keycode = KEY_HOME;       break;
+              case GIIK_PF1:         keycode = KEY_F1;         break;
+              case GIIK_PF2:         keycode = KEY_F2;         break;
+              case GIIK_PF3:         keycode = KEY_F3;         break;
+              case GIIK_PF4:         keycode = KEY_F4;         break;
+              case GIIK_PF5:         keycode = KEY_F5;         break;
+              case GIIK_PF6:         keycode = KEY_F6;         break;
+              case GIIK_PF7:         keycode = KEY_F7;         break;
+              case GIIK_PF8:         keycode = KEY_F8;         break;
+              case GIIK_PF9:         keycode = KEY_F9;         break;
+          }
+          break;
+       case GII_KT_MOD:
+          switch (label) { /* for now, the simple way */
+              case GIIK_ShiftL:      keycode = KEY_LSHIFT;     break;
+              case GIIK_ShiftR:      keycode = KEY_RSHIFT;     break;
+              case GIIK_CtrlL:       keycode = KEY_LCONTROL;   break;
+              case GIIK_CtrlR:       keycode = KEY_RCONTROL;   break;
+              case GIIK_AltL:        keycode = KEY_ALT;        break;
+              case GIIK_AltR:        keycode = KEY_ALTGR;      break;
+              case GIIK_MetaL:       keycode = KEY_LWIN;       break;
+              case GIIK_MetaR:       keycode = KEY_RWIN;       break;
+              case GIIK_ShiftLock:   keycode = KEY_CAPSLOCK;   break;
+              case GIIK_CapsLock:    keycode = KEY_CAPSLOCK;   break;
+              case GIIK_NumLock:     keycode = KEY_NUMLOCK;    break;
+              case GIIK_ScrollLock:  keycode = KEY_SCRLOCK;    break;
+          }
+          break;
+       case GII_KT_DEAD:
+          switch (label) { /* for now, the simple way */
+          }
+          break;
+    }
+#ifdef KEY_DEBUG
+    fprintf(stderr_file,"returning keycode = %d\n",keycode);
+#endif
+    return(keycode);
+}
+
+void sysdep_update_keyboard(void)
+{
+    ggi_event_mask em = emAll; /*emKeyPress | emKeyRelease;*/
+    ggi_event ev;
+    struct timeval to = { 0 , 0 };
+    struct keyboard_event event;
+
+    if (vis) {
+        while(ggiEventPoll(vis,em,&to)) {
+            event.press = 0;
+            
+            ggiEventRead(vis,&ev,em);
+
+            switch(ev.any.type) {
+              case evKeyPress:
+                  event.press = 1;
+              case evKeyRelease:
+                  event.scancode = ggi_key(&ev);
+                  event.unicode = ev.key.sym;
+                  keyboard_register_event(&event);
+                  break;
+            }
+
+            to.tv_sec=to.tv_usec=0;
+        }
+    }
+    return;
+}
+
+
+/*
+ * mouse not really tested
+ */
+void sysdep_mouse_poll(void)
+{
+    ggi_event_mask em = emPtrButtonPress | emPtrButtonRelease | emPtrMove;
+    ggi_event ev;
+    struct timeval to = { 0 , 0 };
+    int bi;
+
+    if (vis) {
+        while(ggiEventPoll(vis,em,&to)) {
+            ggiEventRead(vis,&ev,em);
+            bi = 0;
+
+            switch(ev.any.type) {
+
+              case evPtrButtonPress:
+                  bi = 1;
+              case evPtrButtonRelease:
+                  if (ev.pbutton.button < MOUSE_BUTTONS)
+                     mouse_data[0].buttons[ev.pbutton.button] = bi;
+                  break;
+              case evPtrAbsolute:
+                  mouse_data[0].deltas[0] = lastmouse[0] - ev.pmove.x;
+                  mouse_data[0].deltas[1] = lastmouse[1] - ev.pmove.y;
+                  lastmouse[0] = ev.pmove.x;
+                  lastmouse[1] = ev.pmove.y;
+                  break;
+              case evPtrRelative:
+                  mouse_data[0].deltas[0] = ev.pmove.x;
+                  mouse_data[0].deltas[1] = ev.pmove.y;
+                  lastmouse[0] += ev.pmove.x;
+                  lastmouse[1] += ev.pmove.y;
+                  break;
+            }
+            to.tv_sec=to.tv_usec=0;
+        }
+    }
+}
+
+void sysdep_set_leds(int leds)
+{
+}
+#endif /* ifdef ggi */
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/glcab.c mame-0.36b16/src/unix/video-drivers/glcab.c
--- ../mmmmm/m36b16/src/unix/video-drivers/glcab.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/glcab.c	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,374 @@
+#ifdef xgl
+
+#include <ctype.h>
+#include <GL/gl.h>
+#include <GL/glu.h>
+#include "xmame.h"
+#include "glmame.h"
+
+GLubyte *read_JPEG_file(char *);
+
+GLuint cablist;
+int numtex;
+GLuint *cabtex=NULL;
+GLubyte **cabimg=NULL;
+
+struct CameraPan *cpan=NULL;
+int numpans;
+int pannum;
+int inpan=0;
+
+static int inscreen=0;
+static int scrvert;
+static int inlist=0;
+
+extern GLfloat cscrx1,cscry1,cscrz1,cscrx2,cscry2,cscrz2,
+  cscrx3,cscry3,cscrz3,cscrx4,cscry4,cscrz4;
+
+
+/* Skip until we hit whitespace */
+
+char *SkipToSpace(char *buf)
+{
+  while(*buf&&!(isspace(*buf)||*buf==',')) buf++;
+
+  return buf;
+}
+
+/* Skip whitespace and commas */
+
+char *SkipSpace(char *buf)
+{
+  while(*buf&&(isspace(*buf)||*buf==',')) buf++;
+
+  return buf;
+}
+
+/* Parse a string for a 4-component vector */
+
+char *ParseVec4(char *buf,GLfloat *x,GLfloat *y,GLfloat *z,GLfloat *a)
+{
+  *x=atof(buf);
+
+  buf=SkipSpace(buf);
+  buf=SkipToSpace(buf);
+  buf=SkipSpace(buf);
+
+  *y=atof(buf);
+
+  buf=SkipSpace(buf);
+  buf=SkipToSpace(buf);
+  buf=SkipSpace(buf);
+
+  *z=atof(buf);
+
+  buf=SkipSpace(buf);
+  buf=SkipToSpace(buf);
+  buf=SkipSpace(buf);
+
+  *a=atof(buf);
+
+  buf=SkipSpace(buf);
+  buf=SkipToSpace(buf);
+
+  return buf;
+}
+
+/* Parse a string for a 3-component vector */
+
+char *ParseVec3(char *buf,GLfloat *x,GLfloat *y,GLfloat *z)
+{
+  *x=atof(buf);
+
+  buf=SkipSpace(buf);
+  buf=SkipToSpace(buf);
+  buf=SkipSpace(buf);
+
+  *y=atof(buf);
+
+  buf=SkipSpace(buf);
+  buf=SkipToSpace(buf);
+  buf=SkipSpace(buf);
+
+  *z=atof(buf);
+
+  buf=SkipSpace(buf);
+  buf=SkipToSpace(buf);
+
+  return buf;
+}
+
+/* Parse a string for a 2-component vector */
+
+char  *ParseVec2(char *buf,GLfloat *x,GLfloat *y)
+{
+  *x=atof(buf);
+
+  buf=SkipSpace(buf);
+  buf=SkipToSpace(buf);
+  buf=SkipSpace(buf);
+
+  *y=atof(buf);
+
+  buf=SkipSpace(buf);
+  buf=SkipToSpace(buf);
+
+  return buf;
+}
+
+/* Null-terminate a string after the text is done */
+
+void MakeString(char *buf)
+{
+  while(*buf&&!isspace(*buf)) buf++;
+
+  *buf='\0';
+}
+
+/* Parse a camera pan */
+
+void ParsePan(char *buf,PanType type)
+{
+  if(pannum==numpans) {
+	printf("Error: too many camera pans specified\n");
+	return;
+  }
+
+  cpan[pannum].type=type;
+  buf=ParseVec3(buf,&cpan[pannum].lx,&cpan[pannum].ly,&cpan[pannum].lz);
+  buf=ParseVec3(buf,&cpan[pannum].px,&cpan[pannum].py,&cpan[pannum].pz);
+  buf=ParseVec3(buf,&cpan[pannum].nx,&cpan[pannum].ny,&cpan[pannum].nz);
+
+  if(type==pan_moveto) cpan[pannum].frames=atoi(buf);
+
+  pannum++;
+}
+
+/* Parse a line of the .cab file */
+
+void ParseLine(char *buf)
+{
+  GLfloat x,y,z,a;
+  int texnum;
+  int xdim,ydim;
+
+  buf=SkipSpace(buf);
+
+  if(!*buf||*buf=='#'||*buf=='\n') return;
+
+  if(!strncasecmp(buf,"startgeom",9)) {
+	if(inlist) printf("Error: second call to startgeom\n");
+	else {
+	  glNewList(cablist,GL_COMPILE);
+	  inlist=1;
+	}
+  }
+  else if(!strncasecmp(buf,"numtex",6)) {
+	if(inlist)
+	  printf("numtex must be called before beginning model geometry\n");
+	else {
+	  numtex=atoi(buf+7);
+
+	  if(numtex) {
+		cabtex=(GLuint *)malloc(numtex*sizeof(GLuint));
+		cabimg=(GLubyte **)malloc(numtex*sizeof(GLubyte *));
+	  }
+	}
+  }
+  else if(!strncasecmp(buf,"loadtex",7)) {
+	if(inlist)
+	  printf("loadtex calls cannot come after beginning model geometry\n");
+	else {
+	  if(!cabtex)
+		printf("Error: Number of textures must be declared before texture loading\n");
+	  else {
+		buf=SkipToSpace(buf);
+		buf=SkipSpace(buf);
+		
+		texnum=atoi(buf);
+		
+		if(texnum>=numtex)
+		  printf("Error: Hightest possible texture number is %d\n",numtex-1);
+		else {
+		  buf=SkipToSpace(buf);
+		  buf=SkipSpace(buf);
+		  
+		  xdim=atoi(buf);
+		  
+		  buf=SkipToSpace(buf);
+		  buf=SkipSpace(buf);
+		  
+		  ydim=atoi(buf);
+		  
+		  buf=SkipToSpace(buf);
+		  buf=SkipSpace(buf);
+		  
+		  MakeString(buf);
+		  
+		  printf("Loading texture %d (%dx%d) from %s\n",texnum,xdim,ydim,buf);
+		  
+		  glGenTextures(1,cabtex+texnum);
+		  cabtex[texnum]=glGenLists(1);
+		  glBindTexture(GL_TEXTURE_2D,cabtex[texnum]);
+		  
+		  cabimg[texnum]=read_JPEG_file(buf);
+		  if(!cabimg[texnum])
+			printf("Error: Unable to read %s\n",buf);
+		  
+		  glTexImage2D(GL_TEXTURE_2D,0,3,xdim,ydim,0,GL_RGB,GL_UNSIGNED_BYTE,
+					   cabimg[texnum]);
+		  
+		  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
+		  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+		  
+		  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP);
+		  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP);
+		}
+	  }
+	}
+  }
+  else if(!strncasecmp(buf,"camerapan",9)) {
+	numpans=atoi(buf+9);
+
+	cpan=(struct CameraPan *)malloc(numpans*sizeof(struct CameraPan));
+
+	pannum=0;
+	inpan=1;
+  }
+  else if(!strncasecmp(buf,"goto",4)) {
+	if(!inpan) printf("Error: pan command outside of camerapan\n");
+	else ParsePan(buf+4,pan_goto);
+  }
+  else if(!strncasecmp(buf,"moveto",6)) {
+	if(!inpan) printf("Error: pan command outside of camerapan\n");
+	else ParsePan(buf+6,pan_moveto);
+  }
+  else if(!strncasecmp(buf,"end",3)) {
+	inscreen=0;
+	inpan=0;
+	glEnd();
+  }
+  else {
+	if(!inlist) printf("A startgeom call is needed before specifying any geometry\n");
+	else if(!strncasecmp(buf,"begin",5)) {
+	  if(!strncasecmp(buf+6,"polygon",7)) {
+		glBegin(GL_POLYGON);
+	  }
+	  else if(!strncasecmp(buf+6,"quads",5)) {
+		glBegin(GL_QUADS);
+	  }
+	  else if(!strncasecmp(buf+6,"quad_strip",10)) {
+	  glBegin(GL_QUAD_STRIP);
+	  }
+	  else if(!strncasecmp(buf+6,"screen",6)) {
+		inscreen=1;
+		scrvert=1;
+	  }
+	  else printf("Invalid object type -- %s",buf+6);
+	}
+	else if(!strncasecmp(buf,"color3",6)) {
+	  ParseVec3(buf+7,&x,&y,&z);
+	  glColor3f(x,y,z);
+	}
+	else if(!strncasecmp(buf,"color4",6)) {
+	  ParseVec4(buf+7,&x,&y,&z,&a);
+	  glColor4f(x,y,z,a);
+	}
+	else if(!strncasecmp(buf,"vertex",6)) {
+	  if(inscreen) {
+		switch(scrvert) {
+		case 1:
+		  ParseVec3(buf+7,&cscrx1,&cscry1,&cscrz1);
+		  break;
+		case 2:
+		  ParseVec3(buf+7,&cscrx2,&cscry2,&cscrz2);
+		  break;
+		case 3:
+		  ParseVec3(buf+7,&cscrx3,&cscry3,&cscrz3);
+		  break;
+		case 4:
+		  ParseVec3(buf+7,&cscrx4,&cscry4,&cscrz4);
+		  break;
+		default:
+		  printf("Error: Too many vertices in screen definition\n");
+		  break;
+		}
+		
+		scrvert++;
+	  }
+	  else {
+		ParseVec3(buf+7,&x,&y,&z);
+		glVertex3f(x,y,z);
+	  }
+	}
+	else if(!strncasecmp(buf,"shading",7)) {
+	  if(!strncasecmp(buf+8,"flat",4))
+		glShadeModel(GL_FLAT);
+	  else if(!strncasecmp(buf+8,"smooth",6))
+		glShadeModel(GL_SMOOTH);
+	  else printf("Invalid shading model -- %s",buf+8);
+	}
+	else if(!strncasecmp(buf,"enable",6)) {
+	  if(!strncasecmp(buf+7,"texture",7))
+		glEnable(GL_TEXTURE_2D);
+	  else printf("Invalid feature to enable -- %s",buf+7);
+	}
+	else if(!strncasecmp(buf,"disable",7)) {
+	  if(!strncasecmp(buf+8,"texture",7))
+		glDisable(GL_TEXTURE_2D);
+	  else printf("Invalid feature to disable -- %s",buf+7);
+	}
+	else if(!strncasecmp(buf,"settex",6)) {
+	  texnum=atoi(buf+7);
+	  
+	  if(texnum>=numtex)
+		printf("Error: Hightest possible texture number is %d\n",numtex-1);
+	  else
+		glBindTexture(GL_TEXTURE_2D,cabtex[texnum]);
+	}
+	else if(!strncasecmp(buf,"texcoord",8)) {
+	  ParseVec2(buf+9,&x,&y);
+	  glTexCoord2f(x,y);
+	}
+	else printf("Invalid command -- %s",buf);
+  }
+}
+
+/* Load the cabinet */
+
+int LoadCabinet(char *cabname)
+{
+  FILE *cfp;
+  char buf[256];
+
+  sprintf(buf,"%s/cab/%s/%s.cab",XMAMEROOT,cabname,cabname);
+
+  if(!(cfp=fopen(buf,"r")))
+	return 0;
+
+  printf("Loading Cabinet from %s\n",buf);
+
+  cablist=glGenLists(1);
+
+  if(!fgets(buf,256,cfp)) {
+	printf("File is empty\n");
+	return 0;
+  }
+
+  if(strncasecmp(buf,"cabv1.0",7)) {
+	printf("File is not a v1.0 cabinet file -- cannot load\n");
+	return 0;
+  }
+
+  while(fgets(buf,256,cfp)) {
+	ParseLine(buf);
+  }
+
+  glEndList();
+
+  fclose(cfp);
+
+  return(1);
+}
+
+#endif /*ifdef xgl */
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/glgen.c mame-0.36b16/src/unix/video-drivers/glgen.c
--- ../mmmmm/m36b16/src/unix/video-drivers/glgen.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/glgen.c	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,831 @@
+/*****************************************************************
+
+  Generic OpenGL routines
+
+  Copyright 1998 by Mike Oliphant - oliphant@ling.ed.ac.uk
+
+    http://www.ling.ed.ac.uk/~oliphant/glmame
+
+  This code may be used and distributed under the terms of the
+  Mame license
+
+*****************************************************************/
+
+#ifdef xgl
+
+#include <GL/gl.h>
+#include <GL/glu.h>
+#include "driver.h"
+#include "xmame.h"
+#include "glmame.h"
+
+#ifdef UTAH_GLX
+#define NVIDIA
+#endif
+
+#ifdef NVIDIA
+#undef GL_EXT_paletted_texture
+#endif
+
+int LoadCabinet(const char *fname);
+void SwapBuffers(void);
+void vector_vh_update(struct osd_bitmap *bitmap,int full_refresh);
+void vector_clear_list(void);
+
+
+void DeltaVec(GLfloat x1,GLfloat y1,GLfloat z1,
+			  GLfloat x2,GLfloat y2,GLfloat z2,
+			  GLfloat *dx,GLfloat *dy,GLfloat *dz);
+void CalcFlatPoint(int x,int y,GLfloat *px,GLfloat *py);
+void CalcCabPoint(int x,int y,GLfloat *px,GLfloat *py,GLfloat *pz);
+void SetupFrustum(void);
+void SetupOrtho(void);
+void InitTextures(void);
+void InitVScreen(void);
+void CloseVScreen(void);
+void UpdateTexture(struct osd_bitmap *bitmap);
+void WAvg(GLfloat perc,GLfloat x1,GLfloat y1,GLfloat z1,
+		  GLfloat x2,GLfloat y2,GLfloat z2,
+		  GLfloat *ax,GLfloat *ay,GLfloat *az);
+void UpdateCabDisplay(void);
+void DrawFlatBitmap(void);
+void UpdateFlatDisplay(void);
+void UpdateGLDisplay(struct osd_bitmap *bitmap);
+
+int cabspecified=0;
+
+extern GLuint cablist;
+extern int winwidth;
+extern int winheight;
+extern int doublebuffer;
+
+static double scrnaspect,vscrnaspect;
+
+GLubyte *ctable;
+GLfloat *rcolmap, *gcolmap, *bcolmap;
+
+static int palette_changed=0;
+static int frame=0;
+
+int bilinear=1; /* Do binlinear filtering? */
+int drawbitmap=1;
+int dopersist=0;
+int screendirty=1;  /* Has the bitmap been modified since the last frame? */
+int dodepth=1;
+
+/* The squares that are tiled to make up the game screen polygon */
+
+struct TexSquare
+{
+  GLubyte *texture;
+  GLuint texobj;
+  GLfloat x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4;
+  GLfloat fx1,fy1,fx2,fy2,fx3,fy3,fx4,fy4;
+  GLfloat xcov,ycov;
+};
+
+static struct TexSquare *texgrid=NULL;
+static int texsize=256;
+static int texnumx;
+static int texnumy;
+static GLfloat texpercx;
+static GLfloat texpercy;
+static GLfloat polysize=10.0;
+static GLfloat vscrntlx;
+static GLfloat vscrntly;
+static GLfloat vscrnwidth;
+static GLfloat vscrnheight;
+static GLfloat xinc,yinc;
+
+GLfloat cscrx1,cscry1,cscrz1,cscrx2,cscry2,cscrz2,
+  cscrx3,cscry3,cscrz3,cscrx4,cscry4,cscrz4;
+GLfloat cscrwdx,cscrwdy,cscrwdz;
+GLfloat cscrhdx,cscrhdy,cscrhdz;
+
+extern GLubyte *cabimg[5];
+extern GLuint cabtex[5];
+
+extern struct CameraPan *cpan;
+extern int numpans;
+int currentpan=0;
+int lastpan=0;
+int panframe=0;
+
+/* Vector variables */
+
+int vecgame=0;
+
+extern int antialias;
+extern GLuint veclist;
+extern int inlist;
+
+int sysdep_display_16bpp_capable(void)
+{
+   return 0;
+}
+
+/* Allocate a palette */
+int sysdep_display_alloc_palette(int writable_colors)
+{
+  int col;
+
+#ifdef GL_EXT_paletted_texture
+  ctable=(GLubyte *)malloc(256*4);
+
+  for(col=0;col<(256*4);col+=4) {
+	ctable[col]=0;
+	ctable[col+1]=0;
+	ctable[col+2]=0;
+	ctable[col+3]=255;
+  }
+#else
+  rcolmap=(GLfloat *)malloc(256*sizeof(GLfloat));
+  gcolmap=(GLfloat *)malloc(256*sizeof(GLfloat));
+  bcolmap=(GLfloat *)malloc(256*sizeof(GLfloat));
+
+  for(col=0;col<256;col++) {
+	rcolmap[col]=0.0;
+	gcolmap[col]=0.0;
+	bcolmap[col]=0.0;
+  }
+#endif
+
+  InitTextures();
+  return 0;
+}
+
+/* Change the color of a pen */
+int sysdep_display_set_pen(int pen, unsigned char red,unsigned char green,
+					   unsigned char blue) 
+{
+  int cofs;
+
+  palette_changed=1;
+
+#ifdef GL_EXT_paletted_texture
+  cofs=pen*4;
+
+  ctable[cofs]=red; 
+  ctable[cofs+1]=green;
+  ctable[cofs+2]=blue;
+#else
+  rcolmap[pen]=(GLfloat)red/255.0;
+  gcolmap[pen]=(GLfloat)green/255.0;
+  bcolmap[pen]=(GLfloat)blue/255.0;
+#endif
+  return 0;
+}
+
+/* Compute a delta vector between two points */
+
+void DeltaVec(GLfloat x1,GLfloat y1,GLfloat z1,
+			  GLfloat x2,GLfloat y2,GLfloat z2,
+			  GLfloat *dx,GLfloat *dy,GLfloat *dz)
+{
+  *dx=x2-x1;
+  *dy=y2-y1;
+  *dz=z2-z1;
+}
+
+/* Calculate points for flat screen */
+
+void CalcFlatPoint(int x,int y,GLfloat *px,GLfloat *py)
+{
+  *px=vscrntlx+(float)x*texpercx*vscrnwidth;
+  if(*px>vscrntlx+vscrnwidth) *px=vscrntlx+vscrnwidth;
+
+  *py=vscrntly+vscrnheight-(float)y*texpercy*vscrnheight;
+  if(*py<vscrntly) *py=vscrntly;
+}
+
+/* Calculate points for cabinet screen */
+
+void CalcCabPoint(int x,int y,GLfloat *px,GLfloat *py,GLfloat *pz)
+{
+  GLfloat xperc,yperc;
+
+  xperc=x*texpercx;
+  if(xperc>1.0) xperc=1.0;
+
+  yperc=y*texpercy;
+  if(yperc>1.0) yperc=1.0;
+
+  *px=cscrx1+xperc*cscrwdx+yperc*cscrhdx;
+  *py=cscry1+xperc*cscrwdy+yperc*cscrhdy;
+  *pz=cscrz1+xperc*cscrwdz+yperc*cscrhdz;
+}
+
+
+/* Set up a frustum projection */
+
+void SetupFrustum(void)
+{
+  glMatrixMode(GL_PROJECTION);
+  glLoadIdentity();
+  glFrustum(-vscrnaspect,vscrnaspect,-1.0,1.0,5.0,100.0);
+  glMatrixMode(GL_MODELVIEW);
+  glLoadIdentity();
+  glTranslatef(0.0,0.0,-20.0);
+}
+
+
+/* Set up an orthographic projection */
+
+void SetupOrtho(void)
+{
+  glMatrixMode(GL_PROJECTION);
+  glLoadIdentity();
+  glOrtho(0.0,(GLfloat)winwidth,0.0,(GLfloat)winheight,-1.0,1.0);
+
+  glMatrixMode(GL_MODELVIEW);
+  glLoadIdentity();
+}
+
+void InitTextures(void)
+{
+  int x,y,point;
+  GLuint *tobj;
+  struct TexSquare *tsq;
+
+  /* Allocate the texture memory */
+  
+  texnumx=visual_width/texsize;
+  if(texnumx*texsize!=visual_width) texnumx++;
+  texnumy=visual_height/texsize;
+  if(texnumy*texsize!=visual_height) texnumy++;
+  
+  xinc=vscrnwidth*((double)texsize/(double)visual_width);
+  yinc=vscrnheight*((double)texsize/(double)visual_height);
+  
+  /* printf("%d %d %d %d\n",visual_width,visual_height,texnumx,texnumy); */
+  
+  texpercx=(GLfloat)texsize/(GLfloat)visual_width;
+  if(texpercx>1.0) texpercx=1.0;
+  
+  texpercy=(GLfloat)texsize/(GLfloat)visual_height;
+  if(texpercy>1.0) texpercy=1.0;
+  
+  /*	printf("-- %f %f\n",texpercx,texpercy); */
+  
+  texgrid=(struct TexSquare *)
+	malloc(texnumx*texnumy*sizeof(struct TexSquare));
+  
+  for(y=0;y<texnumy;y++) {
+	for(x=0;x<texnumx;x++) {
+	  tsq=texgrid+y*texnumx+x;
+	  
+	  if(x==texnumx-1 && visual_width%texsize)
+		tsq->xcov=(GLfloat)(visual_width%texsize)/(GLfloat)texsize;
+	  else tsq->xcov=1.0;
+	  
+	  if(y==texnumy-1 && visual_height%texsize)
+		tsq->ycov=(GLfloat)(visual_height%texsize)/(GLfloat)texsize;
+	  else tsq->ycov=1.0;
+	  
+	  CalcCabPoint(x,y,&(tsq->x1),&(tsq->y1),&(tsq->z1));
+	  CalcCabPoint(x+1,y,&(tsq->x2),&(tsq->y2),&(tsq->z2));
+	  CalcCabPoint(x+1,y+1,&(tsq->x3),&(tsq->y3),&(tsq->z3));
+	  CalcCabPoint(x,y+1,&(tsq->x4),&(tsq->y4),&(tsq->z4));
+
+	  CalcFlatPoint(x,y,&(tsq->fx1),&(tsq->fy1));
+	  CalcFlatPoint(x+1,y,&(tsq->fx2),&(tsq->fy2));
+	  CalcFlatPoint(x+1,y+1,&(tsq->fx3),&(tsq->fy3));
+	  CalcFlatPoint(x,y+1,&(tsq->fx4),&(tsq->fy4));
+	  
+	  tsq->texture=malloc(texsize*texsize);
+
+	  /* Initialize the texture memory */
+
+	  for(point=0;point<(texsize*texsize);point++)
+		tsq->texture[point]=0;
+	  
+	  tobj=&(tsq->texobj);
+	  
+	  glGenTextures(1,tobj);
+	  
+	  *tobj=glGenLists(1);
+	  glBindTexture(GL_TEXTURE_2D,*tobj);
+	  
+#ifdef GL_EXT_paletted_texture
+	  printf("Paletted textures not supported, using (slow) workaround\n");
+	  printf("Ask your OpenGL supplier to implement glColorTableEXT\n");
+
+	  glColorTableEXT(GL_TEXTURE_2D,
+					  GL_RGBA,
+					  256,
+					  GL_RGBA,
+					  GL_UNSIGNED_BYTE,
+					  ctable);
+	  
+	  glTexImage2D(GL_TEXTURE_2D,0,GL_COLOR_INDEX8_EXT,texsize,texsize,0,
+				   GL_COLOR_INDEX,GL_UNSIGNED_BYTE,NULL);
+#else
+#ifdef NVIDIA
+	  glTexImage2D(GL_TEXTURE_2D,0,3,texsize,texsize,0,
+				   GL_COLOR_INDEX,GL_UNSIGNED_BYTE,tobj);
+#else
+	  glPixelMapfv(GL_PIXEL_MAP_I_TO_R,256,rcolmap);
+ 	  glPixelMapfv(GL_PIXEL_MAP_I_TO_G,256,gcolmap);
+	  glPixelMapfv(GL_PIXEL_MAP_I_TO_B,256,bcolmap);
+
+	  glTexImage2D(GL_TEXTURE_2D,0,3,texsize,texsize,0,
+				   GL_COLOR_INDEX,GL_UNSIGNED_BYTE,NULL);
+#endif
+#endif
+	  
+	  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
+	  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+	  
+	  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP);
+	  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP);
+	  
+	  glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
+	}
+  }
+}
+
+/* Set up the virtual screen */
+
+void InitVScreen(void)
+{
+  /* clear the buffer */
+
+  glClearColor(0,0,0,1);
+  glClear(GL_COLOR_BUFFER_BIT);
+  glFlush();
+
+  if(!dodepth) cabview=0;
+
+  scrnaspect=(double)visual_width/(double)visual_height;
+  vscrnaspect=(double)winwidth/(double)winheight;
+
+  glViewport(0,0,winwidth,winheight);
+
+  if(cabview)
+    SetupFrustum();
+  else SetupOrtho();
+
+  glShadeModel(GL_SMOOTH);
+
+  glEnable(GL_POLYGON_SMOOTH);
+  
+  glEnable(GL_BLEND);
+  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
+
+  if(dodepth) glDepthFunc(GL_LEQUAL);
+
+  if(scrnaspect<vscrnaspect) {
+	vscrnheight=(GLfloat)winheight;
+	vscrnwidth=vscrnheight*scrnaspect;
+	vscrntlx=((GLfloat)winwidth-vscrnwidth)/2.0;
+	vscrntly=0.0;
+  }
+  else {
+	vscrnwidth=(GLfloat)winwidth;
+	vscrnheight=vscrnwidth/scrnaspect;
+	vscrntlx=0.0;
+	vscrntly=((GLfloat)winheight-vscrnheight)/2.0;
+  }
+
+  if(cabspecified||!LoadCabinet(drivers[game_index]->name)) {
+	if(!LoadCabinet(cabname)) {
+	  printf("Unable to load cabinet %s\n",cabname);
+	}
+  }
+
+  /* Calulate delta vectors for screen height and width */
+
+  DeltaVec(cscrx1,cscry1,cscrz1,cscrx2,cscry2,cscrz2,
+		   &cscrwdx,&cscrwdy,&cscrwdz);
+	
+  DeltaVec(cscrx1,cscry1,cscrz1,cscrx4,cscry4,cscrz4,
+		   &cscrhdx,&cscrhdy,&cscrhdz);
+	
+
+  if(Machine->drv->video_attributes & VIDEO_TYPE_VECTOR)
+	vecgame=1;
+
+  /* fill the display_palette_info struct */
+  memset(&display_palette_info, 0, sizeof(struct sysdep_palette_info));
+  display_palette_info.depth = 8;
+  display_palette_info.writable_colors = 256;
+}
+
+/* Close down the virtual screen */
+
+void CloseVScreen(void)
+{
+  int x,y;
+
+#ifdef GL_EXT_paletted_texture
+  free(ctable);
+#else
+  free(rcolmap);
+  free(bcolmap);
+  free(gcolmap);
+#endif
+
+  if(cpan) free(cpan);
+
+  /* Free Texture stuff */
+
+  if(texgrid) {
+	for(y=0;y<texnumy;y++) {
+	  for(x=0;x<texnumx;x++) {
+		free(texgrid[y*texnumx+x].texture);
+	  }
+	}
+	
+	free(texgrid);
+  }
+}
+
+/* Not needed under GL */
+
+void sysdep_clear_screen(void)
+{
+}
+
+
+/* Update the texture with the contents of the game screen */
+
+void UpdateTexture(struct osd_bitmap *bitmap)
+{
+  unsigned line,rline,texline,xsquare,ysquare,ofs,width;
+
+  if(visual_width<=texsize) width=visual_width;
+  else width=texsize;
+
+  for(line=visual.min_y;line<=visual.max_y;line++) {
+	rline=line-visual.min_y;
+	ysquare=rline/texsize;
+	texline=rline%texsize;
+	  
+	for(xsquare=0;xsquare<texnumx;xsquare++) {
+	  ofs=xsquare*texsize;
+		
+	  if(xsquare<(texnumx-1) || !(visual_width%texsize))
+		width=texsize;
+	  else width=visual_width%texsize;
+	  
+	  memcpy(texgrid[ysquare*texnumx+xsquare].texture+texline*texsize,
+			 bitmap->line[line]+visual.min_x+ofs,width);
+	}
+  }
+}
+
+/* Compute an average between two sets of 3D coordinates */
+
+void WAvg(GLfloat perc,GLfloat x1,GLfloat y1,GLfloat z1,
+		  GLfloat x2,GLfloat y2,GLfloat z2,
+		  GLfloat *ax,GLfloat *ay,GLfloat *az)
+{
+  *ax=(1.0-perc)*x1+perc*x2;
+  *ay=(1.0-perc)*y1+perc*y2;
+  *az=(1.0-perc)*z1+perc*z2;
+}
+
+/* Draw a frame in Cabinet mode */
+
+void UpdateCabDisplay(void)
+{
+  struct TexSquare *square;
+  int x,y;
+  GLfloat camx,camy,camz;
+  GLfloat dirx,diry,dirz;
+  GLfloat normx,normy,normz;
+  GLfloat perc;
+  struct CameraPan *pan,*lpan;
+
+  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+  glPushMatrix();
+
+
+  /* Do the camera panning */
+
+  if(cpan) {
+	pan=cpan+currentpan;
+
+	if(panframe>pan->frames) {
+	  lastpan=currentpan;
+	  currentpan=(currentpan+1)%numpans;
+	  panframe=0;
+	}
+
+	switch(pan->type) {
+	case pan_goto:
+	  camx=pan->lx; camy=pan->ly; camz=pan->lz;
+	  dirx=pan->px; diry=pan->px; dirz=pan->pz;
+	  normx=pan->nx; normy=pan->ny; normz=pan->nz;
+	  break;
+	case pan_moveto:
+	  lpan=cpan+lastpan;
+	  perc=(GLfloat)panframe/(GLfloat)pan->frames;
+	  WAvg(perc,lpan->lx,lpan->ly,lpan->lz,
+		   pan->lx,pan->ly,pan->lz,&camx,&camy,&camz);
+	  WAvg(perc,lpan->px,lpan->py,lpan->pz,
+		   pan->px,pan->py,pan->pz,&dirx,&diry,&dirz);
+	  WAvg(perc,lpan->nx,lpan->ny,lpan->nz,
+		   pan->nx,pan->ny,pan->nz,&normx,&normy,&normz);
+	  break;
+	default:
+	  break;
+	}
+
+	gluLookAt(camx,camy,camz,
+			  dirx,diry,dirz,
+			  normx,normy,normz);
+	
+	panframe++;
+  }
+  else gluLookAt(-5.0,0.0,5.0,0.0,0.0,-5.0,0.0,1.0,0.0);
+
+  glEnable(GL_DEPTH_TEST);
+
+  /* Draw the cabinet */
+
+  glCallList(cablist);
+
+  /* Draw the screen if in vector mode */
+
+  if(vecgame) {
+	glDisable(GL_TEXTURE_2D);
+	glShadeModel(GL_FLAT);
+
+	if(antialias) {
+	  glEnable(GL_LINE_SMOOTH);
+	  glEnable(GL_POINT_SMOOTH);
+	}
+
+	glCallList(veclist);
+
+	if(antialias) {
+	  glDisable(GL_LINE_SMOOTH);
+	  glDisable(GL_POINT_SMOOTH);
+	}
+
+	glShadeModel(GL_SMOOTH);
+
+	if(drawbitmap&&screendirty) {
+	  glClear(GL_DEPTH_BUFFER_BIT);
+
+	  SetupOrtho();
+	  
+	  glColor4f(1.0,1.0,1.0,0.7);
+	  
+	  DrawFlatBitmap();
+	  
+	  SetupFrustum();
+	}
+  }
+  else {  /* Draw the screen of a bitmapped game */
+	glEnable(GL_TEXTURE_2D);
+ 
+	for(y=0;y<texnumy;y++) {
+	  for(x=0;x<texnumx;x++) {
+		square=texgrid+y*texnumx+x;
+		
+		glBindTexture(GL_TEXTURE_2D,square->texobj);
+		
+		/* If the palette was changed, update the color table */
+		
+		if(palette_changed) {
+#ifdef GL_EXT_paletted_texture
+		  glColorTableEXT(GL_TEXTURE_2D,
+						  GL_RGBA,
+						  256,
+						  GL_RGBA,
+						  GL_UNSIGNED_BYTE,
+						  ctable);
+#else
+		  glPixelMapfv(GL_PIXEL_MAP_I_TO_R,256,rcolmap);
+		  glPixelMapfv(GL_PIXEL_MAP_I_TO_G,256,gcolmap);
+		  glPixelMapfv(GL_PIXEL_MAP_I_TO_B,256,bcolmap);
+#endif	
+		}
+	
+		/* This is the quickest way I know of to update the texture */
+		
+		glTexSubImage2D(GL_TEXTURE_2D,0,0,0,texsize,texsize,
+						GL_COLOR_INDEX,GL_UNSIGNED_BYTE,square->texture);
+		
+		glBegin(GL_QUADS);
+		glTexCoord2f(0,0); glVertex3f(square->x1,square->y1,square->z1);
+		glTexCoord2f(square->xcov,0);
+		glVertex3f(square->x2,square->y2,square->z2);
+		glTexCoord2f(square->xcov,square->ycov);
+		glVertex3f(square->x3,square->y3,square->z3);
+		glTexCoord2f(0,square->ycov);
+		glVertex3f(square->x4,square->y4,square->z4);
+		glEnd();
+	  }
+	}
+  }
+
+  glDisable(GL_TEXTURE_2D);
+  glDisable(GL_DEPTH_TEST);
+
+  glPopMatrix();
+
+  if(doublebuffer) SwapBuffers();
+  else glFlush();
+
+  palette_changed=0;
+}
+
+void DrawFlatBitmap(void)
+{
+  struct TexSquare *square;
+  int x,y;
+
+  glEnable(GL_TEXTURE_2D);
+
+  for(y=0;y<texnumy;y++) {
+	for(x=0;x<texnumx;x++) {
+	  square=texgrid+y*texnumx+x;
+	  
+	  glBindTexture(GL_TEXTURE_2D,square->texobj);
+	  
+	  /* If the palette was changed, update the color table */
+	  
+	  if(palette_changed) {
+#ifdef GL_EXT_paletted_texture
+		glColorTableEXT(GL_TEXTURE_2D,
+						GL_RGBA,
+						256,
+						GL_RGBA,
+						GL_UNSIGNED_BYTE,
+						ctable);
+#else
+		  glPixelMapfv(GL_PIXEL_MAP_I_TO_R,256,rcolmap);
+		  glPixelMapfv(GL_PIXEL_MAP_I_TO_G,256,gcolmap);
+		  glPixelMapfv(GL_PIXEL_MAP_I_TO_B,256,bcolmap);
+#endif	
+						}
+
+	  glTexSubImage2D(GL_TEXTURE_2D,0,0,0,texsize,texsize,
+					  GL_COLOR_INDEX,GL_UNSIGNED_BYTE,square->texture);
+	  
+	  glBegin(GL_QUADS);
+	  glTexCoord2f(0,0); glVertex2f(square->fx1,square->fy1);
+	  glTexCoord2f(square->xcov,0);
+	  glVertex2f(square->fx2,square->fy2);
+	  glTexCoord2f(square->xcov,square->ycov);
+	  glVertex2f(square->fx3,square->fy3);
+	  glTexCoord2f(0,square->ycov);
+	  glVertex2f(square->fx4,square->fy4);
+	  glEnd();
+	}
+  }
+
+  glDisable(GL_TEXTURE_2D);
+}
+
+void UpdateFlatDisplay(void)
+{
+  if(!vecgame||!dopersist) glClear(GL_COLOR_BUFFER_BIT);
+
+  glPushMatrix();
+
+  if(dopersist&&vecgame) {
+	glColor4f(0.0,0.0,0.0,0.2);
+
+	glBegin(GL_QUADS);
+	glVertex2f(0.0,0.0);
+	glVertex2f((GLfloat)winwidth,0.0);
+	glVertex2f((GLfloat)winwidth,(GLfloat)winheight);
+	glVertex2f(0.0,(GLfloat)winheight);
+  }
+
+  if(vecgame) {
+	glShadeModel(GL_FLAT);
+
+	if(antialias) {
+	  glEnable(GL_LINE_SMOOTH);
+	  glEnable(GL_POINT_SMOOTH);
+	}
+
+	glCallList(veclist);
+
+	if(antialias) {
+	  glDisable(GL_LINE_SMOOTH);
+	  glDisable(GL_POINT_SMOOTH);
+	}
+
+	glShadeModel(GL_SMOOTH);
+  }
+
+  if(!vecgame||(drawbitmap&&screendirty)) {
+	if(vecgame) glColor4f(1.0,1.0,1.0,0.7);
+	else glColor3f(1.0,1.0,1.0);
+
+	DrawFlatBitmap();
+  }
+
+  glPopMatrix();
+  SwapBuffers();
+
+  palette_changed=0;
+}
+
+void UpdateGLDisplay(struct osd_bitmap *bitmap)
+{
+  if(bitmap && (!vecgame||drawbitmap)) UpdateTexture(bitmap);
+
+  if(vecgame&&inlist)
+	vector_vh_update(NULL,0);
+
+  if(cabview) UpdateCabDisplay();
+  else UpdateFlatDisplay();
+
+  if(vecgame&&inlist)
+	vector_clear_list();
+
+  screendirty=0;
+}
+
+/* used when expose events received */
+
+void osd_refresh_screen(void)
+{
+  /* Just re-draw the whole screen */
+  UpdateGLDisplay(NULL);
+}
+
+
+/* invoked by main tree code to update bitmap into screen */
+
+void sysdep_update_display(struct osd_bitmap *bitmap)
+{
+  int x,y;
+
+  UpdateGLDisplay(bitmap);
+
+  frame++;
+
+  if(keyboard_pressed(KEYCODE_RCONTROL)) {
+#if 0
+	if(keyboard_pressed_memory(KEYCODE_A))
+	  antialias=1-antialias;
+#endif
+	if(keyboard_pressed_memory(KEYCODE_C)&&dodepth)
+	{
+	  cabview=1-cabview;
+
+	  if(cabview)
+		SetupFrustum();
+	  else SetupOrtho();
+	}
+	if(keyboard_pressed_memory(KEYCODE_B))
+	{
+	  bilinear=1-bilinear;
+
+	  if(bilinear) {
+		glBindTexture(GL_TEXTURE_2D,cabtex[0]);
+
+		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
+		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+
+		for(y=0;y<texnumy;y++) {
+		  for(x=0;x<texnumx;x++) {
+			glBindTexture(GL_TEXTURE_2D,texgrid[y*texnumx+x].texobj);
+			
+			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
+			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+		  }
+		}
+	  }
+	  else {
+		glBindTexture(GL_TEXTURE_2D,cabtex[0]);
+
+		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
+		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);
+
+		for(y=0;y<texnumy;y++) {
+		  for(x=0;x<texnumx;x++) {
+			glBindTexture(GL_TEXTURE_2D,texgrid[y*texnumx+x].texobj);
+			
+			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
+			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);
+		  }
+		}
+	  }
+
+	}
+#if 0
+	if(keyboard_pressed_memory(KEYCODE_O))
+	  drawbitmap=1-drawbitmap;
+#endif
+	if(keyboard_pressed_memory(KEYCODE_T))
+	  dopersist=1-dopersist;
+  }
+}
+
+void osd_mark_dirty(int x1, int y1, int x2, int y2, int ui)
+{
+  screendirty=1;
+}
+
+
+#endif /* ifdef xgl */
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/gljpg.c mame-0.36b16/src/unix/video-drivers/gljpg.c
--- ../mmmmm/m36b16/src/unix/video-drivers/gljpg.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/gljpg.c	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,97 @@
+/*****************************************************************
+
+  JPEG loading code for GLmame
+
+  This code is basically taken verbatim from the libjpeg distribution,
+  which is under to GNU Public License
+
+*****************************************************************/
+
+#ifdef xgl
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <malloc.h>
+#include <string.h>
+#include "jpeglib.h"
+#include <setjmp.h>
+#include <GL/glut.h>
+
+extern char *cabname;
+
+struct my_error_mgr {
+  struct jpeg_error_mgr pub;    /* "public" fields */
+
+  jmp_buf setjmp_buffer;        /* for return to caller */
+};
+
+typedef struct my_error_mgr * my_error_ptr;
+
+METHODDEF(void)
+my_error_exit (j_common_ptr cinfo)
+{
+  my_error_ptr myerr = (my_error_ptr) cinfo->err;
+
+  (*cinfo->err->output_message) (cinfo);
+
+  longjmp(myerr->setjmp_buffer, 1);
+}
+
+GLubyte *read_JPEG_file (char * fname)
+{
+  struct jpeg_decompress_struct cinfo;
+  struct my_error_mgr jerr;
+  FILE * infile;		/* source file */
+  JSAMPARRAY buffer;		/* Output row buffer */
+  int row_stride;		/* physical row width in output buffer */
+  long cont;
+  JSAMPLE *image_buffer;
+  char filename[256];
+
+  sprintf(filename,"%s/cab/%s/%s",XMAMEROOT,cabname,fname);
+
+  if ((infile = fopen(filename, "rb")) == NULL) {
+    fprintf(stderr, "can't open %s\n", filename);
+    return NULL;
+  }
+
+  cinfo.err = jpeg_std_error(&jerr.pub);
+  jerr.pub.error_exit = my_error_exit;
+
+  if (setjmp(jerr.setjmp_buffer)) {
+    jpeg_destroy_decompress(&cinfo);
+    fclose(infile);
+    return NULL;
+  }
+
+  jpeg_create_decompress(&cinfo);
+
+  jpeg_stdio_src(&cinfo, infile);
+
+  (void) jpeg_read_header(&cinfo, TRUE);
+  (void) jpeg_start_decompress(&cinfo);
+  row_stride = cinfo.output_width * cinfo.output_components;
+
+  buffer = (*cinfo.mem->alloc_sarray)
+		((j_common_ptr) &cinfo, JPOOL_IMAGE, row_stride, 1);
+
+ image_buffer=(JSAMPLE *) malloc(cinfo.image_width*cinfo.image_height*3);
+
+  cont=(long)cinfo.output_height-1;
+  while (cinfo.output_scanline < cinfo.output_height) {
+    (void) jpeg_read_scanlines(&cinfo, buffer, 1);
+    memcpy(image_buffer+cinfo.image_width*3*cont,buffer[0],row_stride);
+    cont--;
+  }
+
+  (void) jpeg_finish_decompress(&cinfo);
+
+  jpeg_destroy_decompress(&cinfo);
+
+  fclose(infile);
+
+  return image_buffer;
+}
+
+
+#endif /* ifdef xgl */
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/glmame.h mame-0.36b16/src/unix/video-drivers/glmame.h
--- ../mmmmm/m36b16/src/unix/video-drivers/glmame.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/glmame.h	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,25 @@
+/*****************************************************************
+
+  GLmame include file
+
+  Copyright 1998 by Mike Oliphant - oliphant@ling.ed.ac.uk
+
+    http://www.ling.ed.ac.uk/~oliphant/glmame
+
+  This code may be used and distributed under the terms of the
+  Mame license
+
+*****************************************************************/
+
+
+/* Camera panning stuff */
+
+typedef enum {pan_goto,pan_moveto,pan_repeat,pan_end,pan_nocab} PanType;
+
+struct CameraPan {
+  PanType type;      /* Type of pan */
+  GLfloat lx,ly,lz;  /* Location of camera */
+  GLfloat px,py,pz;  /* Vector to point camera along */
+  GLfloat nx,ny,nz;  /* Normal to camera direction */
+  int frames;        /* Number of frames for transition */
+};
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/glvec.c mame-0.36b16/src/unix/video-drivers/glvec.c
--- ../mmmmm/m36b16/src/unix/video-drivers/glvec.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/glvec.c	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,217 @@
+/*****************************************************************
+
+  OpenGL vector routines
+
+  Copyright 1998 by Mike Oliphant - oliphant@ling.ed.ac.uk
+
+    http://www.ling.ed.ac.uk/~oliphant/glmame
+
+  This code may be used and distributed under the terms of the
+  Mame license
+
+*****************************************************************/
+
+#ifdef xgl
+
+#include <GL/gl.h>
+#include "xmame.h"
+#include "driver.h"
+#include "artwork.h"
+
+#ifdef UTAH_GLX
+#define NVIDIA
+#endif
+
+#ifdef NVIDIA
+#undef GL_EXT_paletted_texture
+#endif
+
+extern GLubyte *ctable;
+extern GLfloat *rcolmap,*gcolmap,*bcolmap;
+
+extern GLfloat cscrx1,cscry1,cscrz1,cscrx2,cscry2,cscrz2,
+  cscrx3,cscry3,cscrz3,cscrx4,cscry4,cscrz4;
+extern GLfloat cscrwdx,cscrwdy,cscrwdz;
+extern GLfloat cscrhdx,cscrhdy,cscrhdz;
+
+extern int cabview;
+
+extern int winwidth,winheight;
+
+unsigned char *vectorram;
+int vectorram_size;
+
+int antialias;                            /* flag for anti-aliasing */
+int beam;                                 /* size of vector beam    */
+int flicker;                              /* beam flicker value     */
+int translucency;
+
+GLuint veclist;
+
+int inlist=0;
+int incommand=0;
+static int listalloced=0;
+
+static int vecshift;
+static GLfloat vecwidth,vecheight;
+static GLfloat vecoldx,vecoldy;
+
+
+/*
+ * Initializes vector game video emulation
+ */
+
+int vector_vh_start (void)
+{
+  vecwidth=(GLfloat)(Machine->drv->default_visible_area.max_x-
+	Machine->drv->default_visible_area.min_x);
+  vecheight=(GLfloat)(Machine->drv->default_visible_area.max_y-
+	Machine->drv->default_visible_area.min_y);
+  veclist=glGenLists(1);
+
+  return 0;
+}
+
+/*
+ * Stop the vector video hardware emulation. Free memory.
+ */
+
+void vector_vh_stop (void)
+{
+}
+
+/*
+ * Setup scaling. Currently the Sega games are stuck at VECSHIFT 15
+ * and the the AVG games at VECSHIFT 16
+ */
+
+void vector_set_shift (int shift)
+{
+  vecshift=shift;
+}
+
+/* Convert an xy point to xyz in the 3D scene */
+
+void PointConvert(int x,int y,GLfloat *sx,GLfloat *sy,GLfloat *sz)
+{
+  GLfloat dx,dy,tmp;
+
+  dx=(GLfloat)(x>>vecshift)/vecwidth;
+  dy=(GLfloat)(y>>vecshift)/vecheight;
+
+  if(Machine->orientation&ORIENTATION_SWAP_XY) {
+    tmp=dx;
+    dx=dy;
+    dy=tmp;
+  }
+
+  if(Machine->orientation&ORIENTATION_FLIP_X)
+    dx=1.0-dx;
+
+  if(Machine->orientation&ORIENTATION_FLIP_Y)
+    dy=1.0-dy;
+
+  if(cabview) {
+	*sx=cscrx1+dx*cscrwdx+dy*cscrhdx;
+	*sy=cscry1+dx*cscrwdy+dy*cscrhdy;
+	*sz=cscrz1+dx*cscrwdz+dy*cscrhdz;
+  }
+  else {
+	*sx=dx*(GLfloat)winwidth;
+	*sy=(GLfloat)winheight-dy*(GLfloat)winheight;
+  }
+}
+
+/*
+ * Adds a line end point to the vertices list. The vector processor emulation
+ * needs to call this.
+ */
+
+void vector_add_point (int x, int y, int color, int intensity)
+{
+  GLfloat sx,sy,sz;
+  int col;
+
+  if(intensity==0) {
+	glEnd();
+	glBegin(GL_LINE_STRIP);
+  }
+
+  col=Machine->pens[color];
+
+#ifdef GL_EXT_paletted_texture
+  glColor4f((GLfloat)ctable[col*4]/255.0,
+			(GLfloat)ctable[col*4+1]/255.0,
+			(GLfloat)ctable[col*4+2]/255.0,
+			(GLfloat)intensity/(translucency?450.0:149.0));
+#else
+  glColor4f(rcolmap[col],
+		    gcolmap[col],
+			bcolmap[col],
+			(GLfloat)intensity/(translucency?450.0:149.0));
+#endif
+
+  PointConvert(x,y,&sx,&sy,&sz);
+
+  /* Hack to draw points -- zero-length lines don't show up */
+
+  if(sx==vecoldx&&sy==vecoldy) {
+	glEnd();
+	glBegin(GL_POINTS);
+
+	if(cabview)
+	  glVertex3d(sx,sy,sz);
+	else glVertex2d(sx,sy);
+
+	glEnd();
+	glBegin(GL_LINE_STRIP);
+  }
+  else {
+	if(cabview)
+	  glVertex3d(sx,sy,sz);
+	else
+	  glVertex2d(sx,sy);
+  }
+	vecoldx=sx; vecoldy=sy;
+}
+
+/*
+ * Add new clipping info to the list
+ */
+
+void vector_add_clip (int x1, int yy1, int x2, int y2)
+{
+}
+
+/*
+ * The vector CPU creates a new display list.
+ */
+
+void vector_clear_list(void)
+{
+  glNewList(veclist,GL_COMPILE);
+  glColor4f(1.0,1.0,1.0,1.0);
+
+  glBegin(GL_LINE_STRIP);
+
+  inlist=1;
+  listalloced=1;
+  incommand=1;
+}
+
+/* Called when the frame is complete */
+
+void vector_vh_update(struct osd_bitmap *bitmap,int full_refresh)
+{
+  if(incommand) {
+	glEnd();
+	incommand=0;
+  }
+
+  if(inlist) {
+	glEndList();
+	inlist=0;
+  }
+}
+
+#endif /* ifdef xgl */
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/openstep_input.m mame-0.36b16/src/unix/video-drivers/openstep_input.m
--- ../mmmmm/m36b16/src/unix/video-drivers/openstep_input.m	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/openstep_input.m	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,424 @@
+/*
+ * OpenStep input functions - placed here to separate them out from the
+ * display functions. This code handles keyboard and mouse input using the
+ * OpenStep event queue mechanism. Unknown events are passed onward to allow
+ * minaturisation of the window.
+ *
+ * -bat. 14/3/2000
+ */
+
+#import <AppKit/AppKit.h>
+#import <libc.h>
+#import "xmame.h"
+#import "osdepend.h"
+#import "driver.h"
+#import "keyboard.h"
+#import "devices.h"
+
+/*
+ * Keyboard variables
+ */
+
+typedef struct {
+	unsigned char scancode;
+	unsigned short unicode;
+} key_pair;
+static key_pair ibm_keymap[256];	/* map ascii to ibm keycodes */
+static NSDate *the_past = nil;
+
+/*
+ * External window variable
+ */
+
+extern NSWindow *theWindow;
+
+/*
+ * Keyboard init - all I really do here is set up the keymapping array
+ * between ASCII values and MAME keycodes. Yes, it was all done by
+ * hand, though there aren't actually that many of them. We also initialise
+ * the "distant past" variable here as it belongs to the keyboard code.
+ * This array was slightly over complexified by the introduction of unicode
+ * support, but I *think* I have got it right !
+ */
+
+void
+openstep_keyboard_init(void)
+{
+	int i;
+
+	/* create the past */
+	the_past = [NSDate distantPast];
+	[the_past retain];
+
+	/* zero certain arrays */
+	for(i=0;i<256;i++)
+		ibm_keymap[i]=(key_pair){0,0};
+
+	/* and now we set up this big tedious array	*/
+	ibm_keymap['0']=(key_pair){KEY_0,KEYCODE_0};
+	ibm_keymap['1']=(key_pair){KEY_1,KEYCODE_1};
+	ibm_keymap['2']=(key_pair){KEY_2,KEYCODE_2};
+	ibm_keymap['3']=(key_pair){KEY_3,KEYCODE_3};
+	ibm_keymap['4']=(key_pair){KEY_4,KEYCODE_4};
+	ibm_keymap['5']=(key_pair){KEY_5,KEYCODE_5};
+	ibm_keymap['6']=(key_pair){KEY_6,KEYCODE_6};
+	ibm_keymap['7']=(key_pair){KEY_7,KEYCODE_7};
+	ibm_keymap['8']=(key_pair){KEY_8,KEYCODE_8};
+	ibm_keymap['9']=(key_pair){KEY_9,KEYCODE_9};
+
+	ibm_keymap['-']=(key_pair){KEY_MINUS,KEYCODE_MINUS};
+	ibm_keymap['_']=(key_pair){KEY_MINUS,KEYCODE_MINUS};
+	ibm_keymap['+']=(key_pair){KEY_EQUALS,KEYCODE_EQUALS};
+	ibm_keymap['=']=(key_pair){KEY_EQUALS,KEYCODE_EQUALS};
+	ibm_keymap['\t']=(key_pair){KEY_TAB,KEYCODE_TAB};
+
+	ibm_keymap['=']=(key_pair){KEY_EQUALS,KEYCODE_EQUALS};
+	ibm_keymap['\t']=(key_pair){KEY_TAB,KEYCODE_TAB};
+	ibm_keymap['\r']=(key_pair){KEY_ENTER,KEYCODE_ENTER};
+	ibm_keymap['\n']=(key_pair){KEY_ENTER,KEYCODE_ENTER};
+
+	ibm_keymap['q']=(key_pair){KEY_Q,KEYCODE_Q};
+	ibm_keymap['w']=(key_pair){KEY_W,KEYCODE_W};
+	ibm_keymap['e']=(key_pair){KEY_E,KEYCODE_E};
+	ibm_keymap['r']=(key_pair){KEY_R,KEYCODE_R};
+	ibm_keymap['t']=(key_pair){KEY_T,KEYCODE_T};
+	ibm_keymap['y']=(key_pair){KEY_Y,KEYCODE_Y};
+	ibm_keymap['u']=(key_pair){KEY_U,KEYCODE_U};
+	ibm_keymap['i']=(key_pair){KEY_I,KEYCODE_I};
+	ibm_keymap['o']=(key_pair){KEY_O,KEYCODE_O};
+	ibm_keymap['p']=(key_pair){KEY_P,KEYCODE_P};
+	ibm_keymap['[']=(key_pair){KEY_OPENBRACE,KEYCODE_OPENBRACE};
+	ibm_keymap[']']=(key_pair){KEY_CLOSEBRACE,KEYCODE_CLOSEBRACE};
+
+	ibm_keymap['a']=(key_pair){KEY_A,KEYCODE_A};
+	ibm_keymap['s']=(key_pair){KEY_S,KEYCODE_S};
+	ibm_keymap['d']=(key_pair){KEY_D,KEYCODE_D};
+	ibm_keymap['f']=(key_pair){KEY_F,KEYCODE_F};
+	ibm_keymap['g']=(key_pair){KEY_G,KEYCODE_G};
+	ibm_keymap['h']=(key_pair){KEY_H,KEYCODE_H};
+	ibm_keymap['j']=(key_pair){KEY_J,KEYCODE_J};
+	ibm_keymap['k']=(key_pair){KEY_K,KEYCODE_K};
+	ibm_keymap['l']=(key_pair){KEY_L,KEYCODE_L};
+	ibm_keymap[';']=(key_pair){KEY_COLON,KEYCODE_COLON};
+	ibm_keymap[':']=(key_pair){KEY_COLON,KEYCODE_COLON};
+	ibm_keymap['\'']=(key_pair){KEY_QUOTE,KEYCODE_QUOTE};
+	ibm_keymap['@']=(key_pair){KEY_QUOTE,KEYCODE_QUOTE};
+	ibm_keymap['~']=(key_pair){KEY_TILDE,KEYCODE_TILDE};
+	ibm_keymap['#']=(key_pair){KEY_TILDE,KEYCODE_TILDE};
+
+	ibm_keymap['z']=(key_pair){KEY_Z,KEYCODE_Z};
+	ibm_keymap['x']=(key_pair){KEY_X,KEYCODE_X};
+	ibm_keymap['c']=(key_pair){KEY_C,KEYCODE_C};
+	ibm_keymap['v']=(key_pair){KEY_V,KEYCODE_V};
+	ibm_keymap['b']=(key_pair){KEY_B,KEYCODE_B};
+	ibm_keymap['n']=(key_pair){KEY_N,KEYCODE_N};
+	ibm_keymap['m']=(key_pair){KEY_M,KEYCODE_M};
+	ibm_keymap[',']=(key_pair){KEY_COMMA,KEYCODE_COMMA};
+	ibm_keymap['<']=(key_pair){KEY_COMMA,KEYCODE_COMMA};
+	ibm_keymap['.']=(key_pair){KEY_STOP,KEYCODE_STOP};
+	ibm_keymap['>']=(key_pair){KEY_STOP,KEYCODE_STOP};
+	ibm_keymap['/']=(key_pair){KEY_SLASH,KEYCODE_SLASH};
+	ibm_keymap['?']=(key_pair){KEY_SLASH,KEYCODE_SLASH};
+
+	ibm_keymap['*']=(key_pair){KEY_ASTERISK,KEYCODE_ASTERISK};
+	ibm_keymap[' ']=(key_pair){KEY_SPACE,KEYCODE_SPACE};
+
+	ibm_keymap[8]=(key_pair){KEY_BACKSPACE,KEYCODE_BACKSPACE};
+	ibm_keymap[27]=(key_pair){KEY_ESC,KEYCODE_ESC};
+	ibm_keymap[96]=(key_pair){KEY_NUMLOCK,KEYCODE_NUMLOCK};
+	ibm_keymap[127]=(key_pair){KEY_DEL,KEYCODE_DEL};
+}
+
+
+/*
+ * Nothing needs doing to close the keybaord, but we release the variable
+ * used to hold the distant past here as it is a keyboard variable.
+ */
+
+void
+sysdep_keyboard_close(void)
+{
+	[the_past release];
+	the_past = nil;
+}
+
+/*
+ * Get the mouse location and use this to set the deltas relative to
+ * the last time. We only use this to get the position of the mouse, it's
+ * buttons come in as events in the normal way.
+ */
+
+void
+sysdep_mouse_poll(void)
+{
+	static NSPoint last = {0.0, 0.0};
+	NSPoint current;
+
+	if(!use_mouse)		/* to save time */
+		return;
+
+	current = [theWindow mouseLocationOutsideOfEventStream];
+
+	mouse_data[0].deltas[0] = current.x - last.x;
+	mouse_data[0].deltas[1] = last.y - current.y; /* inverted */
+
+	last = current;
+}
+
+/*
+ * Here we are passed an NSEvent from the keyboard and expected to queue
+ * the MAME key event associated with it. For ASCII characters there
+ * is a simple lookup table, for Unicode characters we use a switch statement
+ * with the constants defined in NSEvent.h. This function also deals with
+ * using the command key to emulate the function keys.
+ */
+
+static inline void
+queue_key_event(NSEvent *keyevent)
+{
+	struct keyboard_event event;
+	unichar buf[2];	/* just in case theres more than 1 */
+	NSString *string = [keyevent charactersIgnoringModifiers];
+	[string getCharacters:buf range:NSMakeRange(0,1)];
+
+	/* check to see if string is ASCII */
+	if([string canBeConvertedToEncoding:NSASCIIStringEncoding]) {
+		event.scancode = ibm_keymap[buf[0]].scancode;
+		event.unicode = ibm_keymap[buf[0]].unicode;
+	} else {
+		 switch(buf[0]) {
+			 case NSUpArrowFunctionKey:
+				event.scancode = KEY_UP;
+				event.unicode = KEYCODE_UP;
+				break;
+			 case NSDownArrowFunctionKey:
+				event.scancode = KEY_DOWN;
+				event.unicode = KEYCODE_DOWN;
+				break;
+			 case NSLeftArrowFunctionKey:
+				event.scancode = KEY_LEFT;
+				event.unicode = KEYCODE_LEFT;
+				break;
+			 case NSRightArrowFunctionKey:
+				event.scancode = KEY_RIGHT;
+				event.unicode = KEYCODE_RIGHT;
+				break;
+			 case NSF1FunctionKey:
+				event.scancode = KEY_F1;
+				event.unicode = KEYCODE_F1;
+				break;
+			 case NSF2FunctionKey:
+				event.scancode = KEY_F2;
+				event.unicode = KEYCODE_F2;
+				break;
+			 case NSF3FunctionKey:
+				event.scancode = KEY_F3;
+				event.unicode = KEYCODE_F3;
+				break;
+			 case NSF4FunctionKey:
+				event.scancode = KEY_F4;
+				event.unicode = KEYCODE_F4;
+				break;
+			 case NSF5FunctionKey:
+				event.scancode = KEY_F5;
+				event.unicode = KEYCODE_F5;
+				break;
+			 case NSF6FunctionKey:
+				event.scancode = KEY_F6;
+				event.unicode = KEYCODE_F6;
+				break;
+			 case NSF7FunctionKey:
+				event.scancode = KEY_F7;
+				event.unicode = KEYCODE_F7;
+				break;
+			 case NSF8FunctionKey:
+				event.scancode = KEY_F8;
+				event.unicode = KEYCODE_F8;
+				break;
+			 case NSF9FunctionKey:
+				event.scancode = KEY_F9;
+				event.unicode = KEYCODE_F9;
+				break;
+			 case NSF10FunctionKey:
+				event.scancode = KEY_F10;
+				event.unicode = KEYCODE_F10;
+				break;
+			 case NSF11FunctionKey:
+				event.scancode = KEY_F11;
+				event.unicode = KEYCODE_F11;
+				break;
+			 case NSF12FunctionKey:
+				event.scancode = KEY_F12;
+				event.unicode = KEYCODE_F12;
+				break;
+			 case NSInsertFunctionKey:
+				event.scancode = KEY_INSERT;
+				event.unicode = KEYCODE_INSERT;
+				break;
+			 case NSDeleteFunctionKey:
+				event.scancode = KEY_DEL;
+				event.unicode = KEYCODE_DEL;
+				break;
+			 case NSHomeFunctionKey:
+				event.scancode = KEY_HOME;
+				event.unicode = KEYCODE_HOME;
+				break;
+			 case NSEndFunctionKey:
+				event.scancode = KEY_END;
+				event.unicode = KEYCODE_END;
+				break;
+			 case NSPageUpFunctionKey:
+				event.scancode = KEY_PGUP;
+				event.unicode = KEYCODE_PGUP;
+				break;
+			 case NSPageDownFunctionKey:
+				event.scancode = KEY_PGDN;
+				event.unicode = KEYCODE_PGDN;
+				break;
+			 case NSPrintScreenFunctionKey:
+				event.scancode = KEY_PRTSCR;
+				event.unicode = KEYCODE_PRTSCR;
+				break;
+			 case NSScrollLockFunctionKey:
+				event.scancode = KEY_SCRLOCK;
+				event.unicode = KEYCODE_SCRLOCK;
+				break;
+			 case NSPauseFunctionKey:
+				event.scancode = KEY_PAUSE;
+				event.unicode = KEYCODE_PAUSE;
+				break;
+			 default:
+				return;
+		 }
+	}
+
+	/* deal with command key */
+	if([keyevent modifierFlags] & NSCommandKeyMask)
+		switch(event.scancode) {
+			case KEY_1:
+				event.scancode = KEY_F1;
+				event.unicode = KEYCODE_F1;
+				break;
+			case KEY_2:
+				event.scancode = KEY_F2;
+				event.unicode = KEYCODE_F2;
+				break;
+			case KEY_3:
+				event.scancode = KEY_F3;
+				event.unicode = KEYCODE_F3;
+				break;
+			case KEY_4:
+				event.scancode = KEY_F4;
+				event.unicode = KEYCODE_F4;
+				break;
+			case KEY_5:
+				event.scancode = KEY_F5;
+				event.unicode = KEYCODE_F5;
+				break;
+			case KEY_6:
+				event.scancode = KEY_F6;
+				event.unicode = KEYCODE_F6;
+				break;
+			case KEY_7:
+				event.scancode = KEY_F7;
+				event.unicode = KEYCODE_F7;
+				break;
+			case KEY_8:
+				event.scancode = KEY_F8;
+				event.unicode = KEYCODE_F8;
+				break;
+			case KEY_9:
+				event.scancode = KEY_F9;
+				event.unicode = KEYCODE_F9;
+				break;
+			case KEY_0:
+				event.scancode = KEY_F10;
+				event.unicode = KEYCODE_F10;
+				break;
+			case KEY_MINUS:
+				event.scancode = KEY_F11;
+				event.unicode = KEYCODE_F11;
+				break;
+			case KEY_EQUALS:
+				event.scancode = KEY_F12;
+				event.unicode = KEYCODE_F12;
+				break;
+		}
+
+	/* now queue it */
+	switch([keyevent type]) {
+		case NSKeyUp:
+			event.press = FALSE;
+			keyboard_register_event(&event);
+			break;
+		case NSKeyDown:
+			event.press = TRUE;
+			keyboard_register_event(&event);
+			break;
+		default:
+			break;
+	}
+}
+
+/*
+ * This loop collect all events from the queue and deals with them by
+ * queueing key up and down events to the xmame fifo. Anything we dont
+ * use gets passed on to whoever might want it. We handle the mouse
+ * button events in this loop too, passing them downwards to allow other
+ * things such as minaturisation to happen. This loop is surrounded by an
+ * autorelease pool as we do create some objects here.
+ */
+
+void
+sysdep_update_keyboard(void)
+{
+	NSAutoreleasePool *pool = [NSAutoreleasePool new];
+	NSEvent *event=nil;
+
+	for(;;) {
+		/* get the next event */
+		event= [NSApp nextEventMatchingMask:NSAnyEventMask
+				untilDate:the_past inMode:NSDefaultRunLoopMode
+				dequeue:YES];
+		/* break out of the loop if there are no more events */
+		if(event==nil)
+			break;
+
+		/* deal with the event */
+		switch([event type]) {
+			case NSKeyUp:
+			case NSKeyDown:
+				queue_key_event(event);
+				break;
+			case NSLeftMouseDown:
+				mouse_data[0].buttons[0] = 1;
+				[NSApp sendEvent:event];
+				break;
+			case NSLeftMouseUp:
+				mouse_data[0].buttons[0] = 0;
+				[NSApp sendEvent:event]; 
+				break;
+			case NSRightMouseDown:
+				mouse_data[0].buttons[1] = 1;
+				[NSApp sendEvent:event];
+				break;
+			case NSRightMouseUp:
+				mouse_data[0].buttons[1] = 0;
+				[NSApp sendEvent:event];
+				break;
+			default:
+				[NSApp sendEvent:event];
+				break;
+		}
+	}
+
+	[pool release];
+}
+
+/*
+ * We do not have access to the keyboard LED's
+ */
+
+void sysdep_set_leds(int leds)
+{
+}
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/openstep.m mame-0.36b16/src/unix/video-drivers/openstep.m
--- ../mmmmm/m36b16/src/unix/video-drivers/openstep.m	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/openstep.m	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,305 @@
+/*
+ * OpenStep specific file for XMAME. Here we define OpenStep specific
+ * versions of all the MAME functions necessary to get it running under
+ * OpenStep. 
+ *
+ * -bat. 11/1/1999
+ */
+
+#import <AppKit/AppKit.h>
+#import <libc.h>
+#import "xmame.h"
+#import "osdepend.h"
+#import "driver.h"
+#import "keyboard.h"
+#import "devices.h"
+
+/* display options */
+
+struct rc_option display_opts[] = {
+	{
+	"OpenStep related", NULL, rc_seperator, NULL, NULL, 0, 0, NULL, NULL
+	}, {
+	NULL, NULL, rc_end, NULL, NULL, 0, 0, NULL, NULL
+	}
+};
+
+/*
+ * Some defines to control various code parameters.
+ */
+
+#define BORDER 12
+#define INSET 4
+#define FLUSH 30
+
+/*
+ * Variables used by command-line DPS window.
+ */
+
+NSWindow *theWindow = nil;		/* needed by keyboard code */
+static NSBitmapImageRep *thisBitmap = nil;
+static int bitmap_width, bitmap_height;
+
+/*
+ * Screen bitmap variable
+ */
+
+static unsigned short *screen12bit = NULL;
+
+/*
+ * Autorelease pool variables. We have an outer pool which is never freed
+ * due to lessons learnt from EOF about always having at least *one* pool
+ * active ! We also have a pool that exists across display open and closes
+ * to make sure that everthing we make in a display open vanishes properly.
+ */
+
+static NSAutoreleasePool *outer_pool = nil;
+static NSAutoreleasePool *display_pool = nil;
+
+/*
+ * Intialise the two pools. Create the application object.
+ */
+
+int
+sysdep_init(void)
+{
+	outer_pool = [NSAutoreleasePool new];
+	NSApp = [[NSApplication sharedApplication] retain];
+	return OSD_OK;
+}
+
+/*
+ * Free up the autorelease pools before exitting.
+ */
+
+void
+sysdep_close(void)
+{
+	[NSApp release];
+	[outer_pool release];
+}
+
+/*
+ * Shut down the display. We close the dps window and exit.
+ */
+
+void
+sysdep_display_close(void)
+{
+	[theWindow close];
+	theWindow = nil;
+	[display_pool release];
+}
+
+extern void openstep_keyboard_init(void);
+
+/*
+ * Create the display. We create a window of the appropriate size, then
+ * make it display on the screen. Keyboard initialisation is also called
+ * from this function.
+ */
+
+int
+sysdep_create_display(int depth)
+{
+	NSRect content_rect = { {100,100}, {0,0} };
+
+	/* make the display pool */
+	display_pool = [NSAutoreleasePool new];
+
+	bitmap_width = visual_width * widthscale;
+	bitmap_height = visual_height * heightscale;
+
+	/* set the size of the view */
+	content_rect.size.width = bitmap_width + (BORDER*2) - 1;
+	content_rect.size.height = bitmap_height + (BORDER*2) - 1;
+
+	/* allocate memory for 12 bit colour version */
+	screen12bit = [[NSMutableData dataWithLength:
+			(2*bitmap_width*bitmap_height)] mutableBytes];
+	if(!screen12bit) {
+		fprintf(stderr,"12 bit memory allocate failed\n");
+		[display_pool release];
+		display_pool = nil;
+		return OSD_NOT_OK;
+	}
+
+	/* create bitmap object  */
+	thisBitmap = [[NSBitmapImageRep alloc]
+		initWithBitmapDataPlanes:(void*)&screen12bit
+		pixelsWide:bitmap_width pixelsHigh:bitmap_height
+		bitsPerSample:4 samplesPerPixel:3
+		hasAlpha:NO isPlanar:NO
+		colorSpaceName:NSDeviceRGBColorSpace
+		bytesPerRow:2*bitmap_width bitsPerPixel:16];
+	if(!thisBitmap) {
+		fprintf(stderr,"Bitmap creation failed\n");
+		[display_pool release];
+		display_pool = nil;
+		return OSD_NOT_OK;
+	}
+	[thisBitmap autorelease];
+
+	/* create a window */
+	theWindow = [[NSWindow alloc] initWithContentRect:content_rect
+		styleMask:(NSTitledWindowMask | NSMiniaturizableWindowMask)
+		backing:NSBackingStoreRetained defer:NO];
+	[theWindow setTitle:[NSString
+		stringWithCString:Machine->gamedrv->description]];
+	[theWindow setReleasedWhenClosed:YES];
+
+	puts(Machine->gamedrv->description);
+
+	/* make it key and bring it to the front */
+	[theWindow makeKeyAndOrderFront:nil];
+
+	/* initialise it */
+	[[theWindow contentView] lockFocus];
+/*
+	DPSPrintf(DPSGetCurrentContext(),"initgraphics 0 setgray\n");
+	DPSFlushContext(DPSGetCurrentContext());
+*/
+	PSinitgraphics();
+	PSsetgray(0);
+	PSrectfill(INSET, INSET,
+			content_rect.size.width + 1 - (INSET*2),
+			content_rect.size.height + 1 - (INSET*2));
+	PSWait();
+	[[theWindow contentView] unlockFocus];
+
+	/* set up the structure for the palette code */
+	display_palette_info.writable_colors = 0;
+	display_palette_info.depth = 16;
+
+#ifdef LSB_FIRST
+	display_palette_info.red_mask = 0x00f0;
+	display_palette_info.green_mask = 0x000f;
+	display_palette_info.blue_mask = 0xf000;
+#else
+	/* untested due to lack of big-endian machines at present */
+	display_palette_info.red_mask = 0xf000;
+	display_palette_info.green_mask = 0x0f00;
+	display_palette_info.blue_mask = 0x00f0;
+#endif
+
+	/* shifts will be calculated from above settings */
+	display_palette_info.red_shift = 0;
+	display_palette_info.green_shift = 0;
+	display_palette_info.blue_shift = 0;
+
+	/* initialise the keyboard and return */
+	openstep_keyboard_init();
+	return OSD_OK;
+}
+
+/*
+ * 8 bit display update. We use dirty unless the palette has been
+ * changed, in which case the whole screen is updated.
+ */
+
+static void
+update_display_8bpp(struct osd_bitmap *bitmap)
+{
+#define	SRC_PIXEL	unsigned char
+#define	DEST_PIXEL	unsigned short
+#define	DEST		screen12bit
+#define	DEST_WIDTH	bitmap_width
+#define	INDIRECT	current_palette->lookup
+#include "blit.h"
+#undef	SRC_PIXEL
+#undef	DEST_PIXEL
+#undef	DEST
+#undef	DEST_WIDTH
+#undef	INDIRECT
+}
+
+/*
+ * 16 bit display update
+ */
+
+static void
+update_display_16bpp(struct osd_bitmap *bitmap)
+{
+#define	SRC_PIXEL	unsigned short
+#define	DEST_PIXEL	unsigned short
+#define	DEST		screen12bit
+#define	DEST_WIDTH	bitmap_width
+	if(current_palette->lookup) {
+#define	INDIRECT	current_palette->lookup
+#include "blit.h"
+#undef	INDIRECT
+	} else {
+#include "blit.h"
+	}
+
+#undef	SRC_PIXEL
+#undef	DEST_PIXEL
+#undef	DEST
+#undef	DEST_WIDTH
+}
+
+/*
+ * Update the display.  We create the bitmapped data for the current frame
+ * and draw it into the window.
+ */
+
+void
+sysdep_update_display(struct osd_bitmap *bitmap)
+{
+	int old_use_dirty;
+
+	/* call appropriate function with dirty*/
+	old_use_dirty = use_dirty;
+	if(current_palette->lookup_dirty)
+		use_dirty = 0;
+	if(bitmap->depth == 16)
+		update_display_16bpp(bitmap);
+	else
+		update_display_8bpp(bitmap);
+	use_dirty = old_use_dirty;
+
+	/* lock focus and draw it */
+	[[theWindow contentView] lockFocus];
+	[thisBitmap drawInRect:(NSRect){ {BORDER, BORDER},
+			{bitmap_width, bitmap_height}}];
+	PSWait();
+	[[theWindow contentView] unlockFocus];
+}
+
+/*
+ * OpenStep system are always 16bpp capable.
+ */
+
+int
+sysdep_display_16bpp_capable(void)
+{
+	return 1;
+}
+
+/*
+ * The following functions are dummies - they should never be called as
+ * we never use 8 bit palletised output graphics under OpenStep. But they
+ * must be present in order to link properly.
+ */
+
+int
+sysdep_display_alloc_palette(int writable_colours)
+{
+	if(writable_colours) {
+		fprintf(stderr,
+			"Error: pallete allocation requested with %d colours\n",
+			writable_colours);
+		return -1;
+	}
+
+	return 0;
+}
+
+int
+sysdep_display_set_pen(int pen,
+		unsigned char r, unsigned char g, unsigned char b)
+{
+	fprintf(stderr, "Error: request made to set pen %d to %d/%d/%d\n",
+			pen, r, g, b);
+	return -1;
+}
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/SDL.c mame-0.36b16/src/unix/video-drivers/SDL.c
--- ../mmmmm/m36b16/src/unix/video-drivers/SDL.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/SDL.c	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,565 @@
+/***************************************************************************
+                                          
+ SDL XMAME display driver, based on
+ Linux SVGALib adaptation by Phillip Ezolt.
+
+ updated and patched by Ricardo Calixto Quesada (riq@ciudad.com.ar)
+
+ TODO: Test the HERMES code.
+       Make other update routines. The only one is 8bpp -> 16bpp 
+       Improve performace.
+   
+***************************************************************************/
+#define __SDL_C
+
+/* #define SDL_DEBUG */
+/* #define DIRECT_HERMES */
+
+#include <signal.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <SDL/SDL.h>
+#include "xmame.h"
+#include "devices.h"
+#include "keyboard.h"
+#include "SDL-keytable.h"
+#ifdef DIRECT_HERMES 
+#include <Hermes/Hermes.h>
+#endif /* DIRECT_HERMES */
+
+static int Vid_width;
+static int Vid_height;
+static int Vid_depth = 8;
+static SDL_Surface* Surface;
+static SDL_Surface* Offscreen_surface;
+static int hardware=1;
+static int mode_number=-1;
+static int list_modes=0;
+SDL_Color *Colors;
+
+#ifdef DIRECT_HERMES
+HermesHandle   H_PaletteHandle;
+HermesHandle H_ConverterHandle;
+int32_t* H_Palette;
+static int H_Palette_modified = 0;
+#endif
+
+typedef void (*update_func_t)(struct osd_bitmap *bitmap);
+
+update_func_t update_function;
+
+struct rc_option display_opts[] = {
+    /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "SDL Related",  NULL,    rc_seperator,  NULL,
+       NULL,         0,       0,             NULL,
+       NULL },
+   { "listmodes",    NULL,    rc_bool,    &list_modes,
+      "0",           0,       0,             NULL,
+      "List all posible full-screen modes" },
+   { "modenumber",    NULL,   rc_int,        &mode_number,
+      "-1",            0,      0,            NULL,
+      "Try to use the 'n' possible full-screen mode" },
+   { NULL,           NULL,    rc_end,        NULL,
+      NULL,          0,       0,             NULL,
+      NULL }
+};
+
+void list_sdl_modes(void);
+void sdl_update_8bpp_16bpp(struct osd_bitmap *bitmap);
+
+int sysdep_init(void)
+{
+   if (SDL_Init(SDL_INIT_VIDEO) < 0) {
+      fprintf (stderr, "SDL: Error: %s\n",SDL_GetError());
+      return OSD_NOT_OK;
+   } 
+#ifdef DIRECT_HERMES
+   Hermes_Init(0);
+#endif /* DIRECT_HERMES */
+   fprintf (stderr, "SDL: Info: SDL initialized\n");
+   atexit (SDL_Quit);
+   return OSD_OK;
+}
+
+void sysdep_close(void)
+{
+   SDL_Quit();
+}
+
+int sysdep_create_display(int depth)
+{
+   SDL_Rect** vid_modes;
+   const SDL_VideoInfo* video_info;
+   int vid_modes_i;
+#ifdef DIRECT_HERMES 
+   HermesFormat* H_src_format;
+   HermesFormat* H_dst_format;
+#endif /* DIRECT_HERMES */
+
+   if(list_modes){
+      list_sdl_modes();
+      exit (OSD_OK);
+   }
+
+   video_info = SDL_GetVideoInfo();
+
+#ifdef SDL_DEBUG
+   fprintf (stderr,"SDL: Info: Best matching mode: \n");
+   fprintf (stderr,"SDL: Info: HW blits %d\n"
+      "SDL: Info: SW blits %d\n"
+      "SDL: Info: Vid mem %d\n"
+      "SDL: Info: Best supported depth %d\n",
+      video_info->blit_hw,
+      video_info->blit_sw,
+      video_info->video_mem,
+      video_info->vfmt->BitsPerPixel);
+#endif
+
+   Vid_depth = video_info->vfmt->BitsPerPixel;
+
+   vid_modes = SDL_ListModes(NULL,SDL_HWSURFACE);
+   vid_modes_i = 0;
+
+
+   if ( (! vid_modes) || ((long)vid_modes == -1)) {
+#ifdef SDL_DEBUG
+      fprintf (stderr, "SDL: Info: Possible all video modes available\n");
+#endif
+      hardware=0;
+      Vid_height = visual_height*heightscale;
+      Vid_width = visual_width*widthscale;
+      update_function = &sdl_update_8bpp_16bpp;
+   } else {
+#ifdef SDL_DEBUG
+      fprintf (stderr, "SDL: visual w:%d visual h:%d\n", visual_width, visual_height);
+#endif
+      hardware=1;
+      update_function = &sdl_update_8bpp_16bpp;
+
+      while( *(vid_modes+vid_modes_i) ) {
+#ifdef SDL_DEBUG
+         fprintf (stderr, "SDL: Info: Found mode %d x %d\n",
+            (*(vid_modes+vid_modes_i))->w,
+            (*(vid_modes+vid_modes_i))->h);
+#endif /* SDL_DEBUG */
+   
+         /* busco el que mejor se ajusta */
+         if( ((*(vid_modes + vid_modes_i))->w < visual_width*widthscale) || ((*(vid_modes + vid_modes_i))->h < visual_height*heightscale)) {
+            vid_modes_i--;
+            break;
+         } else
+            vid_modes_i++;
+      }
+
+      /* mode_number is a command line option */
+      if( mode_number != -1) {
+         if( mode_number >vid_modes_i)
+            fprintf(stderr, "SDL: The mode number is invalid... ignoring\n");
+         else
+            vid_modes_i = mode_number;
+      }
+      if( vid_modes_i<0 ) {
+         fprintf(stderr, "SDL: None of the modes match :-(\n");
+         Vid_height = visual_height*heightscale;
+         Vid_width = visual_width*widthscale;
+      } else {
+         if(*(vid_modes+vid_modes_i)==NULL) 
+            vid_modes_i=vid_modes_i-1;
+
+         Vid_width = (*(vid_modes + vid_modes_i))->w;
+         Vid_height = (*(vid_modes + vid_modes_i))->h;
+      }
+   }
+
+   if(! (Surface = SDL_SetVideoMode(Vid_width, Vid_height,Vid_depth, SDL_HWSURFACE))) {
+      fprintf (stderr, "SDL: Error: Setting video mode failed\n");
+      SDL_Quit();
+      exit (OSD_NOT_OK);
+   } else {
+      fprintf (stderr, "SDL: Info: Video mode set as %d x %d, depth %d\n", Vid_width, Vid_height, Vid_depth);
+   }
+
+#ifndef DIRECT_HERMES
+   Offscreen_surface = SDL_CreateRGBSurface(SDL_SWSURFACE,Vid_width,Vid_height,Vid_depth,0,0,0,0); 
+   if(Offscreen_surface==NULL) {
+      SDL_Quit();
+      exit (OSD_NOT_OK);
+   }
+#else /* DIRECT_HERMES */
+   /* No offscreen surface when using hermes directly */
+   H_ConverterHandle = Hermes_ConverterInstance(0);
+   H_src_format = Hermes_FormatNew (8,0,0,0,0,HERMES_INDEXED);
+   /* TODO: More general destination choosing - uptil
+       now only 16 bit */
+   H_dst_format = Hermes_FormatNew (16,Surface->format->Rmask,Surface->format->Gmask,Surface->format->Bmask,0,0);
+   //  H_dst_format = Hermes_FormatNew (16,5,5,5,0,0);
+   if ( ! (Hermes_ConverterRequest(H_ConverterHandle,H_src_format , H_dst_format)) ) {
+      fprintf (stderr_file, "Hermes: Info: Converter request failed\n");
+      exit (OSD_NOT_OK);
+   }
+#endif /* DIRECT_HERMES */
+
+
+   /* Creating event mask */
+   SDL_EventState(SDL_KEYUP, SDL_ENABLE);
+   SDL_EventState(SDL_KEYDOWN, SDL_ENABLE);
+   SDL_EnableUNICODE(1);
+   
+    /* fill the display_palette_info struct */
+    memset(&display_palette_info, 0, sizeof(struct sysdep_palette_info));
+    display_palette_info.depth = Vid_depth;
+    if (Vid_depth == 8)
+         display_palette_info.writable_colors = 256;
+    else {
+      display_palette_info.red_mask = 0xF800;
+      display_palette_info.green_mask = 0x07E0;
+      display_palette_info.blue_mask   = 0x001F;
+   }
+
+   return OSD_OK;
+}
+
+
+/* Update the display. */
+void sdl_update_8bpp_16bpp(struct osd_bitmap *bitmap)
+{
+#define BLIT_16BPP_HACK
+#define INDIRECT current_palette->lookup
+#define SRC_PIXEL  unsigned char
+#define DEST_PIXEL unsigned short
+#define DEST Offscreen_surface->pixels
+#define DEST_WIDTH Vid_width
+
+#include "blit.h"
+
+#undef DEST_WIDTH
+#undef DEST
+#undef DEST_PIXEL
+#undef SRC_PIXEL
+#undef INDIRECT
+#undef BLIT_16BPP_HACK
+}
+
+#ifndef DIRECT_HERMES
+void sysdep_update_display(struct osd_bitmap *bitmap)
+{
+   int old_use_dirty = use_dirty;
+   SDL_Rect srect = { 0,0,0,0 };
+   SDL_Rect drect = { 0,0,0,0 };
+   srect.w = Vid_width;
+   srect.h = Vid_height;
+   drect.w = Vid_width;
+   drect.h = Vid_height;
+
+   if (current_palette->lookup_dirty)
+      use_dirty = 0;
+   
+   (*update_function)(bitmap);
+
+   
+   if(SDL_BlitSurface (Offscreen_surface, &srect, Surface, &drect)<0) 
+      fprintf (stderr,"SDL: Warn: Unsuccessful blitting\n");
+
+   if(hardware==0)
+      SDL_UpdateRects(Surface,1, &drect);
+   use_dirty = old_use_dirty;
+}
+#else /* DIRECT_HERMES */
+void sysdep_update_display(struct osd_bitmap *bitmap)
+{
+   int i,j,x,y,w,h;
+   int locked =0 ;
+   static int first_run = 1;
+   int line_amount;
+
+#ifdef SDL_DEBUG
+   static int update_count = 0;
+   static char* bak_bitmap;
+   int corrected = 0;
+   int debug = 0;
+#endif /* SDL_DEBUG */
+
+   if (H_Palette_modified) {
+      Hermes_PaletteInvalidateCache(H_PaletteHandle);
+      Hermes_ConverterPalette(H_ConverterHandle,H_PaletteHandle,0);
+      H_Palette_modified = 0;
+   }
+   
+#ifdef PANANOIC 
+      memset(Offscreen_surface->pixels,'\0' ,Vid_height * Vid_width);
+#endif 
+
+   switch   (use_dirty) {
+      long line_min;
+      long line_max;
+      long col_min;
+      long col_amount;
+
+      
+#ifdef SDL_DEBUG
+      int my_off;
+#endif       
+   case 0:
+      /* Not using dirty */
+      if (SDL_MUSTLOCK(Surface))
+         SDL_LockSurface(Surface);
+      
+      Hermes_ConverterCopy (H_ConverterHandle, 
+               bitmap->line[0] ,
+               0, 0 , 
+               Vid_width,Vid_height, bitmap->line[1] - bitmap->line[0],
+               Surface->pixels, 
+               0,0,
+               Vid_width, Vid_height, Vid_width <<1 );
+      
+      SDL_UnlockSurface(Surface);
+      SDL_UpdateRect(Surface,0,0,Vid_width,Vid_height);
+      break;
+
+   case 1:
+      /* Algorithm:
+          search through dirty & find max maximal polygon, which 
+          we can get to clipping (don't know if 8x8 is enought)
+      */
+      osd_dirty_merge();
+      
+   case 2:
+      h = (bitmap->height+7) >> 3; /* Divide by 8, up rounding */
+      w = (bitmap->width +7) >> 3; /* Divide by 8, up rounding */
+      
+#ifdef PARANOIC
+      /* Rechecking dirty correctness ...*/
+      if ( (! first_run) && debug) {
+         for (y=0;y<h;y++ ) {
+            for (i=0;i<8;i++) {
+               int line_off = ((y<<3) + i);
+               for (x=0;x<w;x++) {
+                  for (j=0;j<8;j++) {
+                     int col_off = ((x<<3) + j);
+                     if ( *(bak_bitmap + (line_off * (bitmap->line[1]- bitmap->line[0])) + col_off ) != *(*(bitmap->line + line_off) + col_off)) {
+                        if (! dirty_blocks[y][x] ) {
+                           printf ("Warn!!! Block should be dirty %d, %d, %d - correcting \n",y,x,i);
+                           dirty_blocks[y][x] = 1;
+                           dirty_lines[y]=1;
+                           corrected = 1;
+                        }
+                     } 
+                  }
+               }
+            }
+         }
+      } else {
+         bak_bitmap = (void*)malloc(w<<3 * h<<3);
+      }
+      
+      if (! corrected) {
+         printf ("dirty ok\n");
+      }
+      
+      first_run = 0;
+      for (i = 0;i< bitmap->height;i++)
+         memcpy(bak_bitmap + (bitmap->line[1] - bitmap->line[0])*i,*(bitmap->line+i),w<<3);
+      
+#endif /* PARANOIC */
+
+      // #define dirty_lines old_dirty_lines    
+      // #define dirty_blocks old_dirty_blocks
+      
+      for (y=0;y<h;y++) {
+         if (dirty_lines[y]) {
+            line_min = y<<3;
+            line_max = line_min + 8;
+            // old_dirty_lines[y]=1;
+            for (x=0;x<w;x++) {
+               if (dirty_blocks[y][x]) {
+                  col_min = x<<3;
+                  col_amount = 0;
+                  do { 
+                     col_amount++; 
+                     dirty_blocks[y][x] = 0;
+                     x++; 
+                  } while (dirty_blocks[y][x]); 
+
+                  dirty_blocks[y][x] = 0;
+                  col_amount <<= 3;
+
+                  line_amount = line_max - line_min;
+                  /* Trying to use direct hermes library for fast blitting */
+                  if (SDL_MUSTLOCK(Surface))
+                     SDL_LockSurface(Surface);
+               
+                  Hermes_ConverterCopy (H_ConverterHandle, 
+                     bitmap->line[0] ,
+                     col_min, line_min , 
+                     col_amount,line_amount, bitmap->line[1] - bitmap->line[0],
+                     Surface->pixels, 
+                     col_min, line_min, 
+                     col_amount ,line_amount, Vid_width <<1 );
+               
+                  SDL_UnlockSurface(Surface);
+                  SDL_UpdateRect(Surface,col_min,line_min,col_amount,line_amount);
+               }
+            }
+            dirty_lines[y] = 0;
+         }
+      }
+      
+      /* Vector game .... */
+      break;
+      return ;
+   }
+   
+   /* TODO - It's the real evil - better to use would be original 
+       hermes routines */
+
+#ifdef SDL_DEBUG
+   update_count++;
+#endif
+}
+#endif /* DIRECT_HERMES */
+
+/* shut up the display */
+void sysdep_display_close(void)
+{
+   SDL_FreeSurface(Offscreen_surface);
+}
+
+/*
+ * In 8 bpp we should alloc pallete - some ancient people  
+ * are still using 8bpp displays
+ */
+int sysdep_display_alloc_palette(int totalcolors)
+{
+   int ncolors;
+   int i;
+   ncolors = totalcolors;
+
+   fprintf (stderr, "SDL: sysdep_display_alloc_palette();\n");
+
+#ifndef DIRECT_HERMES
+   Colors = (SDL_Color*) malloc (totalcolors * sizeof(SDL_Color));
+   for (i=0;i<totalcolors;i++) {
+      (Colors + i)->r = 0xFF;
+      (Colors + i)->g = 0x00;
+      (Colors + i)->b = 0x00;
+   }
+   SDL_SetColors (Offscreen_surface,Colors,0,totalcolors-1);
+#else /* DIRECT_HERMES */
+   H_PaletteHandle = Hermes_PaletteInstance();
+   if ( !(H_Palette = Hermes_PaletteGet(H_PaletteHandle)) ) {
+      fprintf (stderr_file, "Hermes: Info: PaletteHandle invalid");
+      exit(OSD_NOT_OK);
+   }
+#endif /* DIRECT_HERMES */
+
+   fprintf (stderr, "SDL: Info: Palette with %d colors allocated\n", totalcolors);
+   return 0;
+}
+
+int sysdep_display_set_pen(int pen,unsigned char red, unsigned char green, unsigned char blue)
+{
+   static int warned = 0;
+
+#ifndef DIRECT_HERMES
+   (Colors + pen)->r = red;
+   (Colors + pen)->g = green;
+   (Colors + pen)->b = blue;
+   if ( (! SDL_SetColors(Offscreen_surface, Colors + pen, pen,1)) && (! warned)) {
+      printf ("Color allocation failed, or > 8 bit display\n");
+      warned = 0;
+   }
+#else /* DIRECT_HERMES */
+   *(H_Palette + pen) = (red<<16) | ((green) <<8) | (blue );
+   H_Palette_modified = 1; 
+#endif 
+
+#ifdef SDL_DEBUG
+   fprintf(stderr, "STD: Debug: Pen %d modification: r %d, g %d, b, %d\n", pen, red,green,blue);
+#endif /* SDL_DEBUG */
+   return 0;
+}
+
+
+
+void sysdep_mouse_poll (void)
+{
+/*   fprintf(stderr,"sysdep_mouse_poll()\n"); */
+}
+
+/* Keyboard procs */
+/* Lighting keyboard leds */
+void sysdep_set_leds(int leds) 
+{
+}
+
+void sysdep_update_keyboard() 
+{
+   struct keyboard_event kevent;
+   SDL_Event event;
+   
+   if (Surface) {
+      while(SDL_PollEvent(&event)) {
+         kevent.press = 0;
+         
+         switch (event.type)
+         {
+            case SDL_KEYDOWN:
+               kevent.press = 1;
+            case SDL_KEYUP:
+               kevent.scancode = klookup[event.key.keysym.sym];
+               kevent.unicode = event.key.keysym.unicode;
+               keyboard_register_event(&kevent);
+               if(!kevent.scancode)
+                  fprintf (stderr, "Unknown symbol 0x%x\n",
+                     event.key.keysym.sym);
+#ifdef SDL_DEBUG
+               fprintf (stderr, "Key %s %ssed\n",
+                  SDL_GetKeyName(event.key.keysym.sym),
+                  kevent.press? "pres":"relea");
+#endif
+               break;
+            case SDL_QUIT:
+               /* Shoult leave this to application */
+               exit(OSD_OK);
+               break;
+            default:
+#ifdef SDL_DEBUG
+               fprintf(stderr, "SDL: Debug: Other event\n");
+#endif /* SDL_DEBUG */
+               break;
+         }
+      }
+   }
+}
+
+/* funciones agregadas */
+int sysdep_display_16bpp_capable(void)
+{
+   return (Vid_depth >=16);
+}
+
+void list_sdl_modes(void)
+{
+   SDL_Rect** vid_modes;
+   int vid_modes_i;
+
+   vid_modes = SDL_ListModes(NULL,SDL_HWSURFACE);
+   vid_modes_i = 0;
+
+   if ( (! vid_modes) || ((long)vid_modes == -1)) {
+      printf("This option only works in a full-screen mode (eg: linux's framebuffer)\n");
+      return;
+   }
+
+   printf("Modes availables:\n");
+
+   while( *(vid_modes+vid_modes_i) ) {
+      printf("\t%d) Mode %d x %d\n",
+         vid_modes_i,
+         (*(vid_modes+vid_modes_i))->w,
+         (*(vid_modes+vid_modes_i))->h
+         );
+   
+      vid_modes_i++;
+   }
+}
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/SDL-keytable.h mame-0.36b16/src/unix/video-drivers/SDL-keytable.h
--- ../mmmmm/m36b16/src/unix/video-drivers/SDL-keytable.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/SDL-keytable.h	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,514 @@
+unsigned char klookup[] = {
+	KEY_NONE            ,   /* SDLK_FIRST           = 0 */
+	KEY_NONE            ,   /* SDLK_NONE            = 1 */
+	KEY_NONE            ,   /* SDLK_NONE            = 2 */
+	KEY_NONE            ,   /* SDLK_NONE            = 3 */
+	KEY_NONE            ,   /* SDLK_NONE            = 4 */
+	KEY_NONE            ,   /* SDLK_NONE            = 5 */
+	KEY_NONE            ,   /* SDLK_NONE            = 6 */
+	KEY_NONE            ,   /* SDLK_NONE            = 7 */
+	KEY_BACKSPACE       ,   /* SDLK_BACKSPACE       = 8 */
+	KEY_TAB             ,   /* SDLK_TAB             = 9 */
+	KEY_NONE            ,   /* SDLK_NONE            = 10 */
+	KEY_NONE            ,   /* SDLK_NONE            = 11 */
+	KEY_NONE            ,   /* SDLK_CLEAR           = 12 */
+	KEY_ENTER           ,   /* SDLK_RETURN          = 13 */
+	KEY_NONE            ,   /* SDLK_NONE            = 14 */
+	KEY_NONE            ,   /* SDLK_NONE            = 15 */
+	KEY_NONE            ,   /* SDLK_NONE            = 16 */
+	KEY_NONE            ,   /* SDLK_NONE            = 17 */
+	KEY_NONE            ,   /* SDLK_NONE            = 18 */
+	KEY_PAUSE           ,   /* SDLK_PAUSE           = 19 */
+	KEY_NONE            ,   /* SDLK_NONE            = 20 */
+	KEY_NONE            ,   /* SDLK_NONE            = 21 */
+	KEY_NONE            ,   /* SDLK_NONE            = 22 */
+	KEY_NONE            ,   /* SDLK_NONE            = 23 */
+	KEY_NONE            ,   /* SDLK_NONE            = 24 */
+	KEY_NONE            ,   /* SDLK_NONE            = 25 */
+	KEY_NONE            ,   /* SDLK_NONE            = 26 */
+	KEY_ESC             ,   /* SDLK_ESCAPE          = 27 */
+	KEY_NONE            ,   /* SDLK_NONE            = 28 */
+	KEY_NONE            ,   /* SDLK_NONE            = 29 */
+	KEY_NONE            ,   /* SDLK_NONE            = 30 */
+	KEY_NONE            ,   /* SDLK_NONE            = 31 */
+	KEY_SPACE           ,   /* SDLK_SPACE           = 32 */
+	KEY_NONE            ,   /* SDLK_EXCLAIM         = 33 */
+	KEY_NONE            ,   /* SDLK_QUOTEDBL        = 34 */
+	KEY_NONE            ,   /* SDLK_HASH            = 35 */
+	KEY_NONE            ,   /* SDLK_DOLLAR          = 36 */
+	KEY_NONE            ,   /* SDLK_NONE            = 37 */
+	KEY_NONE            ,   /* SDLK_AMPERSAND       = 38 */
+	KEY_QUOTE           ,   /* SDLK_QUOTE           = 39 */
+	KEY_OPENBRACE       ,   /* SDLK_LEFTPAREN       = 40 NS */
+	KEY_CLOSEBRACE      ,   /* SDLK_RIGHTPAREN      = 41 NS */
+	KEY_ASTERISK        ,   /* SDLK_ASTERISK        = 42 */
+	KEY_NONE            ,   /* SDLK_PLUS            = 43 */
+	KEY_COMMA           ,   /* SDLK_COMMA           = 44 */
+	KEY_MINUS           ,   /* SDLK_MINUS           = 45 */
+	KEY_NONE            ,   /* SDLK_PERIOD          = 46 */
+	KEY_SLASH           ,   /* SDLK_SLASH           = 47 */
+	KEY_0               ,   /* SDLK_0               = 48 */
+	KEY_1               ,   /* SDLK_1               = 49 */
+	KEY_2               ,   /* SDLK_2               = 50 */
+	KEY_3               ,   /* SDLK_3               = 51 */
+	KEY_4               ,   /* SDLK_4               = 52 */
+	KEY_5               ,   /* SDLK_5               = 53 */
+	KEY_6               ,   /* SDLK_6               = 54 */
+	KEY_7               ,   /* SDLK_7               = 55 */
+	KEY_8               ,   /* SDLK_8               = 56 */
+	KEY_9               ,   /* SDLK_9               = 57 */
+	KEY_COLON           ,   /* SDLK_COLON           = 58 */
+	KEY_NONE            ,   /* SDLK_SEMICOLON       = 59 */
+	KEY_NONE            ,   /* SDLK_LESS            = 60 */
+	KEY_EQUALS          ,   /* SDLK_EQUALS          = 61 */
+	KEY_NONE            ,   /* SDLK_GREATER         = 62 */
+	KEY_NONE            ,   /* SDLK_QUESTION        = 63 */
+	KEY_NONE            ,   /* SDLK_AT              = 64 */
+	KEY_NONE            ,   /* SDLK_NONE            = 65 */
+	KEY_NONE            ,   /* SDLK_NONE            = 66 */
+	KEY_NONE            ,   /* SDLK_NONE            = 67 */
+	KEY_NONE            ,   /* SDLK_NONE            = 68 */
+	KEY_NONE            ,   /* SDLK_NONE            = 69 */
+	KEY_NONE            ,   /* SDLK_NONE            = 70 */
+	KEY_NONE            ,   /* SDLK_NONE            = 71 */
+	KEY_NONE            ,   /* SDLK_NONE            = 72 */
+	KEY_NONE            ,   /* SDLK_NONE            = 73 */
+	KEY_NONE            ,   /* SDLK_NONE            = 74 */
+	KEY_NONE            ,   /* SDLK_NONE            = 75 */
+	KEY_NONE            ,   /* SDLK_NONE            = 76 */
+	KEY_NONE            ,   /* SDLK_NONE            = 77 */
+	KEY_NONE            ,   /* SDLK_NONE            = 78 */
+	KEY_NONE            ,   /* SDLK_NONE            = 79 */
+	KEY_NONE            ,   /* SDLK_NONE            = 80 */
+	KEY_NONE            ,   /* SDLK_NONE            = 81 */
+	KEY_NONE            ,   /* SDLK_NONE            = 82 */
+	KEY_NONE            ,   /* SDLK_NONE            = 83 */
+	KEY_NONE            ,   /* SDLK_NONE            = 84 */
+	KEY_NONE            ,   /* SDLK_NONE            = 85 */
+	KEY_NONE            ,   /* SDLK_NONE            = 86 */
+	KEY_NONE            ,   /* SDLK_NONE            = 87 */
+	KEY_NONE            ,   /* SDLK_NONE            = 88 */
+	KEY_NONE            ,   /* SDLK_NONE            = 89 */
+	KEY_NONE            ,   /* SDLK_NONE            = 90 */
+	KEY_NONE            ,   /* SDLK_LEFTBRACKET     = 91 */
+	KEY_BACKSLASH       ,   /* SDLK_BACKSLASH       = 92 */
+	KEY_NONE            ,   /* SDLK_RIGHTBRACKET    = 93 */
+	KEY_NONE            ,   /* SDLK_CARET           = 94 */
+	KEY_NONE            ,   /* SDLK_UNDERSCORE      = 95 */
+	KEY_NONE            ,   /* SDLK_BACKQUOTE       = 96 */
+	KEY_A               ,   /* SDLK_a               = 97 */
+	KEY_B               ,   /* SDLK_b               = 98 */
+	KEY_C               ,   /* SDLK_c               = 99 */
+	KEY_D               ,   /* SDLK_d               = 100 */
+	KEY_E               ,   /* SDLK_e               = 101 */
+	KEY_F               ,   /* SDLK_f               = 102 */
+	KEY_G               ,   /* SDLK_g               = 103 */
+	KEY_H               ,   /* SDLK_h               = 104 */
+	KEY_I               ,   /* SDLK_i               = 105 */
+	KEY_J               ,   /* SDLK_j               = 106 */
+	KEY_K               ,   /* SDLK_k               = 107 */
+	KEY_L               ,   /* SDLK_l               = 108 */
+	KEY_M               ,   /* SDLK_m               = 109 */
+	KEY_N               ,   /* SDLK_n               = 110 */
+	KEY_O               ,   /* SDLK_o               = 111 */
+	KEY_P               ,   /* SDLK_p               = 112 */
+	KEY_Q               ,   /* SDLK_q               = 113 */
+	KEY_R               ,   /* SDLK_r               = 114 */
+	KEY_S               ,   /* SDLK_s               = 115 */
+	KEY_T               ,   /* SDLK_t               = 116 */
+	KEY_U               ,   /* SDLK_u               = 117 */
+	KEY_V               ,   /* SDLK_v               = 118 */
+	KEY_W               ,   /* SDLK_w               = 119 */
+	KEY_X               ,   /* SDLK_x               = 120 */
+	KEY_Y               ,   /* SDLK_y               = 121 */
+	KEY_Z               ,   /* SDLK_z               = 122 */
+	KEY_NONE            ,   /* SDLK_NONE            = 123 */
+	KEY_NONE            ,   /* SDLK_NONE            = 124 */
+	KEY_NONE            ,   /* SDLK_NONE            = 125 */
+	KEY_NONE            ,   /* SDLK_NONE            = 126 */
+	KEY_DEL             ,   /* SDLK_DELETE          = 127 */
+	KEY_NONE            ,   /* SDLK_NONE            = 128 */
+	KEY_NONE            ,   /* SDLK_NONE            = 129 */
+	KEY_NONE            ,   /* SDLK_NONE            = 130 */
+	KEY_NONE            ,   /* SDLK_NONE            = 131 */
+	KEY_NONE            ,   /* SDLK_NONE            = 132 */
+	KEY_NONE            ,   /* SDLK_NONE            = 133 */
+	KEY_NONE            ,   /* SDLK_NONE            = 134 */
+	KEY_NONE            ,   /* SDLK_NONE            = 135 */
+	KEY_NONE            ,   /* SDLK_NONE            = 136 */
+	KEY_NONE            ,   /* SDLK_NONE            = 137 */
+	KEY_NONE            ,   /* SDLK_NONE            = 138 */
+	KEY_NONE            ,   /* SDLK_NONE            = 139 */
+	KEY_NONE            ,   /* SDLK_NONE            = 140 */
+	KEY_NONE            ,   /* SDLK_NONE            = 141 */
+	KEY_NONE            ,   /* SDLK_NONE            = 142 */
+	KEY_NONE            ,   /* SDLK_NONE            = 143 */
+	KEY_NONE            ,   /* SDLK_NONE            = 144 */
+	KEY_NONE            ,   /* SDLK_NONE            = 145 */
+	KEY_NONE            ,   /* SDLK_NONE            = 146 */
+	KEY_NONE            ,   /* SDLK_NONE            = 147 */
+	KEY_NONE            ,   /* SDLK_NONE            = 148 */
+	KEY_NONE            ,   /* SDLK_NONE            = 149 */
+	KEY_NONE            ,   /* SDLK_NONE            = 150 */
+	KEY_NONE            ,   /* SDLK_NONE            = 151 */
+	KEY_NONE            ,   /* SDLK_NONE            = 152 */
+	KEY_NONE            ,   /* SDLK_NONE            = 153 */
+	KEY_NONE            ,   /* SDLK_NONE            = 154 */
+	KEY_NONE            ,   /* SDLK_NONE            = 155 */
+	KEY_NONE            ,   /* SDLK_NONE            = 156 */
+	KEY_NONE            ,   /* SDLK_NONE            = 157 */
+	KEY_NONE            ,   /* SDLK_NONE            = 158 */
+	KEY_NONE            ,   /* SDLK_NONE            = 159 */
+	KEY_NONE            ,   /* SDLK_WORLD_0         = 160 */
+	KEY_NONE            ,   /* SDLK_WORLD_1         = 161 */
+	KEY_NONE            ,   /* SDLK_WORLD_2         = 162 */
+	KEY_NONE            ,   /* SDLK_WORLD_3         = 163 */
+	KEY_NONE            ,   /* SDLK_WORLD_4         = 164 */
+	KEY_NONE            ,   /* SDLK_WORLD_5         = 165 */
+	KEY_NONE            ,   /* SDLK_WORLD_6         = 166 */
+	KEY_NONE            ,   /* SDLK_WORLD_7         = 167 */
+	KEY_NONE            ,   /* SDLK_WORLD_8         = 168 */
+	KEY_NONE            ,   /* SDLK_WORLD_9         = 169 */
+	KEY_NONE            ,   /* SDLK_WORLD_10        = 170 */
+	KEY_NONE            ,   /* SDLK_WORLD_11        = 171 */
+	KEY_NONE            ,   /* SDLK_WORLD_12        = 172 */
+	KEY_NONE            ,   /* SDLK_WORLD_13        = 173 */
+	KEY_NONE            ,   /* SDLK_WORLD_14        = 174 */
+	KEY_NONE            ,   /* SDLK_WORLD_15        = 175 */
+	KEY_NONE            ,   /* SDLK_WORLD_16        = 176 */
+	KEY_NONE            ,   /* SDLK_WORLD_17        = 177 */
+	KEY_NONE            ,   /* SDLK_WORLD_18        = 178 */
+	KEY_NONE            ,   /* SDLK_WORLD_19        = 179 */
+	KEY_NONE            ,   /* SDLK_WORLD_20        = 180 */
+	KEY_NONE            ,   /* SDLK_WORLD_21        = 181 */
+	KEY_NONE            ,   /* SDLK_WORLD_22        = 182 */
+	KEY_NONE            ,   /* SDLK_WORLD_23        = 183 */
+	KEY_NONE            ,   /* SDLK_WORLD_24        = 184 */
+	KEY_NONE            ,   /* SDLK_WORLD_25        = 185 */
+	KEY_NONE            ,   /* SDLK_WORLD_26        = 186 */
+	KEY_NONE            ,   /* SDLK_WORLD_27        = 187 */
+	KEY_NONE            ,   /* SDLK_WORLD_28        = 188 */
+	KEY_NONE            ,   /* SDLK_WORLD_29        = 189 */
+	KEY_NONE            ,   /* SDLK_WORLD_30        = 190 */
+	KEY_NONE            ,   /* SDLK_WORLD_31        = 191 */
+	KEY_NONE            ,   /* SDLK_WORLD_32        = 192 */
+	KEY_NONE            ,   /* SDLK_WORLD_33        = 193 */
+	KEY_NONE            ,   /* SDLK_WORLD_34        = 194 */
+	KEY_NONE            ,   /* SDLK_WORLD_35        = 195 */
+	KEY_NONE            ,   /* SDLK_WORLD_36        = 196 */
+	KEY_NONE            ,   /* SDLK_WORLD_37        = 197 */
+	KEY_NONE            ,   /* SDLK_WORLD_38        = 198 */
+	KEY_NONE            ,   /* SDLK_WORLD_39        = 199 */
+	KEY_NONE            ,   /* SDLK_WORLD_40        = 200 */
+	KEY_NONE            ,   /* SDLK_WORLD_41        = 201 */
+	KEY_NONE            ,   /* SDLK_WORLD_42        = 202 */
+	KEY_NONE            ,   /* SDLK_WORLD_43        = 203 */
+	KEY_NONE            ,   /* SDLK_WORLD_44        = 204 */
+	KEY_NONE            ,   /* SDLK_WORLD_45        = 205 */
+	KEY_NONE            ,   /* SDLK_WORLD_46        = 206 */
+	KEY_NONE            ,   /* SDLK_WORLD_47        = 207 */
+	KEY_NONE            ,   /* SDLK_WORLD_48        = 208 */
+	KEY_NONE            ,   /* SDLK_WORLD_49        = 209 */
+	KEY_NONE            ,   /* SDLK_WORLD_50        = 210 */
+	KEY_NONE            ,   /* SDLK_WORLD_51        = 211 */
+	KEY_NONE            ,   /* SDLK_WORLD_52        = 212 */
+	KEY_NONE            ,   /* SDLK_WORLD_53        = 213 */
+	KEY_NONE            ,   /* SDLK_WORLD_54        = 214 */
+	KEY_NONE            ,   /* SDLK_WORLD_55        = 215 */
+	KEY_NONE            ,   /* SDLK_WORLD_56        = 216 */
+	KEY_NONE            ,   /* SDLK_WORLD_57        = 217 */
+	KEY_NONE            ,   /* SDLK_WORLD_58        = 218 */
+	KEY_NONE            ,   /* SDLK_WORLD_59        = 219 */
+	KEY_NONE            ,   /* SDLK_WORLD_60        = 220 */
+	KEY_NONE            ,   /* SDLK_WORLD_61        = 221 */
+	KEY_NONE            ,   /* SDLK_WORLD_62        = 222 */
+	KEY_NONE            ,   /* SDLK_WORLD_63        = 223 */
+	KEY_NONE            ,   /* SDLK_WORLD_64        = 224 */
+	KEY_NONE            ,   /* SDLK_WORLD_65        = 225 */
+	KEY_NONE            ,   /* SDLK_WORLD_66        = 226 */
+	KEY_NONE            ,   /* SDLK_WORLD_67        = 227 */
+	KEY_NONE            ,   /* SDLK_WORLD_68        = 228 */
+	KEY_NONE            ,   /* SDLK_WORLD_69        = 229 */
+	KEY_NONE            ,   /* SDLK_WORLD_70        = 230 */
+	KEY_NONE            ,   /* SDLK_WORLD_71        = 231 */
+	KEY_NONE            ,   /* SDLK_WORLD_72        = 232 */
+	KEY_NONE            ,   /* SDLK_WORLD_73        = 233 */
+	KEY_NONE            ,   /* SDLK_WORLD_74        = 234 */
+	KEY_NONE            ,   /* SDLK_WORLD_75        = 235 */
+	KEY_NONE            ,   /* SDLK_WORLD_76        = 236 */
+	KEY_NONE            ,   /* SDLK_WORLD_77        = 237 */
+	KEY_NONE            ,   /* SDLK_WORLD_78        = 238 */
+	KEY_NONE            ,   /* SDLK_WORLD_79        = 239 */
+	KEY_NONE            ,   /* SDLK_WORLD_80        = 240 */
+	KEY_NONE            ,   /* SDLK_WORLD_81        = 241 */
+	KEY_NONE            ,   /* SDLK_WORLD_82        = 242 */
+	KEY_NONE            ,   /* SDLK_WORLD_83        = 243 */
+	KEY_NONE            ,   /* SDLK_WORLD_84        = 244 */
+	KEY_NONE            ,   /* SDLK_WORLD_85        = 245 */
+	KEY_NONE            ,   /* SDLK_WORLD_86        = 246 */
+	KEY_NONE            ,   /* SDLK_WORLD_87        = 247 */
+	KEY_NONE            ,   /* SDLK_WORLD_88        = 248 */
+	KEY_NONE            ,   /* SDLK_WORLD_89        = 249 */
+	KEY_NONE            ,   /* SDLK_WORLD_90        = 250 */
+	KEY_NONE            ,   /* SDLK_WORLD_91        = 251 */
+	KEY_NONE            ,   /* SDLK_WORLD_92        = 252 */
+	KEY_NONE            ,   /* SDLK_WORLD_93        = 253 */
+	KEY_NONE            ,   /* SDLK_WORLD_94        = 254 */
+	KEY_NONE            ,   /* SDLK_WORLD_95        = 255 */
+	KEY_0_PAD           ,   /* SDLK_KP0             = 256 */
+	KEY_1_PAD           ,   /* SDLK_KP1             = 257 */
+	KEY_2_PAD           ,   /* SDLK_KP2             = 258 */
+	KEY_3_PAD           ,   /* SDLK_KP3             = 259 */
+	KEY_4_PAD           ,   /* SDLK_KP4             = 260 */
+	KEY_5_PAD           ,   /* SDLK_KP5             = 261 */
+	KEY_6_PAD           ,   /* SDLK_KP6             = 262 */
+	KEY_7_PAD           ,   /* SDLK_KP7             = 263 */
+	KEY_8_PAD           ,   /* SDLK_KP8             = 264 */
+	KEY_9_PAD           ,   /* SDLK_KP9             = 265 */
+	KEY_DEL_PAD         ,   /* SDLK_KP_PERIOD       = 266 */
+	KEY_SLASH_PAD       ,   /* SDLK_KP_DIVIDE       = 267 NS */
+	KEY_NONE            ,   /* SDLK_KP_MULTIPLY     = 268 */
+	KEY_MINUS_PAD       ,   /* SDLK_KP_MINUS        = 269 */
+	KEY_PLUS_PAD        ,   /* SDLK_KP_PLUS         = 270 */
+	KEY_ENTER_PAD       ,   /* SDLK_KP_ENTER        = 271 */
+	KEY_NONE            ,   /* SDLK_KP_EQUALS       = 272 */
+	KEY_UP              ,   /* SDLK_UP              = 273 */
+	KEY_DOWN            ,   /* SDLK_DOWN            = 274 */
+	KEY_RIGHT           ,   /* SDLK_RIGHT           = 275 */
+	KEY_LEFT            ,   /* SDLK_LEFT            = 276 */
+	KEY_INSERT          ,   /* SDLK_INSERT          = 277 */
+	KEY_HOME            ,   /* SDLK_HOME            = 278 */
+	KEY_END             ,   /* SDLK_END             = 279 */
+	KEY_PGUP            ,   /* SDLK_PAGEUP          = 280 */
+	KEY_PGDN            ,   /* SDLK_PAGEDOWN        = 281 */
+	KEY_F1              ,   /* SDLK_F1              = 282 */
+	KEY_F2              ,   /* SDLK_F2              = 283 */
+	KEY_F3              ,   /* SDLK_F3              = 284 */
+	KEY_F4              ,   /* SDLK_F4              = 285 */
+	KEY_F5              ,   /* SDLK_F5              = 286 */
+	KEY_F6              ,   /* SDLK_F6              = 287 */
+	KEY_F7              ,   /* SDLK_F7              = 288 */
+	KEY_F8              ,   /* SDLK_F8              = 289 */
+	KEY_F9              ,   /* SDLK_F9              = 290 */
+	KEY_F10             ,   /* SDLK_F10             = 291 */
+	KEY_F11             ,   /* SDLK_F11             = 292 */
+	KEY_F12             ,   /* SDLK_F12             = 293 */
+	KEY_NONE            ,   /* SDLK_F13             = 294 */
+	KEY_NONE            ,   /* SDLK_F14             = 295 */
+	KEY_NONE            ,   /* SDLK_F15             = 296 */
+	KEY_NONE            ,   /* SDLK_NONE            = 297 */
+	KEY_NONE            ,   /* SDLK_NONE            = 298 */
+	KEY_NONE            ,   /* SDLK_NONE            = 299 */
+	KEY_NUMLOCK         ,   /* SDLK_NUMLOCK         = 300 */
+	KEY_CAPSLOCK        ,   /* SDLK_CAPSLOCK        = 301 */
+	KEY_SCRLOCK         ,   /* SDLK_SCROLLOCK       = 302 */
+	KEY_RSHIFT          ,   /* SDLK_RSHIFT          = 303 */
+	KEY_LSHIFT          ,   /* SDLK_LSHIFT          = 304 */
+	KEY_RCONTROL        ,   /* SDLK_RCTRL           = 305 */
+	KEY_LCONTROL        ,   /* SDLK_LCTRL           = 306 */
+	KEY_ALTGR           ,   /* SDLK_RALT            = 307 NS */
+	KEY_ALT             ,   /* SDLK_LALT            = 308 NS */
+	KEY_ALTGR           ,   /* SDLK_RMETA           = 309 NS */
+	KEY_ALT             ,   /* SDLK_LMETA           = 310 NS */
+	KEY_NONE            ,   /* SDLK_LSUPER          = 311 */
+	KEY_NONE            ,   /* SDLK_RSUPER          = 312 */
+	KEY_NONE            ,   /* SDLK_MODE            = 313 */
+	KEY_NONE            ,   /* SDLK_NONE            = 314 */
+	KEY_NONE            ,   /* SDLK_HELP            = 315 */
+	KEY_PRTSCR          ,   /* SDLK_PRINT           = 316 NS */
+	KEY_NONE            ,   /* SDLK_SYSREQ          = 317 */
+	KEY_NONE            ,   /* SDLK_BREAK           = 318 */
+	KEY_MENU            ,   /* SDLK_MENU            = 319 */
+	KEY_NONE            ,   /* SDLK_POWER           = 320 */
+	KEY_NONE            ,   /* SDLK_EURO            = 321 */
+	KEY_NONE            ,   /* SDLK_NONE            = 322 */
+	KEY_NONE            ,   /* SDLK_NONE            = 323 */
+	KEY_NONE            ,   /* SDLK_NONE            = 324 */
+	KEY_NONE            ,   /* SDLK_NONE            = 325 */
+	KEY_NONE            ,   /* SDLK_NONE            = 326 */
+	KEY_NONE            ,   /* SDLK_NONE            = 327 */
+	KEY_NONE            ,   /* SDLK_NONE            = 328 */
+	KEY_NONE            ,   /* SDLK_NONE            = 329 */
+	KEY_NONE            ,   /* SDLK_NONE            = 330 */
+	KEY_NONE            ,   /* SDLK_NONE            = 331 */
+	KEY_NONE            ,   /* SDLK_NONE            = 332 */
+	KEY_NONE            ,   /* SDLK_NONE            = 333 */
+	KEY_NONE            ,   /* SDLK_NONE            = 334 */
+	KEY_NONE            ,   /* SDLK_NONE            = 335 */
+	KEY_NONE            ,   /* SDLK_NONE            = 336 */
+	KEY_NONE            ,   /* SDLK_NONE            = 337 */
+	KEY_NONE            ,   /* SDLK_NONE            = 338 */
+	KEY_NONE            ,   /* SDLK_NONE            = 339 */
+	KEY_NONE            ,   /* SDLK_NONE            = 340 */
+	KEY_NONE            ,   /* SDLK_NONE            = 341 */
+	KEY_NONE            ,   /* SDLK_NONE            = 342 */
+	KEY_NONE            ,   /* SDLK_NONE            = 343 */
+	KEY_NONE            ,   /* SDLK_NONE            = 344 */
+	KEY_NONE            ,   /* SDLK_NONE            = 345 */
+	KEY_NONE            ,   /* SDLK_NONE            = 346 */
+	KEY_NONE            ,   /* SDLK_NONE            = 347 */
+	KEY_NONE            ,   /* SDLK_NONE            = 348 */
+	KEY_NONE            ,   /* SDLK_NONE            = 349 */
+	KEY_NONE            ,   /* SDLK_NONE            = 350 */
+	KEY_NONE            ,   /* SDLK_NONE            = 351 */
+	KEY_NONE            ,   /* SDLK_NONE            = 352 */
+	KEY_NONE            ,   /* SDLK_NONE            = 353 */
+	KEY_NONE            ,   /* SDLK_NONE            = 354 */
+	KEY_NONE            ,   /* SDLK_NONE            = 355 */
+	KEY_NONE            ,   /* SDLK_NONE            = 356 */
+	KEY_NONE            ,   /* SDLK_NONE            = 357 */
+	KEY_NONE            ,   /* SDLK_NONE            = 358 */
+	KEY_NONE            ,   /* SDLK_NONE            = 359 */
+	KEY_NONE            ,   /* SDLK_NONE            = 360 */
+	KEY_NONE            ,   /* SDLK_NONE            = 361 */
+	KEY_NONE            ,   /* SDLK_NONE            = 362 */
+	KEY_NONE            ,   /* SDLK_NONE            = 363 */
+	KEY_NONE            ,   /* SDLK_NONE            = 364 */
+	KEY_NONE            ,   /* SDLK_NONE            = 365 */
+	KEY_NONE            ,   /* SDLK_NONE            = 366 */
+	KEY_NONE            ,   /* SDLK_NONE            = 367 */
+	KEY_NONE            ,   /* SDLK_NONE            = 368 */
+	KEY_NONE            ,   /* SDLK_NONE            = 369 */
+	KEY_NONE            ,   /* SDLK_NONE            = 370 */
+	KEY_NONE            ,   /* SDLK_NONE            = 371 */
+	KEY_NONE            ,   /* SDLK_NONE            = 372 */
+	KEY_NONE            ,   /* SDLK_NONE            = 373 */
+	KEY_NONE            ,   /* SDLK_NONE            = 374 */
+	KEY_NONE            ,   /* SDLK_NONE            = 375 */
+	KEY_NONE            ,   /* SDLK_NONE            = 376 */
+	KEY_NONE            ,   /* SDLK_NONE            = 377 */
+	KEY_NONE            ,   /* SDLK_NONE            = 378 */
+	KEY_NONE            ,   /* SDLK_NONE            = 379 */
+	KEY_NONE            ,   /* SDLK_NONE            = 380 */
+	KEY_NONE            ,   /* SDLK_NONE            = 381 */
+	KEY_NONE            ,   /* SDLK_NONE            = 382 */
+	KEY_NONE            ,   /* SDLK_NONE            = 383 */
+	KEY_NONE            ,   /* SDLK_NONE            = 384 */
+	KEY_NONE            ,   /* SDLK_NONE            = 385 */
+	KEY_NONE            ,   /* SDLK_NONE            = 386 */
+	KEY_NONE            ,   /* SDLK_NONE            = 387 */
+	KEY_NONE            ,   /* SDLK_NONE            = 388 */
+	KEY_NONE            ,   /* SDLK_NONE            = 389 */
+	KEY_NONE            ,   /* SDLK_NONE            = 390 */
+	KEY_NONE            ,   /* SDLK_NONE            = 391 */
+	KEY_NONE            ,   /* SDLK_NONE            = 392 */
+	KEY_NONE            ,   /* SDLK_NONE            = 393 */
+	KEY_NONE            ,   /* SDLK_NONE            = 394 */
+	KEY_NONE            ,   /* SDLK_NONE            = 395 */
+	KEY_NONE            ,   /* SDLK_NONE            = 396 */
+	KEY_NONE            ,   /* SDLK_NONE            = 397 */
+	KEY_NONE            ,   /* SDLK_NONE            = 398 */
+	KEY_NONE            ,   /* SDLK_NONE            = 399 */
+	KEY_NONE            ,   /* SDLK_NONE            = 400 */
+	KEY_NONE            ,   /* SDLK_NONE            = 401 */
+	KEY_NONE            ,   /* SDLK_NONE            = 402 */
+	KEY_NONE            ,   /* SDLK_NONE            = 403 */
+	KEY_NONE            ,   /* SDLK_NONE            = 404 */
+	KEY_NONE            ,   /* SDLK_NONE            = 405 */
+	KEY_NONE            ,   /* SDLK_NONE            = 406 */
+	KEY_NONE            ,   /* SDLK_NONE            = 407 */
+	KEY_NONE            ,   /* SDLK_NONE            = 408 */
+	KEY_NONE            ,   /* SDLK_NONE            = 409 */
+	KEY_NONE            ,   /* SDLK_NONE            = 410 */
+	KEY_NONE            ,   /* SDLK_NONE            = 411 */
+	KEY_NONE            ,   /* SDLK_NONE            = 412 */
+	KEY_NONE            ,   /* SDLK_NONE            = 413 */
+	KEY_NONE            ,   /* SDLK_NONE            = 414 */
+	KEY_NONE            ,   /* SDLK_NONE            = 415 */
+	KEY_NONE            ,   /* SDLK_NONE            = 416 */
+	KEY_NONE            ,   /* SDLK_NONE            = 417 */
+	KEY_NONE            ,   /* SDLK_NONE            = 418 */
+	KEY_NONE            ,   /* SDLK_NONE            = 419 */
+	KEY_NONE            ,   /* SDLK_NONE            = 420 */
+	KEY_NONE            ,   /* SDLK_NONE            = 421 */
+	KEY_NONE            ,   /* SDLK_NONE            = 422 */
+	KEY_NONE            ,   /* SDLK_NONE            = 423 */
+	KEY_NONE            ,   /* SDLK_NONE            = 424 */
+	KEY_NONE            ,   /* SDLK_NONE            = 425 */
+	KEY_NONE            ,   /* SDLK_NONE            = 426 */
+	KEY_NONE            ,   /* SDLK_NONE            = 427 */
+	KEY_NONE            ,   /* SDLK_NONE            = 428 */
+	KEY_NONE            ,   /* SDLK_NONE            = 429 */
+	KEY_NONE            ,   /* SDLK_NONE            = 430 */
+	KEY_NONE            ,   /* SDLK_NONE            = 431 */
+	KEY_NONE            ,   /* SDLK_NONE            = 432 */
+	KEY_NONE            ,   /* SDLK_NONE            = 433 */
+	KEY_NONE            ,   /* SDLK_NONE            = 434 */
+	KEY_NONE            ,   /* SDLK_NONE            = 435 */
+	KEY_NONE            ,   /* SDLK_NONE            = 436 */
+	KEY_NONE            ,   /* SDLK_NONE            = 437 */
+	KEY_NONE            ,   /* SDLK_NONE            = 438 */
+	KEY_NONE            ,   /* SDLK_NONE            = 439 */
+	KEY_NONE            ,   /* SDLK_NONE            = 440 */
+	KEY_NONE            ,   /* SDLK_NONE            = 441 */
+	KEY_NONE            ,   /* SDLK_NONE            = 442 */
+	KEY_NONE            ,   /* SDLK_NONE            = 443 */
+	KEY_NONE            ,   /* SDLK_NONE            = 444 */
+	KEY_NONE            ,   /* SDLK_NONE            = 445 */
+	KEY_NONE            ,   /* SDLK_NONE            = 446 */
+	KEY_NONE            ,   /* SDLK_NONE            = 447 */
+	KEY_NONE            ,   /* SDLK_NONE            = 448 */
+	KEY_NONE            ,   /* SDLK_NONE            = 449 */
+	KEY_NONE            ,   /* SDLK_NONE            = 450 */
+	KEY_NONE            ,   /* SDLK_NONE            = 451 */
+	KEY_NONE            ,   /* SDLK_NONE            = 452 */
+	KEY_NONE            ,   /* SDLK_NONE            = 453 */
+	KEY_NONE            ,   /* SDLK_NONE            = 454 */
+	KEY_NONE            ,   /* SDLK_NONE            = 455 */
+	KEY_NONE            ,   /* SDLK_NONE            = 456 */
+	KEY_NONE            ,   /* SDLK_NONE            = 457 */
+	KEY_NONE            ,   /* SDLK_NONE            = 458 */
+	KEY_NONE            ,   /* SDLK_NONE            = 459 */
+	KEY_NONE            ,   /* SDLK_NONE            = 460 */
+	KEY_NONE            ,   /* SDLK_NONE            = 461 */
+	KEY_NONE            ,   /* SDLK_NONE            = 462 */
+	KEY_NONE            ,   /* SDLK_NONE            = 463 */
+	KEY_NONE            ,   /* SDLK_NONE            = 464 */
+	KEY_NONE            ,   /* SDLK_NONE            = 465 */
+	KEY_NONE            ,   /* SDLK_NONE            = 466 */
+	KEY_NONE            ,   /* SDLK_NONE            = 467 */
+	KEY_NONE            ,   /* SDLK_NONE            = 468 */
+	KEY_NONE            ,   /* SDLK_NONE            = 469 */
+	KEY_NONE            ,   /* SDLK_NONE            = 470 */
+	KEY_NONE            ,   /* SDLK_NONE            = 471 */
+	KEY_NONE            ,   /* SDLK_NONE            = 472 */
+	KEY_NONE            ,   /* SDLK_NONE            = 473 */
+	KEY_NONE            ,   /* SDLK_NONE            = 474 */
+	KEY_NONE            ,   /* SDLK_NONE            = 475 */
+	KEY_NONE            ,   /* SDLK_NONE            = 476 */
+	KEY_NONE            ,   /* SDLK_NONE            = 477 */
+	KEY_NONE            ,   /* SDLK_NONE            = 478 */
+	KEY_NONE            ,   /* SDLK_NONE            = 479 */
+	KEY_NONE            ,   /* SDLK_NONE            = 480 */
+	KEY_NONE            ,   /* SDLK_NONE            = 481 */
+	KEY_NONE            ,   /* SDLK_NONE            = 482 */
+	KEY_NONE            ,   /* SDLK_NONE            = 483 */
+	KEY_NONE            ,   /* SDLK_NONE            = 484 */
+	KEY_NONE            ,   /* SDLK_NONE            = 485 */
+	KEY_NONE            ,   /* SDLK_NONE            = 486 */
+	KEY_NONE            ,   /* SDLK_NONE            = 487 */
+	KEY_NONE            ,   /* SDLK_NONE            = 488 */
+	KEY_NONE            ,   /* SDLK_NONE            = 489 */
+	KEY_NONE            ,   /* SDLK_NONE            = 490 */
+	KEY_NONE            ,   /* SDLK_NONE            = 491 */
+	KEY_NONE            ,   /* SDLK_NONE            = 492 */
+	KEY_NONE            ,   /* SDLK_NONE            = 493 */
+	KEY_NONE            ,   /* SDLK_NONE            = 494 */
+	KEY_NONE            ,   /* SDLK_NONE            = 495 */
+	KEY_NONE            ,   /* SDLK_NONE            = 496 */
+	KEY_NONE            ,   /* SDLK_NONE            = 497 */
+	KEY_NONE            ,   /* SDLK_NONE            = 498 */
+	KEY_NONE            ,   /* SDLK_NONE            = 499 */
+	KEY_NONE            ,   /* SDLK_NONE            = 500 */
+	KEY_NONE            ,   /* SDLK_NONE            = 501 */
+	KEY_NONE            ,   /* SDLK_NONE            = 502 */
+	KEY_NONE            ,   /* SDLK_NONE            = 503 */
+	KEY_NONE            ,   /* SDLK_NONE            = 504 */
+	KEY_NONE            ,   /* SDLK_NONE            = 505 */
+	KEY_NONE            ,   /* SDLK_NONE            = 506 */
+	KEY_NONE            ,   /* SDLK_NONE            = 507 */
+	KEY_NONE            ,   /* SDLK_NONE            = 508 */
+	KEY_NONE            ,   /* SDLK_NONE            = 509 */
+	KEY_NONE            ,   /* SDLK_NONE            = 510 */
+	KEY_NONE                /* SDLK_NONE            = 511 */
+};
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/svgafx.c mame-0.36b16/src/unix/video-drivers/svgafx.c
--- ../mmmmm/m36b16/src/unix/video-drivers/svgafx.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/svgafx.c	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,103 @@
+/***************************************************************************
+
+  Xmame 3Dfx console-mode driver
+
+  Written based on Phillip Ezolt's svgalib driver by Mike Oliphant -
+
+    oliphant@ling.ed.ac.uk
+
+    http://www.ling.ed.ac.uk/~oliphant/glmame
+
+***************************************************************************/
+#define __SVGAFX_C
+
+#include <vga.h>
+#include <glide.h>
+#include "xmame.h"
+#include "svgainput.h"
+
+int  InitVScreen(void);
+void CloseVScreen(void);
+int  InitGlide(void);
+int  SetResolution(struct rc_option *option, const char *arg, int priority);
+
+extern struct rc_option fx_opts[];
+
+struct rc_option display_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { NULL, 		NULL,			rc_link,	fx_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+int sysdep_init(void)
+{
+   fprintf(stderr,
+      "info: using FXmame v0.5 driver for xmame, written by Mike Oliphant\n");
+   
+   if (InitGlide()!=OSD_OK)
+      return OSD_NOT_OK;
+   if (vga_init())
+      return OSD_NOT_OK;
+   if (svga_input_init())
+      return OSD_NOT_OK;
+   
+   return OSD_OK;
+}
+
+void sysdep_close(void)
+{
+   svga_input_exit();
+}
+
+static void release_function(void)
+{
+   grSstControl(GR_CONTROL_DEACTIVATE);
+}
+
+static void acquire_function(void)
+{
+   grSstControl(GR_CONTROL_ACTIVATE);
+}
+
+/* This name doesn't really cover this function, since it also sets up mouse
+   and keyboard. This is done over here, since on most display targets the
+   mouse and keyboard can't be setup before the display has. */
+int sysdep_create_display(int depth)
+{
+  if(depth == 16)
+  {
+     fprintf(stderr_file, "%s doesn't support 16bpp video modes\n", title);
+     return OSD_NOT_OK;
+  }
+
+  if (InitVScreen() != OSD_OK)
+     return OSD_NOT_OK;
+     
+  /* with newer svgalib's the console switch signals are only active if a
+     graphics mode is set, so we set one which each card should support */
+  vga_setmode(G320x200x16);
+  
+  /* init input */
+  if(svga_input_open(release_function, acquire_function))
+     return OSD_NOT_OK;
+   
+  return OSD_OK;
+}
+
+
+/* shut up the display */
+void sysdep_display_close(void)
+{
+   /* close input */
+   svga_input_close();
+   
+   /* close svgalib */
+   vga_setmode(TEXT);
+   
+   /* close glide */
+   CloseVScreen();
+}
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/svgainput.c mame-0.36b16/src/unix/video-drivers/svgainput.c
--- ../mmmmm/m36b16/src/unix/video-drivers/svgainput.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/svgainput.c	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,343 @@
+#include <vga.h>
+#include <vgakeyboard.h>
+/* fix ansi compilation */
+#define inline
+#include <vgamouse.h>
+#undef inline
+#include <signal.h>
+#include <linux/kd.h>
+#include <sys/ioctl.h>
+#include "svgainput.h"
+#include "xmame.h"
+#include "devices.h"
+#include "keyboard.h"
+
+static int console_fd       = -1;
+static int mouse_fd         = -1;
+static int leds             =  0;
+static int release_signal   =  0;
+static int acquire_signal   =  0;
+static struct sigaction release_sa;
+static struct sigaction oldrelease_sa;
+static struct sigaction acquire_sa;
+static struct sigaction oldacquire_sa;
+static void (*release_function)(void) = NULL;
+static void (*acquire_function)(void) = NULL;
+
+static const char scancode_to_unicode[128][2] = {
+   { 0,   0   }, /* 0 */
+   { 0,   0   },
+   { '1', '!' },
+   { '2', '@' },
+   { '3', '#' },
+   { '4', '$' },
+   { '5', '%' },
+   { '6', '^' },
+   { '7', '&' },
+   { '8', '*' },
+   { '9', '(' }, /* 10 */
+   { '0', ')' },
+   { '-', '_' },
+   { '=', '+' },
+   { 0x8, 0x8 },
+   { 0,   0   },
+   { 'q', 'Q' },
+   { 'w', 'W' },
+   { 'e', 'E' },
+   { 'r', 'R' },
+   { 't', 'T' }, /* 20 */
+   { 'y', 'Y' },
+   { 'u', 'U' },
+   { 'i', 'I' },
+   { 'o', 'O' },
+   { 'p', 'P' },
+   { '[', '{' },
+   { ']', '}' },
+   { 0,   0   },
+   { 0,   0   },
+   { 'a', 'A' }, /* 30 */
+   { 's', 'S' },
+   { 'd', 'D' },
+   { 'f', 'F' },
+   { 'g', 'G' },
+   { 'h', 'H' },
+   { 'j', 'J' },
+   { 'k', 'K' },
+   { 'l', 'L' },
+   { ';', ':' },
+   { '\'', '"' },/* 40 */
+   { '`', '~' },
+   { 0,   0   },
+   { '\\', '|' },
+   { 'z', 'Z' },
+   { 'x', 'X' },
+   { 'c', 'C' },
+   { 'v', 'V' },
+   { 'b', 'B' },
+   { 'n', 'N' },
+   { 'm', 'M' }, /* 50 */
+   { ',', '<' },
+   { '.', '>' },
+   { '/', '?' },
+   { 0,   0   },
+   { '*', '*' },
+   { 0,   0   },
+   { ' ', ' ' },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   }, /* 60 */
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   }, /* 70 */
+   { '7', '7' },
+   { '8', '8' },
+   { '9', '9' },
+   { '-', '-' },
+   { '4', '4' },
+   { '5', '5' },
+   { '6', '6' },
+   { '+', '+' },
+   { '1', '1' },
+   { '2', '2' }, /* 80 */
+   { '3', '3' },
+   { '0', '0' },
+   { '.', '.' },
+   { 0,   0   },
+   { 0,   0   },
+   { '\\', '|' },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   }, /* 90 */
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { '/', '/' },
+   { 0,   0   },
+   { 0,   0   }, /* 100 */
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   }, /* 110 */
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   }, /* 120 */
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   }
+};
+
+void release_handler(int n)
+{
+   if (release_function)
+      release_function();
+   oldrelease_sa.sa_handler(n);
+   sigaction(release_signal, &release_sa, NULL);
+   sigaction(acquire_signal, &acquire_sa, NULL);
+}
+
+void acquire_handler(int n)
+{
+   oldacquire_sa.sa_handler(n);
+   sigaction(release_signal, &release_sa, NULL);
+   sigaction(acquire_signal, &acquire_sa, NULL);
+   keyboard_clearstate();
+   keyboard_clear();
+   if (console_fd >= 0)
+      ioctl(console_fd, KDSETLED, leds);
+   if (acquire_function)
+      acquire_function();
+}
+
+void keyboard_handler(int scancode, int press)
+{
+   static int shift = 0;
+   int shift_mask = 0;
+   struct keyboard_event event;
+   
+   switch (scancode)
+   {
+      case KEY_LSHIFT:
+         shift_mask = 0x01;
+         break;
+      case KEY_RSHIFT:
+         shift_mask = 0x02;
+         break;
+   }
+   
+   if (press)
+      shift |= shift_mask;
+   else
+      shift &= ~shift_mask;
+   
+   event.press = press;   
+   event.scancode = scancode;
+   event.unicode = scancode_to_unicode[scancode][shift? 1:0];
+   keyboard_register_event(&event);
+}
+
+int svga_input_init(void)
+{
+   /* open the mouse here and not in open/close, this is not done
+      because this requires root rights, but because open/close can
+      be called multiple times, and svgalib's mouse_open/close can't
+      handle that */
+   mouse_fd = mouse_init_return_fd("/dev/mouse", vga_getmousetype(),
+      MOUSE_DEFAULTSAMPLERATE);
+   if(mouse_fd < 0)
+   {
+      perror("mouse_init");
+      fprintf(stderr_file,"SVGALib: failed to open mouse device\n");
+   }
+   
+   return 0;
+}
+
+void svga_input_exit(void)
+{
+   if (mouse_fd >= 0)
+      mouse_close();
+}
+
+int svga_input_open(void (*release_func)(void), void (*acquire_func)(void))
+{
+   release_function = release_func;
+   acquire_function = acquire_func;
+   
+   /* newer svgalib's use different signals */
+   if (vga_setmode(-1)<0x1410)
+   {
+      fprintf(stderr_file, "info: svgalib version older then 1.4.1 detected, using old style signals\n");
+      release_signal = SIGUSR1;
+      acquire_signal = SIGUSR2;
+   }
+   else
+   {
+      fprintf(stderr_file, "info: svgalib version 1.4.1 or newer detected, using new style signals\n");
+      release_signal = SIGPROF;
+      acquire_signal = SIGUNUSED;
+   }
+  
+   /* catch console switch signals to enable / disable the vga pass through */
+   memset(&release_sa, 0, sizeof(struct sigaction));
+   memset(&acquire_sa, 0, sizeof(struct sigaction));
+   release_sa.sa_handler = release_handler;
+   acquire_sa.sa_handler = acquire_handler;
+   sigaction(release_signal, &release_sa, &oldrelease_sa);
+   sigaction(acquire_signal, &acquire_sa, &oldacquire_sa);
+
+   /* init the keyboard */
+   if ((console_fd = keyboard_init_return_fd()) < 0)
+   {
+      fprintf(stderr_file, "Svgalib: Error: Couldn't open keyboard\n");
+      return -1;
+   }
+   keyboard_seteventhandler(keyboard_handler);
+   ioctl(console_fd, KDSETLED, leds);
+
+   /* init the mouse */
+   if((mouse_fd >= 0) && use_mouse)
+   {
+	/* fix ranges and initial position of mouse */
+	mouse_setrange_6d(-500,500, -500,500, -500,500, -500,500,
+                  -500,500, -500,500, MOUSE_6DIM);
+	mouse_setposition_6d(0, 0, 0, 0, 0, 0, MOUSE_6DIM);
+   }
+   else
+      use_mouse = 0;
+   
+   return 0;
+}
+
+void svga_input_close(void)
+{
+   /* restore the old handlers */
+   sigaction(release_signal, &oldrelease_sa, NULL);
+   sigaction(acquire_signal, &oldacquire_sa, NULL);
+
+   if (console_fd >= 0)
+   {
+      ioctl(console_fd, KDSETLED, 8);
+      keyboard_close();
+   }
+}
+
+void sysdep_mouse_poll (void)
+{
+	int i, mouse_buttons;
+	
+	if((mouse_fd < 0) || !use_mouse)
+	   return;
+	
+	mouse_update();
+	
+	mouse_getposition_6d(&mouse_data[0].deltas[0],
+           &mouse_data[0].deltas[1],
+           &mouse_data[0].deltas[2],
+           &mouse_data[0].deltas[3],
+           &mouse_data[0].deltas[4],
+           &mouse_data[0].deltas[5]);
+	
+	/* scale down the delta's to some more sane values */
+	for(i=0; i<6; i++)
+	   mouse_data[0].deltas[i] /= 20;
+
+	mouse_buttons = mouse_getbutton();
+
+        for(i=0; i<MOUSE_BUTTONS; i++)
+        {
+           mouse_data[0].buttons[i] = mouse_buttons & (0x01 << i);
+        }
+
+	mouse_setposition_6d(0, 0, 0, 0, 0, 0, MOUSE_6DIM);
+}
+
+void sysdep_set_leds(int new_leds)
+{
+   static int old_leds = 0;
+   
+   if (old_leds != new_leds)
+   {
+      leds = 0;
+      
+      if (new_leds & 0x01)
+         leds |= LED_NUM;
+      if (new_leds & 0x02)
+         leds |= LED_CAP;
+      if (new_leds & 0x04)
+         leds |= LED_SCR;
+      
+      if (console_fd >= 0)
+         ioctl(console_fd, KDSETLED, leds);
+      
+      old_leds = new_leds;
+   }
+}
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/svgainput.h mame-0.36b16/src/unix/video-drivers/svgainput.h
--- ../mmmmm/m36b16/src/unix/video-drivers/svgainput.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/svgainput.h	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,9 @@
+#ifndef __SVGAINPUT_H
+#define __SVGAINPUT_H
+
+int svga_input_init(void);
+int svga_input_open(void (*release_func)(void), void (*aqcuire_func)(void));
+void svga_input_close(void);
+void svga_input_exit(void);
+
+#endif
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/svgalib.c mame-0.36b16/src/unix/video-drivers/svgalib.c
--- ../mmmmm/m36b16/src/unix/video-drivers/svgalib.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/svgalib.c	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,561 @@
+/***************************************************************************
+
+ Linux SVGALib adaptation by Phillip Ezolt pe28+@andrew.cmu.edu
+  
+***************************************************************************/
+#define __SVGALIB_C
+
+#include <math.h>
+#include <vga.h>
+#include <vgagl.h>
+#include "xmame.h"
+#include "svgainput.h"
+
+static int startx, starty;
+static int scaled_visual_width, scaled_visual_height;
+static int video_mode       = -1;
+static int tweaked_mode     = -1;
+static int update_function  = -1;
+static int text_mode        = TRUE;
+static unsigned char *video_mem = NULL;
+static unsigned char *doublebuffer_buffer = NULL;
+static int use_tweak = 0;
+static int use_planar = 1;
+static int use_linear = 0;
+static int center_x = 0;
+static int center_y = 0;
+static vga_modeinfo video_modeinfo;
+static void svgalib_update_linear(struct osd_bitmap *bitmap);
+static void svgalib_update_planar(struct osd_bitmap *bitmap);
+static void svgalib_update_gl(struct osd_bitmap *bitmap);
+static void svgalib_update_gl_scaled(struct osd_bitmap *bitmap);
+static void svgalib_update_linear_16bpp(struct osd_bitmap *bitmap);
+static void svgalib_update_gl_16bpp(struct osd_bitmap *bitmap);
+static void svgalib_update_gl_scaled_16bpp(struct osd_bitmap *bitmap);
+
+struct rc_option display_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "Svgalib Related",	NULL,			rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "tweak",		NULL,			rc_bool,	&use_tweak,
+     "0",		0,			0,		NULL,
+     "Enable/disable svgalib tweaked video modes" },
+   { "planar",		NULL,			rc_bool,	&use_planar,
+     "1",		0,			0,		NULL,
+     "Enable/disable use of planar (modeX) modes (slow)" },
+   { "linear",		NULL,			rc_bool,	&use_linear,
+     "0",		0,			0,		NULL,
+     "Enable/disable use of linear framebuffer (fast)" },
+   { "centerx",		NULL,			rc_int,		&center_x,
+     "0",		0,			0,		NULL,
+     "Adjust the horizontal center of tweaked vga modes" },
+   { "centery",		NULL,			rc_int,		&center_y,
+     "0",		0,			0,		NULL,
+     "Adjust the vertical center of tweaked vga modes" },
+   { NULL,		NULL,			rc_link,	mode_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+
+typedef void (*update_func)(struct osd_bitmap *bitmap);
+
+static update_func update_functions[8] = {
+   svgalib_update_linear,
+   svgalib_update_planar,
+   svgalib_update_gl,
+   svgalib_update_gl_scaled,
+   svgalib_update_linear_16bpp,
+   NULL,
+   svgalib_update_gl_16bpp,
+   svgalib_update_gl_scaled_16bpp
+};
+
+/* tweaked modes */
+#ifdef __CPU_i386
+#include "twkuser.c"
+#include "twkmodes.h"
+
+struct tweaked_mode_struct
+{
+   int width;
+   int height;
+   Register *registers;
+   Register *registers_scanline;
+   int planar;
+   int horizontal_squashed;
+};
+
+/* all available videomodes */
+static struct tweaked_mode_struct tweaked_modes[] = {
+{  384, 256, scr384x256,    NULL,		 1, 0 },
+{  384, 240, scr384x240,    NULL,		 1, 0 },
+{  384, 224, scr384x224,    NULL,		 1, 0 },
+{  336, 240, scr336x240,    NULL,		 1, 0 },
+{  320, 240, scr320x240,    NULL,		 1, 0 },
+{  320, 204, scr320x204,    NULL,                0, 0 },
+{  288, 224, scr288x224,    NULL,                0, 0 },
+{  256, 240, scr256x240,    NULL,                0, 0 },
+{  256, 256, scr256x256,    NULL,                0, 0 },
+{  256, 256, scr256x256ver, NULL,                0, 1 },
+{  240, 256, scr240x256,    NULL,                0, 0 },
+{  224, 288, scr224x288,    scr224x288scanlines, 0, 0 },
+{  200, 320, scr200x320,    NULL,                0, 0 },
+{    0,   0, NULL,          NULL,                0, 0 }
+};
+
+static void set_tweaked_mode(void)
+{
+	if (!text_mode && tweaked_mode >= 0)
+	{
+	   Register *r = tweaked_modes[tweaked_mode].registers;
+	   center_mode(r);
+	   if (use_scanlines)
+	   {
+	      if (tweaked_modes[tweaked_mode].registers_scanline)
+	         r = tweaked_modes[tweaked_mode].registers_scanline;
+	      else
+	         r = make_scanline_mode(r, 21);
+	   }
+	   outRegArray(r, 21);
+	}
+}
+#endif /* ifdef __CPU_i386 */
+
+int sysdep_init(void)
+{
+   vga_init();
+   
+   if(svga_input_init())
+      return OSD_NOT_OK;
+   
+   return OSD_OK;
+}
+
+void sysdep_close(void)
+{
+   svga_input_exit();
+
+   /* close svgalib */
+   vga_setmode(TEXT);
+}
+
+int sysdep_display_16bpp_capable(void)
+{
+   int i;
+   vga_modeinfo *my_modeinfo;
+   
+   for (i=1; (my_modeinfo=vga_getmodeinfo(i)); i++)
+      if( (my_modeinfo->colors == 32768) ||
+          (my_modeinfo->colors == 65536) )
+         return 1;
+         
+   return 0;
+}
+
+int sysdep_set_video_mode (void)
+{
+   int i;
+   
+   if (!text_mode) return OSD_NOT_OK;
+   
+   vga_setmode(video_mode);
+   gl_setcontextvga(video_mode);
+   text_mode = FALSE;
+   set_tweaked_mode();
+
+   if (video_modeinfo.flags & IS_MODEX)
+      update_function=1;
+   else
+   {
+#ifdef __CPU_i386
+      /* do we have a linear framebuffer ? */
+      i = video_modeinfo.width * video_modeinfo.height *
+         video_modeinfo.bytesperpixel;
+      if (i <= 65536 || 
+          (video_modeinfo.flags & IS_LINEAR) ||
+          (use_linear && (video_modeinfo.flags && CAPABLE_LINEAR) &&
+           vga_setlinearaddressing() >=  i))
+      {
+         video_mem  = vga_getgraphmem();
+         video_mem += startx * video_modeinfo.bytesperpixel;
+         video_mem += starty * video_modeinfo.width *
+            video_modeinfo.bytesperpixel;
+         if ((widthscale > 1 || heightscale > 1) &&
+             doublebuffer_buffer == NULL)
+         {
+            doublebuffer_buffer = malloc(scaled_visual_width * 
+               video_modeinfo.bytesperpixel);
+            if (!doublebuffer_buffer)
+            {
+               fprintf(stderr_file, "Svgalib: Error: Couldn't allocate doublebuffer buffer\n");
+               return OSD_NOT_OK;
+            }
+         }
+         update_function=0;
+         fprintf(stderr_file, "Svgalib: Info: Using a linear framebuffer to speed up\n");
+      }
+      else
+#endif
+      {
+         if((widthscale == 1) && (heightscale == 1))
+            update_function=2;
+         else
+            update_function=3;
+         /* we might need the doublebuffer_buffer for 1x1 in 16bpp, since it
+            could be paletised */
+         if( ((widthscale > 1) || (heightscale > 1) || (video_modeinfo.bytesperpixel == 2))
+             && !doublebuffer_buffer)
+         {
+            doublebuffer_buffer = malloc(scaled_visual_width*scaled_visual_height*
+               video_modeinfo.bytesperpixel);
+            if (!doublebuffer_buffer)
+            {
+               fprintf(stderr_file, "Svgalib: Error: Couldn't allocate doublebuffer buffer\n");
+               return OSD_NOT_OK;
+            }
+         }
+      }
+   }
+      
+   if (video_modeinfo.bytesperpixel == 2)
+      update_function+=4;
+   
+   return OSD_OK;
+}
+
+void sysdep_set_text_mode (void)
+{
+   if (text_mode) return;
+   vga_setmode(TEXT);
+   text_mode=TRUE;
+}
+
+/* This name doesn't really cover this function, since it also sets up mouse
+   and keyboard. This is done over here, since on most display targets the
+   mouse and keyboard can't be setup before the display has. */
+int sysdep_create_display(int depth)
+{
+   int i;
+   int score, best_score = 0;
+   vga_modeinfo *my_modeinfo;
+   
+   video_mode       = -1;
+   tweaked_mode     = -1;
+   update_function  = -1;
+   text_mode        = TRUE;
+   video_mem        = NULL;
+   doublebuffer_buffer = NULL;
+   
+   scaled_visual_width  = visual_width  * widthscale;
+   scaled_visual_height = visual_height * heightscale;
+   
+   for (i=1; (my_modeinfo=vga_getmodeinfo(i)); i++)
+   {
+      if(depth == 16)
+      {
+         if(my_modeinfo->colors != 32768 &&
+            my_modeinfo->colors != 65536)
+            continue;
+      }
+      else
+      {
+         if(my_modeinfo->colors != 256)
+            continue;
+         if((my_modeinfo->flags & IS_MODEX) &&
+            (!use_planar || widthscale != 1 || heightscale != 1))
+            continue;
+      }
+      if (!vga_hasmode(i))
+         continue;
+      /* we only want modes which are a multiple of 8 width, due to alignment
+         issues */
+      if (my_modeinfo->width & 7)
+         continue;
+      if (mode_disabled(my_modeinfo->width, my_modeinfo->height, depth))
+         continue;
+      score = mode_match(my_modeinfo->width, my_modeinfo->height);
+      if (score && score >= best_score)
+      {
+         best_score = score;
+         video_mode = i;
+         video_modeinfo = *my_modeinfo;
+      }
+      fprintf(stderr_file, "Svgalib: Info: Found videomode %dx%dx%d\n",
+         my_modeinfo->width, my_modeinfo->height, my_modeinfo->colors);
+   }
+   
+   if (use_tweak && depth == 8 && vga_hasmode(G320x200x256) &&
+       vga_hasmode(G320x240x256))
+   {
+      float orig_display_aspect_ratio = display_aspect_ratio;
+      for(i=0; tweaked_modes[i].width; i++)
+      {
+         if (mode_disabled(tweaked_modes[i].width, tweaked_modes[i].height, depth))
+            continue;
+         if((tweaked_modes[i].planar) &&
+            (!use_planar || widthscale != 1 || heightscale != 1))
+            continue;
+         if (tweaked_modes[i].horizontal_squashed)
+            display_aspect_ratio = display_aspect_ratio * 9.0 / 16.0;
+         score = mode_match(tweaked_modes[i].width, tweaked_modes[i].height);
+         display_aspect_ratio = orig_display_aspect_ratio;
+         if (score && score >= best_score)
+         {
+            best_score   = score;
+            tweaked_mode = i;
+            memset(&video_modeinfo, 0, sizeof(video_modeinfo));
+            if (tweaked_modes[i].planar)
+            {
+               video_mode = G320x240x256;
+               video_modeinfo.bytesperpixel = 0;
+               video_modeinfo.maxpixels     = 262144;
+               video_modeinfo.flags         = IS_MODEX;
+            }
+            else
+            {
+               video_mode = G320x200x256;
+               video_modeinfo.bytesperpixel = 1;
+               video_modeinfo.maxpixels     = 65536;
+               video_modeinfo.flags         = IS_LINEAR;
+            }
+            video_modeinfo.colors = 256;
+            video_modeinfo.width  = video_modeinfo.linewidth =
+               tweaked_modes[i].width;
+            video_modeinfo.height = tweaked_modes[i].height;
+         }
+         fprintf(stderr_file, "Svgalib: Info: Found videomode %dx%dx256\n",
+            tweaked_modes[i].width, tweaked_modes[i].height);
+      }
+   }
+   
+   if (best_score == 0)
+   {
+      fprintf(stderr_file, "Svgalib: Couldn't find a suitable mode for a resolution of %d x %d\n",
+         scaled_visual_width, scaled_visual_height);
+      return OSD_NOT_OK;
+   }
+   
+   fprintf(stderr_file, "Svgalib: Info: Choose videomode %dx%dx%d\n",
+      video_modeinfo.width, video_modeinfo.height, video_modeinfo.colors);
+   
+   startx = ((video_modeinfo.width  - scaled_visual_width ) / 2) & ~7;
+   starty =  (video_modeinfo.height - scaled_visual_height) / 2;
+   
+   if (sysdep_set_video_mode()!=OSD_OK) return OSD_NOT_OK;
+   
+   fprintf(stderr_file, "Using a mode with a resolution of %d x %d, starting at %d x %d\n",
+      video_modeinfo.width, video_modeinfo.height, startx, starty);
+
+   /* fill the display_palette_info struct */
+   memset(&display_palette_info, 0, sizeof(struct sysdep_palette_info));
+   display_palette_info.depth = depth;
+   if (depth == 8)
+      display_palette_info.writable_colors = 256;
+   else
+      if (video_modeinfo.colors == 32768)
+      {
+         display_palette_info.red_mask   = 0x001F;
+         display_palette_info.green_mask = 0x03E0;
+         display_palette_info.blue_mask  = 0xEC00;
+      }
+      else
+      {
+         display_palette_info.red_mask   = 0xF800;
+         display_palette_info.green_mask = 0x07E0;
+         display_palette_info.blue_mask  = 0x001F;
+      }
+
+   /* init input */
+#ifdef __CPU_i386
+   if(svga_input_open(NULL, set_tweaked_mode))
+#else
+   if(svga_input_open(NULL, NULL))
+#endif
+      return OSD_NOT_OK;
+   
+   return OSD_OK;
+}
+
+/* shut up the display */
+void sysdep_display_close(void)
+{
+   /* close input */
+   svga_input_close();
+   
+   /* close svgalib */
+   sysdep_set_text_mode();
+
+   /* and don't forget to free our other resources */
+   if (doublebuffer_buffer)
+   {
+      free(doublebuffer_buffer);
+      doublebuffer_buffer = NULL;
+   }
+}
+
+int sysdep_display_alloc_palette(int writable_colors)
+{
+   return 0;
+}
+
+int sysdep_display_set_pen(int pen,unsigned char red, unsigned char green,
+   unsigned char blue)
+{
+   gl_setpalettecolor(pen,(red>>2),(green>>2),(blue>>2));
+   return 0;
+}
+
+/* Update the display. */
+void sysdep_update_display(struct osd_bitmap *bitmap)
+{
+   int old_use_dirty = use_dirty;
+   
+   if (current_palette->lookup_dirty)
+      use_dirty = 0;
+   
+   update_functions[update_function](bitmap);
+   
+   use_dirty = old_use_dirty;
+}
+
+
+static void svgalib_update_linear(struct osd_bitmap *bitmap)
+{
+#define SRC_PIXEL  unsigned char
+#define DEST_PIXEL unsigned char
+#define DEST video_mem
+#define DEST_WIDTH video_modeinfo.linewidth
+#define DOUBLEBUFFER
+#include "blit.h"
+#undef DEST
+#undef DEST_WIDTH
+#undef DOUBLEBUFFER
+#undef SRC_PIXEL
+#undef DEST_PIXEL
+}
+
+static void svgalib_update_planar(struct osd_bitmap *bitmap)
+{
+  /* use page flipping otherwise the screen tears in planar modes,
+     unfortunatly this also means we can't use dirty in planar modes */
+  static int page=0;
+  if (page) page=0;
+   else page=131072;
+  vga_copytoplanar256(bitmap->line[visual.min_y] + visual.min_x,
+     bitmap->line[1] - bitmap->line[0],
+     (starty*video_modeinfo.width + startx + page)/4,
+      video_modeinfo.width/4, visual_width, visual_height);
+  vga_setdisplaystart(page);
+}
+
+static void svgalib_update_gl(struct osd_bitmap *bitmap)
+{
+   int bitmap_linewidth = (bitmap->line[1] - bitmap->line[0]) /
+      video_modeinfo.bytesperpixel;
+#define PUT_IMAGE(X, Y, WIDTH, HEIGHT) \
+      gl_putboxpart( \
+         startx + X, starty + Y, \
+         WIDTH, HEIGHT, \
+         bitmap_linewidth, bitmap->height, \
+         bitmap->line[0], X + visual.min_x, Y + visual.min_y);
+         /* Note: we calculate the real bitmap->width, as used in
+            osd_create_bitmap, this fixes the scewing bug in tempest
+            & others */
+#include "blit.h"
+#undef PUT_IMAGE
+}
+
+static void svgalib_update_gl_scaled(struct osd_bitmap *bitmap)
+{
+#define SRC_PIXEL  unsigned char
+#define DEST_PIXEL unsigned char
+#define DEST doublebuffer_buffer
+#define DEST_WIDTH scaled_visual_width
+#define PUT_IMAGE(X, Y, WIDTH, HEIGHT) \
+      gl_putboxpart( \
+         startx + X, starty + Y, \
+         WIDTH, HEIGHT, \
+         scaled_visual_width, scaled_visual_height, \
+         doublebuffer_buffer, X, Y );
+#include "blit.h"
+#undef DEST
+#undef DEST_WIDTH
+#undef PUT_IMAGE
+#undef SRC_PIXEL
+#undef DEST_PIXEL
+}
+
+static void svgalib_update_linear_16bpp(struct osd_bitmap *bitmap)
+{
+   int linewidth = video_modeinfo.linewidth/2;
+#define SRC_PIXEL  unsigned short
+#define DEST_PIXEL unsigned short
+#define DEST video_mem
+#define DEST_WIDTH linewidth
+#define DOUBLEBUFFER
+   if(current_palette->lookup)
+   {
+#define INDIRECT current_palette->lookup
+#include "blit.h"
+#undef INDIRECT
+   }
+   else
+   {
+#include "blit.h"
+   }
+#undef DEST
+#undef DEST_WIDTH
+#undef DOUBLEBUFFER
+#undef SRC_PIXEL
+#undef DEST_PIXEL
+}
+
+static void svgalib_update_gl_16bpp(struct osd_bitmap *bitmap)
+{
+   if(current_palette->lookup)
+   {
+      /* since we need the lookups we need to go through an extra buffer,
+         just like svgalib_update_gl_scaled_16bpp() does */
+      svgalib_update_gl_scaled_16bpp(bitmap);
+   }
+   else
+   {
+      /* we can just call svgalib_update_gl which only uses gllib functions
+         and thus doesn't care about 8 / 16 bpp */
+      svgalib_update_gl(bitmap);
+   }
+}
+
+static void svgalib_update_gl_scaled_16bpp(struct osd_bitmap *bitmap)
+{
+#define SRC_PIXEL  unsigned short
+#define DEST_PIXEL unsigned short
+#define DEST doublebuffer_buffer
+#define DEST_WIDTH scaled_visual_width
+#define PUT_IMAGE(X, Y, WIDTH, HEIGHT) \
+      gl_putboxpart( \
+         startx + X, starty + Y, \
+         WIDTH, HEIGHT, \
+         scaled_visual_width, scaled_visual_height, \
+         doublebuffer_buffer, X, Y );
+   if(current_palette->lookup)
+   {
+#define INDIRECT current_palette->lookup
+#include "blit.h"
+#undef INDIRECT
+   }
+   else
+   {
+#include "blit.h"
+   }
+#undef DEST
+#undef DEST_WIDTH
+#undef PUT_IMAGE
+#undef SRC_PIXEL
+#undef DEST_PIXEL
+}
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/twkmodes.h mame-0.36b16/src/unix/video-drivers/twkmodes.h
--- ../mmmmm/m36b16/src/unix/video-drivers/twkmodes.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/twkmodes.h	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,470 @@
+#ifndef __TWKMODES_H
+#define __TWKMODES_H
+
+/* Tweaked modes definitions, taken from mame-dos */
+
+/* indices into our register array */
+#define	CLOCK_INDEX		0
+#define	H_TOTAL_INDEX		1
+#define	H_DISPLAY_INDEX		2
+#define	H_BLANKING_START_INDEX	3
+#define	H_BLANKING_END_INDEX	4
+#define	H_RETRACE_START_INDEX	5
+#define	H_RETRACE_END_INDEX	6
+#define	V_TOTAL_INDEX		7
+#define	OVERFLOW_INDEX		8
+#define	MAXIMUM_SCANLINE_INDEX	10
+#define	V_RETRACE_START_INDEX	11
+#define	V_RETRACE_END_INDEX	12
+#define	V_END_INDEX		13
+#define	MEM_OFFSET_INDEX	14
+#define	UNDERLINE_LOC_INDEX	15
+#define	V_BLANKING_START_INDEX	16
+#define	V_BLANKING_END_INDEX	17
+#define MODE_CONTROL_INDEX	18
+#define	MEMORY_MODE_INDEX	20
+
+/* -----------------------------------------------------------------------------------------*/
+/* NOTES:                                                                                   */
+/* horizontal/vertical retrace and blanking timings are genereted by - center_mode()        */
+/* most 'scanline' versions of tweaked modes are generated by        - make_scanline_mode() */
+/* but some mode's need a custom scanline register set                                      */
+/* -----------------------------------------------------------------------------------------*/
+
+/* PC Monitor Tweaked Modes */
+/* ------------------------ */
+
+
+/* 224x288 - vertical mode */
+/* Dot Clock - 28MHz */
+/* Horizontal Scanrate ~ 35.0KHz*/
+/* Vertical Refresh Rate ~60Hz */
+/* Mode Type - Linear */
+/* Notes: uses a very high horizontal scanrate to fit 288 display lines into 60Hz refresh cycle */
+Register scr224x288[] =
+{
+	{ 0x3c2, 0x00, 0xe7},{ 0x3d4, 0x00, 0x5f},{ 0x3d4, 0x01, 0x37},
+	{ 0x3d4, 0x02, 0x38},{ 0x3d4, 0x03, 0x82},{ 0x3d4, 0x04, 0x49},
+	{ 0x3d4, 0x05, 0x9a},{ 0x3d4, 0x06, 0x54},{ 0x3d4, 0x07, 0xf0},
+	{ 0x3d4, 0x08, 0x00},{ 0x3d4, 0x09, 0x61},{ 0x3d4, 0x10, 0x40},
+	{ 0x3d4, 0x11, 0xac},{ 0x3d4, 0x12, 0x3f},{ 0x3d4, 0x13, 0x1c},
+	{ 0x3d4, 0x14, 0x40},{ 0x3d4, 0x15, 0x40},{ 0x3d4, 0x16, 0x4a},
+	{ 0x3d4, 0x17, 0xa3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x0e}
+};
+
+Register scr224x288scanlines[] =
+{
+	{ 0x3c2, 0x00, 0xe3},{ 0x3d4, 0x00, 0x5f},{ 0x3d4, 0x01, 0x37},
+	{ 0x3d4, 0x02, 0x38},{ 0x3d4, 0x03, 0x82},{ 0x3d4, 0x04, 0x4a},
+	{ 0x3d4, 0x05, 0x9a},{ 0x3d4, 0x06, 0x43},{ 0x3d4, 0x07, 0x1f},
+	{ 0x3d4, 0x08, 0x00},{ 0x3d4, 0x09, 0x60},{ 0x3d4, 0x10, 0x2a},
+	{ 0x3d4, 0x11, 0xac},{ 0x3d4, 0x12, 0x1f},{ 0x3d4, 0x13, 0x1c},
+	{ 0x3d4, 0x14, 0x40},{ 0x3d4, 0x15, 0x27},{ 0x3d4, 0x16, 0x3a},
+	{ 0x3d4, 0x17, 0xa3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x0e}
+};
+
+/* Dot Clock - 28MHz */
+/* Horizontal Scanrate ~ 32.4KHz*/
+/* Vertical Refresh Rate ~60Hz */
+/* Mode Type - Linear */
+/* Notes: uses a high horizontal scanrate to fit 256 display lines into 60Hz refresh cycle */
+Register scr240x256[] =
+{
+	{ 0x3c2, 0x00, 0xe7},{ 0x3D4, 0x00, 0x67},{ 0x3d4, 0x01, 0x3b},
+	{ 0x3d4, 0x02, 0x40},{ 0x3D4, 0x03, 0x42},{ 0x3d4, 0x04, 0x4e},
+	{ 0x3d4, 0x05, 0x9a},{ 0x3D4, 0x06, 0x23},{ 0x3d4, 0x07, 0xb2},
+	{ 0x3d4, 0x08, 0x00},{ 0x3D4, 0x09, 0x61},{ 0x3d4, 0x10, 0x0a},
+	{ 0x3d4, 0x11, 0xac},{ 0x3D4, 0x12, 0xff},{ 0x3d4, 0x13, 0x1e},
+	{ 0x3d4, 0x14, 0x40},{ 0x3d4, 0x15, 0x07},{ 0x3D4, 0x16, 0x11},
+	{ 0x3d4, 0x17, 0xa3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x0e}
+};
+
+/* 256x240 - horizontal mode */
+/* Dot Clock - 25MHz */
+/* Horizontal Scanrate ~ 34.7KHz*/
+/* Vertical Refresh Rate ~60Hz */
+/* Mode Type - Linear */
+Register scr256x240[] =
+{
+	{ 0x3c2, 0x00, 0xe3},{ 0x3d4, 0x00, 0x55},{ 0x3d4, 0x01, 0x3f},
+	{ 0x3d4, 0x02, 0x80},{ 0x3d4, 0x03, 0x90},{ 0x3d4, 0x04, 0x49},
+	{ 0x3d4, 0x05, 0x80},{ 0x3D4, 0x06, 0x43},{ 0x3d4, 0x07, 0xb2},
+	{ 0x3d4, 0x08, 0x00},{ 0x3D4, 0x09, 0x61},{ 0x3d4, 0x10, 0x04},
+	{ 0x3d4, 0x11, 0xac},{ 0x3D4, 0x12, 0xdf},{ 0x3d4, 0x13, 0x20},
+	{ 0x3d4, 0x14, 0x40},{ 0x3d4, 0x15, 0x07},{ 0x3D4, 0x16, 0x11},
+	{ 0x3d4, 0x17, 0xa3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x0e}
+};
+
+/* 256x256 - horizontal mode */
+/* Dot Clock - 25MHz */
+/* Horizontal Scanrate ~34.7KHz*/
+/* Vertical Refresh Rate ~57Hz */
+/* Mode Type - Linear */
+Register scr256x256[] =
+{
+	{ 0x3c2, 0x00, 0xe3},{ 0x3d4, 0x00, 0x55},{ 0x3d4, 0x01, 0x3f},
+	{ 0x3d4, 0x02, 0x40},{ 0x3d4, 0x03, 0x90},{ 0x3d4, 0x04, 0x49},
+	{ 0x3d4, 0x05, 0x80},{ 0x3D4, 0x06, 0x60},{ 0x3d4, 0x07, 0xb2},
+	{ 0x3d4, 0x08, 0x00},{ 0x3D4, 0x09, 0x61},{ 0x3d4, 0x10, 0x28},
+	{ 0x3d4, 0x11, 0xac},{ 0x3D4, 0x12, 0xff},{ 0x3d4, 0x13, 0x20},
+	{ 0x3d4, 0x14, 0x40},{ 0x3d4, 0x15, 0x07},{ 0x3D4, 0x16, 0x11},
+	{ 0x3d4, 0x17, 0xa3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x0e}
+};
+
+/* 256x256 - vertical mode */
+/* Dot Clock - 28MHz */
+/* Horizontal Scanrate ~ 31KHz*/
+/* Vertical Refresh Rate ~57Hz */
+/* Mode Type - Linear */
+/* Notes: uses a faster dot clock than horizontal the 256x256 mode to make a thinner display */
+Register scr256x256ver[] =
+{
+	{ 0x3c2, 0x00, 0xe7},{ 0x3D4, 0x00, 0x6c},{ 0x3d4, 0x01, 0x3f},
+	{ 0x3d4, 0x02, 0x40},{ 0x3D4, 0x03, 0x42},{ 0x3d4, 0x04, 0x51},
+	{ 0x3d4, 0x05, 0x9a},{ 0x3D4, 0x06, 0x23},{ 0x3d4, 0x07, 0xb2},
+	{ 0x3d4, 0x08, 0x00},{ 0x3D4, 0x09, 0x61},{ 0x3d4, 0x10, 0x0a},
+	{ 0x3d4, 0x11, 0xac},{ 0x3D4, 0x12, 0xff},{ 0x3d4, 0x13, 0x20},
+	{ 0x3d4, 0x14, 0x40},{ 0x3d4, 0x15, 0x07},{ 0x3D4, 0x16, 0x11},
+	{ 0x3d4, 0x17, 0xa3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x0e}
+};
+
+/* 288x224 - horizontal mode */
+/* Dot Clock - 25MHz */
+/* Horizontal Scanrate ~31.2KHz*/
+/* Vertical Refresh Rate ~60Hz */
+/* Mode Type - Linear */
+Register scr288x224[] =
+{
+	{ 0x3c2, 0x00, 0xe3},{ 0x3d4, 0x00, 0x5f},{ 0x3d4, 0x01, 0x47},
+	{ 0x3d4, 0x02, 0x49},{ 0x3d4, 0x03, 0x90},{ 0x3d4, 0x04, 0x50},
+	{ 0x3d4, 0x05, 0x80},{ 0x3d4, 0x06, 0x0c},{ 0x3d4, 0x07, 0x3e},
+	{ 0x3d4, 0x08, 0x00},{ 0x3d4, 0x09, 0x41},{ 0x3d4, 0x10, 0xd8},
+	{ 0x3d4, 0x11, 0xac},{ 0x3d4, 0x12, 0xbf},{ 0x3d4, 0x13, 0x24},
+	{ 0x3d4, 0x14, 0x40},{ 0x3d4, 0x15, 0xc2},{ 0x3d4, 0x16, 0xf4},
+	{ 0x3d4, 0x17, 0xa3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x0e}
+};
+
+/* 240x320 - vertical mode */
+/* Dot Clock - 28MHz */
+/* Horizontal Scanrate ~36.8KHz*/
+/* Vertical Refresh Rate ~56Hz */
+/* Mode Type - Planar */
+/* Notes: uses a very high horizontal scanrate to fit 320 display lines into 56Hz refresh cycle */
+Register scr240x320[] =
+{
+	{ 0x3c2, 0x00, 0xe7},{ 0x3d4, 0x00, 0x5a},{ 0x3d4, 0x01, 0x3b},
+	{ 0x3d4, 0x02, 0x3c},{ 0x3d4, 0x03, 0x96},{ 0x3d4, 0x04, 0x47},
+	{ 0x3d4, 0x05, 0x14},{ 0x3d4, 0x06, 0x8c},{ 0x3d4, 0x07, 0xf0},
+	{ 0x3d4, 0x08, 0x00},{ 0x3d4, 0x09, 0x61},{ 0x3d4, 0x10, 0x80},
+	{ 0x3d4, 0x11, 0x92},{ 0x3d4, 0x12, 0x7f},{ 0x3d4, 0x13, 0x1e},
+	{ 0x3d4, 0x14, 0x00},{ 0x3d4, 0x15, 0x80},{ 0x3d4, 0x16, 0x84},
+	{ 0x3d4, 0x17, 0xe3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x06}
+};
+
+/* 320x240 - horizontal mode */
+/* Dot Clock - 25MHz */
+/* Horizontal Scanrate ~ 31.2KHz*/
+/* Vertical Refresh Rate ~60Hz */
+/* Mode Type - Planar */
+Register scr320x240[] =
+{
+	{ 0x3c2, 0x00, 0xe3},{ 0x3d4, 0x00, 0x5f},{ 0x3d4, 0x01, 0x4f},
+	{ 0x3d4, 0x02, 0x50},{ 0x3d4, 0x03, 0x82},{ 0x3d4, 0x04, 0x54},
+	{ 0x3d4, 0x05, 0x80},{ 0x3d4, 0x06, 0x0c},{ 0x3d4, 0x07, 0x3e},
+	{ 0x3d4, 0x08, 0x00},{ 0x3d4, 0x09, 0x41},{ 0x3d4, 0x10, 0xe9},
+	{ 0x3d4, 0x11, 0xac},{ 0x3d4, 0x12, 0xdf},{ 0x3d4, 0x13, 0x28},
+	{ 0x3d4, 0x14, 0x00},{ 0x3d4, 0x15, 0xe7},{ 0x3d4, 0x16, 0x06},
+	{ 0x3d4, 0x17, 0xe3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x06}
+};
+
+/* 336x240 - horizontal mode */
+/* Dot Clock - 25MHz */
+/* Horizontal Scanrate ~ 31.2KHz*/
+/* Vertical Refresh Rate ~60Hz */
+/* Mode Type - Planar */
+Register scr336x240[] =
+{
+	{ 0x3c2, 0x00, 0xe3},{ 0x3d4, 0x00, 0x5f},{ 0x3d4, 0x01, 0x53},
+	{ 0x3d4, 0x02, 0x56},{ 0x3d4, 0x03, 0x80},{ 0x3d4, 0x04, 0x57},
+	{ 0x3d4, 0x05, 0x9b},{ 0x3d4, 0x06, 0x0c},{ 0x3d4, 0x07, 0x3e},
+	{ 0x3d4, 0x08, 0x00},{ 0x3d4, 0x09, 0x41},{ 0x3d4, 0x10, 0xe5},
+	{ 0x3d4, 0x11, 0xac},{ 0x3d4, 0x12, 0xdf},{ 0x3d4, 0x13, 0x2a},
+	{ 0x3d4, 0x14, 0x00},{ 0x3d4, 0x15, 0xe8},{ 0x3d4, 0x16, 0x02},
+	{ 0x3d4, 0x17, 0xe3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x06}
+};
+
+/* 384x224 - horizontal mode */
+/* Dot Clock - 28MHz */
+/* Horizontal Scanrate ~ 31KHz*/
+/* Vertical Refresh Rate ~60Hz */
+/* Mode Type - Planar */
+/* Notes: this mode is basically identical to 384x240, but allows VGA triple buffering */
+Register scr384x224[] =
+{
+	{ 0x3c2, 0x00, 0xe7},{ 0x3d4, 0x00, 0x6c},{ 0x3d4, 0x01, 0x5f},
+	{ 0x3d4, 0x02, 0x61},{ 0x3d4, 0x03, 0x8b},{ 0x3d4, 0x04, 0x62},
+	{ 0x3d4, 0x05, 0x86},{ 0x3d4, 0x06, 0x0c},{ 0x3d4, 0x07, 0x3e},
+	{ 0x3d4, 0x08, 0x00},{ 0x3d4, 0x09, 0x41},{ 0x3d4, 0x10, 0xd8},
+	{ 0x3d4, 0x11, 0xac},{ 0x3d4, 0x12, 0xbf},{ 0x3d4, 0x13, 0x30},
+	{ 0x3d4, 0x14, 0x00},{ 0x3d4, 0x15, 0xc2},{ 0x3d4, 0x16, 0xf4},
+	{ 0x3d4, 0x17, 0xe3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x06}
+};
+
+/* 384x240 - horizontal mode */
+/* Dot Clock - 28MHz */
+/* Horizontal Scanrate ~ 31KHz*/
+/* Vertical Refresh Rate ~60Hz */
+/* Mode Type - Planar */
+Register scr384x240[] =
+{
+	{ 0x3c2, 0x00, 0xe7},{ 0x3d4, 0x00, 0x6c},{ 0x3d4, 0x01, 0x5f},
+	{ 0x3d4, 0x02, 0x61},{ 0x3d4, 0x03, 0x8b},{ 0x3d4, 0x04, 0x62},
+	{ 0x3d4, 0x05, 0x86},{ 0x3d4, 0x06, 0x0c},{ 0x3d4, 0x07, 0x3e},
+	{ 0x3d4, 0x08, 0x00},{ 0x3d4, 0x09, 0x41},{ 0x3d4, 0x10, 0xe9},
+	{ 0x3d4, 0x11, 0xac},{ 0x3d4, 0x12, 0xdf},{ 0x3d4, 0x13, 0x30},
+	{ 0x3d4, 0x14, 0x00},{ 0x3d4, 0x15, 0xe8},{ 0x3d4, 0x16, 0x04},
+	{ 0x3d4, 0x17, 0xe3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x06}
+};
+
+/* 384x256 - horizontal mode */
+/* Dot Clock - 28MHz */
+/* Horizontal Scanrate ~ 31KHz*/
+/* Vertical Refresh Rate ~57Hz */
+/* Mode Type - Planar */
+Register scr384x256[] =
+{
+	{ 0x3c2, 0x00, 0xe7},{ 0x3d4, 0x00, 0x6c},{ 0x3d4, 0x01, 0x5f},
+	{ 0x3d4, 0x02, 0x61},{ 0x3d4, 0x03, 0x8b},{ 0x3d4, 0x04, 0x62},
+	{ 0x3d4, 0x05, 0x86},{ 0x3D4, 0x06, 0x23},{ 0x3d4, 0x07, 0x36},
+	{ 0x3d4, 0x08, 0x00},{ 0x3D4, 0x09, 0x61},{ 0x3d4, 0x10, 0xff},
+	{ 0x3d4, 0x11, 0xac},{ 0x3D4, 0x12, 0xff},{ 0x3d4, 0x13, 0x30},
+	{ 0x3d4, 0x14, 0x00},{ 0x3d4, 0x15, 0x07},{ 0x3D4, 0x16, 0x11},
+	{ 0x3d4, 0x17, 0xe3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x06}
+};
+
+/* old svgalib tweak modes */
+
+/* 320x204 - horizontal mode */
+/* Mode Type - Linear */
+Register scr320x204[] =
+{
+	{ 0x3c2, 0x00, 0xe3},{ 0x3d4, 0x00, 0x5f},{ 0x3d4, 0x01, 0x4f},
+	{ 0x3d4, 0x02, 0x50},{ 0x3d4, 0x03, 0x82},{ 0x3d4, 0x04, 0x54},
+	{ 0x3d4, 0x05, 0x80},{ 0x3d4, 0x06, 0xbf},{ 0x3d4, 0x07, 0x1f},
+	{ 0x3d4, 0x08, 0x00},{ 0x3d4, 0x09, 0x41},{ 0x3d4, 0x10, 0x9c},
+	{ 0x3d4, 0x11, 0x8e},{ 0x3d4, 0x12, 0x97},{ 0x3d4, 0x13, 0x28},
+	{ 0x3d4, 0x14, 0x40},{ 0x3d4, 0x15, 0x96},{ 0x3d4, 0x16, 0xb9},
+	{ 0x3d4, 0x17, 0xa3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x0e},
+};
+
+/* 200x320 - vertical mode */
+/* Mode Type - Linear */
+Register scr200x320[] =
+{
+	{ 0x3c2, 0x00, 0xe3},{ 0x3d4, 0x00, 0x5f},{ 0x3d4, 0x01, 0x31},
+	{ 0x3d4, 0x02, 0x38},{ 0x3d4, 0x03, 0x82},{ 0x3d4, 0x04, 0x4a},
+	{ 0x3d4, 0x05, 0x9a},{ 0x3d4, 0x06, 0x4e},{ 0x3d4, 0x07, 0x1f},
+	{ 0x3d4, 0x08, 0x00},{ 0x3d4, 0x09, 0x40},{ 0x3d4, 0x10, 0x40},
+	{ 0x3d4, 0x11, 0x90},{ 0x3d4, 0x12, 0x3f},{ 0x3d4, 0x13, 0x19},
+	{ 0x3d4, 0x14, 0x40},{ 0x3d4, 0x15, 0x80},{ 0x3d4, 0x16, 0x40},
+	{ 0x3d4, 0x17, 0xa3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x0e}
+};
+
+Register *make_scanline_mode(Register *inreg,int entries)
+{
+	static Register outreg[32];
+	int maxscan,maxscanout;
+	int overflow,overflowout;
+	int ytotalin,ytotalout;
+	int ydispin,ydispout;
+	int vrsin,vrsout,vreout,vblksout,vblkeout;
+/* first - check's it not already a 'non doubled' line mode */
+	maxscan = inreg[MAXIMUM_SCANLINE_INDEX].value;
+	if ((maxscan & 1) == 0)
+	/* it is, so just return the array as is */
+  		return inreg;
+/* copy across our standard display array */
+	memcpy (&outreg, inreg, entries * sizeof(Register));
+/* keep hold of the overflow register - as we'll need to refer to it a lot */
+	overflow = inreg[OVERFLOW_INDEX].value;
+/* set a large line compare value  - as we won't be doing any split window scrolling etc.*/
+	maxscanout = 0x40;
+/* half all the y values */
+/* total */
+	ytotalin = inreg[V_TOTAL_INDEX].value;
+	ytotalin |= ((overflow & 1)<<0x08) | ((overflow & 0x20)<<0x04);
+    ytotalout = ytotalin >> 1;
+/* display enable end */
+	ydispin = inreg[13].value | ((overflow & 0x02)<< 0x07) | ((overflow & 0x040) << 0x03);
+	ydispin ++;
+	ydispout = ydispin >> 1;
+	ydispout --;
+	overflowout = ((ydispout & 0x100) >> 0x07) | ((ydispout && 0x200) >> 0x03);
+	outreg[V_END_INDEX].value = (ydispout & 0xff);
+/* avoid top over scan */
+	if ((ytotalin - ydispin) < 40 && !center_y)
+	{
+  		vrsout = ydispout;
+		/* give ourselves a scanline cushion */
+		ytotalout += 2;
+	}
+  	else
+	{
+/* vertical retrace start */
+		vrsin = inreg[V_RETRACE_START_INDEX].value | ((overflow & 0x04)<<0x06) | ((overflow & 0x80)<<0x02);
+		vrsout = vrsin >> 1;
+	}
+/* check it's legal */
+	if (vrsout < ydispout)
+		vrsout = ydispout;
+/*update our output overflow */
+	overflowout |= (((vrsout & 0x100) >> 0x06) | ((vrsout & 0x200) >> 0x02));
+	outreg[V_RETRACE_START_INDEX].value = (vrsout & 0xff);
+/* vertical retrace end */
+	vreout = vrsout + 2;
+/* make sure the retrace fits into our adjusted display size */
+	if (vreout > (ytotalout - 9))
+		ytotalout = vreout + 9;
+/* write out the vertical retrace end */
+	outreg[V_RETRACE_END_INDEX].value &= ~0x0f;
+	outreg[V_RETRACE_END_INDEX].value |= (vreout & 0x0f);
+/* vertical blanking start */
+	vblksout = ydispout + 1;
+/* check it's legal */
+	if(vblksout > vreout)
+		vblksout = vreout;
+/* save the overflow value */
+	overflowout |= ((vblksout & 0x100) >> 0x05);
+	maxscanout |= ((vblksout & 0x200) >> 0x04);
+/* write the v blank value out */
+	outreg[V_BLANKING_START_INDEX].value = (vblksout & 0xff);
+/* vertical blanking end */
+	vblkeout = vreout + 1;
+/* make sure the blanking fits into our adjusted display size */
+	if (vblkeout > (ytotalout - 9))
+		ytotalout = vblkeout + 9;
+/* write out the vertical blanking total */
+	outreg[V_BLANKING_END_INDEX].value = (vblkeout & 0xff);
+/* update our output overflow */
+	overflowout |= ((ytotalout & 0x100) >> 0x08) | ((ytotalout & 0x200) >> 0x04);
+/* write out the new vertical total */
+	outreg[V_TOTAL_INDEX].value = (ytotalout & 0xff);
+
+/* write out our over flows */
+	outreg[OVERFLOW_INDEX].value = overflowout;
+/* finally the max scan line */
+	outreg[MAXIMUM_SCANLINE_INDEX].value = maxscanout;
+/* and we're done */
+	return outreg;
+
+}
+
+void center_mode(Register *pReg)
+{
+	int center;
+	int hrt_start, hrt_end, hrt, hblnk_start, hblnk_end;
+	int vrt_start, vrt_end, vert_total, vert_display, vblnk_start, vrt, vblnk_end;
+/* check for empty array */
+	if (!pReg)
+		return;
+/* vertical retrace width */
+	vrt = 2;
+/* check the clock speed, to work out the retrace width */
+	if (pReg[CLOCK_INDEX].value == 0xe7)
+		hrt = 11;
+	else
+		hrt = 10;
+/* our center x tweak value */
+	center = center_x;
+/* check for double width scanline rather than half clock (15.75kHz modes) */
+	if( pReg[H_TOTAL_INDEX].value > 0x96)
+	{
+		center<<=1;
+		hrt<<=1;
+	}
+/* set the hz retrace */
+	hrt_start = pReg[H_RETRACE_START_INDEX].value;
+	hrt_start += center;
+/* make sure it's legal */
+	if (hrt_start <= pReg[H_DISPLAY_INDEX].value)
+		hrt_start = pReg[H_DISPLAY_INDEX].value + 1;
+	pReg[H_RETRACE_START_INDEX].value = hrt_start;
+/* set hz retrace end */
+	hrt_end = hrt_start + hrt;
+/* make sure it's legal */
+	if( hrt_end > pReg[H_TOTAL_INDEX].value)
+		hrt_end = pReg[H_TOTAL_INDEX].value;
+
+/* set the hz blanking */
+	hblnk_start = pReg[H_DISPLAY_INDEX].value + 1;
+/* make sure it's legal */
+	if (hblnk_start > hrt_start)
+		hblnk_start = pReg[H_RETRACE_START_INDEX].value;
+
+	pReg[H_BLANKING_START_INDEX].value = hblnk_start;
+/* the horizontal blanking end */
+	hblnk_end = hrt_end + 2;
+/* make sure it's legal */
+	if( hblnk_end > pReg[H_TOTAL_INDEX].value)
+		hblnk_end = pReg[H_TOTAL_INDEX].value;
+/* write horizontal blanking - include 7th test bit (always 1) */
+	pReg[H_BLANKING_END_INDEX].value = (hblnk_end & 0x1f) | 0x80;
+/* include the 5th bit of the horizontal blanking in the horizontal retrace reg. */
+	hrt_end = ((hrt_end & 0x1f) | ((hblnk_end & 0x20) << 2));
+	pReg[H_RETRACE_END_INDEX].value = hrt_end;
+
+
+/* get the vt retrace */
+	vrt_start = pReg[V_RETRACE_START_INDEX].value | ((pReg[OVERFLOW_INDEX].value & 0x04) << 6) |
+				((pReg[OVERFLOW_INDEX].value & 0x80) << 2);
+
+/* set the new retrace start */
+	vrt_start += center_y;
+/* check it's legal, get the display line count */
+	vert_display = (pReg[V_END_INDEX].value | ((pReg[OVERFLOW_INDEX].value & 0x02) << 7) |
+				((pReg[OVERFLOW_INDEX].value & 0x40) << 3)) + 1;
+
+	if (vrt_start < vert_display)
+		vrt_start = vert_display;
+
+/* and get the vertical line count */
+	vert_total = pReg[V_TOTAL_INDEX].value | ((pReg[OVERFLOW_INDEX].value & 0x01) << 8) |
+				((pReg[OVERFLOW_INDEX].value & 0x20) << 4);
+
+
+
+	pReg[V_RETRACE_START_INDEX].value = (vrt_start & 0xff);
+	pReg[OVERFLOW_INDEX].value &= ~0x84;
+	pReg[OVERFLOW_INDEX].value |= ((vrt_start & 0x100) >> 6);
+	pReg[OVERFLOW_INDEX].value |= ((vrt_start & 0x200) >> 2);
+	vrt_end = vrt_start + vrt;
+
+
+	if (vrt_end > vert_total)
+		vrt_end = vert_total;
+
+/* write retrace end, include CRT protection and IRQ2 bits */
+	pReg[V_RETRACE_END_INDEX].value = (vrt_end  & 0x0f) | 0x80 | 0x20;
+
+/* get the start of vt blanking */
+	vblnk_start = vert_display + 1;
+/* check it's legal */
+	if (vblnk_start > vrt_start)
+		vblnk_start = vrt_start;
+/* and the end */
+	vblnk_end = vrt_end + 2;
+/* check it's legal */
+	if (vblnk_end > vert_total)
+		vblnk_end = vert_total;
+/* set vblank start */
+	pReg[V_BLANKING_START_INDEX].value = (vblnk_start & 0xff);
+/* write out any overflows */
+	pReg[OVERFLOW_INDEX].value &= ~0x08;
+	pReg[OVERFLOW_INDEX].value |= ((vblnk_start & 0x100) >> 5);
+	pReg[MAXIMUM_SCANLINE_INDEX].value &= ~0x20;
+	pReg[MAXIMUM_SCANLINE_INDEX].value |= ((vblnk_start &0x200) >> 4);
+/* set the vblank end */
+	pReg[V_BLANKING_END_INDEX].value = (vblnk_end & 0xff);
+}
+
+#endif /* ifndef __TWKMODES_H */
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/twkuser.c mame-0.36b16/src/unix/video-drivers/twkuser.c
--- ../mmmmm/m36b16/src/unix/video-drivers/twkuser.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/twkuser.c	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,147 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+/* make ansi compilation happy */
+#define inline __inline__
+#include <asm/io.h>
+#undef inline
+#include "twkuser.h"
+
+/*
+    readyVgaRegs() does the initialization to make the VGA ready to
+	accept any combination of configuration register settings.
+
+	This involves enabling writes to index 0 to 7 of the CRT controller
+	(port 0x3d4), by clearing the most significant bit (bit 7) of index
+	0x11.
+*/
+
+void readyVgaRegs(void)
+	{
+	int v;
+
+	   /*
+	   outportb(0x3d4,0x11);
+    v = inportb(0x3d5) & 0x7f;
+	outportb(0x3d4,0x11);
+	outportb(0x3d5,v);
+	   */
+	   
+	   outb(0x11,0x3d4);
+	   v = inb(0x3d5) & 0x7f;
+	   outb(0x11,0x3d4);
+	   outb(v,0x3d5);
+	   
+	
+	}
+
+/*
+	outReg sets a single register according to the contents of the
+	passed Register structure.
+*/
+
+void outReg(Register r)
+	{
+	switch (r.port)
+		{
+		/* First handle special cases: */
+
+		case ATTRCON_ADDR:
+			inb(STATUS_ADDR);  		/* reset read/write flip-flop */
+			outb(r.index | 0x20,ATTRCON_ADDR);
+										/* ensure VGA output is enabled */
+			outb(r.value,ATTRCON_ADDR);
+			break;
+
+		case MISC_ADDR:
+		case VGAENABLE_ADDR:
+			outb(r.value,r.port);	/*	directly to the port */
+			break;
+
+		case SEQ_ADDR:
+		case GRACON_ADDR:
+		case CRTC_ADDR:
+		default:						/* This is the default method: */
+			outb(r.index,r.port);	/*	index to port			   */
+			outb(r.value,r.port+1);/*	value to port+1 		   */
+			break;
+		}
+	}
+
+
+/*
+	outRegArray sets n registers according to the array pointed to by r.
+	First, indexes 0-7 of the CRT controller are enabled for writing.
+*/
+
+void outRegArray(Register *r, int n)
+	{
+    readyVgaRegs();
+	while (n--)
+		outReg(*r++);
+	}
+
+
+/*
+	loadRegArray opens the given file, does some validity checking, then
+	reads the entire file into an array of Registers, which is returned
+	via the array parameter.
+
+	You will probably want to provide your own error handling code in
+	this function, as it never aborts the program, rather than just
+	printing an error message and returning NULL.
+
+	The returned value is the number of Registers read.  The &array
+	parameter is set to the allocated Register array.
+
+	If you use this function, remember to free() the returned array
+	pointer, as it was allocated dynamically using malloc() (unless NULL
+	is returned, which designates an error)!
+*/
+
+#if 0
+int loadRegArray(char *fpath, RegisterPtr *array)
+	{
+	int handle, regs;
+	long fsize;
+	*array = NULL;
+
+	if ((handle = open(fpath, O_BINARY | O_RDONLY)) == -1)
+		/* error opening file */
+		/* include your error handling code here */
+		goto fileerror;
+
+    if ((fsize = filelength(handle)) == -1)
+		/* error acquiring file size */
+		goto fileerror;
+	if (fsize % sizeof(Register))
+		{
+		fprintf(stderr_file, "Illegal TWEAK file size: %s\n", fpath);
+		return 0;
+		}
+	regs = fsize / sizeof(Register);
+
+    if (!(*array = (Register *)malloc(fsize)))
+		{
+		fprintf(stderr_file, "Out of memory allocating buffer for %s\n", fpath);
+		return 0;
+		}
+	if (read(handle, (void*)*array, fsize) == -1)
+		/* error reading file */
+		goto fileerror;
+
+    if (close(handle) == -1)
+		{
+		/* error closing file */
+		goto fileerror;
+		}
+
+	/* file read ok, return pointer to buffer */
+	return regs;
+
+fileerror:
+	perror(fpath);
+	if (*array) free(*array);
+	return 0;
+	}
+#endif
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/twkuser.h mame-0.36b16/src/unix/video-drivers/twkuser.h
--- ../mmmmm/m36b16/src/unix/video-drivers/twkuser.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/twkuser.h	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,45 @@
+#ifndef _TwkUser_h
+#define _TwkUser_h
+
+/*
+	xxxxADDR defines the base port number used to access VGA component xxxx,
+	and is defined for xxxx =
+		ATTRCON		-	Attribute Controller
+		MISC		-	Miscellaneous Register
+		VGAENABLE	-	VGA Enable Register
+		SEQ			-	Sequencer
+		GRACON		-	Graphics Controller
+		CRTC		-	Cathode Ray Tube Controller
+		STATUS		-	Status Register
+*/
+
+#define ATTRCON_ADDR	0x3c0
+#define MISC_ADDR		0x3c2
+#define VGAENABLE_ADDR	0x3c3
+#define SEQ_ADDR		0x3c4
+#define GRACON_ADDR		0x3ce
+#define CRTC_ADDR		0x3d4
+#define STATUS_ADDR		0x3da
+
+
+/*
+	Note that the following C definition of Register is not compatible
+	with the C++ definition used in the source code of TWEAK itself!
+*/
+
+typedef struct
+	{
+	unsigned port;
+	unsigned char index;
+	unsigned char value;
+	} Register;
+
+typedef Register *RegisterPtr;
+
+void readyVgaRegs(void);
+void outRegArray(Register *r, int n);
+void outReg(Register r);
+int loadRegArray(char *fpath, RegisterPtr *array);
+
+#endif
+
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/vectorgen.c mame-0.36b16/src/unix/video-drivers/vectorgen.c
--- ../mmmmm/m36b16/src/unix/video-drivers/vectorgen.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/vectorgen.c	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,30 @@
+#include "xmame.h"
+#include "driver.h"
+#include "vidhrdw/vector.h"
+
+static float intensity_correction = 1.0;
+
+void vector_set_gamma(float gamma)
+{
+	sysdep_palette_set_gamma(normal_palette, gamma);
+}
+
+float vector_get_gamma(void)
+{
+	return sysdep_palette_get_gamma(normal_palette);
+}
+
+void vector_set_intensity(float _intensity)
+{
+	intensity_correction = _intensity;
+}
+
+float vector_get_intensity(void)
+{
+	return intensity_correction;
+}
+
+void vector_vh_screenrefresh(struct osd_bitmap *bitmap,int full_refresh)
+{
+	vector_vh_update(bitmap, full_refresh);
+}
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/vroot.h mame-0.36b16/src/unix/video-drivers/vroot.h
--- ../mmmmm/m36b16/src/unix/video-drivers/vroot.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/vroot.h	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,126 @@
+/*****************************************************************************/
+/**                   Copyright 1991 by Andreas Stolcke                     **/
+/**               Copyright 1990 by Solbourne Computer Inc.                 **/
+/**                          Longmont, Colorado                             **/
+/**                                                                         **/
+/**                           All Rights Reserved                           **/
+/**                                                                         **/
+/**    Permission to use, copy, modify, and distribute this software and    **/
+/**    its documentation  for  any  purpose  and  without  fee is hereby    **/
+/**    granted, provided that the above copyright notice appear  in  all    **/
+/**    copies and that both  that  copyright  notice  and  this  permis-    **/
+/**    sion  notice appear in supporting  documentation,  and  that  the    **/
+/**    name of Solbourne not be used in advertising                         **/
+/**    in publicity pertaining to distribution of the  software  without    **/
+/**    specific, written prior permission.                                  **/
+/**                                                                         **/
+/**    ANDREAS STOLCKE AND SOLBOURNE COMPUTER INC. DISCLAIMS ALL WARRANTIES **/
+/**    WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF    **/
+/**    MERCHANTABILITY  AND  FITNESS,  IN  NO  EVENT SHALL ANDREAS STOLCKE  **/
+/**    OR SOLBOURNE BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL    **/
+/**    DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA   **/
+/**    OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER    **/
+/**    TORTIOUS ACTION, ARISING OUT OF OR IN  CONNECTION  WITH  THE  USE    **/
+/**    OR PERFORMANCE OF THIS SOFTWARE.                                     **/
+/*****************************************************************************/
+/*
+ * vroot.h -- Virtual Root Window handling header file
+ *
+ * This header file redefines the X11 macros RootWindow and DefaultRootWindow,
+ * making them look for a virtual root window as provided by certain `virtual'
+ * window managers like swm and tvtwm. If none is found, the ordinary root
+ * window is returned, thus retaining backward compatibility with standard
+ * window managers.
+ * The function implementing the virtual root lookup remembers the result of
+ * its last invocation to avoid overhead in the case of repeated calls
+ * on the same display and screen arguments. 
+ * The lookup code itself is taken from Tom LaStrange's ssetroot program.
+ *
+ * Most simple root window changing X programs can be converted to using
+ * virtual roots by just including
+ *
+ * #include <X11/vroot.h>
+ *
+ * after all the X11 header files.  It has been tested on such popular
+ * X clients as xphoon, xfroot, xloadimage, and xaqua.
+ * It also works with the core clients xprop, xwininfo, xwd, and editres
+ * (and is necessary to get those clients working under tvtwm).
+ * It does NOT work with xsetroot; get the xsetroot replacement included in
+ * the tvtwm distribution instead.
+ *
+ * Andreas Stolcke <stolcke@ICSI.Berkeley.EDU>, 9/7/90
+ * - replaced all NULL's with properly cast 0's, 5/6/91
+ * - free children list (suggested by Mark Martin <mmm@cetia.fr>), 5/16/91
+ * - include X11/Xlib.h and support RootWindowOfScreen, too 9/17/91
+ */
+
+#ifndef _VROOT_H_
+#define _VROOT_H_
+
+#if !defined(lint) && !defined(SABER)
+static const char vroot_rcsid[] = "#Id: vroot.h,v 1.4 1991/09/30 19:23:16 stolcke Exp stolcke #";
+#endif
+
+#include <X11/X.h>
+#include <X11/Xatom.h>
+#include <X11/Xlib.h>
+
+static Window
+#ifdef __STDC__ /* ANSIfication added by jwz, to avoid superfluous warnings. */
+VirtualRootWindowOfScreen(Screen *screen)
+#else /* !__STDC__ */
+VirtualRootWindowOfScreen(screen) Screen *screen;
+#endif /* !__STDC__ */
+{
+	static Screen *save_screen = (Screen *)0;
+	static Window root = (Window)0;
+
+	if (screen != save_screen) {
+		Display *dpy = DisplayOfScreen(screen);
+		Atom __SWM_VROOT = None;
+		int i;
+		Window rootReturn, parentReturn, *children;
+		unsigned int numChildren;
+
+		root = RootWindowOfScreen(screen);
+
+		/* go look for a virtual root */
+		__SWM_VROOT = XInternAtom(dpy, "__SWM_VROOT", False);
+		if (XQueryTree(dpy, root, &rootReturn, &parentReturn,
+				 &children, &numChildren)) {
+			for (i = 0; i < numChildren; i++) {
+				Atom actual_type;
+				int actual_format;
+				unsigned long nitems, bytesafter;
+				Window *newRoot = (Window *)0;
+
+				if (XGetWindowProperty(dpy, children[i],
+					__SWM_VROOT, 0, 1, False, XA_WINDOW,
+					&actual_type, &actual_format,
+					&nitems, &bytesafter,
+					(unsigned char **) &newRoot) == Success
+				    && newRoot) {
+				    root = *newRoot;
+				    break;
+				}
+			}
+			if (children)
+				XFree((char *)children);
+		}
+
+		save_screen = screen;
+	}
+
+	return root;
+}
+
+#undef RootWindowOfScreen
+#define RootWindowOfScreen(s) VirtualRootWindowOfScreen(s)
+
+#undef RootWindow
+#define RootWindow(dpy,screen) VirtualRootWindowOfScreen(ScreenOfDisplay(dpy,screen))
+
+#undef DefaultRootWindow
+#define DefaultRootWindow(dpy) VirtualRootWindowOfScreen(DefaultScreenOfDisplay(dpy))
+
+#endif /* _VROOT_H_ */
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/x11.c mame-0.36b16/src/unix/video-drivers/x11.c
--- ../mmmmm/m36b16/src/unix/video-drivers/x11.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/x11.c	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,246 @@
+/*
+ * X-Mame video specifics code
+ *
+ */
+#ifdef x11
+#define __X11_C_
+
+/*
+ * Include files.
+ */
+
+#include <math.h>
+#include <X11/Xlib.h>
+#include "xmame.h"
+#include "x11.h"
+#include "input.h"
+#include "keyboard.h"
+
+struct rc_option display_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "X11 Related",	NULL,			rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "x11-mode",	NULL,			rc_int,		&x11_video_mode,
+     "0",		0,			X11_MODE_COUNT-1, NULL,
+     "Select x11 video mode: (if compiled in)\n0 Normal window  (hotkey left-alt + insert)\n1 Fullscreen DGA (hotkey left-alt + home)" },
+   { NULL,		NULL,			rc_link,	x11_window_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL,		NULL,			rc_link,	xf86_dga_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL,		NULL,			rc_link,	x11_input_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+struct x_func_struct {
+   int  (*init)(void);
+   int  (*create_display)(void);
+   void (*close_display)(void);
+   void (*update_display)(void);
+   int  (*alloc_palette)(int writable_colors);
+   int  (*modify_pen)(int pen, unsigned char red, unsigned char green, unsigned char blue);
+   int  (*_16bpp_capable)(void);
+};
+
+static struct x_func_struct x_func[X11_MODE_COUNT] = {
+{ NULL,
+  x11_window_create_display,
+  x11_window_close_display,
+  x11_window_update_display,
+  x11_window_alloc_palette,
+  x11_window_modify_pen,
+  x11_window_16bpp_capable },
+#ifdef USE_DGA
+{ xf86_dga_init,
+  xf86_dga_create_display,
+  xf86_dga_close_display,
+  xf86_dga_update_display,
+  xf86_dga_alloc_palette,
+  xf86_dga_modify_pen,
+  xf86_dga_16bpp_capable }
+#else
+{ NULL, NULL, NULL, NULL, NULL, NULL, NULL }
+#endif
+};
+
+int sysdep_init (void)
+{
+   int i;
+   
+   if(!(display = XOpenDisplay (NULL)))
+   {
+      /* Don't use stderr_file here it isn't assigned a value yet ! */
+      fprintf (stderr, "Could not open display\n");
+      return OSD_NOT_OK;
+   }
+   
+   for (i=0;i<X11_MODE_COUNT;i++)
+   {
+      if(x_func[i].create_display)
+         mode_available[i] = TRUE;
+      else
+         mode_available[i] = FALSE;
+      
+      if(x_func[i].init && (*x_func[i].init)() != OSD_OK)
+         return OSD_NOT_OK;
+   }
+   
+   return OSD_OK;
+}
+
+void sysdep_close(void)
+{
+   if(display)
+      XCloseDisplay (display);
+}
+
+int sysdep_display_16bpp_capable(void)
+{
+   if (x11_video_mode >= X11_MODE_COUNT)
+   {
+      fprintf (stderr_file,
+         "X11-mode %d does not exist, falling back to normal window code\n",
+         x11_video_mode);
+      x11_video_mode = X11_WINDOW;
+   }
+
+   if (!mode_available[x11_video_mode])
+   {
+      fprintf (stderr_file,
+         "X11-mode %d not available, falling back to normal window code\n",
+         x11_video_mode);
+      x11_video_mode = X11_WINDOW;
+   }
+
+   return (*x_func[x11_video_mode]._16bpp_capable) ();
+}
+
+/* This name doesn't really cover this function, since it also sets up mouse
+   and keyboard. This is done over here, since on most display targets the
+   mouse and keyboard can't be setup before the display has. */
+int sysdep_create_display (void)
+{
+   return (*x_func[x11_video_mode].create_display)();
+}
+
+void osd_close_display (void)
+{
+   (*x_func[x11_video_mode].close_display)();
+   osd_dirty_close ();
+   /* free the bitmap after cleaning the dirty stuff as it uses the bitmap */
+   osd_free_bitmap (bitmap);
+}
+
+int x11_init_palette_info(void)
+{
+   memset(&display_palette_info, 0, sizeof(struct sysdep_palette_info));
+   
+   display_palette_info.depth = depth;
+   
+   if (depth == 8)
+   {
+      if (xvisual->class != PseudoColor)
+      {
+         fprintf(stderr_file, "X11: Error 8 bpp only supported on PseudoColor visuals\n");
+         return OSD_NOT_OK;
+      }
+      display_palette_info.writable_colors = 256;
+   }
+   else
+   {
+      if (xvisual->class != TrueColor)
+      {
+         fprintf(stderr_file, "X11: Error: %d bpp modes only supported on TrueColor visuals\n",
+            depth);
+         return OSD_NOT_OK;
+      }
+      display_palette_info.red_mask   = xvisual->red_mask;
+      display_palette_info.green_mask = xvisual->green_mask;
+      display_palette_info.blue_mask  = xvisual->blue_mask;
+   }
+   return OSD_OK;
+}
+
+int sysdep_display_alloc_palette (int writable_colors)
+{
+   return (*x_func[x11_video_mode].alloc_palette) (writable_colors);
+}
+
+int sysdep_display_set_pen (int pen, unsigned char red, unsigned char green,
+   unsigned char blue)
+{
+   return (*x_func[x11_video_mode].modify_pen) (pen, red, green, blue);
+}
+
+void sysdep_update_display (void)
+{
+   extern unsigned short *shrinked_pens;
+   int new_video_mode = x11_video_mode;
+
+   if (keyboard_pressed (KEYCODE_LALT))
+   { 
+      if (keyboard_pressed_memory (KEYCODE_INSERT))
+         new_video_mode = X11_WINDOW;
+      if (keyboard_pressed_memory (KEYCODE_HOME))
+         new_video_mode = X11_DGA;
+   }
+
+   if (new_video_mode != x11_video_mode && mode_available[new_video_mode])
+   {
+      (*x_func[x11_video_mode].close_display)();
+      if ((*x_func[new_video_mode].create_display)() != OSD_OK)
+      {
+         fprintf(stderr_file,
+            "X11: Warning: Couldn't create display for new x11-mode\n"
+            "   Trying again with the old x11-mode\n");
+         (*x_func[new_video_mode].close_display)();
+         if ((*x_func[x11_video_mode].create_display)() != OSD_OK)
+            goto barf;
+      }
+      else
+         x11_video_mode = new_video_mode;
+
+      if(sysdep_palette_change_display(&sysdep_palette))
+         goto barf;
+      
+      keyboard_clear();
+      osd_mark_dirty (0, 0, bitmap->width - 1, bitmap->height - 1, 1);
+      /* poll mouse twice to clear internal vars */
+      if (use_mouse)
+      {
+         sysdep_mouse_poll ();
+         sysdep_mouse_poll ();
+      }
+   }
+
+   (*x_func[x11_video_mode].update_display) ();
+   return;
+   
+barf:   
+   osd_close_display();   /* This cleans up and must be called to
+                             restore the videomode with dga */
+   osd_exit();
+   sysdep_close();
+   fprintf (stderr_file,
+      "X11: Error: couldn't create new display while switching display modes\n");
+   exit (1);              /* ugly, anyone know a better way ? */
+}
+
+/* these aren't nescesarry under x11 since we have both a graphics window and
+   a textwindow (xterm) */
+int sysdep_set_video_mode (void)
+{
+   return OSD_OK;
+}
+
+void sysdep_set_text_mode (void)
+{
+}
+
+#endif /* ifdef x11 */
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/x11.h mame-0.36b16/src/unix/video-drivers/x11.h
--- ../mmmmm/m36b16/src/unix/video-drivers/x11.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/x11.h	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,92 @@
+#ifndef __X11_H_
+#define __X11_H_
+
+#include <X11/Xlib.h>
+
+#ifdef __X11_C_
+#define EXTERN
+#else
+#define EXTERN extern
+#endif
+
+enum { X11_WINDOW, X11_DGA };
+#define X11_MODE_COUNT 2
+
+EXTERN Display 		*display;
+EXTERN Window		window;
+EXTERN Screen 		*screen;
+EXTERN Colormap		colormap;
+EXTERN Visual		*xvisual;
+EXTERN int		depth;
+EXTERN unsigned char	*scaled_buffer_ptr;
+EXTERN int		mode_available[X11_MODE_COUNT];
+EXTERN Cursor		normal_cursor;
+EXTERN Cursor		invisible_cursor;
+EXTERN int		x11_video_mode;
+EXTERN int		x11_grab_mouse;
+EXTERN int		run_in_root_window;
+EXTERN int		show_cursor;
+EXTERN int		use_private_cmap;
+EXTERN int		use_xil;
+EXTERN int		use_mt_xil;
+extern struct rc_option xf86_dga_opts[];
+extern struct rc_option x11_window_opts[];
+extern struct rc_option	x11_input_opts[];
+
+#if defined x11 && defined USE_DGA
+EXTERN int		xf86_dga_fix_viewport;
+EXTERN int		xf86_dga_first_click;
+#endif
+
+#ifdef X11_JOYSTICK
+EXTERN int devicebuttonpress;
+EXTERN int devicebuttonrelease;
+EXTERN int devicemotionnotify;
+EXTERN int devicebuttonmotion;
+#endif
+
+/*** prototypes ***/
+
+/* device related */
+void process_x11_joy_event(XEvent *event);
+
+#ifdef x11
+
+/* Normal x11_window functions */
+int  x11_window_create_display(void);
+void x11_window_close_display(void);
+int  x11_window_modify_pen(int pen, unsigned char red,unsigned char green,unsigned char blue);
+void x11_window_update_display(void);
+int  x11_window_alloc_palette(int writable_colors);
+void x11_window_refresh_screen(void);
+int  x11_window_16bpp_capable(void);
+
+/* Xf86_dga functions */
+int  xf86_dga_init(void);
+int  xf86_dga_create_display(void);
+void xf86_dga_close_display(void);
+int  xf86_dga_modify_pen(int pen, unsigned char red,unsigned char green,unsigned char blue);
+void xf86_dga_update_display(void);
+int  xf86_dga_alloc_palette(int writable_colors);
+int  xf86_dga_16bpp_capable(void);
+
+/* XIL functions */
+#ifdef USE_XIL
+void init_xil( void );
+void setup_xil_images( int, int );
+void refresh_xil_screen( void );
+#endif
+
+/* DBE functions */
+#ifdef USE_DBE
+void setup_dbe( void );
+void swap_dbe_buffers( void );
+#endif
+
+/* generic helper functions */
+int x11_init_palette_info(void);
+
+#endif /* ifdef x11 */
+
+#undef EXTERN
+#endif /* ifndef __X11_H_ */
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/x11_window.c mame-0.36b16/src/unix/video-drivers/x11_window.c
--- ../mmmmm/m36b16/src/unix/video-drivers/x11_window.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/x11_window.c	2023-07-07 14:20:22.696001903 -0400
@@ -0,0 +1,997 @@
+/*
+ * X-Mame video specifics code
+ *
+ */
+#ifdef x11
+#define __X11_WINDOW_C_
+
+/*
+ * Include files.
+ */
+
+/* for FLT_MAX */
+#include <float.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/cursorfont.h>
+#ifdef USE_MITSHM
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#include <X11/extensions/XShm.h>
+#endif
+#include "xmame.h"
+#include "x11.h"
+#include "driver.h"
+/* for xscreensaver support */
+#include "vroot.h"
+
+static void x11_window_update_8_to_8bpp (void);
+static void x11_window_update_8_to_16bpp (void);
+static void x11_window_update_8_to_24bpp (void);
+static void x11_window_update_8_to_32bpp (void);
+static void x11_window_update_8_to_8bpp_direct (void);
+static void x11_window_update_16_to_16bpp (void);
+static void x11_window_update_16_to_24bpp (void);
+static void x11_window_update_16_to_32bpp (void);
+static void (*x11_window_update_display_func) (void) = NULL;
+
+/* hmm we need these to do the clean up correctly, or we could just 
+   trust unix & X to clean up after us but lett's keep things clean */
+#ifdef USE_MITSHM
+static int mit_shm_attached = 0;
+static XShmSegmentInfo shm_info;
+static int use_mit_shm = 1;  /* use mitshm if available */
+#endif
+static int private_cmap_allocated = 0;
+static XImage *image = NULL;
+static GC gc;
+static int orig_widthscale, orig_heightscale;
+static int image_width;
+enum { X11_NORMAL, X11_MITSHM, X11_XIL };
+static int x11_window_update_method = X11_NORMAL;
+static int startx = 0;
+static int starty = 0;
+static unsigned long black_pen;
+static int use_xsync = 0;
+static int root_window_id; /* root window id (for swallowing the mame window) */
+static char *geometry = NULL;
+
+/* we need to look a lookup table for pseudo modes since X doesn't give us full
+   access to the palette */
+static char *pseudo_color_allocated;
+static unsigned long *pseudo_color_lookup;
+static int pseudo_color_lookup_dirty;
+static int pseudo_color_use_rw_palette;
+static int pseudo_color_warn_low_on_colors;
+
+struct rc_option x11_window_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "X11-window Related", NULL,		rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "cursor",		"nocursor",		rc_bool,       &show_cursor,
+     "1",		0,			0,		NULL,
+     "Show/ don't show the cursor" },
+   { "mitshm",		"nomitshm",		rc_bool,	&use_mit_shm,
+     "1",		0,			0,		NULL,
+     "Use / don't use MIT Shared Mem (if avaiable and compiled in)" },
+   { "xsync",		"noxsync",		rc_bool,	&use_xsync,
+     "1",		0,			0,		NULL,
+     "Use / don't use XSync instead of XFlush as screen refresh method" },
+   { "privatecmap",	"noprivatecmap",	rc_bool,	&use_private_cmap,
+     "0",		0,			0,		NULL,
+     "Enable/disable use of private color map" },
+   { "xil",		"noxil",		rc_bool,	&use_xil,
+     "1",		0,			0,		NULL,
+     "Enable/disable use of XIL for scaling (if available and compiled in)" },
+   { "mtxil",		"nomtxil",		rc_bool,	&use_mt_xil,
+     "0",		0,			0,		NULL,
+     "Enable/disable multi threading of XIL" },
+   { "run-in-root-window", "norun-in-root-window", rc_bool,	&run_in_root_window,
+     "0",		0,			0,		NULL,
+     "Enable/disable running in root window" },
+   { "root_window_id",	NULL,			rc_int,		&root_window_id,
+     "0",		0,			0,		NULL,
+     "Create the xmame-window in an alternate root-window, mostly usefull for frontends!" },
+   { "geometry",	NULL,			rc_string,	&geometry,
+     "640x480",		0,			0,		NULL,
+     "Specify the location of the window" },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+/*
+ * Create a display screen, or window, large enough to accomodate a bitmap
+ * of the given dimensions.
+ */
+
+#ifdef USE_MITSHM
+/* following routine traps missused MIT-SHM if not available */
+int test_mit_shm (Display * display, XErrorEvent * error)
+{
+   char msg[256];
+   unsigned char ret = error->error_code;
+
+   XGetErrorText (display, ret, msg, 256);
+   /* if MIT-SHM request failed, note and continue */
+   if (ret == BadAccess)
+   {
+      use_mit_shm = 0;
+      return 0;
+   }
+   /* else unspected error code: notify and exit */
+   fprintf (stderr_file, "Unspected X Error %d: %s\n", ret, msg);
+   exit (1);
+}
+#endif
+
+/*
+ * This function creates an invisible cursor.
+ *
+ * I got the idea and code fragment from in the Apple II+ Emulator
+ * version 0.06 for Linux by Aaron Culliney
+ * <chernabog@baldmountain.bbn.com>
+ *
+ * I also found a post from Steve Lamont <spl@szechuan.ucsd.edu> on
+ * xforms@bob.usuf2.usuhs.mil.  His comments read:
+ *
+ * Lifted from unclutter
+ * Mark M Martin. cetia 1991 mmm@cetia.fr
+ * Version 4 changes by Charles Hannum <mycroft@ai.mit.edu>
+ *
+ * So I guess this code has been around the block a few times.
+ */
+
+static Cursor create_invisible_cursor (Display * display, Window win)
+{
+   Pixmap cursormask;
+   XGCValues xgc;
+   XColor dummycolour;
+   Cursor cursor;
+   GC gc;
+
+   cursormask = XCreatePixmap (display, win, 1, 1, 1 /*depth */ );
+   xgc.function = GXclear;
+   gc = XCreateGC (display, cursormask, GCFunction, &xgc);
+   XFillRectangle (display, cursormask, gc, 0, 0, 1, 1);
+   dummycolour.pixel = 0;
+   dummycolour.red = 0;
+   dummycolour.flags = 04;
+   cursor = XCreatePixmapCursor (display, cursormask, cursormask,
+                                 &dummycolour, &dummycolour, 0, 0);
+   XFreeGC (display, gc);
+   XFreePixmap (display, cursormask);
+   return cursor;
+}
+
+static int x11_find_best_visual(int bitmap_depth)
+{
+   XVisualInfo visualinfo;
+   int screen_no = DefaultScreen (display);
+   
+   if(bitmap_depth == 8 &&
+      XMatchVisualInfo (display, screen_no, 8, PseudoColor, &visualinfo))
+   {
+      xvisual = visualinfo.visual;
+      depth   = 8;
+      return 0;
+   }
+   if(XMatchVisualInfo (display, screen_no, 15, TrueColor, &visualinfo))
+   {
+      xvisual = visualinfo.visual;
+      depth   = 15;
+      return 0;
+   }
+   if(XMatchVisualInfo (display, screen_no, 16, TrueColor, &visualinfo))
+   {
+      xvisual = visualinfo.visual;
+      depth   = 16;
+      return 0;
+   }
+   if(XMatchVisualInfo (display, screen_no, 24, TrueColor, &visualinfo))
+   {
+      xvisual = visualinfo.visual;
+      depth   = 24;
+      return 0;
+   }
+   return -1;
+}
+
+int x11_window_16bpp_capable(void)
+{
+   return !x11_find_best_visual(16);
+}
+
+/* This name doesn't really cover this function, since it also sets up mouse
+   and keyboard. This is done over here, since on most display targets the
+   mouse and keyboard can't be setup before the display has. */
+int x11_window_create_display (void)
+{
+   XSetWindowAttributes winattr;
+   XGCValues xgcv;
+   int screen_no;
+   XEvent event;
+   XSizeHints hints;
+   XWMHints wm_hints;
+   int image_height;
+   int i;
+   int event_mask;
+   int window_width, window_height;
+   int my_use_private_cmap = use_private_cmap;
+   
+   /* set all the default values */
+   window = 0;
+   image  = NULL;
+#ifdef USE_MITSHM
+   mit_shm_attached = 0;
+#endif
+   private_cmap_allocated = 0;
+   pseudo_color_allocated = NULL;
+   pseudo_color_lookup = NULL;
+   pseudo_color_lookup_dirty = FALSE;
+   pseudo_color_use_rw_palette = FALSE;
+   pseudo_color_warn_low_on_colors = TRUE;
+
+   window_width     = widthscale  * visual_width;
+   window_height    = heightscale * visual_height;
+   image_width      = widthscale  * visual_width;
+   image_height     = heightscale * visual_height;
+   orig_widthscale  = widthscale;
+   orig_heightscale = heightscale;
+   screen           = DefaultScreenOfDisplay (display);
+   screen_no        = DefaultScreen (display);
+   
+   if(run_in_root_window)
+   {
+      xvisual = DefaultVisual(display, screen_no);
+      depth   = DefaultDepth(display, screen_no);
+      my_use_private_cmap = 0;
+   }
+   else
+   {
+      if(x11_find_best_visual(bitmap->depth))
+      {
+         fprintf(stderr_file, "X11: Error: Couldn't find a suitable visual\n");
+         return OSD_NOT_OK;
+      }
+      if ( (xvisual->class != DefaultVisual(display, screen_no)->class) ||
+           (DefaultDepth(display, screen_no) != depth) )
+      {
+         my_use_private_cmap = TRUE;
+      }
+   }
+      
+   fprintf(stderr_file, "Using a Visual with a depth of %dbpp.\n", depth);
+   
+   /* check the available extensions if compiled in */
+#ifdef USE_XIL
+   if (use_xil)
+   {
+      init_xil ();
+   }
+
+   /*
+    *  If the XIL initialization worked, then use_xil will still be set.
+    */
+   if (use_xil)
+   {
+      image_width  = visual_width;
+      image_height = visual_height;
+      widthscale   = 1;
+      heightscale  = 1;
+      x11_window_update_method = X11_XIL;
+   }
+#endif
+#if defined USE_XIL && defined USE_MITSHM
+   else
+#endif
+#ifdef USE_MITSHM
+   if (use_mit_shm)             /* look for available Mitshm extensions */
+   {
+      /* get XExtensions to be if mit shared memory is available */
+      if (XQueryExtension (display, "MIT-SHM", &i, &i, &i))
+      {
+         x11_window_update_method = X11_MITSHM;
+      }
+      else
+      {
+         fprintf (stderr_file, "X-Server Doesn't support MIT-SHM extension\n");
+         use_mit_shm = 0;
+      }
+   }
+#endif
+
+   /* create / asign a colormap */
+   if (my_use_private_cmap)
+   {
+      colormap = XCreateColormap (display, RootWindowOfScreen (screen), xvisual, AllocNone);
+      private_cmap_allocated = 1;
+      black_pen = 0;
+      fprintf (stderr_file, "Using private color map\n");
+   }
+   else
+   {
+      colormap = DefaultColormapOfScreen (screen);
+      black_pen = BlackPixelOfScreen (screen);
+   }
+
+
+   if (run_in_root_window)
+   {
+      int width  = DisplayWidth(display, screen_no);
+      int height = DisplayHeight(display, screen_no);
+      if (window_width > width || window_height > height)
+      {
+         fprintf (stderr_file, "OSD ERROR: Root window is to small: %dx%d, needed %dx%d\n",
+            width, height, window_width, window_height);
+         return OSD_NOT_OK;
+      }
+      
+      startx        = ((width  - window_width)  / 2) & ~0x07;
+      starty        = ((height - window_height) / 2) & ~0x07;
+      window        = RootWindowOfScreen (screen);
+      window_width  = width;
+      window_height = height;
+      use_mouse     = FALSE;
+   }
+   else
+   {
+      /*  Placement hints etc. */
+
+#ifdef USE_XIL
+      /*
+       *  XIL allows us to rescale the window on the fly,
+       *  so in this case, we don't prevent the user from
+       *  resizing.
+       */
+      if (use_xil)
+      {
+         hints.flags = PSize;
+      }
+      else
+#endif
+         hints.flags = PSize | PMinSize | PMaxSize;
+
+      hints.min_width  = hints.max_width  = hints.base_width  = window_width;
+      hints.min_height = hints.max_height = hints.base_height = window_height;
+      hints.x = hints.y = 0;
+      hints.win_gravity = NorthWestGravity;
+      
+      i = XWMGeometry(display, screen_no, geometry, NULL, 0, &hints, &hints.x,
+         &hints.y, &i, &i, &hints.win_gravity);
+      if ((i&XValue) && (i&YValue))
+         hints.flags |= PPosition | PWinGravity;
+      
+      /* Create and setup the window. No buttons, no fancy stuff. */
+      
+      winattr.background_pixel  = black_pen;
+      winattr.border_pixel      = WhitePixelOfScreen (screen);
+      winattr.bit_gravity       = ForgetGravity;
+      winattr.win_gravity       = hints.win_gravity;
+      winattr.backing_store     = NotUseful;
+      winattr.override_redirect = False;
+      winattr.save_under        = False;
+      winattr.event_mask        = 0;
+      winattr.do_not_propagate_mask = 0;
+      winattr.colormap          = colormap;
+      winattr.cursor            = None;
+      if (root_window_id == 0)
+      {
+         root_window_id = RootWindowOfScreen (screen);
+      }
+      window = XCreateWindow (display, root_window_id, hints.x, hints.y,
+                              window_width, window_height,
+                              0, depth,
+                              InputOutput, xvisual,
+                              (CWBorderPixel | CWBackPixel | CWBitGravity |
+                               CWWinGravity | CWBackingStore |
+                               CWOverrideRedirect | CWSaveUnder | CWEventMask |
+                               CWDontPropagate | CWColormap | CWCursor),
+                              &winattr);
+      if (!window)
+      {
+         fprintf (stderr_file, "OSD ERROR: failed in XCreateWindow().\n");
+         return OSD_NOT_OK;
+      }
+
+      wm_hints.input = TRUE;
+      wm_hints.flags = InputHint;
+
+      XSetWMHints (display, window, &wm_hints);
+      XSetWMNormalHints (display, window, &hints);
+      XStoreName (display, window, title);
+
+      /* Select event mask */
+      
+      event_mask = FocusChangeMask | ExposureMask |
+         EnterWindowMask | LeaveWindowMask |
+         KeyPressMask | KeyReleaseMask;
+      if (use_mouse)
+      {
+         event_mask |= ButtonPressMask | ButtonReleaseMask;
+      }
+#ifdef USE_XIL
+      if (use_xil)
+      {
+         event_mask |= StructureNotifyMask;
+      }
+#endif
+      XSelectInput (display, window, event_mask);
+
+      XMapRaised (display, window);
+      XClearWindow (display, window);
+      XWindowEvent (display, window, ExposureMask, &event);
+   }
+   
+   /* create and setup the image */
+   switch (x11_window_update_method)
+   {
+      case X11_XIL:
+#ifdef USE_XIL
+         /*
+          *  XIL takes priority over MITSHM
+          */
+         setup_xil_images (image_width, image_height);
+#endif
+         break;
+      case X11_MITSHM:
+#ifdef USE_MITSHM
+         /* Create a MITSHM image. */
+         fprintf (stderr_file, "MIT-SHM Extension Available. trying to use... ");
+         XSetErrorHandler (test_mit_shm);
+
+         image = XShmCreateImage (display,
+                                  xvisual,
+                                  depth,
+                                  ZPixmap,
+                                  NULL,
+                                  &shm_info,
+                                  image_width,
+                                  image_height);
+         if (image)
+         {
+            shm_info.shmid = shmget (IPC_PRIVATE,
+                                     image->bytes_per_line * image->height,
+                                     (IPC_CREAT | 0777));
+            if (shm_info.shmid < 0)
+            {
+               fprintf (stderr_file, "\nError: failed to create MITSHM block.\n");
+               return OSD_NOT_OK;
+            }
+
+            /* And allocate the bitmap buffer. */
+            /* new pen color code force double buffering in every cases */
+            image->data = shm_info.shmaddr =
+               (char *) shmat (shm_info.shmid, 0, 0);
+
+            scaled_buffer_ptr = (unsigned char *) image->data;
+            if (!scaled_buffer_ptr)
+            {
+               fprintf (stderr_file, "\nError: failed to allocate MITSHM bitmap buffer.\n");
+               return OSD_NOT_OK;
+            }
+
+            shm_info.readOnly = FALSE;
+
+            /* Attach the MITSHM block. this will cause an exception if */
+            /* MIT-SHM is not available. so trap it and process         */
+            if (!XShmAttach (display, &shm_info))
+            {
+               fprintf (stderr_file, "\nError: failed to attach MITSHM block.\n");
+               return OSD_NOT_OK;
+            }
+            XSync (display, False);  /* be sure to get request processed */
+            sleep (2);          /* enought time to notify error if any */
+            XSetErrorHandler (None);  /* Restore error handler to default */
+            /* Mark segment as deletable after we attach.  When all processes
+               detach from the segment (progam exits), it will be deleted. 
+               This way it won't be left in memory if we crash or something.
+               Grr, have todo this after X attaches too since slowlaris doesn't
+               like it otherwise */
+            shmctl(shm_info.shmid, IPC_RMID, NULL);
+            
+            /* if use_mit_shm is still set we've succeeded */
+            if (use_mit_shm)
+            {
+               fprintf (stderr_file, "Success.\nUsing Shared Memory Features to speed up\n");
+               mit_shm_attached = 1;
+               break;
+            }
+            /* else we have failed clean up before retrying without MITSHM */
+            shmdt ((char *) scaled_buffer_ptr);
+            scaled_buffer_ptr = NULL;
+            XDestroyImage (image);
+            image = NULL;
+         }
+         fprintf (stderr_file, "Failed\nReverting to normal XPutImage() mode\n");
+         x11_window_update_method = X11_NORMAL;
+#endif
+      case X11_NORMAL:
+         scaled_buffer_ptr = malloc (4 * image_width * image_height);
+         if (!scaled_buffer_ptr)
+         {
+            fprintf (stderr_file, "Error: failed to allocate bitmap buffer.\n");
+            return OSD_NOT_OK;
+         }
+         image = XCreateImage (display,
+                               xvisual,
+                               depth,
+                               ZPixmap,
+                               0,
+                               (char *) scaled_buffer_ptr,
+                               image_width, image_height,
+                               32, /* image_width always is a multiple of 8 */
+                               0);
+
+         if (!image)
+         {
+            fprintf (stderr_file, "OSD ERROR: could not create image.\n");
+            return OSD_NOT_OK;
+         }
+         break;
+      default:
+         fprintf (stderr_file, "Error unknown X11 update method, this shouldn't happen\n");
+         return OSD_NOT_OK;
+   }
+   
+   /* verify the number of bits per pixel and choose the correct update method */
+#ifdef USE_XIL
+   if (use_xil)
+      /* XIL uses 8 bit visuals and does any conversion it self */
+      depth = 8;
+   else
+#endif
+      depth = image->bits_per_pixel;
+   
+   /* setup the palette_info struct now we have the depth */
+   if (x11_init_palette_info() != OSD_OK)
+      return OSD_NOT_OK;
+
+   fprintf(stderr_file, "Actual bits per pixel = %d... ", depth);
+
+   if (bitmap->depth == 16)
+   {
+      switch(depth)
+      {
+         case 16:
+            x11_window_update_display_func = x11_window_update_16_to_16bpp;
+            break;
+         case 24:
+            x11_window_update_display_func = x11_window_update_16_to_24bpp;
+            break;
+         case 32:
+            x11_window_update_display_func = x11_window_update_16_to_32bpp;
+            break;
+      }
+   }
+   else
+   {
+      switch(depth)
+      {
+         case 8:
+            x11_window_update_display_func = x11_window_update_8_to_8bpp;
+            break;
+         case 16:
+            x11_window_update_display_func = x11_window_update_8_to_16bpp;
+            break;
+         case 24:
+            x11_window_update_display_func = x11_window_update_8_to_24bpp;
+            break;
+         case 32:
+            x11_window_update_display_func = x11_window_update_8_to_32bpp;
+            break;
+      }
+   }
+   
+   if (x11_window_update_display_func == NULL)
+   {
+      fprintf(stderr_file, "Error: Unsupported\n");
+      return OSD_NOT_OK;
+   }
+   fprintf(stderr_file, "Ok\n");
+   
+   /* create gc */
+   gc = XCreateGC (display, window, 0, &xgcv);
+   
+   /* mouse pointer stuff */
+   if (!use_mouse || (x11_grab_mouse &&  XGrabPointer (display, window, True,
+      0, GrabModeAsync, GrabModeAsync, window, None, CurrentTime)))
+      x11_grab_mouse = FALSE;
+
+   if (!run_in_root_window)
+   {
+      normal_cursor = XCreateFontCursor (display, XC_trek);
+      invisible_cursor = create_invisible_cursor (display, window);
+
+      if (x11_grab_mouse || !show_cursor)
+         XDefineCursor (display, window, invisible_cursor);
+      else
+         XDefineCursor (display, window, normal_cursor);
+   }
+
+   return OSD_OK;
+}
+
+/*
+ * Shut down the display, also called by the core to clean up if any error
+ * happens when creating the display.
+ */
+void x11_window_close_display (void)
+{
+   /* FIXME: free cursors */
+   int i;
+
+   widthscale  = orig_widthscale;
+   heightscale = orig_heightscale;
+
+   /* better free any allocated colors before freeing the colormap */
+   if (pseudo_color_lookup)
+   {
+      if (pseudo_color_use_rw_palette)
+      {
+         XFreeColors (display, colormap, pseudo_color_lookup,
+            display_palette_info.writable_colors, 0);
+      }
+      else
+      {
+         for (i = 0; i < display_palette_info.writable_colors; i++)
+         {
+            if (pseudo_color_allocated[i])
+               XFreeColors (display, colormap, &pseudo_color_lookup[i], 1, 0);
+         }
+         free(pseudo_color_allocated);
+      }
+      free(pseudo_color_lookup);
+   }
+   
+   /* This is only allocated/done if we succeeded to get a window */
+   if (window)
+   {
+      if (x11_grab_mouse)
+         XUngrabPointer (display, CurrentTime);
+         
+#ifdef USE_MITSHM
+      if (use_mit_shm)
+      {
+         if (mit_shm_attached)
+            XShmDetach (display, &shm_info);
+         if (scaled_buffer_ptr)
+            shmdt (scaled_buffer_ptr);
+         scaled_buffer_ptr = NULL;
+      }
+#endif
+      if (image)
+      {
+         XDestroyImage (image);
+         scaled_buffer_ptr = NULL;
+      }
+      if (scaled_buffer_ptr)
+         free (scaled_buffer_ptr);
+   
+      XDestroyWindow (display, window);
+   }
+
+   if (private_cmap_allocated)
+      XFreeColormap (display, colormap);
+
+   XSync (display, False);      /* send all events to sync; */
+}
+
+/*
+ * Set the screen colors using the given palette.
+ *
+ */
+int x11_window_alloc_palette (int writable_colors)
+{
+   int i;
+   
+   if(!(pseudo_color_lookup = malloc(writable_colors * sizeof(unsigned long))))
+   {
+      fprintf(stderr_file, "X11-window: Error: Malloc failed for pseudo color lookup table\n");
+      return -1;
+   }
+   
+   /* set the palette to black */
+   for (i = 0; i < writable_colors; i++)
+      pseudo_color_lookup[i] = black_pen;
+
+   /* allocate color cells */
+   if (XAllocColorCells (display, colormap, 0, 0, 0, pseudo_color_lookup,
+      writable_colors))
+   {
+      pseudo_color_use_rw_palette = 1;
+      fprintf (stderr_file, "Using r/w palette entries to speed up, good\n");
+      for (i = 0; i < writable_colors; i++)
+         if (pseudo_color_lookup[i] != i) break;
+         
+      if (i == writable_colors)
+      {
+         x11_window_update_display_func = x11_window_update_8_to_8bpp_direct;
+         fprintf (stderr_file, "Using direct copy to speed up, good\n");
+      }
+   }
+   else
+   {
+      if (!(pseudo_color_allocated = calloc(writable_colors, sizeof(char))))
+      {
+         fprintf(stderr_file, "X11-window: Error: Malloc failed for pseudo color lookup table\n");
+         free(pseudo_color_lookup);
+         pseudo_color_lookup=NULL;
+         return -1;
+      }
+   }
+   
+   display_palette_info.writable_colors = writable_colors;
+   return 0;
+}
+
+int x11_window_modify_pen (int pen, unsigned char red, unsigned char green,
+   unsigned char blue)
+{
+   XColor color;
+
+   /* Translate 0-255 values of new color to X 0-65535 values. */
+   color.flags = (DoRed | DoGreen | DoBlue);
+   color.red = (int) red << 8;
+   color.green = (int) green << 8;
+   color.blue = (int) blue << 8;
+   color.pixel = pseudo_color_lookup[pen];
+
+   if (pseudo_color_use_rw_palette)
+   {
+      XStoreColor (display, colormap, &color);
+   }
+   else
+   {
+      /* free previously allocated color */
+      if (pseudo_color_allocated[pen])
+      {
+         XFreeColors (display, colormap, &pseudo_color_lookup[pen], 1, 0);
+         pseudo_color_allocated[pen] = FALSE;
+      }
+
+      /* allocate new color and assign it to pen index */
+      if (XAllocColor (display, colormap, &color))
+      {
+         if (pseudo_color_lookup[pen] != color.pixel)
+            pseudo_color_lookup_dirty = TRUE;
+         pseudo_color_lookup[pen] = color.pixel;
+         pseudo_color_allocated[pen] = TRUE;
+      }
+      else /* try again with the closest match */
+      {
+         int i;
+         XColor colors[256];
+         int my_red   = (int)red << 8;
+         int my_green = (int)green << 8;
+         int my_blue  = (int)blue << 8;
+         int best_pixel = black_pen;
+         float best_diff = FLT_MAX;
+         
+         for(i=0;i<256;i++)
+            colors[i].pixel = i;
+         
+         XQueryColors(display, colormap, colors, 256);
+         for(i=0;i<256;i++)
+         {
+            #define SQRT(x) ((float)(x)*(x))
+            float diff = SQRT(my_red - colors[i].red) + 
+               SQRT(my_green - colors[i].green) +
+               SQRT(my_blue - colors[i].blue);
+            if (diff < best_diff)
+            {
+               best_pixel = colors[i].pixel;
+               best_diff  = diff;
+            }
+         }
+         
+         color = colors[best_pixel];
+         
+         if (XAllocColor (display, colormap, &color))
+         {
+            if (pseudo_color_lookup[pen] != color.pixel)
+               pseudo_color_lookup_dirty = TRUE;
+            pseudo_color_lookup[pen] = color.pixel;
+            pseudo_color_allocated[pen] = TRUE;
+         }
+         else
+         {
+            if (pseudo_color_warn_low_on_colors)
+            {
+               pseudo_color_warn_low_on_colors = 0;
+               fprintf (stderr_file,
+                  "X11-palette: Warning: Closest color match alloc failed\n"
+                  "Couldn't allocate all colors, some parts of the emulation may be black\n"
+                  "Try running xmame with the -privatecmap option\n");
+            }
+            
+            /* If color allocation failed, use black to ensure the
+               pen is not left set to an invalid color */
+            pseudo_color_lookup[pen] = black_pen;
+            return -1;
+         }
+      }
+   }
+   return 0;
+}
+
+/* invoked by main tree code to update bitmap into screen */
+void x11_window_update_display (void)
+{
+   int old_use_dirty = use_dirty;
+   
+   if (sysdep_palette->lookup_dirty || pseudo_color_lookup_dirty)
+   {
+      use_dirty = 0;
+      pseudo_color_lookup_dirty = 0;
+      /* sysdep_palette->lookup_dirty is cleared for us by
+         sysdep_palette_update() */
+   }
+
+   (*x11_window_update_display_func) ();
+
+#ifdef USE_XIL
+   if (use_xil)
+      refresh_xil_screen ();
+#endif
+
+   use_dirty = old_use_dirty;
+
+   if (use_mouse &&
+       keyboard_pressed (KEYCODE_LALT) &&
+       keyboard_pressed_memory (KEYCODE_PGDN))
+   {
+      if (x11_grab_mouse)
+      {
+         XUngrabPointer (display, CurrentTime);
+         if (show_cursor)
+            XDefineCursor (display, window, normal_cursor);
+         x11_grab_mouse = FALSE;
+      }
+      else
+      {
+         if (!XGrabPointer (display, window, True, 0, GrabModeAsync,
+                            GrabModeAsync, window, None, CurrentTime))
+         {
+            if (show_cursor)
+               XDefineCursor (display, window, invisible_cursor);
+            x11_grab_mouse = TRUE;
+         }
+      }
+   }
+
+   /* some games "flickers" with XFlush, so command line option is provided */
+   if (use_xsync)
+      XSync (display, False);   /* be sure to get request processed */
+   else
+      XFlush (display);         /* flush buffer to server */
+}
+
+void x11_window_refresh_screen (void)
+{
+   switch (x11_window_update_method)
+   {
+      case X11_XIL:
+#ifdef USE_XIL
+         refresh_xil_screen ();
+#endif
+         break;
+      case X11_MITSHM:
+#ifdef USE_MITSHM
+         XShmPutImage (display, window, gc, image, 0, 0, 0, 0, image->width,
+                       image->height, FALSE);
+#endif
+         break;
+      case X11_NORMAL:
+         XPutImage (display, window, gc, image, 0, 0, 0, 0, image->width,
+                    image->height);
+         break;
+   }
+}
+
+INLINE void x11_window_put_image (int x, int y, int width, int height)
+{
+   switch (x11_window_update_method)
+   {
+      case X11_XIL:
+         /* xil doesn't need a put_image */
+         break;
+      case X11_MITSHM:
+#ifdef USE_MITSHM
+         XShmPutImage (display, window, gc, image, x, y, x+startx, y+starty, width, height,
+                       FALSE);
+#endif
+         break;
+      case X11_NORMAL:
+         XPutImage (display, window, gc, image, x, y, x+startx, y+starty, width, height);
+         break;
+   }
+}
+
+#define DEST_WIDTH image_width
+#define DEST scaled_buffer_ptr
+#define SRC_PIXEL unsigned char
+#define PUT_IMAGE(X, Y, WIDTH, HEIGHT) x11_window_put_image(X, Y, WIDTH, HEIGHT);
+
+#define DEST_PIXEL unsigned char
+
+static void x11_window_update_8_to_8bpp_direct (void)
+{
+#include "blit.h"
+}
+
+static void x11_window_update_8_to_8bpp (void)
+{
+#define INDIRECT pseudo_color_lookup
+#include "blit.h"
+#undef INDIRECT
+}
+
+#undef DEST_PIXEL
+
+#define INDIRECT sysdep_palette->lookup
+
+static void x11_window_update_8_to_16bpp (void)
+{
+#define BLIT_16BPP_HACK
+#define DEST_PIXEL unsigned short
+#include "blit.h"
+#undef DEST_PIXEL
+#undef BLIT_16BPP_HACK
+}
+
+#define DEST_PIXEL unsigned int
+
+static void x11_window_update_8_to_24bpp (void)
+{
+#define PACK_BITS
+#include "blit.h"
+#undef PACK_BITS
+}
+
+static void x11_window_update_8_to_32bpp (void)
+{
+#include "blit.h"
+}
+
+#undef  DEST_PIXEL
+
+#undef  SRC_PIXEL
+#define SRC_PIXEL unsigned short
+
+static void x11_window_update_16_to_16bpp (void)
+{
+#define DEST_PIXEL unsigned short
+
+   if (sysdep_palette->lookup)
+   {
+#include "blit.h"
+   }
+   else
+   {
+#undef  INDIRECT
+#include "blit.h"
+#define INDIRECT sysdep_palette->lookup
+   }
+
+#undef DEST_PIXEL
+}
+
+#define DEST_PIXEL unsigned int
+
+static void x11_window_update_16_to_24bpp (void)
+{
+#define PACK_BITS
+#include "blit.h"
+#undef PACK_BITS
+}
+
+static void x11_window_update_16_to_32bpp (void)
+{
+#include "blit.h"
+}
+
+#undef  DEST_PIXEL
+
+#endif /* ifdef x11 */
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/xf86_dga.c mame-0.36b16/src/unix/video-drivers/xf86_dga.c
--- ../mmmmm/m36b16/src/unix/video-drivers/xf86_dga.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/xf86_dga.c	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,596 @@
+/*
+ *	XFree86 VidMode and DGA support by Jens Vaasjo <jvaasjo@iname.com>
+ */
+#ifdef USE_DGA
+#define __XF86_DGA_C
+
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/extensions/xf86dga.h>
+#include <X11/extensions/xf86vmode.h>
+#endif
+#include "xmame.h"
+#include "x11.h"
+
+struct rc_option xf86_dga_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+#ifdef USE_DGA
+   { "XFree86 DGA Related", NULL,		rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL,		NULL,			rc_link,	mode_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+#endif
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+#ifdef USE_DGA
+
+static void xf86_dga_update_display_8_to_8bpp(struct osd_bitmap *bitmap);
+static void xf86_dga_update_display_8_to_16bpp(struct osd_bitmap *bitmap);
+static void xf86_dga_update_display_8_to_24bpp(struct osd_bitmap *bitmap);
+static void xf86_dga_update_display_8_to_32bpp(struct osd_bitmap *bitmap);
+static void xf86_dga_update_display_16_to_16bpp(struct osd_bitmap *bitmap);
+static void xf86_dga_update_display_16_to_24bpp(struct osd_bitmap *bitmap);
+static void xf86_dga_update_display_16_to_32bpp(struct osd_bitmap *bitmap);
+
+static struct
+{
+	int screen;
+	unsigned char *addr;
+	int grabbed_keybd;
+	int grabbed_mouse;
+	int old_grab_mouse;
+	char *base_addr;
+	int width;
+	int bank_size;
+	int ram_size;
+	Colormap cmap;
+	void (*xf86_dga_update_display_func)(struct osd_bitmap *bitmap);
+	XF86VidModeModeInfo orig_mode;
+	int vidmode_changed;
+	int palette_dirty;
+} xf86ctx = {-1,NULL,FALSE,FALSE,FALSE,NULL,-1,-1,-1,0,NULL,{0},FALSE,FALSE};
+		
+static unsigned char *doublebuffer_buffer = NULL;
+
+
+int xf86_dga_init(void)
+{
+	int i;
+	char *s;
+	
+	mode_available[X11_DGA] = FALSE;
+	xf86ctx.screen          = DefaultScreen(display);
+	
+	
+	if(geteuid())
+		fprintf(stderr,"DGA requires root rights\n");
+	else if (!(s = getenv("DISPLAY")) || (s[0] != ':'))
+		fprintf(stderr,"DGA only works on a local display\n");
+	else if(!XF86DGAQueryVersion(display, &i, &i))
+		fprintf(stderr,"XF86DGAQueryVersion failed\n");
+	else if(!XF86DGAQueryExtension(display, &i, &i))
+		fprintf(stderr,"XF86DGAQueryExtension failed\n");
+	else if(!XF86DGAQueryDirectVideo(display, xf86ctx.screen, &i))
+		fprintf(stderr,"XF86DGAQueryDirectVideo failed\n");
+	else if(!(i & XF86DGADirectPresent))
+		fprintf(stderr,"XF86DGADirectVideo support is not present\n");
+	else if(!XF86DGAGetVideo(display,xf86ctx.screen,
+		 &xf86ctx.base_addr,&xf86ctx.width,
+		 &xf86ctx.bank_size,&xf86ctx.ram_size))
+		fprintf(stderr,"XF86DGAGetVideo failed\n");
+	else
+		mode_available[X11_DGA] = TRUE; 
+		
+	if (!mode_available[X11_DGA])
+		fprintf(stderr,"Use of DGA-modes is disabled\n");
+
+	return OSD_OK;
+}
+
+int xf86_dga_16bpp_capable(void)
+{
+   int screen_no = DefaultScreen (display);
+   return (DefaultDepth(display, screen_no) >= 15);
+}
+
+static int xf86_dga_vidmode_check_exts(void)
+{
+	int major,minor,event_base,error_base;
+
+	if(!XF86VidModeQueryVersion(display,&major,&minor))
+	{
+		fprintf(stderr_file,"XF86VidModeQueryVersion failed\n");
+		return OSD_NOT_OK;
+	}
+
+	if(!XF86VidModeQueryExtension(display,&event_base,&error_base))
+	{
+		fprintf(stderr_file,"XF86VidModeQueryExtension failed\n");
+		return OSD_NOT_OK;
+	}
+
+	return OSD_OK;
+}
+
+static XF86VidModeModeInfo *xf86_dga_vidmode_find_best_vidmode(int depth)
+{
+	XF86VidModeModeInfo **modes,*bestmode = NULL;
+	int score, best_score = 0;
+	int i,modecount = 0;
+
+	if(!XF86VidModeGetAllModeLines(display,xf86ctx.screen,
+						&modecount,&modes))
+	{
+		fprintf(stderr_file,"XF86VidModeGetAllModeLines failed\n");
+		return NULL;
+	}
+	
+	fprintf(stderr, "XF86DGA: info: found %d modes:\n", modecount);
+
+	for(i=0;i<modecount;i++)
+	{
+		if (mode_disabled(modes[i]->hdisplay, modes[i]->vdisplay, depth))
+			continue;
+		fprintf(stderr, "XF86DGA: info: found mode: %dx%d\n",
+		   modes[i]->hdisplay, modes[i]->vdisplay);
+		/* ignore modes with a width which is not 64 bit aligned */
+		if(modes[i]->hdisplay & 7) continue;
+		
+		score = mode_match(modes[i]->hdisplay, modes[i]->vdisplay);
+		if(score > best_score)
+		{
+			best_score = score;
+			bestmode   = modes[i];
+		}
+	}
+
+	return bestmode;
+}
+
+static Bool xf86_dga_vidmode_getmodeinfo(XF86VidModeModeInfo *modeinfo)
+{
+	XF86VidModeModeLine modeline;
+	int dotclock;
+	Bool err;
+
+	err = XF86VidModeGetModeLine(display,xf86ctx.screen,
+					&dotclock,&modeline);
+
+	modeinfo->dotclock = dotclock;
+	modeinfo->hdisplay = modeline.hdisplay;
+	modeinfo->hsyncstart = modeline.hsyncstart;
+	modeinfo->hsyncend = modeline.hsyncend;
+	modeinfo->htotal = modeline.htotal;
+	modeinfo->vdisplay = modeline.vdisplay;
+	modeinfo->vsyncstart = modeline.vsyncstart;
+	modeinfo->vsyncend = modeline.vsyncend;
+	modeinfo->vtotal = modeline.vtotal;
+	modeinfo->flags = modeline.flags;
+	modeinfo->privsize = modeline.privsize;
+	modeinfo->private = modeline.private;
+
+	return err;
+}
+
+static void xf86_dga_vidmode_restoremode(Display *disp)
+{
+	XF86VidModeSwitchToMode(disp, xf86ctx.screen, &xf86ctx.orig_mode);
+	/* 'Mach64-hack': restores screen when screwed up */
+	XF86VidModeSwitchMode(disp,xf86ctx.screen,-1);
+	XF86VidModeSwitchMode(disp,xf86ctx.screen,1);
+	/**************************************************/
+	XSync(disp,False);
+}
+
+static int xf86_dga_vidmode_setup_mode_restore(void)
+{
+	Display *disp;
+	int status;
+	pid_t pid;
+
+	if(!xf86_dga_vidmode_getmodeinfo(&xf86ctx.orig_mode))
+	{
+		fprintf(stderr_file,"XF86VidModeGetModeLine failed\n");
+		return OSD_NOT_OK;
+	}
+
+	pid = fork();
+	if(pid > 0)
+	{
+		waitpid(pid,&status,0);
+		disp = XOpenDisplay(NULL);
+		xf86_dga_vidmode_restoremode(disp);
+		XCloseDisplay(disp);
+		_exit(!WIFEXITED(status));
+	}
+
+	if (pid < 0)
+	{
+		perror("fork");
+		return OSD_NOT_OK;
+	}
+
+	return OSD_OK;
+}
+
+int xf86_dga_alloc_palette(int writable_colors)
+{
+	XColor color;
+	int i;
+
+	/* this is only relevant for 8bpp displays */
+	if (depth != 8)
+	   return 0;
+
+	xf86ctx.cmap = XCreateColormap(display,window,xvisual,AllocAll);
+
+	for(i=0;i<writable_colors;i++)
+	{
+		color.pixel = i;
+		color.red   = 0;
+		color.green = 0;
+		color.blue  = 0;
+		color.flags = DoRed | DoGreen | DoBlue;
+
+		XStoreColor(display,xf86ctx.cmap,&color);
+	}
+	return 0;
+}
+
+static int xf86_dga_setup_graphics(XF86VidModeModeInfo *modeinfo, int bitmap_depth)
+{
+	int sizeof_pixel;
+	
+	if(xf86ctx.bank_size != (xf86ctx.ram_size * 1024))
+	{
+		fprintf(stderr_file,"banked graphics modes not supported\n");
+		return OSD_NOT_OK;
+	}
+	
+	if (bitmap_depth == 16)
+	{
+	    switch(depth)
+	    {
+		case 16:
+			xf86ctx.xf86_dga_update_display_func =
+				xf86_dga_update_display_16_to_16bpp;
+			break;
+		case 24:
+			xf86ctx.xf86_dga_update_display_func =
+				xf86_dga_update_display_16_to_24bpp;
+			break;
+		case 32:
+			xf86ctx.xf86_dga_update_display_func =
+				xf86_dga_update_display_16_to_32bpp;
+			break;
+	    }
+	}
+	else
+	{
+	    switch(depth)
+	    {
+		case 8:
+			xf86ctx.xf86_dga_update_display_func =
+				xf86_dga_update_display_8_to_8bpp;
+			break;
+		case 16:
+			xf86ctx.xf86_dga_update_display_func =
+				xf86_dga_update_display_8_to_16bpp;
+			break;
+		case 24:
+			xf86ctx.xf86_dga_update_display_func =
+				xf86_dga_update_display_8_to_24bpp;
+			break;
+		case 32:
+			xf86ctx.xf86_dga_update_display_func =
+				xf86_dga_update_display_8_to_32bpp;
+			break;
+	    }
+	}
+	
+	if (xf86ctx.xf86_dga_update_display_func == NULL)
+	{
+		fprintf(stderr_file, "unsupported depth %dbpp\n",depth);
+		return OSD_NOT_OK;
+	}
+	
+	fprintf(stderr_file, "XF86-DGA running at: %dbpp\n", depth);
+	
+	sizeof_pixel  = depth / 8;
+
+	xf86ctx.addr  = (unsigned char*)xf86ctx.base_addr;
+	xf86ctx.addr += (((modeinfo->hdisplay - visual_width*widthscale) / 2) & ~7)
+						* sizeof_pixel;
+	xf86ctx.addr += ((modeinfo->vdisplay - visual_height*heightscale) / 2)
+				* xf86ctx.width * sizeof_pixel;
+
+	return OSD_OK;
+}
+
+/* This name doesn't really cover this function, since it also sets up mouse
+   and keyboard. This is done over here, since on most display targets the
+   mouse and keyboard can't be setup before the display has. */
+int xf86_dga_create_display(int bitmap_depth)
+{
+	int i, count;
+	XPixmapFormatValues *pixmaps;
+	XF86VidModeModeInfo *bestmode;
+	/* only have todo the fork's the first time we go DGA, otherwise people
+	   who do a lott of dga <-> window switching will get a lott of
+	   children */
+	static int first_time  = 1;
+	xf86_dga_fix_viewport  = 0;
+	xf86_dga_first_click   = 1;
+	xf86ctx.palette_dirty  = FALSE;
+	xf86ctx.old_grab_mouse = x11_grab_mouse;
+	x11_grab_mouse         = FALSE;
+	
+	xvisual = DefaultVisual(display,xf86ctx.screen);
+	window  = RootWindow(display,xf86ctx.screen);
+	/* dirty hack 24bpp can be either 24bpp packed or 32 bpp sparse */
+	pixmaps = XListPixmapFormats(display, &count);
+	if (!pixmaps)
+	{
+	   fprintf(stderr_file, "X11-Error: Couldn't list pixmap formats.\n"
+	      "Probably out of memory.\n");
+	   return OSD_NOT_OK;
+	}
+        for(i=0; i<count; i++)
+        {
+           if(pixmaps[i].depth==DefaultDepth(display,xf86ctx.screen))
+           {
+	      depth = pixmaps[i].bits_per_pixel;
+	      break;
+           }  
+        }
+        if(i==count)
+        {
+           fprintf(stderr_file, "Couldn't find a zpixmap with the defaultcolordepth\nThis should not happen!\n");
+           return OSD_NOT_OK;
+        }
+        XFree(pixmaps);
+        
+	/* setup the palette_info struct now we have the depth */
+	if (x11_init_palette_info() != OSD_OK)
+	    return OSD_NOT_OK;
+        
+        if (widthscale != 1 || heightscale != 1)
+        {
+	   doublebuffer_buffer = malloc (visual_width * widthscale * depth / 8);
+	   if (doublebuffer_buffer == NULL)
+	   {
+	      fprintf(stderr, "Error: Couldn't alloc enough memory\n");
+	      return OSD_NOT_OK;
+	   }
+        }
+
+	if(xf86_dga_vidmode_check_exts())
+		return OSD_NOT_OK;
+
+	bestmode = xf86_dga_vidmode_find_best_vidmode(bitmap_depth);
+	if(!bestmode)
+	{
+		fprintf(stderr_file,"no suitable mode found\n");
+		return OSD_NOT_OK;
+	}
+
+	if(xf86_dga_setup_graphics(bestmode, bitmap_depth))
+		return OSD_NOT_OK;
+	
+	if (first_time)
+	{
+		if(xf86_dga_vidmode_setup_mode_restore())
+			return OSD_NOT_OK;
+	}
+
+	fprintf(stderr_file,"VidMode Switching To Mode: %d x %d\n",
+			bestmode->hdisplay,bestmode->vdisplay);
+
+	if(!XF86VidModeSwitchToMode(display,xf86ctx.screen,bestmode))
+	{
+		fprintf(stderr_file,"XF86VidModeSwitchToMode failed\n");
+		return OSD_NOT_OK;
+	}
+	xf86ctx.vidmode_changed = TRUE;
+
+	if(XGrabKeyboard(display,window,True,
+		GrabModeAsync,GrabModeAsync,CurrentTime))
+	{
+		fprintf(stderr_file,"XGrabKeyboard failed\n");
+		return OSD_NOT_OK;
+	}
+	xf86ctx.grabbed_keybd = 1;
+
+	if(use_mouse)
+	{
+		if(XGrabPointer(display,window,True,
+			PointerMotionMask|ButtonPressMask|ButtonReleaseMask,
+			GrabModeAsync,GrabModeAsync,None,None,CurrentTime))
+		{
+			fprintf(stderr_file, "XGrabPointer failed, mouse disabled\n");
+			use_mouse = 0;
+		}
+		else
+			xf86ctx.grabbed_mouse = 1;
+	}
+
+	if(first_time)
+	{
+		if(XF86DGAForkApp(xf86ctx.screen))
+		{
+			perror("fork");
+			return OSD_NOT_OK;
+		}
+		first_time = 0;
+	}
+
+	if(!XF86DGADirectVideo(display,xf86ctx.screen,
+		XF86DGADirectGraphics|XF86DGADirectMouse|XF86DGADirectKeyb))
+	{
+		fprintf(stderr_file,"XF86DGADirectVideo failed\n");
+		return OSD_NOT_OK;
+	}
+
+	if(!XF86DGASetViewPort(display,xf86ctx.screen,0,0))
+	{
+		fprintf(stderr_file,"XF86DGASetViewPort failed\n");
+		return OSD_NOT_OK;
+	}
+
+	memset(xf86ctx.base_addr,0,xf86ctx.bank_size);
+	
+	return OSD_OK;
+}
+
+
+int xf86_dga_modify_pen(int pen,
+	unsigned char red,unsigned char green,unsigned char blue)
+{
+	XColor color;
+	color.pixel = pen;
+	color.red   = red   << 8;
+	color.green = green << 8;
+	color.blue  = blue  << 8;
+	color.flags = DoRed | DoGreen | DoBlue;
+
+	XStoreColor(display,xf86ctx.cmap,&color);
+	xf86ctx.palette_dirty = TRUE;
+	return 0;
+}
+
+#define DEST xf86ctx.addr
+#define DEST_WIDTH xf86ctx.width
+#define SRC_PIXEL unsigned char
+/* Use double buffering where it speeds things up */
+#define DOUBLEBUFFER
+
+static void xf86_dga_update_display_8_to_8bpp(struct osd_bitmap *bitmap)
+{
+   if (xf86ctx.palette_dirty)
+   {
+      XF86DGAInstallColormap(display,xf86ctx.screen,xf86ctx.cmap);
+      xf86ctx.palette_dirty = FALSE;
+   }
+#define DEST_PIXEL unsigned char
+#include "blit.h"
+#undef DEST_PIXEL
+}
+
+#define INDIRECT current_palette->lookup
+
+static void xf86_dga_update_display_8_to_16bpp(struct osd_bitmap *bitmap)
+{
+#define DEST_PIXEL unsigned short
+#define BLIT_16BPP_HACK
+#include "blit.h"
+#undef DEST_PIXEL
+#undef BLIT_16BPP_HACK
+}
+
+#define DEST_PIXEL unsigned int
+
+static void xf86_dga_update_display_8_to_24bpp(struct osd_bitmap *bitmap)
+{
+#define PACK_BITS
+#include "blit.h"
+#undef PACK_BITS
+}
+
+static void xf86_dga_update_display_8_to_32bpp(struct osd_bitmap *bitmap)
+{
+#include "blit.h"
+}
+
+#undef  DEST_PIXEL
+
+#undef  SRC_PIXEL
+#define SRC_PIXEL unsigned short
+
+static void xf86_dga_update_display_16_to_16bpp(struct osd_bitmap *bitmap)
+{
+#define DEST_PIXEL unsigned short
+   if (current_palette->lookup)
+   {
+#include "blit.h"
+   }
+   else
+   {
+#undef  INDIRECT
+#include "blit.h"
+#define INDIRECT current_palette->lookup
+   }
+#undef DEST_PIXEL
+}
+
+#define DEST_PIXEL unsigned int
+
+static void xf86_dga_update_display_16_to_24bpp(struct osd_bitmap *bitmap)
+{
+#define PACK_BITS
+#include "blit.h"
+#undef PACK_BITS
+}
+
+static void xf86_dga_update_display_16_to_32bpp(struct osd_bitmap *bitmap)
+{
+#include "blit.h"
+}
+#undef DEST_PIXEL
+
+void xf86_dga_update_display(struct osd_bitmap *bitmap)
+{
+	int old_use_dirty = use_dirty;
+   
+	if(xf86_dga_fix_viewport)
+	{
+		XF86DGASetViewPort(display,xf86ctx.screen,0,0);
+		xf86_dga_fix_viewport = 0;
+	}
+	
+	if (current_palette->lookup_dirty)
+		use_dirty = 0;
+	
+	(*xf86ctx.xf86_dga_update_display_func)(bitmap);
+	
+	use_dirty = old_use_dirty;
+}
+
+void xf86_dga_close_display(void)
+{
+	if(doublebuffer_buffer)
+	{
+		free(doublebuffer_buffer);
+		doublebuffer_buffer = NULL;
+	}
+	if(xf86ctx.cmap)
+	{
+		XFreeColormap(display,xf86ctx.cmap);
+		xf86ctx.cmap = 0;
+	}
+	if(xf86ctx.grabbed_mouse)
+	{
+		XUngrabPointer(display,CurrentTime);
+		xf86ctx.grabbed_mouse = FALSE;
+	}
+	if(xf86ctx.grabbed_keybd)
+	{
+		XUngrabKeyboard(display,CurrentTime);
+		xf86ctx.grabbed_keybd = FALSE;
+	}
+	XF86DGADirectVideo(display,xf86ctx.screen, 0);
+	if(xf86ctx.vidmode_changed)
+	{
+		xf86_dga_vidmode_restoremode(display);
+		xf86ctx.vidmode_changed = FALSE;
+	}
+	x11_grab_mouse = xf86ctx.old_grab_mouse;
+}
+
+#endif /*def USE_DGA*/
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/xfx.c mame-0.36b16/src/unix/video-drivers/xfx.c
--- ../mmmmm/m36b16/src/unix/video-drivers/xfx.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/xfx.c	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,243 @@
+/*****************************************************************
+
+  Xmame glide driver
+
+  Written based on the x11 driver by Mike Oliphant - oliphant@ling.ed.ac.uk
+
+    http://www.ling.ed.ac.uk/~oliphant/glmame
+
+  This code may be used and distributed under the terms of the
+  Mame license
+
+*****************************************************************/
+/* pretend we're x11.c otherwise display and a few other crucial things don't
+   get declared */
+#define __X11_C_   
+#define __XFX_C_
+
+
+#include <math.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/cursorfont.h>
+#include "xmame.h"
+#include "x11.h"
+
+int  InitVScreen(void);
+void CloseVScreen(void);
+int  InitGlide(void);
+
+extern int fxwidth;
+extern int fxheight;
+extern struct rc_option fx_opts[];
+
+static Cursor        cursor;
+static XVisualInfo   myvisual;
+
+struct rc_option display_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { NULL, 		NULL,			rc_link,	fx_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL, 		NULL,			rc_link,	x11_input_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+typedef struct {
+#define MWM_HINTS_DECORATIONS   2
+  long flags;
+  long functions;
+  long decorations;
+  long input_mode;
+} MotifWmHints;
+
+int sysdep_init(void)
+{
+  fprintf(stdout,
+     "info: using FXmame v0.5 driver for xmame, written by Mike Oliphant\n");
+  
+  /* Open the display. */
+  display=XOpenDisplay(NULL);
+
+  if(!display) {
+	fprintf (stderr,"OSD ERROR: failed to open the display.\n");
+	return OSD_NOT_OK; 
+  }
+
+  return InitGlide();
+}
+
+void sysdep_close(void)
+{
+   XCloseDisplay(display);
+}
+
+/* This name doesn't really cover this function, since it also sets up mouse
+   and keyboard. This is done over here, since on most display targets the
+   mouse and keyboard can't be setup before the display has. */
+int sysdep_create_display(int depth)
+{
+  XSetWindowAttributes winattr;
+  int 		 myscreen;
+  XEvent	 event;
+  XSizeHints 	 hints;
+  XWMHints 	 wm_hints;
+  MotifWmHints mwmhints;
+  Atom mwmatom;
+  
+  if(depth == 16)
+  {
+     fprintf(stderr_file, "%s doesn't support 16bpp video modes\n", title);
+     return OSD_NOT_OK;
+  }
+
+  screen=DefaultScreenOfDisplay(display);
+  myscreen=DefaultScreen(display);
+  cursor=XCreateFontCursor(display,XC_trek);
+  
+  if(!XMatchVisualInfo(display,myscreen,8,PseudoColor,&myvisual)) {
+	fprintf(stderr,"8bit depth PseudoColor X-Visual not available :-( \n");
+	/* test for a 8bpp environment */
+	if      (XMatchVisualInfo(display,myscreen,8,TrueColor,&myvisual))
+	  fprintf(stderr,"Using 8bpp TrueColor X-Visual Resource\n");
+	/* test for a 15bpp environment */
+	else if (XMatchVisualInfo(display,myscreen,15,TrueColor,&myvisual))
+	  fprintf(stderr,"Using 15bpp TrueColor X-Visual Resource\n");
+	/* test for a 16bpp environment */
+	else if (XMatchVisualInfo(display,myscreen,16,TrueColor,&myvisual))
+	  fprintf(stderr,"Using 16bpp TrueColor X-Visual Resource\n");
+	/* test for a 24bpp environment */
+	else if (XMatchVisualInfo(display,myscreen,24,TrueColor,&myvisual))
+	  fprintf(stderr,"Using 24bpp TrueColor X-Visual Resource\n");
+	/* test for a 32bpp environment */
+	else if (XMatchVisualInfo(display,myscreen,32,TrueColor,&myvisual))
+	  fprintf(stderr,"Using 32bpp TrueColor X-Visual Resource\n");
+	/* if arrives here means an error :-( */
+	else
+	  {
+		fprintf(stderr,"Cannot find any supported X-Visual resource\n");
+		sysdep_display_close(); /* this will clean up for us */
+		return OSD_NOT_OK; 
+	  }
+  } else fprintf(stderr,"Using 8bpp PseudoColor Visual. Good!\n");
+
+  colormap=XCreateColormap(display,
+						   RootWindow(display,myvisual.screen),
+						   myvisual.visual,AllocNone);
+
+  winattr.background_pixel=0;
+  winattr.border_pixel=WhitePixelOfScreen(screen);
+  winattr.bit_gravity=ForgetGravity;
+  winattr.win_gravity=NorthWestGravity;
+  winattr.backing_store=NotUseful;
+  winattr.override_redirect=False;
+  winattr.save_under=False;
+  winattr.event_mask=0;
+  winattr.do_not_propagate_mask=0;
+  winattr.colormap=colormap;
+  winattr.cursor=None;
+
+  window=XCreateWindow(display,RootWindowOfScreen(screen),0,0,fxwidth,fxheight,
+					   0,myvisual.depth,
+					   InputOutput,myvisual.visual,
+					   CWBorderPixel | CWBackPixel |
+					   CWEventMask | CWDontPropagate |
+					   CWColormap | CWCursor,&winattr);
+  
+  if (!window) {
+	fprintf(stderr,"OSD ERROR: failed in XCreateWindow().\n");
+	sysdep_display_close();
+	return OSD_NOT_OK; 
+  }
+  
+  /*  Placement hints etc. */
+
+  hints.flags=PMinSize|PMaxSize|USPosition|USSize;
+  
+  hints.min_width=hints.max_width=hints.base_width=screen->width;
+  hints.min_height=hints.max_height=hints.base_height=screen->height;
+
+  hints.x=hints.y=0;
+  
+  wm_hints.input=TRUE;
+  wm_hints.flags=InputHint;
+  
+  XSetWMHints(display,window,&wm_hints);
+  XSetWMNormalHints(display,window,&hints);
+  XStoreName(display,window,title);
+  
+  XDefineCursor(display,window,cursor);
+
+  /* Hack to get rid of window title bar */
+  
+  mwmhints.flags=MWM_HINTS_DECORATIONS;
+  mwmhints.decorations=0;
+  mwmatom=XInternAtom(display,"_MOTIF_WM_HINTS",0);
+  
+  XChangeProperty(display,window,mwmatom,mwmatom,32,
+				  PropModeReplace,(unsigned char *)&mwmhints,4);
+  
+  /* Map and expose the window. */
+
+  if(use_mouse) {
+	/* grab the pointer and query MotionNotify events */
+
+	XSelectInput(display, 
+				 window, 
+				 FocusChangeMask   | ExposureMask | 
+				 KeyPressMask      | KeyReleaseMask | 
+				 EnterWindowMask   | LeaveWindowMask |
+				 PointerMotionMask | ButtonMotionMask |
+				 ButtonPressMask   | ButtonReleaseMask
+				 );
+	
+	XGrabPointer(display,
+				 window, /* RootWindow(display,DefaultScreen(display)), */
+				 False,
+				 PointerMotionMask | ButtonMotionMask |
+				 ButtonPressMask   | ButtonReleaseMask | 
+				 EnterWindowMask   | LeaveWindowMask ,
+				 GrabModeAsync, GrabModeAsync,
+				 None, cursor, CurrentTime );
+  }
+  else {
+	XSelectInput(display, 
+				 window, 
+				 FocusChangeMask | ExposureMask | 
+				 KeyPressMask | KeyReleaseMask
+				 );
+  }
+  
+  XMapRaised(display,window);
+  XClearWindow(display,window);
+  XWindowEvent(display,window,ExposureMask,&event);
+  
+  if (InitVScreen() != OSD_OK)
+     return OSD_NOT_OK;
+  
+  return OSD_OK;
+}
+
+/*
+ * Shut down the display, also used to clean up if any error happens
+ * when creating the display
+ */
+
+void sysdep_display_close (void)
+{
+   XFreeColormap(display, colormap);
+     
+   if(window) {
+     /* ungrab the pointer */
+
+     if(use_mouse) XUngrabPointer(display,CurrentTime);
+
+     CloseVScreen();  /* Shut down glide stuff */
+   }
+
+   XSync(display,False); /* send all events to sync; */
+}
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/xgl.c mame-0.36b16/src/unix/video-drivers/xgl.c
--- ../mmmmm/m36b16/src/unix/video-drivers/xgl.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/xgl.c	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,321 @@
+/*****************************************************************
+
+  Xmame OpenGL driver
+
+  Written based on the x11 driver by Mike Oliphant - oliphant@ling.ed.ac.uk
+
+    http://www.ling.ed.ac.uk/~oliphant/glmame
+
+  This code may be used and distributed under the terms of the
+  Mame license
+
+*****************************************************************/
+/* pretend we're x11.c otherwise display and a few other crucial things don't
+   get declared */
+#define __X11_C_   
+#define __XOPENGL_C_
+
+#define RRand(range) (random()%range)
+
+#include <math.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/Xmd.h>
+#include <X11/cursorfont.h>
+#include <GL/gl.h>
+#include <GL/glx.h>
+#include <GL/glu.h>
+#include "xmame.h"
+#include "x11.h"
+
+void InitVScreen(void);
+void CloseVScreen(void);
+
+static Cursor        cursor;
+static XVisualInfo   *myvisual;
+
+typedef struct {
+#define MWM_HINTS_DECORATIONS   2
+  long flags;
+  long functions;
+  long decorations;
+  long input_mode;
+} MotifWmHints;
+
+int winwidth = 640;
+int winheight = 480;
+int doublebuffer = 1;
+
+static int dbdepat[]={GLX_RGBA,GLX_DOUBLEBUFFER,GLX_DEPTH_SIZE,16,None};
+static int sbdepat[]={GLX_RGBA,GLX_DEPTH_SIZE,16,None};
+static int dbnodepat[]={GLX_RGBA,GLX_DOUBLEBUFFER,None};
+static int sbnodepat[]={GLX_RGBA,None};
+static GLXContext cx;
+
+extern int screendirty;
+extern int dodepth;
+
+static int xgl_handle_resolution(struct rc_option *option, const char *arg,
+   int priority)
+{
+  int width, height;
+  
+  if (sscanf(arg, "%dx%d", &width, &height) != 2)
+  {
+      fprintf(stderr, "error: invalid resolution: \"%s\".\n", arg);
+      return -1;
+  }
+  winwidth  = width;
+  winheight = height;
+  return 0;
+}
+
+struct rc_option display_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "OpenGL Related",	NULL,			rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "resolution",	"res",			rc_use_function, NULL,
+     "640x480",		0,			0,		xgl_handle_resolution,
+     "Specify the resolution/ windowsize to use in the form of XRESxYRES" },
+   { "dblbuffer",	NULL,			rc_bool,	&doublebuffer,
+     "1",		0,			0,		NULL,
+     "Enable/disable double buffering" },
+   { "cabview",		NULL,			rc_bool,	&cabview,
+     "1",		0,			0,		NULL,
+     "Start/ don't start in cabinet view mode" },
+   { "cabinet",		NULL,			rc_string,	&cabname,
+     "glmame",		0,			0,		NULL,
+     "Specify which cabinet model to use" },
+   { NULL,		NULL,			rc_link,	x11_input_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+int sysdep_init(void)
+{
+   fprintf(stdout, "Using GLmame v0.6 driver for xmame, written by Mike Oliphant\n");
+
+   /* Open the display. */
+   display=XOpenDisplay(NULL);
+
+   if(!display) {
+      fprintf (stderr,"OSD ERROR: failed to open the display.\n");
+      return OSD_NOT_OK; 
+   }
+  
+   return OSD_OK;
+}
+
+void sysdep_close(void)
+{
+   XCloseDisplay(display);
+}
+
+
+/* This name doesn't really cover this function, since it also sets up mouse
+   and keyboard. This is done over here, since on most display targets the
+   mouse and keyboard can't be setup before the display has. */
+int sysdep_create_display(int depth)
+{
+  XSetWindowAttributes winattr;
+  int 		myscreen;
+  XEvent	event;
+  XSizeHints 	hints;
+  XWMHints 	wm_hints;
+  MotifWmHints	mwmhints;
+  Atom mwmatom;
+  char *glxfx;
+  int fx = 0;
+  int x, y;
+
+  if(depth == 16)
+  {
+     fprintf(stderr_file, "%s doesn't support 16bpp video modes\n", title);
+     return OSD_NOT_OK;
+  }
+
+  printf("Using GLmame v0.6 driver for xmame, written by Mike Oliphant\n");
+  
+  if ((glxfx=getenv("MESA_GLX_FX")) && (glxfx[0]=='f') )
+  {
+     fx=1;
+     putenv("FX_GLIDE_NO_SPLASH=");
+  }
+
+  screen=DefaultScreenOfDisplay(display);
+  myscreen=DefaultScreen(display);
+  cursor=XCreateFontCursor(display,XC_trek);
+  
+  if(doublebuffer) {
+	if(dodepth)
+	  myvisual=glXChooseVisual(display,myscreen,dbdepat);
+	else 
+	  myvisual=glXChooseVisual(display,myscreen,dbnodepat);
+  }
+  else {
+	if(dodepth)
+	  myvisual=glXChooseVisual(display,myscreen,sbdepat);
+	else
+	  myvisual=glXChooseVisual(display,myscreen,sbnodepat);
+  }
+
+  if(!myvisual) {
+	fprintf(stderr,"OSD ERROR: failed to obtain visual.\n");
+	sysdep_display_close();
+	return OSD_NOT_OK; 
+  }
+
+  cx=glXCreateContext(display,myvisual,0,GL_TRUE);
+
+  if(!cx) {
+	fprintf(stderr,"OSD ERROR: failed to create OpenGL context.\n");
+	sysdep_display_close();
+	return OSD_NOT_OK; 
+  }
+  
+  colormap=XCreateColormap(display,
+						   RootWindow(display,myvisual->screen),
+						   myvisual->visual,AllocNone);
+
+  winattr.background_pixel=0;
+  winattr.border_pixel=WhitePixelOfScreen(screen);
+  winattr.bit_gravity=ForgetGravity;
+  winattr.win_gravity=NorthWestGravity;
+  winattr.backing_store=NotUseful;
+  winattr.override_redirect=False;
+  winattr.save_under=False;
+  winattr.event_mask=0;
+  winattr.do_not_propagate_mask=0;
+  winattr.colormap=colormap;
+  winattr.cursor=None;
+
+  window=XCreateWindow(display,RootWindowOfScreen(screen),0,0,winwidth,winheight,
+					   0,myvisual->depth,
+					   InputOutput,myvisual->visual,
+					   CWBorderPixel | CWBackPixel |
+					   CWEventMask | CWDontPropagate |
+					   CWColormap | CWCursor,&winattr);
+  
+  if (!window) {
+	fprintf(stderr,"OSD ERROR: failed in XCreateWindow().\n");
+	sysdep_display_close();
+	return OSD_NOT_OK; 
+  }
+  
+  /*  Placement hints etc. */
+  
+  hints.flags=PMinSize|PMaxSize;
+  
+  if(fx) hints.flags|=USPosition|USSize;
+  else hints.flags|=PSize;
+
+  hints.min_width	= hints.max_width = hints.base_width = winwidth;
+  hints.min_height= hints.max_height = hints.base_height = winheight;
+  
+  wm_hints.input=TRUE;
+  wm_hints.flags=InputHint;
+  
+  XSetWMHints(display,window,&wm_hints);
+  XSetWMNormalHints(display,window,&hints);
+  XStoreName(display,window,title);
+  
+  XDefineCursor(display,window,cursor);
+
+  /* Hack to get rid of window title bar */
+  
+  if(fx) {
+	mwmhints.flags=MWM_HINTS_DECORATIONS;
+	mwmhints.decorations=0;
+	mwmatom=XInternAtom(display,"_MOTIF_WM_HINTS",0);
+  
+	XChangeProperty(display,window,mwmatom,mwmatom,32,
+					PropModeReplace,(unsigned char *)&mwmhints,4);
+  }
+  
+  /* Map and expose the window. */
+
+  if(use_mouse) {
+	/* grab the pointer and query MotionNotify events */
+
+	XSelectInput(display, 
+				 window, 
+				 FocusChangeMask   | ExposureMask | 
+				 KeyPressMask      | KeyReleaseMask | 
+				 EnterWindowMask   | LeaveWindowMask |
+				 PointerMotionMask | ButtonMotionMask |
+				 ButtonPressMask   | ButtonReleaseMask
+				 );
+	
+	XGrabPointer(display,
+				 window, /* RootWindow(display,DefaultScreen(display)), */
+				 False,
+				 PointerMotionMask | ButtonMotionMask |
+				 ButtonPressMask   | ButtonReleaseMask | 
+				 EnterWindowMask   | LeaveWindowMask ,
+				 GrabModeAsync, GrabModeAsync,
+				 None, cursor, CurrentTime );
+  }
+  else {
+	XSelectInput(display, 
+				 window, 
+				 FocusChangeMask | ExposureMask | 
+				 KeyPressMask | KeyReleaseMask
+				 );
+  }
+  
+  XMapRaised(display,window);
+  XClearWindow(display,window);
+  XWindowEvent(display,window,ExposureMask,&event);
+  
+  glXMakeCurrent(display,window,cx);
+
+  /* If using 3Dfx, Resize the window to fullscreen so we don't lose focus
+     We have to do this after glXMakeCurrent(), or else the voodoo driver
+     will give us the wrong resolution */
+
+  if(fx) {
+	XResizeWindow(display,window,screen->width,screen->height);
+
+	hints.min_width	= hints.max_width = hints.base_width = screen->width;
+	hints.min_height= hints.max_height = hints.base_height = screen->height;
+
+	XSetWMNormalHints(display,window,&hints);
+  }
+
+  InitVScreen();
+  
+  return OSD_OK;
+}
+
+/*
+ * Shut down the display, also used to clean up if any error happens
+ * when creating the display
+ */
+
+void sysdep_display_close (void)
+{
+   glXDestroyContext(display,cx);
+
+   XFreeColormap(display, colormap);
+     
+   if(window) {
+     /* ungrab the pointer */
+
+     if(use_mouse) XUngrabPointer(display,CurrentTime);
+
+     CloseVScreen();  /* Shut down GL stuff */
+   }
+
+   XSync(display,False); /* send all events to sync; */
+}
+
+/* Swap GL video buffers */
+
+void SwapBuffers(void)
+{
+  glXSwapBuffers(display,window);
+}
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/xil.c mame-0.36b16/src/unix/video-drivers/xil.c
--- ../mmmmm/m36b16/src/unix/video-drivers/xil.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/xil.c	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,129 @@
+/*
+ *  Support for the XIL imaging library.
+ *
+ *  Elias Mrtenson (elias-m@algonet.se)
+ */
+
+/* moved above the #ifdef to avoid warning about empty c-files */
+#include <stdio.h>
+
+#ifdef USE_XIL
+
+#include <thread.h>
+#include <pthread.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <xil/xil.h>
+#include "xmame.h"
+#include "x11.h"
+
+static void scale_screen( XilImage );
+static void *redraw_thread( void * );
+
+static XilSystemState state;
+static XilImage window_image, draw_image;
+static int draw_image_xsize, draw_image_ysize;
+static int window_width, window_height;
+
+static pthread_mutex_t img_mutex;
+static pthread_cond_t img_cond;
+static int paintflag;
+static XilImage back_image;
+
+void init_xil( void )
+{
+  if( (state = xil_open()) == NULL ) {
+    fprintf( stderr, "Failed to open XIL library, disabling\n" );
+    use_xil = 0;
+  }
+  else {
+    printf( "Using XIL library\n" );
+  }
+}
+
+void setup_xil_images( int xsize, int ysize )
+{
+  XilMemoryStorage storage_info;
+  pthread_t thread_id;
+
+  window_image = xil_create_from_window( state, display, window );
+
+  draw_image_xsize = xsize;
+  draw_image_ysize = ysize;
+
+  window_width = xsize;
+  window_height = ysize;
+
+  draw_image = xil_create( state, xsize, ysize, 1, XIL_BYTE );
+  xil_export( draw_image );
+  xil_get_memory_storage( draw_image, &storage_info );
+  scaled_buffer_ptr = (char *)storage_info.byte.data;
+
+  if( use_mt_xil ) {
+    printf( "initializing scaling thread\n" );
+    back_image = xil_create( state, xsize, ysize, 1, XIL_BYTE );
+    pthread_mutex_init( &img_mutex, NULL );
+    paintflag = 0;
+    pthread_create( &thread_id, NULL, redraw_thread, NULL );
+  }
+}
+
+void refresh_xil_screen( void )
+{
+  XilMemoryStorage storage_info;
+
+  xil_import( draw_image, TRUE );
+  if( use_mt_xil ) {
+    pthread_mutex_lock( &img_mutex );
+    while( paintflag ) {
+      pthread_cond_wait( &img_cond, &img_mutex );
+    }
+    xil_copy( draw_image, back_image );
+    paintflag = 1;
+    pthread_mutex_unlock( &img_mutex );
+    pthread_cond_signal( &img_cond );
+  }
+  else {
+    scale_screen( draw_image );
+  }
+
+  xil_export( draw_image );
+  xil_get_memory_storage( draw_image, &storage_info );
+  scaled_buffer_ptr = (char *)storage_info.byte.data;
+}
+
+static void scale_screen( XilImage source )
+{
+  xil_scale( source, window_image, "nearest",
+	     window_width / (float)draw_image_xsize,
+	     window_height / (float)draw_image_ysize );
+}
+
+void update_xil_window_size( int width, int height )
+{
+  window_width = width;
+  window_height = height;
+
+  if( window_image != NULL ) {
+    xil_destroy( window_image );
+  }
+  window_image = xil_create_from_window( state, display, window );
+}  
+
+static void *redraw_thread( void *arg )
+{
+  for( ;; ) {
+    pthread_mutex_lock( &img_mutex );
+    while( !paintflag ) {
+      pthread_cond_wait( &img_cond, &img_mutex );
+    }
+    scale_screen( back_image );
+    paintflag = 0;
+    pthread_mutex_unlock( &img_mutex );
+    pthread_cond_signal( &img_cond );
+  }
+
+  return NULL;
+}
+
+#endif
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/xinput.c mame-0.36b16/src/unix/video-drivers/xinput.c
--- ../mmmmm/m36b16/src/unix/video-drivers/xinput.c	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/xinput.c	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,273 @@
+/*
+ * X-Mame x11 input code
+ *
+ */
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/keysym.h>
+#include "xmame.h"
+#include "devices.h"
+#include "x11.h"
+#include "xkeyboard.h"
+#include "keyboard.h"
+
+static int current_mouse[MOUSE_AXIS] = {0,0,0,0,0,0,0,0};
+static int x11_use_winkeys = 0;
+
+static int x11_mapkey(struct rc_option *option, const char *arg, int priority);
+
+struct rc_option x11_input_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "X11-input related", NULL,			rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "grabmouse",	"gm",			rc_bool,	&x11_grab_mouse,
+     "0",		0,			0,		NULL,
+     "Enable/disable mousegrabbing (also alt + pagedown)" },
+   { "winkeys",		"wk",			rc_bool,	&x11_use_winkeys,
+     "0",		0,			0,		NULL,
+     "Enable/disable mapping of windowskeys under X" },
+   { "mapkey",		"mk",			rc_use_function, NULL,
+     NULL,		0,			0,		x11_mapkey,
+     "Set a specific key mapping, see xmamerc.dist" },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+/*
+ * Parse keyboard events
+ */
+void sysdep_update_keyboard (void)
+{
+  XEvent 		E;
+  KeySym 		keysym;
+  char			keyname[16+1];
+  int			mask;
+  struct keyboard_event event;
+  static int		old_grab_mouse = FALSE;
+  /* grrr some windowmanagers send multiple focus events, this is used to
+     filter them. */
+  static int            focus = FALSE;
+
+  /* handle winkey mappings */
+  if (x11_use_winkeys)
+  {
+    extended_code_table[XK_Meta_L&0x1FF] = KEY_LWIN;
+    extended_code_table[XK_Meta_R&0x1FF] = KEY_RWIN;
+  }
+
+#ifdef NOT_DEFINED /* x11 */
+  if(run_in_root_window && x11_video_mode == X11_WINDOW)
+  {
+     static int i=0;
+     i = ++i % 3;
+     switch (i)
+     {
+        case 0:
+           xkey[KEY_O] = 0;
+           xkey[KEY_K] = 0;
+           break;
+        case 1:
+           xkey[KEY_O] = 1;
+           xkey[KEY_K] = 0;
+           break;
+        case 2:
+           xkey[KEY_O] = 0;
+           xkey[KEY_K] = 1;
+           break;
+     }
+  }
+  else
+#endif
+
+  /* query all events that we have previously requested */
+  while ( XPending(display) )
+  {
+    mask = FALSE;
+    event.press = FALSE;
+
+    XNextEvent(display,&E);
+/*  fprintf(stderr_file,"Event: %d\n",E.type); */
+
+    /* we don't have to check x11_video_mode or extensions like xil here,
+       since our eventmask should make sure that we only get the event's matching
+       the current update method */
+    switch (E.type)
+    {
+      /* display events */
+#ifdef x11
+      case Expose:
+  	if ( E.xexpose.count == 0 ) x11_window_refresh_screen();
+	break;
+#endif
+      case FocusIn:
+        /* check for multiple events and ignore them */
+        if (focus) break;
+        focus = TRUE;
+	/* to avoid some meta-keys to get locked when wm iconify xmame, we must
+	perform a key reset whenever we retrieve keyboard focus */
+	keyboard_clear();
+	if (old_grab_mouse)
+	{
+            if (!XGrabPointer(display, window, True, 0, GrabModeAsync,
+                GrabModeAsync, window, None, CurrentTime))
+            {
+                if (show_cursor) XDefineCursor(display,window,invisible_cursor);
+                x11_grab_mouse = TRUE;
+            }
+	}
+	break;
+      case FocusOut:
+        /* check for multiple events and ignore them */
+        if (!focus) break;
+        focus = FALSE;
+        old_grab_mouse = x11_grab_mouse;
+        if (x11_grab_mouse)
+        {
+            XUngrabPointer(display, CurrentTime);
+            if (show_cursor) XDefineCursor(display,window,normal_cursor);
+            x11_grab_mouse = FALSE;
+        }
+        break;
+      case EnterNotify:
+	if (use_private_cmap) XInstallColormap(display,colormap);
+	break;
+      case LeaveNotify:
+	if (use_private_cmap) XInstallColormap(display,DefaultColormapOfScreen(screen));
+	break;
+#ifdef USE_XIL
+      case ConfigureNotify:
+	update_xil_window_size( E.xconfigure.width, E.xconfigure.height );
+	break;
+#endif
+      /* input events */
+      case MotionNotify:
+        current_mouse[0] += E.xmotion.x_root;
+        current_mouse[1] += E.xmotion.y_root;
+        break;
+      case ButtonPress:
+        mask = TRUE;
+#ifdef USE_DGA
+        /* Some buggy combination of XFree and virge screwup the viewport
+           on the first mouseclick */
+        if(xf86_dga_first_click) { xf86_dga_first_click = 0; xf86_dga_fix_viewport = 1; }
+#endif
+      case ButtonRelease:
+        mouse_data[0].buttons[E.xbutton.button-1] = mask;
+        break;
+      case KeyPress:
+        event.press = TRUE;
+      case KeyRelease:
+        /* get bare keysym, for the scancode */
+        keysym = XLookupKeysym ((XKeyEvent *) &E, 0);
+        /* get key name, using modifiers for the unicode */
+	XLookupString ((XKeyEvent *) &E, keyname, 16, NULL, NULL);
+
+/*	fprintf(stderr, "Keyevent keycode: %04X, keysym: %04X, unicode: %02X\n",
+	   E.xkey.keycode, (unsigned int)keysym, (unsigned int)keyname[0]); */
+
+	/* look which table should be used */
+        if ( (keysym & ~0x1ff) == 0xfe00 )
+	   event.scancode = extended_code_table[keysym & 0x01ff];
+	else if (keysym < 0xff)
+	   event.scancode = code_table[keysym & 0x00ff];
+	else
+	   event.scancode = 0;
+
+	event.unicode = keyname[0];
+
+	keyboard_register_event(&event);
+	break;
+#ifdef X11_JOYSTICK
+      /* grrr we can't use case here since the event types for XInput devices
+         aren't hardcoded, since we should have caught anything else above,
+         just asume it's an XInput event */
+      default:
+	  process_x11_joy_event(&E);
+	  break;
+#endif
+    } /* switch */
+  } /* while */
+}
+
+/*
+ *  keyboard remapping routine
+ *  invoiced in startup code
+ *  returns 0-> success 1-> invalid from or to
+ */
+static int x11_mapkey(struct rc_option *option, const char *arg, int priority)
+{
+   unsigned int from,to;
+   /* ultrix sscanf() requires explicit leading of 0x for hex numbers */
+   if ( sscanf(arg,"0x%x,0x%x",&from,&to) == 2)
+   {
+      /* perform tests */
+      /* fprintf(stderr_file,"trying to map %x to%x\n",from,to); */
+      if ( to <= 127 )
+      {
+         if ( from <= 0x00ff )
+         {
+            code_table[from]=to; return OSD_OK;
+         }
+         else if ( (from>=0xfe00) && (from<=0xffff) )
+         {
+            extended_code_table[from&0x01ff]=to; return OSD_OK;
+         }
+      }
+      /* stderr_file isn't defined yet when we're called. */
+      fprintf(stderr,"Invalid keymapping %s. Ignoring...\n", arg);
+   }
+   return OSD_NOT_OK;
+}
+
+void sysdep_mouse_poll (void)
+{
+	int i;
+	if(x11_video_mode == X11_DGA)
+	{
+		/* 2 should be MOUSE_AXIS but we don't support more
+		   then 2 axis at the moment so this is faster */
+		for (i=0; i<2; i++)
+		{
+		   mouse_data[0].deltas[i] = current_mouse[i];
+		   current_mouse[i] = 0;
+		}
+	}
+	else
+	{
+		Window root,child;
+		int root_x, root_y, pos_x, pos_y;
+		unsigned int keys_buttons;
+
+		if (!XQueryPointer(display,window, &root,&child, &root_x,&root_y,
+			&pos_x,&pos_y,&keys_buttons) )
+		{
+			mouse_data[0].deltas[0] = 0;
+			mouse_data[0].deltas[1] = 0;
+			return;
+		}
+
+		if ( x11_grab_mouse )
+		{
+			XWarpPointer(display, None, window, 0, 0, 0, 0,
+				visual_width/2, visual_height/2);
+			mouse_data[0].deltas[0] = pos_x - visual_width/2;
+			mouse_data[0].deltas[1] = pos_y - visual_height/2;
+		}
+		else
+		{
+			mouse_data[0].deltas[0] = pos_x - current_mouse[0];
+			mouse_data[0].deltas[1] = pos_y - current_mouse[1];
+			current_mouse[0] = pos_x;
+			current_mouse[1] = pos_y;
+		}
+	}
+}
+
+void osd_led_w(int led, int on)
+{
+  (void) led;
+  (void) on;
+  /* empty sysdep_set_leds() from m37b7.1 */
+}
diff -Naur ../mmmmm/m36b16/src/unix/video-drivers/xkeyboard.h mame-0.36b16/src/unix/video-drivers/xkeyboard.h
--- ../mmmmm/m36b16/src/unix/video-drivers/xkeyboard.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/video-drivers/xkeyboard.h	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,823 @@
+#include "keyboard.h"
+
+/* translation table from X11 codes to raw keyboard scan codes */
+/* the idea is make a re-definable lookup table, instead a long case switch */
+
+/* following code is taken from keysmdef.h */
+
+/******************************************************************/
+/* $XConsortium: keysymdef.h /main/24 1996/02/02 14:28:10 kaleb $ */
+/******************************************************************/
+
+/* XK_VoidSymbol	0xFFFFFF	*/ /* void symbol */
+
+static int extended_code_table[512] = {
+/*                      		0xFE00  */ KEY_NONE,
+/* XK_ISO_Lock				0xFE01  */ KEY_NONE,
+/* XK_ISO_Level2_Latch			0xFE02  */ KEY_NONE,
+/* XK_ISO_Level3_Shift			0xFE03  */ KEY_NONE,
+/* XK_ISO_Level3_Latch			0xFE04  */ KEY_NONE,
+/* XK_ISO_Level3_Lock			0xFE05  */ KEY_NONE,
+/* XK_ISO_Group_Latch			0xFE06  */ KEY_NONE,
+/* XK_ISO_Group_Lock			0xFE07  */ KEY_NONE,
+/* XK_ISO_Next_Group			0xFE08  */ KEY_NONE,
+/* XK_ISO_Next_Group_Lock		0xFE09  */ KEY_NONE,
+/* XK_ISO_Prev_Group			0xFE0A  */ KEY_NONE,
+/* XK_ISO_Prev_Group_Lock		0xFE0B  */ KEY_NONE,
+/* XK_ISO_First_Group			0xFE0C  */ KEY_NONE,
+/* XK_ISO_First_Group_Lock		0xFE0D  */ KEY_NONE,
+/* XK_ISO_Last_Group			0xFE0E  */ KEY_NONE,
+/* XK_ISO_Last_Group_Lock		0xFE0F  */ KEY_NONE,
+/*					0xFE10  */ KEY_NONE,
+/*					0xFE11  */ KEY_NONE,
+/*					0xFE12  */ KEY_NONE,
+/*					0xFE13  */ KEY_NONE,
+/*					0xFE14  */ KEY_NONE,
+/*					0xFE15  */ KEY_NONE,
+/*					0xFE16  */ KEY_NONE,
+/*					0xFE17  */ KEY_NONE,
+/*					0xFE18  */ KEY_NONE,
+/*					0xFE19  */ KEY_NONE,
+/*					0xFE1A  */ KEY_NONE,
+/*					0xFE1B  */ KEY_NONE,
+/*					0xFE1C  */ KEY_NONE,
+/*					0xFE1D  */ KEY_NONE,
+/*					0xFE1E  */ KEY_NONE,
+/*					0xFE1F  */ KEY_NONE,
+/* XK_ISO_Left_Tab			0xFE20  */ KEY_TAB,
+/* XK_ISO_Move_Line_Up			0xFE21  */ KEY_UP,
+/* XK_ISO_Move_Line_Down		0xFE22  */ KEY_DOWN,
+/* XK_ISO_Partial_Line_Up		0xFE23  */ KEY_NONE,
+/* XK_ISO_Partial_Line_Down		0xFE24  */ KEY_NONE,
+/* XK_ISO_Partial_Space_Left		0xFE25  */ KEY_NONE,
+/* XK_ISO_Partial_Space_Right		0xFE26  */ KEY_NONE,
+/* XK_ISO_Set_Margin_Left		0xFE27  */ KEY_NONE,
+/* XK_ISO_Set_Margin_Right		0xFE28  */ KEY_NONE,
+/* XK_ISO_Release_Margin_Left		0xFE29  */ KEY_NONE,
+/* XK_ISO_Release_Margin_Right		0xFE2A  */ KEY_NONE,
+/* XK_ISO_Release_Both_Margins		0xFE2B  */ KEY_NONE,
+/* XK_ISO_Fast_Cursor_Left		0xFE2C  */ KEY_LEFT,
+/* XK_ISO_Fast_Cursor_Right		0xFE2D  */ KEY_RIGHT,
+/* XK_ISO_Fast_Cursor_Up		0xFE2E  */ KEY_UP,
+/* XK_ISO_Fast_Cursor_Down		0xFE2F  */ KEY_DOWN,
+/* XK_ISO_Continuous_Underline		0xFE30  */ KEY_MINUS,
+/* XK_ISO_Discontinuous_Underline	0xFE31  */ KEY_MINUS,
+/* XK_ISO_Emphasize			0xFE32  */ KEY_NONE,
+/* XK_ISO_Center_Object			0xFE33  */ KEY_NONE,
+/* XK_ISO_Enter				0xFE34  */ KEY_ENTER,
+/*					0xFE35  */ KEY_NONE,
+/*					0xFE36  */ KEY_NONE,
+/*					0xFE37  */ KEY_NONE,
+/*					0xFE38  */ KEY_NONE,
+/*					0xFE39  */ KEY_NONE,
+/*					0xFE3A  */ KEY_NONE,
+/*					0xFE3B  */ KEY_NONE,
+/*					0xFE3C  */ KEY_NONE,
+/*					0xFE3D  */ KEY_NONE,
+/*					0xFE3E  */ KEY_NONE,
+/*					0xFE3F  */ KEY_NONE,
+/*					0xFE40  */ KEY_NONE,
+/*					0xFE41  */ KEY_NONE,
+/*					0xFE42  */ KEY_NONE,
+/*					0xFE43  */ KEY_NONE,
+/*					0xFE44  */ KEY_NONE,
+/*					0xFE45  */ KEY_NONE,
+/*					0xFE46  */ KEY_NONE,
+/*					0xFE47  */ KEY_NONE,
+/*					0xFE48  */ KEY_NONE,
+/*					0xFE49  */ KEY_NONE,
+/*					0xFE4A  */ KEY_NONE,
+/*					0xFE4B  */ KEY_NONE,
+/*					0xFE4C  */ KEY_NONE,
+/*					0xFE4D  */ KEY_NONE,
+/*					0xFE4E  */ KEY_NONE,
+/*					0xFE4F  */ KEY_NONE,
+/* XK_dead_grave			0xFE50  */ KEY_TILDE,
+/* XK_dead_acute			0xFE51  */ KEY_NONE,
+/* XK_dead_circumflex			0xFE52  */ KEY_TILDE,
+/* XK_dead_tilde			0xFE53  */ KEY_TILDE,
+/* XK_dead_macron			0xFE54  */ KEY_NONE,
+/* XK_dead_breve			0xFE55  */ KEY_NONE,
+/* XK_dead_abovedot			0xFE56  */ KEY_NONE,
+/* XK_dead_diaeresis			0xFE57  */ KEY_NONE,
+/* XK_dead_abovering			0xFE58  */ KEY_NONE,
+/* XK_dead_doubleacute			0xFE59  */ KEY_NONE,
+/* XK_dead_caron			0xFE5A  */ KEY_NONE,
+/* XK_dead_cedilla			0xFE5B  */ KEY_NONE,
+/* XK_dead_ogonek			0xFE5C  */ KEY_NONE,
+/* XK_dead_iota				0xFE5D  */ KEY_NONE,
+/* XK_dead_voiced_sound			0xFE5E  */ KEY_NONE,
+/* XK_dead_semivoiced_sound		0xFE5F  */ KEY_NONE,
+/* XK_dead_belowdot			0xFE60  */ KEY_NONE,
+/*					0xFE61  */ KEY_NONE,
+/*					0xFE62  */ KEY_NONE,
+/*					0xFE63  */ KEY_NONE,
+/*					0xFE64  */ KEY_NONE,
+/*					0xFE65  */ KEY_NONE,
+/*					0xFE66  */ KEY_NONE,
+/*					0xFE67  */ KEY_NONE,
+/*					0xFE68  */ KEY_NONE,
+/*					0xFE69  */ KEY_NONE,
+/*					0xFE6A  */ KEY_NONE,
+/*					0xFE6B  */ KEY_NONE,
+/*					0xFE6C  */ KEY_NONE,
+/*					0xFE6D  */ KEY_NONE,
+/*					0xFE6E  */ KEY_NONE,
+/*					0xFE6F  */ KEY_NONE,
+/* XK_AccessX_Enable			0xFE70  */ KEY_NONE,
+/* XK_AccessX_Feedback_Enable		0xFE71  */ KEY_NONE,
+/* XK_RepeatKeys_Enable			0xFE72  */ KEY_NONE,
+/* XK_SlowKeys_Enable			0xFE73  */ KEY_NONE,
+/* XK_BounceKeys_Enable			0xFE74  */ KEY_NONE,
+/* XK_StickyKeys_Enable			0xFE75  */ KEY_NONE,
+/* XK_MouseKeys_Enable			0xFE76  */ KEY_NONE,
+/* XK_MouseKeys_Accel_Enable		0xFE77  */ KEY_NONE,
+/* XK_Overlay1_Enable			0xFE78  */ KEY_NONE,
+/* XK_Overlay2_Enable			0xFE79  */ KEY_NONE,
+/* XK_AudibleBell_Enable		0xFE7A  */ KEY_NONE,
+/*					0xFE7B  */ KEY_NONE,
+/*					0xFE7C  */ KEY_NONE,
+/*					0xFE7D  */ KEY_NONE,
+/*					0xFE7E  */ KEY_NONE,
+/*					0xFE7F  */ KEY_NONE,
+/*					0xFE80  */ KEY_NONE,
+/*					0xFE81  */ KEY_NONE,
+/*					0xFE82  */ KEY_NONE,
+/*					0xFE83  */ KEY_NONE,
+/*					0xFE84  */ KEY_NONE,
+/*					0xFE85  */ KEY_NONE,
+/*					0xFE86  */ KEY_NONE,
+/*					0xFE87  */ KEY_NONE,
+/*					0xFE88  */ KEY_NONE,
+/*					0xFE89  */ KEY_NONE,
+/*					0xFE8A  */ KEY_NONE,
+/*					0xFE8B  */ KEY_NONE,
+/*					0xFE8C  */ KEY_NONE,
+/*					0xFE8D  */ KEY_NONE,
+/*					0xFE8E  */ KEY_NONE,
+/*					0xFE8F  */ KEY_NONE,
+/*					0xFE90  */ KEY_NONE,
+/*					0xFE91  */ KEY_NONE,
+/*					0xFE92  */ KEY_NONE,
+/*					0xFE93  */ KEY_NONE,
+/*					0xFE94  */ KEY_NONE,
+/*					0xFE95  */ KEY_NONE,
+/*					0xFE96  */ KEY_NONE,
+/*					0xFE97  */ KEY_NONE,
+/*					0xFE98  */ KEY_NONE,
+/*					0xFE99  */ KEY_NONE,
+/*					0xFE9A  */ KEY_NONE,
+/*					0xFE9B  */ KEY_NONE,
+/*					0xFE9C  */ KEY_NONE,
+/*					0xFE9D  */ KEY_NONE,
+/*					0xFE9E  */ KEY_NONE,
+/*					0xFE9F  */ KEY_NONE,
+/*					0xFEA0  */ KEY_NONE,
+/*					0xFEA1  */ KEY_NONE,
+/*					0xFEA2  */ KEY_NONE,
+/*					0xFEA3  */ KEY_NONE,
+/*					0xFEA4  */ KEY_NONE,
+/*					0xFEA5  */ KEY_NONE,
+/*					0xFEA6  */ KEY_NONE,
+/*					0xFEA7  */ KEY_NONE,
+/*					0xFEA8  */ KEY_NONE,
+/*					0xFEA9  */ KEY_NONE,
+/*					0xFEAA  */ KEY_NONE,
+/*					0xFEAB  */ KEY_NONE,
+/*					0xFEAC  */ KEY_NONE,
+/*					0xFEAD  */ KEY_NONE,
+/*					0xFEAE  */ KEY_NONE,
+/*					0xFEAF  */ KEY_NONE,
+/*					0xFEB0  */ KEY_NONE,
+/*					0xFEB1  */ KEY_NONE,
+/*					0xFEB2  */ KEY_NONE,
+/*					0xFEB3  */ KEY_NONE,
+/*					0xFEB4  */ KEY_NONE,
+/*					0xFEB5  */ KEY_NONE,
+/*					0xFEB6  */ KEY_NONE,
+/*					0xFEB7  */ KEY_NONE,
+/*					0xFEB8  */ KEY_NONE,
+/*					0xFEB9  */ KEY_NONE,
+/*					0xFEBA  */ KEY_NONE,
+/*					0xFEBB  */ KEY_NONE,
+/*					0xFEBC  */ KEY_NONE,
+/*					0xFEBD  */ KEY_NONE,
+/*					0xFEBE  */ KEY_NONE,
+/*					0xFEBF  */ KEY_NONE,
+/*					0xFEC0  */ KEY_NONE,
+/*					0xFEC1  */ KEY_NONE,
+/*					0xFEC2  */ KEY_NONE,
+/*					0xFEC3  */ KEY_NONE,
+/*					0xFEC4  */ KEY_NONE,
+/*					0xFEC5  */ KEY_NONE,
+/*					0xFEC6  */ KEY_NONE,
+/*					0xFEC7  */ KEY_NONE,
+/*					0xFEC8  */ KEY_NONE,
+/*					0xFEC9  */ KEY_NONE,
+/*					0xFECA  */ KEY_NONE,
+/*					0xFECB  */ KEY_NONE,
+/*					0xFECC  */ KEY_NONE,
+/*					0xFECD  */ KEY_NONE,
+/*					0xFECE  */ KEY_NONE,
+/*					0xFECF  */ KEY_NONE,
+/* XK_First_Virtual_Screen		0xFED0  */ KEY_NONE,
+/* XK_Prev_Virtual_Screen		0xFED1  */ KEY_NONE,
+/* XK_Next_Virtual_Screen		0xFED2  */ KEY_NONE,
+/*					0xFED3  */ KEY_NONE,
+/* XK_Last_Virtual_Screen		0xFED4  */ KEY_NONE,
+/* XK_Terminate_Server			0xFED5  */ KEY_NONE,
+/*					0xFED6  */ KEY_NONE,
+/*					0xFED7  */ KEY_NONE,
+/*					0xFED8  */ KEY_NONE,
+/*					0xFED9  */ KEY_NONE,
+/*					0xFEDA  */ KEY_NONE,
+/*					0xFEDB  */ KEY_NONE,
+/*					0xFEDC  */ KEY_NONE,
+/*					0xFEDD  */ KEY_NONE,
+/*					0xFEDE  */ KEY_NONE,
+/*					0xFEDF  */ KEY_NONE,
+/* XK_Pointer_Left			0xFEE0  */ KEY_NONE,
+/* XK_Pointer_Right			0xFEE1  */ KEY_NONE,
+/* XK_Pointer_Up			0xFEE2  */ KEY_NONE,
+/* XK_Pointer_Down			0xFEE3  */ KEY_NONE,
+/* XK_Pointer_UpLeft			0xFEE4  */ KEY_NONE,
+/* XK_Pointer_UpRight			0xFEE5  */ KEY_NONE,
+/* XK_Pointer_DownLeft			0xFEE6  */ KEY_NONE,
+/* XK_Pointer_DownRight			0xFEE7  */ KEY_NONE,
+/* XK_Pointer_Button_Dflt		0xFEE8  */ KEY_NONE,
+/* XK_Pointer_Button1			0xFEE9  */ KEY_NONE,
+/* XK_Pointer_Button2			0xFEEA  */ KEY_NONE,
+/* XK_Pointer_Button3			0xFEEB  */ KEY_NONE,
+/* XK_Pointer_Button4			0xFEEC  */ KEY_NONE,
+/* XK_Pointer_Button5			0xFEED  */ KEY_NONE,
+/* XK_Pointer_DblClick_Dflt		0xFEEE  */ KEY_NONE,
+/* XK_Pointer_DblClick1			0xFEEF  */ KEY_NONE,
+/* XK_Pointer_DblClick2			0xFEF0  */ KEY_NONE,
+/* XK_Pointer_DblClick3			0xFEF1  */ KEY_NONE,
+/* XK_Pointer_DblClick4			0xFEF2  */ KEY_NONE,
+/* XK_Pointer_DblClick5			0xFEF3  */ KEY_NONE,
+/* XK_Pointer_Drag_Dflt			0xFEF4  */ KEY_NONE,
+/* XK_Pointer_Drag1			0xFEF5  */ KEY_NONE,
+/* XK_Pointer_Drag2			0xFEF6  */ KEY_NONE,
+/* XK_Pointer_Drag3			0xFEF7  */ KEY_NONE,
+/* XK_Pointer_Drag4			0xFEF8  */ KEY_NONE,
+/* XK_Pointer_EnableKeys		0xFEF9  */ KEY_NONE,
+/* XK_Pointer_Accelerate		0xFEFA  */ KEY_NONE,
+/* XK_Pointer_DfltBtnNext		0xFEFB  */ KEY_NONE,
+/* XK_Pointer_DfltBtnPrev		0xFEFC  */ KEY_NONE,
+/* XK_Pointer_Drag5			0xFEFD  */ KEY_NONE,
+/*					0xFEFE  */ KEY_NONE,
+/*					0xFEFF  */ KEY_NONE,
+/*					0xFF00  */ KEY_NONE,
+/*					0xFF01  */ KEY_NONE,
+/*					0xFF02  */ KEY_NONE,
+/*					0xFF03  */ KEY_NONE,
+/*					0xFF04  */ KEY_NONE,
+/*					0xFF05  */ KEY_NONE,
+/*					0xFF06  */ KEY_NONE,
+/*					0xFF07  */ KEY_NONE,
+/* XK_BackSpace				0xFF08	*/ KEY_BACKSPACE,
+/* XK_Tab				0xFF09	*/ KEY_TAB,
+/* XK_Linefeed				0xFF0A	*/ KEY_ENTER,
+/* XK_Clear				0xFF0B  */ KEY_DEL,
+/*					0xFF0C  */ KEY_NONE,
+/* XK_Return				0xFF0D	*/ KEY_ENTER,
+/*					0xFF0E  */ KEY_NONE,
+/*					0xFF0F  */ KEY_NONE,
+/*					0xFF10  */ KEY_F11,
+/*					0xFF11  */ KEY_F12,
+/*					0xFF12  */ KEY_NONE,
+/* XK_Pause				0xFF13	*/ KEY_PAUSE,
+/* XK_Scroll_Lock			0xFF14  */ KEY_SCRLOCK,
+/* XK_Sys_Req				0xFF15  */ KEY_PRTSCR,
+/*					0xFF16  */ KEY_NONE,
+/*					0xFF17  */ KEY_NONE,
+/*					0xFF18  */ KEY_NONE,
+/*					0xFF19  */ KEY_NONE,
+/*					0xFF1A  */ KEY_NONE,
+/* XK_Escape				0xFF1B  */ KEY_ESC,
+/*					0xFF1C  */ KEY_NONE,
+/*					0xFF1D  */ KEY_NONE,
+/*					0xFF1E  */ KEY_NONE,
+/*					0xFF1F  */ KEY_NONE,
+/* XK_Multi_key				0xFF20  */ KEY_NONE,
+/* XK_Kanji				0xFF21	*/ KEY_NONE,
+/* XK_Muhenkan				0xFF22  */ KEY_NONE,
+/* XK_Henkan_Mode			0xFF23  */ KEY_NONE,
+/* XK_Henkan				0xFF23  duplicated */
+/* XK_Romaji				0xFF24  */ KEY_NONE,
+/* XK_Hiragana				0xFF25  */ KEY_NONE,
+/* XK_Katakana				0xFF26  */ KEY_NONE,
+/* XK_Hiragana_Katakana			0xFF27  */ KEY_NONE,
+/* XK_Zenkaku				0xFF28  */ KEY_NONE,
+/* XK_Hankaku				0xFF29  */ KEY_NONE,
+/* XK_Zenkaku_Hankaku			0xFF2A  */ KEY_NONE,
+/* XK_Touroku				0xFF2B  */ KEY_NONE,
+/* XK_Massyo				0xFF2C  */ KEY_NONE,
+/* XK_Kana_Lock				0xFF2D  */ KEY_NONE,
+/* XK_Kana_Shift			0xFF2E  */ KEY_NONE,
+/* XK_Eisu_Shift			0xFF2F  */ KEY_NONE,
+/* XK_Eisu_toggle			0xFF30  */ KEY_NONE,
+/*					0xFF31  */ KEY_NONE,
+/*					0xFF32  */ KEY_NONE,
+/*					0xFF33  */ KEY_NONE,
+/*					0xFF34  */ KEY_NONE,
+/*					0xFF35  */ KEY_NONE,
+/*					0xFF36  */ KEY_NONE,
+/*					0xFF37  */ KEY_NONE,
+/*					0xFF38  */ KEY_NONE,
+/*					0xFF39  */ KEY_NONE,
+/*					0xFF3A  */ KEY_NONE,
+/*					0xFF3B  */ KEY_NONE,
+/*					0xFF3C  */ KEY_NONE,
+/*					0xFF3D  */ KEY_NONE,
+/*					0xFF3E  */ KEY_NONE,
+/*					0xFF3F  */ KEY_NONE,
+/*					0xFF40  */ KEY_NONE,
+/*					0xFF41  */ KEY_NONE,
+/*					0xFF42  */ KEY_NONE,
+/*					0xFF43  */ KEY_NONE,
+/*					0xFF44  */ KEY_NONE,
+/*					0xFF45  */ KEY_NONE,
+/*					0xFF46  */ KEY_NONE,
+/*					0xFF47  */ KEY_NONE,
+/*					0xFF48  */ KEY_NONE,
+/*					0xFF49  */ KEY_NONE,
+/*					0xFF4A  */ KEY_NONE,
+/*					0xFF4B  */ KEY_NONE,
+/*					0xFF4C  */ KEY_NONE,
+/*					0xFF4D  */ KEY_NONE,
+/*					0xFF4E  */ KEY_NONE,
+/*					0xFF4F  */ KEY_NONE,
+/* XK_Home				0xFF50  */ KEY_HOME,
+/* XK_Left				0xFF51	*/ KEY_LEFT,
+/* XK_Up				0xFF52	*/ KEY_UP,
+/* XK_Right				0xFF53	*/ KEY_RIGHT,
+/* XK_Down				0xFF54	*/ KEY_DOWN,
+/* XK_Prior				0xFF55	*/ KEY_PGUP,
+/* XK_Page_Up				0xFF55  duplicated */
+/* XK_Next				0xFF56	*/ KEY_PGDN,
+/* XK_Page_Down				0xFF56  duplicated */
+/* XK_End				0xFF57	*/ KEY_END,
+/* XK_Begin				0xFF58	*/ KEY_HOME,
+/*					0xFF59  */ KEY_NONE,
+/*					0xFF5A  */ KEY_NONE,
+/*					0xFF5B  */ KEY_NONE,
+/*					0xFF5C  */ KEY_NONE,
+/*					0xFF5D  */ KEY_NONE,
+/*					0xFF5E  */ KEY_NONE,
+/*					0xFF5F  */ KEY_NONE,
+/* XK_Select				0xFF60	*/ KEY_ENTER_PAD,
+/* XK_Print				0xFF61  */ KEY_PRTSCR,
+/* XK_Execute				0xFF62	*/ KEY_ENTER,
+/* XK_Insert				0xFF63	*/ KEY_INSERT,
+/*					0xFF64	*/ KEY_NONE,
+/* XK_Undo				0xFF65	*/ KEY_NONE,
+/* XK_Redo				0xFF66	*/ KEY_NONE,
+/* XK_Menu				0xFF67  */ KEY_MENU,
+/* XK_Find				0xFF68	*/ KEY_NONE,
+/* XK_Cancel				0xFF69	*/ KEY_ESC,
+/* XK_Help				0xFF6A	*/ KEY_NONE,
+/* XK_Break				0xFF6B  */ KEY_PAUSE,
+/* 					0xFF6C  */ KEY_NONE,
+/* 					0xFF6D  */ KEY_NONE,
+/* 					0xFF6E  */ KEY_NONE,
+/* 					0xFF6F  */ KEY_NONE,
+/* 					0xFF70  */ KEY_NONE,
+/* 					0xFF71  */ KEY_NONE,
+/* 					0xFF72  */ KEY_NONE,
+/* 					0xFF73  */ KEY_NONE,
+/* 					0xFF74  */ KEY_NONE,
+/* 					0xFF75  */ KEY_NONE,
+/* 					0xFF76  */ KEY_NONE,
+/* 					0xFF77  */ KEY_NONE,
+/* 					0xFF78  */ KEY_NONE,
+/* 					0xFF79  */ KEY_NONE,
+/* 					0xFF7A  */ KEY_NONE,
+/* 					0xFF7B  */ KEY_NONE,
+/* 					0xFF7C  */ KEY_NONE,
+/* 					0xFF7D  */ KEY_NONE,
+/* XK_Mode_switch			0xFF7E	*/ KEY_ALTGR,
+/* XK_script_switch			0xFF7E  duplicated */
+/* XK_Num_Lock				0xFF7F  */ KEY_NUMLOCK,
+/* XK_KP_Space				0xFF80	*/ KEY_SPACE,
+/* 					0xFF81  */ KEY_NONE,
+/* 					0xFF82  */ KEY_NONE,
+/* 					0xFF83  */ KEY_NONE,
+/* 					0xFF84  */ KEY_NONE,
+/* 					0xFF85  */ KEY_NONE,
+/* 					0xFF86  */ KEY_NONE,
+/* 					0xFF87  */ KEY_NONE,
+/* 					0xFF88  */ KEY_NONE,
+/* XK_KP_Tab				0xFF89  */ KEY_TAB,
+/* 					0xFF8A  */ KEY_NONE,
+/* 					0xFF8B  */ KEY_NONE,
+/* 					0xFF8C  */ KEY_NONE,
+/* XK_KP_Enter				0xFF8D	*/ KEY_ENTER_PAD,
+/* 					0xFF8E  */ KEY_NONE,
+/* 					0xFF8F  */ KEY_NONE,
+/* 					0xFF90  */ KEY_NONE,
+/* XK_KP_F1				0xFF91	*/ KEY_F1,
+/* XK_KP_F2				0xFF92  */ KEY_F2,
+/* XK_KP_F3				0xFF93  */ KEY_F3,
+/* XK_KP_F4				0xFF94  */ KEY_F4,
+/* XK_KP_Home				0xFF95  */ KEY_7_PAD,
+/* XK_KP_Left				0xFF96  */ KEY_4_PAD,
+/* XK_KP_Up				0xFF97  */ KEY_8_PAD,
+/* XK_KP_Right				0xFF98  */ KEY_6_PAD,
+/* XK_KP_Down				0xFF99  */ KEY_2_PAD,
+/* XK_KP_Prior				0xFF9A  */ KEY_9_PAD,
+/* XK_KP_Page_Up			0xFF9A  duplicated */
+/* XK_KP_Next				0xFF9B  */ KEY_3_PAD,
+/* XK_KP_Page_Down			0xFF9B  duplicated */
+/* XK_KP_End				0xFF9C  */ KEY_1_PAD,
+/* XK_KP_Begin				0xFF9D  */ KEY_5_PAD,
+/* XK_KP_Insert				0xFF9E  */ KEY_0_PAD,
+/* XK_KP_Delete				0xFF9F  */ KEY_DEL_PAD,
+/* 					0xFFA0  */ KEY_NONE,
+/* 					0xFFA1  */ KEY_NONE,
+/* 					0xFFA2  */ KEY_NONE,
+/* 					0xFFA3  */ KEY_NONE,
+/* 					0xFFA4  */ KEY_NONE,
+/* 					0xFFA5  */ KEY_NONE,
+/* 					0xFFA6  */ KEY_NONE,
+/* 					0xFFA7  */ KEY_NONE,
+/* 					0xFFA8  */ KEY_NONE,
+/* 					0xFFA9  */ KEY_NONE,
+/* XK_KP_Multiply			0xFFAA  */ KEY_ASTERISK,
+/* XK_KP_Add				0xFFAB  */ KEY_PLUS_PAD,
+/* XK_KP_Separator			0xFFAC	*/ KEY_DEL_PAD,
+/* XK_KP_Subtract			0xFFAD  */ KEY_MINUS_PAD,
+/* XK_KP_Decimal			0xFFAE  */ KEY_DEL_PAD,
+/* XK_KP_Divide				0xFFAF  */ KEY_SLASH_PAD,
+/* XK_KP_0				0xFFB0  */ KEY_0_PAD,
+/* XK_KP_1				0xFFB1  */ KEY_1_PAD,
+/* XK_KP_2				0xFFB2  */ KEY_2_PAD,
+/* XK_KP_3				0xFFB3  */ KEY_3_PAD,
+/* XK_KP_4				0xFFB4  */ KEY_4_PAD,
+/* XK_KP_5				0xFFB5  */ KEY_5_PAD,
+/* XK_KP_6				0xFFB6  */ KEY_6_PAD,
+/* XK_KP_7				0xFFB7  */ KEY_7_PAD,
+/* XK_KP_8				0xFFB8  */ KEY_8_PAD,
+/* XK_KP_9				0xFFB9  */ KEY_9_PAD,
+/* 					0xFFBA  */ KEY_NONE,
+/* 					0xFFBB  */ KEY_NONE,
+/* 					0xFFBC  */ KEY_NONE,
+/* XK_KP_Equal				0xFFBD	*/ KEY_ENTER_PAD,
+/* XK_F1				0xFFBE  */ KEY_F1,
+/* XK_F2				0xFFBF  */ KEY_F2,
+/* XK_F3				0xFFC0  */ KEY_F3,
+/* XK_F4				0xFFC1  */ KEY_F4,
+/* XK_F5				0xFFC2  */ KEY_F5,
+/* XK_F6				0xFFC3  */ KEY_F6,
+/* XK_F7				0xFFC4  */ KEY_F7,
+/* XK_F8				0xFFC5  */ KEY_F8,
+/* XK_F9				0xFFC6  */ KEY_F9,
+/* XK_F10				0xFFC7  */ KEY_F10,
+/* XK_F11				0xFFC8  */ KEY_F11,
+/* XK_L1				0xFFC8  duplicated */
+/* XK_F12				0xFFC9  */ KEY_F12,
+/* XK_L2				0xFFC9  duplicated */
+/* XK_F13				0xFFCA  */ KEY_NONE,
+/* XK_L3				0xFFCA  duplicated */
+/* XK_F14				0xFFCB  */ KEY_NONE,
+/* XK_L4				0xFFCB  duplicated */
+/* XK_F15				0xFFCC  */ KEY_NONE,
+/* XK_L5				0xFFCC  duplicated */
+/* XK_F16				0xFFCD  */ KEY_NONE,
+/* XK_L6				0xFFCD  duplicated */
+/* XK_F17				0xFFCE  */ KEY_NONE,
+/* XK_L7				0xFFCE  duplicated */
+/* XK_F18				0xFFCF  */ KEY_NONE,
+/* XK_L8				0xFFCF  duplicated */
+/* XK_F19				0xFFD0  */ KEY_NONE,
+/* XK_L9				0xFFD0  duplicated */
+/* XK_F20				0xFFD1  */ KEY_NONE,
+/* XK_L10				0xFFD1  duplicated */
+/* XK_F21				0xFFD2  */ KEY_NONE,
+/* XK_R1				0xFFD2  duplicated */
+/* XK_F22				0xFFD3  */ KEY_NONE,
+/* XK_R2				0xFFD3  duplicated */
+/* XK_F23				0xFFD4  */ KEY_NONE,
+/* XK_R3				0xFFD4  duplicated */
+/* XK_F24				0xFFD5  */ KEY_NONE,
+/* XK_R4				0xFFD5  duplicated */
+/* XK_F25				0xFFD6  */ KEY_NONE,
+/* XK_R5				0xFFD6  duplicated */
+/* XK_F26				0xFFD7  */ KEY_NONE,
+/* XK_R6				0xFFD7  duplicated */
+/* XK_F27				0xFFD8  */ KEY_NONE,
+/* XK_R7				0xFFD8  duplicated */
+/* XK_F28				0xFFD9  */ KEY_NONE,
+/* XK_R8				0xFFD9  duplicated */
+/* XK_F29				0xFFDA  */ KEY_NONE,
+/* XK_R9				0xFFDA  duplicated */
+/* XK_F30				0xFFDB  */ KEY_NONE,
+/* XK_R10				0xFFDB  duplicated */
+/* XK_F31				0xFFDC  */ KEY_NONE,
+/* XK_R11				0xFFDC  duplicated */
+/* XK_F32				0xFFDD  */ KEY_NONE,
+/* XK_R12				0xFFDD  duplicated */
+/* XK_F33				0xFFDE  */ KEY_NONE,
+/* XK_R13				0xFFDE  duplicated */
+/* XK_F34				0xFFDF  */ KEY_NONE,
+/* XK_R14				0xFFDF  duplicated */
+/* XK_F35				0xFFE0  */ KEY_NONE,
+/* XK_R15				0xFFE0  duplicated */
+/* XK_Shift_L				0xFFE1	*/ KEY_LSHIFT,
+/* XK_Shift_R				0xFFE2	*/ KEY_RSHIFT,
+/* XK_Control_L				0xFFE3	*/ KEY_LCONTROL,
+/* XK_Control_R				0xFFE4	*/ KEY_RCONTROL,
+/* XK_Caps_Lock				0xFFE5	*/ KEY_CAPSLOCK,
+/* XK_Shift_Lock			0xFFE6	*/ KEY_CAPSLOCK,
+/* XK_Meta_L				0xFFE7	*/ KEY_ALT,
+/* XK_Meta_R				0xFFE8	*/ KEY_ALT, 
+/* XK_Alt_L				0xFFE9	*/ KEY_ALT,
+/* XK_Alt_R				0xFFEA	*/ KEY_ALTGR,
+/* XK_Super_L				0xFFEB	*/ KEY_NONE,
+/* XK_Super_R				0xFFEC	*/ KEY_NONE,
+/* XK_Hyper_L				0xFFED	*/ KEY_NONE,
+/* XK_Hyper_R				0xFFEE	*/ KEY_NONE,
+/* 					0xFFEF  */ KEY_NONE,
+/* 					0xFFF0  */ KEY_NONE,
+/* 					0xFFF1  */ KEY_NONE,
+/* 					0xFFF2  */ KEY_NONE,
+/* 					0xFFF3  */ KEY_NONE,
+/* 					0xFFF4  */ KEY_NONE,
+/* 					0xFFF5  */ KEY_NONE,
+/* 					0xFFF6  */ KEY_NONE,
+/* 					0xFFF7  */ KEY_NONE,
+/* 					0xFFF8  */ KEY_NONE,
+/* 					0xFFF9  */ KEY_NONE,
+/* 					0xFFFA  */ KEY_NONE,
+/* 					0xFFFB  */ KEY_NONE,
+/* 					0xFFFC  */ KEY_NONE,
+/* 					0xFFFD  */ KEY_NONE,
+/* 					0xFFFE  */ KEY_NONE,
+/* XK_Delete				0xFFFF	*/ KEY_DEL
+}; 	/* extended_code_table */
+
+static int code_table[] = {
+
+/* 			  0x000  */ KEY_NONE,
+/* 			  0x001  */ KEY_NONE,
+/* 			  0x002  */ KEY_NONE,
+/* 			  0x003  */ KEY_NONE,
+/* 			  0x004  */ KEY_NONE,
+/* 			  0x005  */ KEY_NONE,
+/* 			  0x006  */ KEY_NONE,
+/* 			  0x007  */ KEY_NONE,
+/* 			  0x008  */ KEY_NONE,
+/* 			  0x009  */ KEY_NONE,
+/* 			  0x00a  */ KEY_NONE,
+/* 			  0x00b  */ KEY_NONE,
+/* 			  0x00c  */ KEY_NONE,
+/* 			  0x00d  */ KEY_NONE,
+/* 			  0x00e  */ KEY_NONE,
+/* 			  0x00f  */ KEY_NONE,
+/* 			  0x010  */ KEY_NONE,
+/* 			  0x011  */ KEY_NONE,
+/* 			  0x012  */ KEY_NONE,
+/* 			  0x013  */ KEY_NONE,
+/* 			  0x014  */ KEY_NONE,
+/* 			  0x015  */ KEY_NONE,
+/* 			  0x016  */ KEY_NONE,
+/* 			  0x017  */ KEY_NONE,
+/* 			  0x018  */ KEY_NONE,
+/* 			  0x019  */ KEY_NONE,
+/* 			  0x01a  */ KEY_NONE,
+/* 			  0x01b  */ KEY_NONE,
+/* 			  0x01c  */ KEY_NONE,
+/* 			  0x01d  */ KEY_NONE,
+/* 			  0x01e  */ KEY_NONE,
+/* 			  0x01f  */ KEY_NONE,
+/* XK_space               0x020  */ KEY_SPACE,
+/* XK_exclam              0x021  */ KEY_1,
+/* XK_quotedbl            0x022  */ KEY_QUOTE,
+/* XK_numbersign          0x023  */ KEY_3,
+/* XK_dollar              0x024  */ KEY_4,
+/* XK_percent             0x025  */ KEY_5,
+/* XK_ampersand           0x026  */ KEY_7,
+/* XK_apostrophe          0x027  */ KEY_QUOTE, /* keyboard dependent */
+/* XK_quoteright          0x027	 duplicated */ 
+/* XK_parenleft           0x028  */ KEY_9,
+/* XK_parenright          0x029  */ KEY_0,
+/* XK_asterisk            0x02a  */ KEY_ASTERISK,
+/* XK_plus                0x02b  */ KEY_EQUALS,/* keyboard dependent */
+/* XK_comma               0x02c  */ KEY_COMMA,
+/* XK_minus               0x02d  */ KEY_MINUS,
+/* XK_period              0x02e  */ KEY_STOP,
+/* XK_slash               0x02f  */ KEY_SLASH,
+/* XK_0                   0x030  */ KEY_0,
+/* XK_1                   0x031  */ KEY_1,
+/* XK_2                   0x032  */ KEY_2,
+/* XK_3                   0x033  */ KEY_3,
+/* XK_4                   0x034  */ KEY_4,
+/* XK_5                   0x035  */ KEY_5,
+/* XK_6                   0x036  */ KEY_6,
+/* XK_7                   0x037  */ KEY_7,
+/* XK_8                   0x038  */ KEY_8,
+/* XK_9                   0x039  */ KEY_9,
+/* XK_colon               0x03a  */ KEY_COLON,
+/* XK_semicolon           0x03b  */ KEY_COLON,
+/* XK_less                0x03c  */ KEY_COMMA,
+/* XK_equal               0x03d  */ KEY_EQUALS,
+/* XK_greater             0x03e  */ KEY_STOP,
+/* XK_question            0x03f  */ KEY_SLASH,
+/* XK_at                  0x040  */ KEY_2,
+/* XK_A                   0x041  */ KEY_A,
+/* XK_B                   0x042  */ KEY_B,
+/* XK_C                   0x043  */ KEY_C,
+/* XK_D                   0x044  */ KEY_D,
+/* XK_E                   0x045  */ KEY_E,
+/* XK_F                   0x046  */ KEY_F,
+/* XK_G                   0x047  */ KEY_G,
+/* XK_H                   0x048  */ KEY_H,
+/* XK_I                   0x049  */ KEY_I,
+/* XK_J                   0x04a  */ KEY_J,
+/* XK_K                   0x04b  */ KEY_K,
+/* XK_L                   0x04c  */ KEY_L,
+/* XK_M                   0x04d  */ KEY_M,
+/* XK_N                   0x04e  */ KEY_N,
+/* XK_O                   0x04f  */ KEY_O,
+/* XK_P                   0x050  */ KEY_P,
+/* XK_Q                   0x051  */ KEY_Q,
+/* XK_R                   0x052  */ KEY_R,
+/* XK_S                   0x053  */ KEY_S,
+/* XK_T                   0x054  */ KEY_T,
+/* XK_U                   0x055  */ KEY_U,
+/* XK_V                   0x056  */ KEY_V,
+/* XK_W                   0x057  */ KEY_W,
+/* XK_X                   0x058  */ KEY_X,
+/* XK_Y                   0x059  */ KEY_Y,
+/* XK_Z                   0x05a  */ KEY_Z,
+/* XK_bracketleft         0x05b  */ KEY_OPENBRACE,
+/* XK_backslash           0x05c  */ KEY_BACKSLASH,
+/* XK_bracketright        0x05d  */ KEY_CLOSEBRACE,
+/* XK_asciicircum         0x05e  */ KEY_TILDE,
+/* XK_underscore          0x05f  */ KEY_MINUS,
+/* XK_grave               0x060  */ KEY_TILDE, /* keyboard dependent */
+/* XK_quoteleft           0x060  duplicated */
+/* XK_a                   0x061  */ KEY_A,
+/* XK_b                   0x062  */ KEY_B,
+/* XK_c                   0x063  */ KEY_C,
+/* XK_d                   0x064  */ KEY_D,
+/* XK_e                   0x065  */ KEY_E,
+/* XK_f                   0x066  */ KEY_F,
+/* XK_g                   0x067  */ KEY_G,
+/* XK_h                   0x068  */ KEY_H,
+/* XK_i                   0x069  */ KEY_I,
+/* XK_j                   0x06a  */ KEY_J,
+/* XK_k                   0x06b  */ KEY_K,
+/* XK_l                   0x06c  */ KEY_L,
+/* XK_m                   0x06d  */ KEY_M,
+/* XK_n                   0x06e  */ KEY_N,
+/* XK_o                   0x06f  */ KEY_O,
+/* XK_p                   0x070  */ KEY_P,
+/* XK_q                   0x071  */ KEY_Q,
+/* XK_r                   0x072  */ KEY_R,
+/* XK_s                   0x073  */ KEY_S,
+/* XK_t                   0x074  */ KEY_T,
+/* XK_u                   0x075  */ KEY_U,
+/* XK_v                   0x076  */ KEY_V,
+/* XK_w                   0x077  */ KEY_W,
+/* XK_x                   0x078  */ KEY_X,
+/* XK_y                   0x079  */ KEY_Y,
+/* XK_z                   0x07a  */ KEY_Z,
+/* XK_braceleft           0x07b  */ KEY_OPENBRACE,
+/* XK_bar                 0x07c  */ KEY_NONE,
+/* XK_braceright          0x07d  */ KEY_CLOSEBRACE,
+/* XK_asciitilde          0x07e  */ KEY_TILDE,
+/*                        0x07f  */ KEY_NONE,
+/* 			  0x080  */ KEY_NONE,
+/* 			  0x081  */ KEY_NONE,
+/* 			  0x082  */ KEY_NONE,
+/* 			  0x083  */ KEY_NONE,
+/* 			  0x084  */ KEY_NONE,
+/* 			  0x085  */ KEY_NONE,
+/* 			  0x086  */ KEY_NONE,
+/* 			  0x087  */ KEY_NONE,
+/* 			  0x088  */ KEY_NONE,
+/* 			  0x089  */ KEY_NONE,
+/* 			  0x08a  */ KEY_NONE,
+/* 			  0x08b  */ KEY_NONE,
+/* 			  0x08c  */ KEY_NONE,
+/* 			  0x08d  */ KEY_NONE,
+/* 			  0x08e  */ KEY_NONE,
+/* 			  0x08f  */ KEY_NONE,
+/* 			  0x090  */ KEY_NONE,
+/* 			  0x091  */ KEY_NONE,
+/* 			  0x092  */ KEY_NONE,
+/* 			  0x093  */ KEY_NONE,
+/* 			  0x094  */ KEY_NONE,
+/* 			  0x095  */ KEY_NONE,
+/* 			  0x096  */ KEY_NONE,
+/* 			  0x097  */ KEY_NONE,
+/* 			  0x098  */ KEY_NONE,
+/* 			  0x099  */ KEY_NONE,
+/* 			  0x09a  */ KEY_NONE,
+/* 			  0x09b  */ KEY_NONE,
+/* 			  0x09c  */ KEY_NONE,
+/* 			  0x09d  */ KEY_NONE,
+/* 			  0x09e  */ KEY_NONE,
+/* 			  0x09f  */ KEY_NONE,
+/* XK_nobreakspace        0x0a0  */ KEY_NONE,
+/* XK_exclamdown          0x0a1  */ KEY_EQUALS, /* keyboard dependent */
+/* XK_cent                0x0a2  */ KEY_NONE,
+/* XK_sterling            0x0a3  */ KEY_NONE,
+/* XK_currency            0x0a4  */ KEY_NONE,
+/* XK_yen                 0x0a5  */ KEY_NONE,
+/* XK_brokenbar           0x0a6  */ KEY_NONE,
+/* XK_section             0x0a7  */ KEY_TILDE,
+/* XK_diaeresis           0x0a8  */ KEY_NONE,
+/* XK_copyright           0x0a9  */ KEY_NONE,
+/* XK_ordfeminine         0x0aa  */ KEY_NONE,
+/* XK_guillemotleft       0x0ab  */ KEY_NONE,
+/* XK_notsign             0x0ac  */ KEY_NONE,
+/* XK_hyphen              0x0ad  */ KEY_NONE,
+/* XK_registered          0x0ae  */ KEY_NONE,
+/* XK_macron              0x0af  */ KEY_NONE,
+/* XK_degree              0x0b0  */ KEY_NONE,
+/* XK_plusminus           0x0b1  */ KEY_NONE,
+/* XK_twosuperior         0x0b2  */ KEY_NONE,
+/* XK_treesuperior        0x0b3  */ KEY_NONE,
+/* XK_acute               0x0b4  */ KEY_QUOTE, /* keyboard dependent */
+/* XK_mu                  0x0b5  */ KEY_NONE,
+/* XK_paragraph           0x0b6  */ KEY_NONE,
+/* XK_periodcentered      0x0b7  */ KEY_NONE,
+/* XK_cedilla             0x0b8  */ KEY_NONE,
+/* XK_onesuperior         0x0b9  */ KEY_NONE,
+/* XK_masculine           0x0ba  */ KEY_NONE,
+/* XK_guillemotright      0x0bb  */ KEY_NONE,
+/* XK_onequarter          0x0bc  */ KEY_NONE,
+/* XK_onehalf             0x0bd  */ KEY_NONE,
+/* XK_threequarters       0x0be  */ KEY_NONE,
+/* XK_questiondown        0x0bf  */ KEY_NONE,
+/* XK_Agrave              0x0c0  */ KEY_NONE,
+/* XK_Aacute              0x0c1  */ KEY_NONE,
+/* XK_Acircumflex         0x0c2  */ KEY_NONE,
+/* XK_Atilde              0x0c3  */ KEY_NONE,
+/* XK_Adiaeresis          0x0c4  */ KEY_NONE,
+/* XK_Aring               0x0c5  */ KEY_NONE,
+/* XK_AE                  0x0c6  */ KEY_NONE,
+/* XK_Ccedilla            0x0c7  */ KEY_NONE,
+/* XK_Egrave              0x0c8  */ KEY_NONE,
+/* XK_Eacute              0x0c9  */ KEY_NONE,
+/* XK_Ecircumflex         0x0ca  */ KEY_NONE,
+/* XK_Ediaeresis          0x0cb  */ KEY_NONE,
+/* XK_Igrave              0x0cc  */ KEY_NONE,
+/* XK_Iacute              0x0cd  */ KEY_NONE,
+/* XK_Icircumflex         0x0ce  */ KEY_NONE,
+/* XK_Idiaeresis          0x0cf  */ KEY_NONE,
+/* XK_ETH                 0x0d0  */ KEY_NONE,
+/* XK_Eth                 0x0d0  duplicated */
+/* XK_Ntilde              0x0d1  */ KEY_NONE,
+/* XK_Ograve              0x0d2  */ KEY_NONE,
+/* XK_Oacute              0x0d3  */ KEY_NONE,
+/* XK_Ocircumflex         0x0d4  */ KEY_NONE,
+/* XK_Otilde              0x0d5  */ KEY_NONE,
+/* XK_Odiaeresis          0x0d6  */ KEY_NONE,
+/* XK_multiply            0x0d7  */ KEY_NONE,
+/* XK_Ooblique            0x0d8  */ KEY_NONE,
+/* XK_Ugrave              0x0d9  */ KEY_NONE,
+/* XK_Uacute              0x0da  */ KEY_NONE,
+/* XK_Ucircumflex         0x0db  */ KEY_NONE,
+/* XK_Udiaeresis          0x0dc  */ KEY_NONE,
+/* XK_Yacute              0x0dd  */ KEY_NONE,
+/* XK_THORN               0x0de  */ KEY_NONE,
+/* XK_Thorn               0x0de  duplicated */
+/* XK_ssharp              0x0df  */ KEY_NONE,
+/* XK_agrave              0x0e0  */ KEY_NONE,
+/* XK_aacute              0x0e1  */ KEY_NONE,
+/* XK_acircumflex         0x0e2  */ KEY_NONE,
+/* XK_atilde              0x0e3  */ KEY_NONE,
+/* XK_adiaeresis          0x0e4  */ KEY_NONE,
+/* XK_aring               0x0e5  */ KEY_NONE,
+/* XK_ae                  0x0e6  */ KEY_NONE,
+/* XK_ccedilla            0x0e7  */ KEY_SLASH, /* keyboard dependent */
+/* XK_egrave              0x0e8  */ KEY_NONE,
+/* XK_eacute              0x0e9  */ KEY_NONE,
+/* XK_ecircumflex         0x0ea  */ KEY_NONE,
+/* XK_ediaeresis          0x0eb  */ KEY_NONE,
+/* XK_igrave              0x0ec  */ KEY_NONE,
+/* XK_iacute              0x0ed  */ KEY_NONE,
+/* XK_icircumflex         0x0ee  */ KEY_NONE,
+/* XK_idiaeresis          0x0ef  */ KEY_NONE,
+/* XK_eth                 0x0f0  */ KEY_NONE,
+/* XK_ntilde              0x0f1  */ KEY_COLON, /* keyboard dependent */
+/* XK_ograve              0x0f2  */ KEY_NONE,
+/* XK_oacute              0x0f3  */ KEY_NONE,
+/* XK_ocircumflex         0x0f4  */ KEY_NONE,
+/* XK_otilde              0x0f5  */ KEY_NONE,
+/* XK_odiaeresis          0x0f6  */ KEY_NONE,
+/* XK_division            0x0f7  */ KEY_NONE,
+/* XK_oslash              0x0f8  */ KEY_NONE,
+/* XK_ugrave              0x0f9  */ KEY_NONE,
+/* XK_uacute              0x0fa  */ KEY_NONE,
+/* XK_ucircumflex         0x0fb  */ KEY_NONE,
+/* XK_udiaeresis          0x0fc  */ KEY_NONE,
+/* XK_yacute              0x0fd  */ KEY_NONE,
+/* XK_thorn               0x0fe  */ KEY_NONE,
+/* XK_ydiaeresis          0x0ff  */ KEY_NONE
+
+}; /* code_table */
diff -Naur ../mmmmm/m36b16/src/unix/xmame.6-1 mame-0.36b16/src/unix/xmame.6-1
--- ../mmmmm/m36b16/src/unix/xmame.6-1	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/xmame.6-1	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,80 @@
+.\"  -*- nroff -*-
+.\"
+.\" xmame.6
+.\"
+.\" Done by Ren Herrmann <rene.herrmann@berlin.de>, September 2000
+.\"
+.\" xmame should be distributed under terms of the license in
+.\" readme.mame.
+.\" The main issue involves ROM images. ROM images are protected under the
+.\" copyrights of their authors, and CANNOT be distributed in the same
+.\" package as xmame. Download any ROM images at your own risk and
+.\" responsibility.
+.\"
+.Dd 02. September 2000
+.Dt Xmame 6
+.Os
+.Sh NAME
+.Nm xmame
+.Nd THE Arcade game machine emulator for UNIX/X
+.Sh SYNOPSIS
+.Nm xmame[.x11|svga]
+.Op Fl options
+.Ar gamename
+.Sh EXAMPLES
+Some examples for those who are in a hurry.
+
+If you don't have/want a frontend, you'll mostly use
+.Nm xmame
+(with a well defined xmamerc) in the following way:
+
+.Nm xmame
+.Ar ladybug
+
+Plays Ladybug with all options defined in xmamerc. If there is no xmamerc the 
+game starts with the buildin defaults.
+
+.Nm xmame
+.Ar defender
+.Fl frameskip Ar 1
+.Fl cheat
+
+Starts
+.Ar defender
+using a frameskip of 1 and cheat is enabled.
+Useful for slower computers, if the game is running really slowly.
+And of course if you want (have?) to cheat. ;-)
+.Sh LEGAL NOTICE
+The main issue involves ROM images. ROM images are protected under the
+copyrights of their authors, and CANNOT be distributed in the same
+package as xmame. Download any ROM images at your own risk and
+responsibility.
+
+.Nm xmame
+should be distributed under terms of the license in doc/readme.mame
+
+XInputExtensions based Joystick support. Source code is entirely pure 
+hack work. No sample code, no info at all was found (only library 
+reference manual) and is copyrighted by me (Juan Antonio Marmnez).
+Use it under terms of GNU General Public License.
+
+PLEASE BE AWARE OF THE POSSIBLE LEGAL RAMIFICATIONS OF DOWNLOADING ROM
+IMAGES, BEFORE YOU ACTUALLY DO SO!  YOU HAVE BEEN WARNED, AND WE TAKE NO
+RESPONSIBILITY FOR YOUR ACTIONS -- YOU ARE ON YOUR OWN!
+
+Also, the
+.Nm xmame 
+authors ask that you DO NOT distribute any ROM images with either source
+code or binaries of the
+.Nm xmame
+emulator.
+.Sh DESCRIPTION
+.Nm xmame 
+is the (M)ulti (A)rcade (M)achine (E)mulator for UNIX-(X).  It emulates
+the hardware of realy many classic arcade game machines.
+
+Most games allow you to specify one or more options to control the behavior of
+.Nm xmame
+and the game of your choice. Below is a complete list of all the available
+options:
+.Bl -tag -width Ds
diff -Naur ../mmmmm/m36b16/src/unix/xmame.6-3 mame-0.36b16/src/unix/xmame.6-3
--- ../mmmmm/m36b16/src/unix/xmame.6-3	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/xmame.6-3	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,240 @@
+.It \fB*** Arguments ***\fR
+.It Ar game
+the name of the game you wish to play. You better choose one. :-)
+.El
+
+Note: There are really many options. You can set the default options and / or
+options per game in
+.Nm xmames
+config files see the RCFILES section below.
+.Sh INSTALLING GAMES
+Most game ROM images come in ZIP files.  Download the ZIP files for
+the games you want, and move them to a directory of your choice (i.e. it is
+a good idea to put them all in one dir).
+
+Note: There is no need to unzip the games in a separate directory, because
+.Nm xmame
+has zip file support through zlib.
+
+.Nm xmame
+uses a ":" seperated rompath to find out which dirs to search for
+roms/samples. The default rompath is XMAMEROOT as defined in the Makefile
+during the compilation (normaly /usr/games/lib/xmame). If you put all the
+zipped-ROM-Files in this dir everything will work automagicly.
+
+The rompath will be overwritten by any rompath in xmamerc. Which can be
+overwritten again with the -rompath commandline option.
+
+.Nm xmame
+searches every dir in this path for roms (and samples) in the following way:
+
+.TS
+tab (@);
+l l.
+<dir>/gamename.zip@(containing filename.ext)
+<dir>/gamename/filename.ext
+<dir>/gamename/filename.ext.gz@(containing filename.ext)
+<dir>/gamename/filename.zip@(containing filename.ext)
+.TE
+
+Note: If your neogeo games can't find neogeo.rom put it in a dir called
+neogeo somewhere in your rompath, or put it in neogeo.zip somewhere in
+your rompath.
+.Sh PLAYING GAMES
+After running
+.Nm xmame
+i.e.
+.Nm xmame
+.Ar ladybug
+you will see two screens.
+
+The first with a copyright message (PLEASE READ THIS!). If you type (ok)
+this screen will only come up again after the cfg-file of the game
+(romname.cfg) will be deleted.
+
+Another screen shows information about the game. Hit any key to continue.
+
+Note: If you want to see this information screen again, you could press
+\fI<TAB>\fR and select \fI<Game Information>\fR or hit \fI<ESC>\fR and
+restart. ;-)
+
+The game will then go through a `hardware self-test' (remember,
+.Nm xmame
+is emulating game HARDWARE). After the self-test, you are `in' the video game.
+Feed the hungry machine with some coins (key \fI<5>\fR for one coin)
+then start (key \fI<1>\fR) it. For more coins and player read the next section
+(KEYBOARD COMMANDS).
+
+HAVE A LOT OF FUN!
+.Sh KEYBOARD COMMANDS
+While playing a game, there are certain keyboard commands available for
+you to use.
+
+.TS
+tab (@);
+l l.
+\fBKEY@Action\fR
+<1> (the number `one')@Start a 1-player game.
+<2> (the number `two')@Start a 2-player game.
+<3> (the number `three')@Start a 3-player game.
+<4> (the number `four')@Start a 4-player game.
+<5> (the number `five')@Insert coin (slot 1).
+<6> (the number `six')@Insert coin (slot 2).
+<7> (the number `seven')@Insert coin (slot 3).
+<8> (the number `eight')@Insert coin (slot 4).
+<Tab>@Toggles the configuration menu.
+<~> (Tilde)@Toggles the `On Screen Display'.
+@Use the up and down arrow keys to select
+@the parameter (global volume, mixing level,
+@gamma correction etc.), left and right to
+@modify.
+<P>@Pauses the game.
+<Shift+P>@While paused, walk to the next frame.
+<F3>@Resets the game (start with
+@`hardware self-test').
+<F4>@Shows the game graphics. Use cursor keys
+@to change set/color, F4 or Esc to return to
+@the emulation.
+<F9>@Changes frame skip on the fly.
+<F10>@Toggles speed throttling.
+<F11>@Toggles speed display.
+<Shift+F11>@Toggles profiler display.
+<F12>@Saves a screen snapshot. The default
+@target directory is SNAP. You must create
+@this directory yourself; the program will
+@not create it if it doesn't exist.
+<ESC>@Exits the emulator.
+<L-CTRL>@is mostly used as a button.
+<L-ALT>)@is also mostly used as a button.
+<arrows>@will emulate the joystick, pad or
+@trakball. If you have a joystick (pad,
+@trakball ), you can use it with the
+@Input-Related options: -joytype, -jt 
+@and/or -[no]analogstick, -[no]as
+.TE
+
+For a complete list of the usefull keys in
+.Nm xmame
+start a game, press the \fI<tab>\fR button, select \fI<Input (general)>\fR or
+\fI<Input (this game)>\fR and you see a complete list of the related keys.
+.Sh RCFILES
+You can put the most commandline options in an (r)essource (c)onfiguration
+(rc) file. To generate a `clean' xmamerc you type in your ${HOME}/.xmame
+directory:
+
+.Nm xmame
+.Fl sc
+>
+.Ar xmamerc
+
+Now you have a good base to build your specific rc-file. Here is a piece
+from this file to tell you how the syntax works.
+
+    ### X11-window Related ###
+    cursor                  1
+    mitshm                  1
+    xsync                   1
+    privatecmap             0
+    xil                     1
+    mtxil                   0
+    run-in-root-window      0
+    root_window_id          0
+    geometry                640x480
+
+    ### XFree86 DGA Related ###
+
+    ### Video Mode Selection Related ###
+    keepaspect              1
+    displayaspectratio      1.330000
+
+The number `0' is equal to `no' or `false' and `1' means `yes' or `true'.
+
+Some parameters like `geometry' needs a string `800x600' and
+some others like `displayaspectratio' use a number `1.330000'.
+.Sh ENVIRONMENT
+The following environment variables are used:
+
+.TS
+tab (@);
+l l.
+\fBENV@USE\fR
+HOME@The user's home directory.  (normally set by the login process.)
+DISPLAY@X server to display in.
+.TE
+.Sh FILES
+The config files are parsed in the following order:
+
+.TS
+tab (@);
+l l.
+\fBPATH@CONFIG FILE\fR
+/usr/games/lib/xmame/xmamerc@global configuration
+${HOME}/.xmame/xmamerc@user configuration
+/usr/games/lib/xmame/xmame-x11rc@global per display
+@method
+${HOME}/.xmame/xmame-x11rc@user per display
+@method
+/usr/games/lib/xmame/rc/<game>rc@global per game
+${HOME}/.xmame/rc/<game>rc@user per game
+.TE
+.Sh BUGS
+There might be some bugs. Take a look in the doc-dir for more info,
+because the xmame-project is always in progress. :-)
+.Sh CREDITS
+Lots and lots and lots of thank to everyone for there great help on the
+xmame project. I would like to thank the following people and of course anyone
+I've forgotten.
+
+Thank you all,
+
+Hans
+
+  1. Fathers of the mame-creature (main version)
+        Nicola Salmoria
+        Allard van der Bas
+        Mirko (Mix) Buffoni (General Mantainer)
+  2. Fathers of mess
+        Brad Oliver
+        Richard Bannister
+        Ben Bruscella (current coordinator)
+  3. Original UNIX/X11 port
+        Allard van der Bas
+        Dick the Ridder
+        Juan Antonio Marmnez
+  4. Unix maintainer
+        Hans de Goede
+  5. Alpha specific issues
+        Christian Groessler
+  6. Sun specific issues
+        Keith Hargrove
+        Mathis Rosenhau
+  7. Irix specific issues
+        Tristram Scott
+  8. GGI maintainance
+        Gabriele Boccone (original port)
+        Christian Groessler (current maintainer)
+  9. OpenGL code & maintainance
+        Mike Oliphant
+ 10. Network code
+        Eric Totel
+ 11. Perl scripts for automation of some porting issues
+        Bill Adams
+ 12. Xmame rpms
+        Jeremy Hansen
+ 13. Mailing list maintainer
+        Chris McCraw
+ 14. Bits and pieces
+        Christian Groessler
+        Torsten Paul
+ 15. AIX Sound code
+        Chris Sharpp
+ 16. IRIX Sound code
+        entropy@zippy.bernstein.com
+ 17. German readme
+        Robert Hamberger
+ 18. Documentation (SGML, HTML, MAN ...)
+        Rene Herrmann
+
+    And now you've come to the end of this man(ual).
+    Have a lot of fun
+    Rene'
diff -Naur ../mmmmm/m36b16/src/unix/xmame.h mame-0.36b16/src/unix/xmame.h
--- ../mmmmm/m36b16/src/unix/xmame.h	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/xmame.h	2023-07-07 14:20:22.688001896 -0400
@@ -0,0 +1,180 @@
+/*
+ ******************* X-Mame header file *********************
+ * file "xmame.h"
+ *
+ * by jantonio@dit.upm.es
+ *
+ ************************************************************
+*/
+
+#ifndef __XMAME_H_
+#define __XMAME_H_
+
+#ifdef __MAIN_C_
+#define EXTERN
+#else
+#define EXTERN extern
+#endif
+
+/*
+ * Include files.
+ */
+
+#ifdef openstep
+#include <libc.h>
+#include <math.h>
+#endif /* openstep */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <ctype.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include "osdepend.h"
+#include "mame.h"
+#include "sysdep/sysdep_palette.h"
+#include "sysdep/rc.h"
+#include "sysdep/sound_stream.h"
+
+/*
+ * Definitions.
+ */
+#ifndef TRUE
+#define	TRUE			(1)
+#endif
+
+#ifndef FALSE
+#define FALSE			(0)
+#endif
+
+#define OSD_OK			(0)
+#define OSD_NOT_OK		(1)
+
+#define DEBUG(x)
+
+#define FRAMESKIP_LEVELS 12
+
+/* Taken from common.h since the rest of common.h creates to many conflicts
+   with X headers */
+struct my_rectangle
+{
+	int min_x,max_x;
+	int min_y,max_y;
+};
+
+/*
+ * Global variables.
+ */
+
+/* dirty stuff */
+#if !defined xgl
+EXTERN unsigned char *dirty_lines;
+EXTERN unsigned char **dirty_blocks;
+EXTERN unsigned char *old_dirty_lines;
+EXTERN unsigned char **old_dirty_blocks;
+#endif
+
+/* global variables and miscellaneous flags */
+
+EXTERN int		sound_enabled;
+EXTERN int	 	widthscale;     /* X scale */
+EXTERN int	 	heightscale;    /* Y SCALE */
+EXTERN char		*home_dir;
+EXTERN char		title[50]; 
+EXTERN int		use_mouse;
+EXTERN int		use_dirty;
+EXTERN int		throttle;
+EXTERN int		autoframeskip;
+EXTERN int		frameskip;
+EXTERN int		game_index;
+EXTERN struct osd_bitmap *bitmap;
+EXTERN int		use_scanlines;
+EXTERN int		cabview;
+EXTERN char		*cabname;
+EXTERN float		display_aspect_ratio;
+EXTERN int 		sleep_idle;
+EXTERN int 		max_autoframeskip;
+EXTERN struct sysdep_palette_info display_palette_info;
+EXTERN struct sysdep_palette_struct *sysdep_palette;
+EXTERN struct sound_stream_struct *sound_stream;
+#ifdef MESS
+EXTERN char		*crcdir;
+#endif
+
+/* visual is the visual part of the bitmap */
+EXTERN int 		visual_width;
+EXTERN int		visual_height;
+EXTERN struct my_rectangle visual;
+
+/* File descripters for stdout / stderr redirection, without svgalib inter
+   fering */
+EXTERN FILE *stdout_file;
+EXTERN FILE *stderr_file;
+
+/* system dependent functions */
+int  sysdep_init(void);
+void sysdep_close(void);
+int  sysdep_create_display(void);
+int  sysdep_display_alloc_palette(int writable_colors);
+int  sysdep_display_set_pen(int pen, unsigned char red, unsigned char green, unsigned char blue);
+int  sysdep_display_16bpp_capable(void);
+void sysdep_update_display(void);
+int  sysdep_set_video_mode(void);
+void sysdep_set_text_mode(void);
+
+/* input related */
+int  osd_input_initpre(void);
+int  osd_input_initpost(void);
+void osd_input_close(void);
+void sysdep_update_keyboard (void);
+void sysdep_mouse_poll(void);
+
+/* dirty functions */
+int  osd_dirty_init(void);
+void osd_dirty_close(void);
+void osd_dirty_merge(void);
+
+/* network funtions */
+int  osd_net_init(void);
+void osd_net_close(void);
+
+/* debug functions */
+int  osd_debug_init(void);
+void osd_debug_close(void);
+
+/* mode handling functions */
+int mode_disabled(int width, int height);
+int mode_match(int width, int height);
+
+/* frameskip functions */
+int dos_skip_next_frame(int show_fps_counter);
+int barath_skip_next_frame(int show_fps_counter);
+
+/* miscelaneous */
+int config_init (int argc, char *argv[]);
+void config_exit(void);
+int frontend_list(char *gamename);
+int frontend_ident(char *gamename);
+void init_rom_path(void);
+#ifndef HAVE_SNPRINTF
+int snprintf(char *s, size_t maxlen, const char *fmt, ...);
+#endif
+
+/* option structs */
+extern struct rc_option video_opts[];
+extern struct rc_option display_opts[];
+extern struct rc_option mode_opts[];
+extern struct rc_option sound_opts[];
+extern struct rc_option input_opts[];
+extern struct rc_option network_opts[];
+extern struct rc_option fileio_opts[];
+extern struct rc_option frontend_list_opts[];
+extern struct rc_option frontend_ident_opts[];
+
+#undef EXTERN
+#endif
diff -Naur ../mmmmm/m36b16/src/unix/xmamerc-keybinding-notes.txt mame-0.36b16/src/unix/xmamerc-keybinding-notes.txt
--- ../mmmmm/m36b16/src/unix/xmamerc-keybinding-notes.txt	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/src/unix/xmamerc-keybinding-notes.txt	2023-07-07 14:20:22.700001908 -0400
@@ -0,0 +1,37 @@
+### X11 keymapping ###
+#
+# mapkey	<Xcode>,<Scancode>
+#
+# Xcode means the HEX code of the key as appears in /usr/include/X11/keysymdef.h
+# Scancode means the hexadecimal code that represents the value used for Xmame
+# 	in keyboard inputs, as defined in src/osdepend.h xmame source file
+# IMPORTANT: 
+#	1- Due to some limitations, only LATIN-1 X-codes ( 0x0000-0x00ff ) and
+#	Especial X-keycodes ( 0xff00-0xffff ) are supported
+#	2- Some keys are keyboard dependent: As Xmame works internally with
+#	Standard US-AT keyboard codes, you must take care in remmaping some keys
+#
+
+# An example: map space as "firebutton" (Mame predefines it as OSD_KEY_RCONTROL)
+# in simbolic Xlib/Mame notation it should be:
+#
+# mapkey XK_space,OSD_KEY_RCONTROL 
+# 
+# So looking in X11/keysymdef.h and src/osdepend.h we'll write
+# mapkey 0x0020,0x0039
+#
+# (Other example). To use F8 key to insert coin you shoud use:
+# mapkey 0xffc5,0x0004
+
+### suggested german keymap mods by Peter Trauner <peter.trauner@jk.uni-linz.ac.at> ###
+#mapkey 0xfe52,0x0029
+#mapkey 0x00df,0x000c
+#mapkey 0xfe51,0x000d
+#mapkey 0x00fc,0x001a
+#mapkey 0x002b,0x001b
+#mapkey 0x00f6,0x0027
+#mapkey 0x00e4,0x0028
+#mapkey 0x0023,0x002b
+#mapkey 0x0059,0x002c
+#mapkey 0x005a,0x0015
+#mapkey 0x002d,0x0035
diff -Naur ../mmmmm/m36b16/src/usrintrf.c mame-0.36b16/src/usrintrf.c
--- ../mmmmm/m36b16/src/usrintrf.c	2000-01-28 09:02:04.000000000 -0500
+++ mame-0.36b16/src/usrintrf.c	2023-07-07 14:42:39.599160889 -0400
@@ -1009,7 +1009,7 @@
 
 		memcpy(orig_used_colors,palette_used_colors,Machine->drv->total_colors * sizeof(unsigned char));
 	}
-
+#if 0 /* RB */
 #ifndef NEOFREE
 #ifndef TINY_COMPILE
 	if (Machine->gamedrv->clone_of == &driver_neogeo ||
@@ -1018,7 +1018,7 @@
 		game_is_neogeo=1;
 #endif
 #endif
-
+#endif /* RB */
 	bank = -1;
 	color = 0;
 	firstdrawn = 0;
@@ -1162,7 +1162,8 @@
 						}
 					}
 				}
-			}
+			}
+#if 0 /* RB */
 #ifndef NEOFREE
 #ifndef TINY_COMPILE
 			else	/* neogeo sprite tiles */
@@ -1204,7 +1205,7 @@
 			}
 #endif
 #endif
-
+#endif /* RB */
 			if (bank >= 0)
 				sprintf(buf,"GFXSET %d COLOR %2X CODE %X-%X",bank,color,firstdrawn,lastdrawn);
 			else
@@ -2785,7 +2786,7 @@
 
 }
 
-
+#if 0 /* RB */
 #ifndef NEOFREE
 #ifndef TINY_COMPILE
 int	memcard_menu(int selection)
@@ -2901,7 +2902,7 @@
 }
 #endif
 #endif
-
+#endif /* RB */
 
 #ifndef MESS
 enum { UI_SWITCH = 0,UI_DEFCODE,UI_CODE,UI_ANALOG,UI_CALIBRATE,
@@ -2974,7 +2975,7 @@
 	{
 		menu_item[menu_total] = "Cheat"; menu_action[menu_total++] = UI_CHEAT;
 	}
-
+#if 0 /* RB */
 #ifndef NEOFREE
 #ifndef TINY_COMPILE
 	if (Machine->gamedrv->clone_of == &driver_neogeo ||
@@ -2985,7 +2986,7 @@
 	}
 #endif
 #endif
-
+#endif /* 0 */
 	#ifndef MESS
 	menu_item[menu_total] = "Reset Game"; menu_action[menu_total++] = UI_RESET;
 	menu_item[menu_total] = "Return to Game"; menu_action[menu_total++] = UI_EXIT;
@@ -3121,7 +3122,7 @@
 osd_sound_enable(1);
 sel = sel & 0xff;
 				break;
-
+#if 0 /* RB */
 #ifndef NEOFREE
 #ifndef TINY_COMPILE
 			case UI_MEMCARD:
@@ -3136,6 +3137,7 @@
 				break;
 #endif
 #endif
+#endif /* 0 */
 		}
 
 		return sel + 1;
diff -Naur ../mmmmm/m36b16/xmame_cb/xmame_cb.cbp mame-0.36b16/xmame_cb/xmame_cb.cbp
--- ../mmmmm/m36b16/xmame_cb/xmame_cb.cbp	1969-12-31 19:00:00.000000000 -0500
+++ mame-0.36b16/xmame_cb/xmame_cb.cbp	2023-07-07 14:27:38.320559766 -0400
@@ -0,0 +1,376 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
+<CodeBlocks_project_file>
+	<FileVersion major="1" minor="6" />
+	<Project>
+		<Option title="xmame_cb" />
+		<Option pch_mode="2" />
+		<Option compiler="gcc" />
+		<Build>
+			<Target title="Debug">
+				<Option output="bin/Debug/xmame_cb" prefix_auto="1" extension_auto="1" />
+				<Option object_output="obj/Debug/" />
+				<Option type="1" />
+				<Option compiler="gcc" />
+				<Option parameters="pacman -rompath /home/xubuntu/junk/MAME_hack/xmame-0.37b7.1" />
+				<Compiler>
+					<Add option="-g" />
+				</Compiler>
+			</Target>
+			<Target title="Release">
+				<Option output="bin/Release/xmame_cb" prefix_auto="1" extension_auto="1" />
+				<Option object_output="obj/Release/" />
+				<Option type="1" />
+				<Option compiler="gcc" />
+				<Compiler>
+					<Add option="-O2" />
+				</Compiler>
+				<Linker>
+					<Add option="-s" />
+				</Linker>
+			</Target>
+		</Build>
+		<Compiler>
+			<Add option="-Wall" />
+			<Add option='-DINLINE=&quot;static __inline__&quot;' />
+			<Add option="-DLSB_FIRST" />
+			<Add option="-Dx11" />
+			<Add option="-Dstricmp=strcasecmp" />
+			<Add option="-Dstrnicmp=strncasecmp" />
+			<Add option="-DUNIX" />
+			<Add option="-DHAS_NAMCO" />
+			<Add option="-DHAS_NAMCO_52XX" />
+			<Add option="-DHAS_NAMCO_54XX" />
+			<Add option="-DHAS_SAMPLES" />
+			<Add option="-DHAS_Z80" />
+			<Add option="-DHAS_SN76496=1" />
+			<Add option="-DHAS_AY8910=1" />
+			<Add option='-DNAME=\&apos;&quot;xmame&quot;\&apos;' />
+			<Add option='-DDISPLAY_METHOD=\&apos;&quot;x11&quot;\&apos;' />
+			<Add option='-DXMAMEROOT=\&apos;&quot;/usr/local/share/xmame&quot;\&apos;' />
+			<Add option='-DSYSCONFDIR=\&apos;&quot;/usr/local/share/xmame&quot;\&apos;' />
+			<Add option="-DUSE_MITSHM=1" />
+			<Add option="-DSYSDEP_DSP_ALSA" />
+			<Add option="-DSOUND_ALSA=1" />
+			<Add option="-DHAVE_GETTIMEOFDAY" />
+			<Add directory="../src" />
+			<Add directory="../src/unix" />
+			<Add directory="../src/includes" />
+		</Compiler>
+		<Linker>
+			<Add library="z" />
+			<Add library="expat" />
+			<Add library="m" />
+			<Add library="asound" />
+			<Add library="Xext" />
+			<Add library="X11" />
+			<Add library="Xv" />
+		</Linker>
+		<Unit filename="../src/artwork.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/artwork.h" />
+		<Unit filename="../src/audit.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/audit.h" />
+		<Unit filename="../src/chd.h" />
+		<Unit filename="../src/cheat.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/cheat.h" />
+		<Unit filename="../src/common.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/common.h" />
+		<Unit filename="../src/config.h" />
+		<Unit filename="../src/cpu/z80/z80.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/cpu/z80/z80.h" />
+		<Unit filename="../src/cpuexec.h" />
+		<Unit filename="../src/cpuint.h" />
+		<Unit filename="../src/cpuintrf.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/cpuintrf.h" />
+		<Unit filename="../src/datafile.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/datafile.h" />
+		<Unit filename="../src/drawgfx.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/drawgfx.h" />
+		<Unit filename="../src/driver.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/driver.h" />
+		<Unit filename="../src/drivers/dkong.c">
+			<Option compilerVar="CC" />
+			<Option compile="0" />
+			<Option link="0" />
+		</Unit>
+		<Unit filename="../src/drivers/pacman.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/fileio.h" />
+		<Unit filename="../src/gfxobj.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/gfxobj.h" />
+		<Unit filename="../src/hash.h" />
+		<Unit filename="../src/hiscore.h" />
+		<Unit filename="../src/includes/pacman.h" />
+		<Unit filename="../src/info.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/info.h" />
+		<Unit filename="../src/inptport.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/inptport.h" />
+		<Unit filename="../src/input.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/input.h" />
+		<Unit filename="../src/machine/atari_vg.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/machine/atari_vg.h" />
+		<Unit filename="../src/machine/eeprom.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/machine/eeprom.h" />
+		<Unit filename="../src/machine/namcoio.h" />
+		<Unit filename="../src/machine/pacman.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/machine/pacplus.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/machine/theglob.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/machine/xevious.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/mame.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/mame.h" />
+		<Unit filename="../src/md5.h" />
+		<Unit filename="../src/memory.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/memory.h" />
+		<Unit filename="../src/osdepend.h" />
+		<Unit filename="../src/palette.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/palette.h" />
+		<Unit filename="../src/png.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/png.h" />
+		<Unit filename="../src/profiler.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/profiler.h" />
+		<Unit filename="../src/sha1.h" />
+		<Unit filename="../src/sndintrf.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/sndintrf.h" />
+		<Unit filename="../src/sound/ay8910.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/sound/ay8910.h" />
+		<Unit filename="../src/sound/filter.h" />
+		<Unit filename="../src/sound/mixer.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/sound/mixer.h" />
+		<Unit filename="../src/sound/namco.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/sound/namco.h" />
+		<Unit filename="../src/sound/namco52.h" />
+		<Unit filename="../src/sound/namco54.h" />
+		<Unit filename="../src/sound/samples.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/sound/samples.h" />
+		<Unit filename="../src/sound/sn76496.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/sound/sn76496.h" />
+		<Unit filename="../src/sound/streams.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/sound/streams.h" />
+		<Unit filename="../src/sprite.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/sprite.h" />
+		<Unit filename="../src/state.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/state.h" />
+		<Unit filename="../src/tilemap.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/tilemap.h" />
+		<Unit filename="../src/timer.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/timer.h" />
+		<Unit filename="../src/ui_text.h" />
+		<Unit filename="../src/unix/config.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/devices.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/devices.h" />
+		<Unit filename="../src/unix/dirio.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/dirty.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/effect.h" />
+		<Unit filename="../src/unix/effect_funcs.h" />
+		<Unit filename="../src/unix/fileio.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/frameskip-drivers/barath.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/frameskip-drivers/dos.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/fronthlp.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/ident.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/joystick-drivers/joy_i386.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/joystick-drivers/joy_pad.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/joystick-drivers/joy_usb.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/joystick-drivers/joy_x11.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/keyboard.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/keyboard.h" />
+		<Unit filename="../src/unix/main.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/mode.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/network.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/sound.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/sysdep/dsp-drivers/alsa.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/sysdep/misc.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/sysdep/misc.h" />
+		<Unit filename="../src/unix/sysdep/plugin_manager.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/sysdep/plugin_manager.h" />
+		<Unit filename="../src/unix/sysdep/rc.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/sysdep/rc.h" />
+		<Unit filename="../src/unix/sysdep/sound_stream.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/sysdep/sound_stream.h" />
+		<Unit filename="../src/unix/sysdep/sysdep_dsp.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/sysdep/sysdep_dsp.h" />
+		<Unit filename="../src/unix/sysdep/sysdep_mixer.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/sysdep/sysdep_mixer.h" />
+		<Unit filename="../src/unix/sysdep/sysdep_palette.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/sysdep/sysdep_palette.h" />
+		<Unit filename="../src/unix/ticker.h" />
+		<Unit filename="../src/unix/video-drivers/x11.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/video-drivers/x11.h" />
+		<Unit filename="../src/unix/video-drivers/x11_window.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/video-drivers/xf86_dga.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/video-drivers/xinput.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unix/video.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unzip.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/unzip.h" />
+		<Unit filename="../src/usrintrf.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/usrintrf.h" />
+		<Unit filename="../src/version.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/vidhrdw/avgdvg.c">
+			<Option compilerVar="CC" />
+			<Option target="&lt;{~None~}&gt;" />
+		</Unit>
+		<Unit filename="../src/vidhrdw/avgdvg.h" />
+		<Unit filename="../src/vidhrdw/bosco.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/vidhrdw/digdug.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/vidhrdw/galaga.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/vidhrdw/generic.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/vidhrdw/generic.h" />
+		<Unit filename="../src/vidhrdw/pengo.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/vidhrdw/vector.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="../src/vidhrdw/vector.h" />
+		<Unit filename="../src/vidhrdw/xevious.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="xmame_cb.cbp" />
+		<Extensions />
+	</Project>
+</CodeBlocks_project_file>
